
import { createRequire } from 'node:module';
const require = createRequire(import.meta.url);

// ----- polyfilling for module build command -----

import pathPolyfill123 from "node:path"
import { fileURLToPath as fileURLToPathPolyfill123 } from "node:url"
const __filename = fileURLToPathPolyfill123(import.meta.url)
const __dirname = pathPolyfill123.dirname(__filename)

// -------------------------------------------------

var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __require = /* @__PURE__ */ ((x2) => typeof require !== "undefined" ? require : typeof Proxy !== "undefined" ? new Proxy(x2, {
  get: (a3, b) => (typeof require !== "undefined" ? require : a3)[b]
}) : x2)(function(x2) {
  if (typeof require !== "undefined")
    return require.apply(this, arguments);
  throw Error('Dynamic require of "' + x2 + '" is not supported');
});
var __esm = (fn, res) => function __init() {
  return fn && (res = (0, fn[__getOwnPropNames(fn)[0]])(fn = 0)), res;
};
var __commonJS = (cb, mod) => function __require2() {
  return mod || (0, cb[__getOwnPropNames(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
};
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));

// <define:ENV_DEFINED_IN_BUILD_STEP>
var define_ENV_DEFINED_IN_BUILD_STEP_default;
var init_define_ENV_DEFINED_IN_BUILD_STEP = __esm({
  "<define:ENV_DEFINED_IN_BUILD_STEP>"() {
    define_ENV_DEFINED_IN_BUILD_STEP_default = { IS_PRODUCTION: true, PUBLIC_POSTHOG_TOKEN: "phc_m5yJZCxjOGxF8CJvP5sQ3H0d76xpnLrsmiZHduT4jDz" };
  }
});

// ../../../node_modules/.pnpm/commander@11.1.0/node_modules/commander/lib/error.js
var require_error = __commonJS({
  "../../../node_modules/.pnpm/commander@11.1.0/node_modules/commander/lib/error.js"(exports) {
    init_define_ENV_DEFINED_IN_BUILD_STEP();
    var CommanderError2 = class extends Error {
      /**
       * Constructs the CommanderError class
       * @param {number} exitCode suggested exit code which could be used with process.exit
       * @param {string} code an id string representing the error
       * @param {string} message human-readable description of the error
       * @constructor
       */
      constructor(exitCode, code, message) {
        super(message);
        Error.captureStackTrace(this, this.constructor);
        this.name = this.constructor.name;
        this.code = code;
        this.exitCode = exitCode;
        this.nestedError = void 0;
      }
    };
    var InvalidArgumentError2 = class extends CommanderError2 {
      /**
       * Constructs the InvalidArgumentError class
       * @param {string} [message] explanation of why argument is invalid
       * @constructor
       */
      constructor(message) {
        super(1, "commander.invalidArgument", message);
        Error.captureStackTrace(this, this.constructor);
        this.name = this.constructor.name;
      }
    };
    exports.CommanderError = CommanderError2;
    exports.InvalidArgumentError = InvalidArgumentError2;
  }
});

// ../../../node_modules/.pnpm/commander@11.1.0/node_modules/commander/lib/argument.js
var require_argument = __commonJS({
  "../../../node_modules/.pnpm/commander@11.1.0/node_modules/commander/lib/argument.js"(exports) {
    init_define_ENV_DEFINED_IN_BUILD_STEP();
    var { InvalidArgumentError: InvalidArgumentError2 } = require_error();
    var Argument3 = class {
      /**
       * Initialize a new command argument with the given name and description.
       * The default is that the argument is required, and you can explicitly
       * indicate this with <> around the name. Put [] around the name for an optional argument.
       *
       * @param {string} name
       * @param {string} [description]
       */
      constructor(name, description) {
        this.description = description || "";
        this.variadic = false;
        this.parseArg = void 0;
        this.defaultValue = void 0;
        this.defaultValueDescription = void 0;
        this.argChoices = void 0;
        switch (name[0]) {
          case "<":
            this.required = true;
            this._name = name.slice(1, -1);
            break;
          case "[":
            this.required = false;
            this._name = name.slice(1, -1);
            break;
          default:
            this.required = true;
            this._name = name;
            break;
        }
        if (this._name.length > 3 && this._name.slice(-3) === "...") {
          this.variadic = true;
          this._name = this._name.slice(0, -3);
        }
      }
      /**
       * Return argument name.
       *
       * @return {string}
       */
      name() {
        return this._name;
      }
      /**
       * @api private
       */
      _concatValue(value, previous) {
        if (previous === this.defaultValue || !Array.isArray(previous)) {
          return [value];
        }
        return previous.concat(value);
      }
      /**
       * Set the default value, and optionally supply the description to be displayed in the help.
       *
       * @param {*} value
       * @param {string} [description]
       * @return {Argument}
       */
      default(value, description) {
        this.defaultValue = value;
        this.defaultValueDescription = description;
        return this;
      }
      /**
       * Set the custom handler for processing CLI command arguments into argument values.
       *
       * @param {Function} [fn]
       * @return {Argument}
       */
      argParser(fn) {
        this.parseArg = fn;
        return this;
      }
      /**
       * Only allow argument value to be one of choices.
       *
       * @param {string[]} values
       * @return {Argument}
       */
      choices(values) {
        this.argChoices = values.slice();
        this.parseArg = (arg, previous) => {
          if (!this.argChoices.includes(arg)) {
            throw new InvalidArgumentError2(`Allowed choices are ${this.argChoices.join(", ")}.`);
          }
          if (this.variadic) {
            return this._concatValue(arg, previous);
          }
          return arg;
        };
        return this;
      }
      /**
       * Make argument required.
       */
      argRequired() {
        this.required = true;
        return this;
      }
      /**
       * Make argument optional.
       */
      argOptional() {
        this.required = false;
        return this;
      }
    };
    function humanReadableArgName(arg) {
      const nameOutput = arg.name() + (arg.variadic === true ? "..." : "");
      return arg.required ? "<" + nameOutput + ">" : "[" + nameOutput + "]";
    }
    exports.Argument = Argument3;
    exports.humanReadableArgName = humanReadableArgName;
  }
});

// ../../../node_modules/.pnpm/commander@11.1.0/node_modules/commander/lib/help.js
var require_help = __commonJS({
  "../../../node_modules/.pnpm/commander@11.1.0/node_modules/commander/lib/help.js"(exports) {
    init_define_ENV_DEFINED_IN_BUILD_STEP();
    var { humanReadableArgName } = require_argument();
    var Help2 = class {
      constructor() {
        this.helpWidth = void 0;
        this.sortSubcommands = false;
        this.sortOptions = false;
        this.showGlobalOptions = false;
      }
      /**
       * Get an array of the visible subcommands. Includes a placeholder for the implicit help command, if there is one.
       *
       * @param {Command} cmd
       * @returns {Command[]}
       */
      visibleCommands(cmd) {
        const visibleCommands = cmd.commands.filter((cmd2) => !cmd2._hidden);
        if (cmd._hasImplicitHelpCommand()) {
          const [, helpName, helpArgs] = cmd._helpCommandnameAndArgs.match(/([^ ]+) *(.*)/);
          const helpCommand = cmd.createCommand(helpName).helpOption(false);
          helpCommand.description(cmd._helpCommandDescription);
          if (helpArgs)
            helpCommand.arguments(helpArgs);
          visibleCommands.push(helpCommand);
        }
        if (this.sortSubcommands) {
          visibleCommands.sort((a3, b) => {
            return a3.name().localeCompare(b.name());
          });
        }
        return visibleCommands;
      }
      /**
       * Compare options for sort.
       *
       * @param {Option} a
       * @param {Option} b
       * @returns number
       */
      compareOptions(a3, b) {
        const getSortKey = (option) => {
          return option.short ? option.short.replace(/^-/, "") : option.long.replace(/^--/, "");
        };
        return getSortKey(a3).localeCompare(getSortKey(b));
      }
      /**
       * Get an array of the visible options. Includes a placeholder for the implicit help option, if there is one.
       *
       * @param {Command} cmd
       * @returns {Option[]}
       */
      visibleOptions(cmd) {
        const visibleOptions = cmd.options.filter((option) => !option.hidden);
        const showShortHelpFlag = cmd._hasHelpOption && cmd._helpShortFlag && !cmd._findOption(cmd._helpShortFlag);
        const showLongHelpFlag = cmd._hasHelpOption && !cmd._findOption(cmd._helpLongFlag);
        if (showShortHelpFlag || showLongHelpFlag) {
          let helpOption;
          if (!showShortHelpFlag) {
            helpOption = cmd.createOption(cmd._helpLongFlag, cmd._helpDescription);
          } else if (!showLongHelpFlag) {
            helpOption = cmd.createOption(cmd._helpShortFlag, cmd._helpDescription);
          } else {
            helpOption = cmd.createOption(cmd._helpFlags, cmd._helpDescription);
          }
          visibleOptions.push(helpOption);
        }
        if (this.sortOptions) {
          visibleOptions.sort(this.compareOptions);
        }
        return visibleOptions;
      }
      /**
       * Get an array of the visible global options. (Not including help.)
       *
       * @param {Command} cmd
       * @returns {Option[]}
       */
      visibleGlobalOptions(cmd) {
        if (!this.showGlobalOptions)
          return [];
        const globalOptions = [];
        for (let ancestorCmd = cmd.parent; ancestorCmd; ancestorCmd = ancestorCmd.parent) {
          const visibleOptions = ancestorCmd.options.filter((option) => !option.hidden);
          globalOptions.push(...visibleOptions);
        }
        if (this.sortOptions) {
          globalOptions.sort(this.compareOptions);
        }
        return globalOptions;
      }
      /**
       * Get an array of the arguments if any have a description.
       *
       * @param {Command} cmd
       * @returns {Argument[]}
       */
      visibleArguments(cmd) {
        if (cmd._argsDescription) {
          cmd.registeredArguments.forEach((argument) => {
            argument.description = argument.description || cmd._argsDescription[argument.name()] || "";
          });
        }
        if (cmd.registeredArguments.find((argument) => argument.description)) {
          return cmd.registeredArguments;
        }
        return [];
      }
      /**
       * Get the command term to show in the list of subcommands.
       *
       * @param {Command} cmd
       * @returns {string}
       */
      subcommandTerm(cmd) {
        const args = cmd.registeredArguments.map((arg) => humanReadableArgName(arg)).join(" ");
        return cmd._name + (cmd._aliases[0] ? "|" + cmd._aliases[0] : "") + (cmd.options.length ? " [options]" : "") + // simplistic check for non-help option
        (args ? " " + args : "");
      }
      /**
       * Get the option term to show in the list of options.
       *
       * @param {Option} option
       * @returns {string}
       */
      optionTerm(option) {
        return option.flags;
      }
      /**
       * Get the argument term to show in the list of arguments.
       *
       * @param {Argument} argument
       * @returns {string}
       */
      argumentTerm(argument) {
        return argument.name();
      }
      /**
       * Get the longest command term length.
       *
       * @param {Command} cmd
       * @param {Help} helper
       * @returns {number}
       */
      longestSubcommandTermLength(cmd, helper) {
        return helper.visibleCommands(cmd).reduce((max, command) => {
          return Math.max(max, helper.subcommandTerm(command).length);
        }, 0);
      }
      /**
       * Get the longest option term length.
       *
       * @param {Command} cmd
       * @param {Help} helper
       * @returns {number}
       */
      longestOptionTermLength(cmd, helper) {
        return helper.visibleOptions(cmd).reduce((max, option) => {
          return Math.max(max, helper.optionTerm(option).length);
        }, 0);
      }
      /**
       * Get the longest global option term length.
       *
       * @param {Command} cmd
       * @param {Help} helper
       * @returns {number}
       */
      longestGlobalOptionTermLength(cmd, helper) {
        return helper.visibleGlobalOptions(cmd).reduce((max, option) => {
          return Math.max(max, helper.optionTerm(option).length);
        }, 0);
      }
      /**
       * Get the longest argument term length.
       *
       * @param {Command} cmd
       * @param {Help} helper
       * @returns {number}
       */
      longestArgumentTermLength(cmd, helper) {
        return helper.visibleArguments(cmd).reduce((max, argument) => {
          return Math.max(max, helper.argumentTerm(argument).length);
        }, 0);
      }
      /**
       * Get the command usage to be displayed at the top of the built-in help.
       *
       * @param {Command} cmd
       * @returns {string}
       */
      commandUsage(cmd) {
        let cmdName = cmd._name;
        if (cmd._aliases[0]) {
          cmdName = cmdName + "|" + cmd._aliases[0];
        }
        let ancestorCmdNames = "";
        for (let ancestorCmd = cmd.parent; ancestorCmd; ancestorCmd = ancestorCmd.parent) {
          ancestorCmdNames = ancestorCmd.name() + " " + ancestorCmdNames;
        }
        return ancestorCmdNames + cmdName + " " + cmd.usage();
      }
      /**
       * Get the description for the command.
       *
       * @param {Command} cmd
       * @returns {string}
       */
      commandDescription(cmd) {
        return cmd.description();
      }
      /**
       * Get the subcommand summary to show in the list of subcommands.
       * (Fallback to description for backwards compatibility.)
       *
       * @param {Command} cmd
       * @returns {string}
       */
      subcommandDescription(cmd) {
        return cmd.summary() || cmd.description();
      }
      /**
       * Get the option description to show in the list of options.
       *
       * @param {Option} option
       * @return {string}
       */
      optionDescription(option) {
        const extraInfo = [];
        if (option.argChoices) {
          extraInfo.push(
            // use stringify to match the display of the default value
            `choices: ${option.argChoices.map((choice) => JSON.stringify(choice)).join(", ")}`
          );
        }
        if (option.defaultValue !== void 0) {
          const showDefault = option.required || option.optional || option.isBoolean() && typeof option.defaultValue === "boolean";
          if (showDefault) {
            extraInfo.push(`default: ${option.defaultValueDescription || JSON.stringify(option.defaultValue)}`);
          }
        }
        if (option.presetArg !== void 0 && option.optional) {
          extraInfo.push(`preset: ${JSON.stringify(option.presetArg)}`);
        }
        if (option.envVar !== void 0) {
          extraInfo.push(`env: ${option.envVar}`);
        }
        if (extraInfo.length > 0) {
          return `${option.description} (${extraInfo.join(", ")})`;
        }
        return option.description;
      }
      /**
       * Get the argument description to show in the list of arguments.
       *
       * @param {Argument} argument
       * @return {string}
       */
      argumentDescription(argument) {
        const extraInfo = [];
        if (argument.argChoices) {
          extraInfo.push(
            // use stringify to match the display of the default value
            `choices: ${argument.argChoices.map((choice) => JSON.stringify(choice)).join(", ")}`
          );
        }
        if (argument.defaultValue !== void 0) {
          extraInfo.push(`default: ${argument.defaultValueDescription || JSON.stringify(argument.defaultValue)}`);
        }
        if (extraInfo.length > 0) {
          const extraDescripton = `(${extraInfo.join(", ")})`;
          if (argument.description) {
            return `${argument.description} ${extraDescripton}`;
          }
          return extraDescripton;
        }
        return argument.description;
      }
      /**
       * Generate the built-in help text.
       *
       * @param {Command} cmd
       * @param {Help} helper
       * @returns {string}
       */
      formatHelp(cmd, helper) {
        const termWidth = helper.padWidth(cmd, helper);
        const helpWidth = helper.helpWidth || 80;
        const itemIndentWidth = 2;
        const itemSeparatorWidth = 2;
        function formatItem(term, description) {
          if (description) {
            const fullText = `${term.padEnd(termWidth + itemSeparatorWidth)}${description}`;
            return helper.wrap(fullText, helpWidth - itemIndentWidth, termWidth + itemSeparatorWidth);
          }
          return term;
        }
        function formatList(textArray) {
          return textArray.join("\n").replace(/^/gm, " ".repeat(itemIndentWidth));
        }
        let output = [`Usage: ${helper.commandUsage(cmd)}`, ""];
        const commandDescription = helper.commandDescription(cmd);
        if (commandDescription.length > 0) {
          output = output.concat([helper.wrap(commandDescription, helpWidth, 0), ""]);
        }
        const argumentList = helper.visibleArguments(cmd).map((argument) => {
          return formatItem(helper.argumentTerm(argument), helper.argumentDescription(argument));
        });
        if (argumentList.length > 0) {
          output = output.concat(["Arguments:", formatList(argumentList), ""]);
        }
        const optionList = helper.visibleOptions(cmd).map((option) => {
          return formatItem(helper.optionTerm(option), helper.optionDescription(option));
        });
        if (optionList.length > 0) {
          output = output.concat(["Options:", formatList(optionList), ""]);
        }
        if (this.showGlobalOptions) {
          const globalOptionList = helper.visibleGlobalOptions(cmd).map((option) => {
            return formatItem(helper.optionTerm(option), helper.optionDescription(option));
          });
          if (globalOptionList.length > 0) {
            output = output.concat(["Global Options:", formatList(globalOptionList), ""]);
          }
        }
        const commandList = helper.visibleCommands(cmd).map((cmd2) => {
          return formatItem(helper.subcommandTerm(cmd2), helper.subcommandDescription(cmd2));
        });
        if (commandList.length > 0) {
          output = output.concat(["Commands:", formatList(commandList), ""]);
        }
        return output.join("\n");
      }
      /**
       * Calculate the pad width from the maximum term length.
       *
       * @param {Command} cmd
       * @param {Help} helper
       * @returns {number}
       */
      padWidth(cmd, helper) {
        return Math.max(
          helper.longestOptionTermLength(cmd, helper),
          helper.longestGlobalOptionTermLength(cmd, helper),
          helper.longestSubcommandTermLength(cmd, helper),
          helper.longestArgumentTermLength(cmd, helper)
        );
      }
      /**
       * Wrap the given string to width characters per line, with lines after the first indented.
       * Do not wrap if insufficient room for wrapping (minColumnWidth), or string is manually formatted.
       *
       * @param {string} str
       * @param {number} width
       * @param {number} indent
       * @param {number} [minColumnWidth=40]
       * @return {string}
       *
       */
      wrap(str, width, indent, minColumnWidth = 40) {
        const indents = " \\f\\t\\v\xA0\u1680\u2000-\u200A\u202F\u205F\u3000\uFEFF";
        const manualIndent = new RegExp(`[\\n][${indents}]+`);
        if (str.match(manualIndent))
          return str;
        const columnWidth = width - indent;
        if (columnWidth < minColumnWidth)
          return str;
        const leadingStr = str.slice(0, indent);
        const columnText = str.slice(indent).replace("\r\n", "\n");
        const indentString = " ".repeat(indent);
        const zeroWidthSpace = "\u200B";
        const breaks = `\\s${zeroWidthSpace}`;
        const regex2 = new RegExp(`
|.{1,${columnWidth - 1}}([${breaks}]|$)|[^${breaks}]+?([${breaks}]|$)`, "g");
        const lines = columnText.match(regex2) || [];
        return leadingStr + lines.map((line, i2) => {
          if (line === "\n")
            return "";
          return (i2 > 0 ? indentString : "") + line.trimEnd();
        }).join("\n");
      }
    };
    exports.Help = Help2;
  }
});

// ../../../node_modules/.pnpm/commander@11.1.0/node_modules/commander/lib/option.js
var require_option = __commonJS({
  "../../../node_modules/.pnpm/commander@11.1.0/node_modules/commander/lib/option.js"(exports) {
    init_define_ENV_DEFINED_IN_BUILD_STEP();
    var { InvalidArgumentError: InvalidArgumentError2 } = require_error();
    var Option2 = class {
      /**
       * Initialize a new `Option` with the given `flags` and `description`.
       *
       * @param {string} flags
       * @param {string} [description]
       */
      constructor(flags, description) {
        this.flags = flags;
        this.description = description || "";
        this.required = flags.includes("<");
        this.optional = flags.includes("[");
        this.variadic = /\w\.\.\.[>\]]$/.test(flags);
        this.mandatory = false;
        const optionFlags = splitOptionFlags(flags);
        this.short = optionFlags.shortFlag;
        this.long = optionFlags.longFlag;
        this.negate = false;
        if (this.long) {
          this.negate = this.long.startsWith("--no-");
        }
        this.defaultValue = void 0;
        this.defaultValueDescription = void 0;
        this.presetArg = void 0;
        this.envVar = void 0;
        this.parseArg = void 0;
        this.hidden = false;
        this.argChoices = void 0;
        this.conflictsWith = [];
        this.implied = void 0;
      }
      /**
       * Set the default value, and optionally supply the description to be displayed in the help.
       *
       * @param {*} value
       * @param {string} [description]
       * @return {Option}
       */
      default(value, description) {
        this.defaultValue = value;
        this.defaultValueDescription = description;
        return this;
      }
      /**
       * Preset to use when option used without option-argument, especially optional but also boolean and negated.
       * The custom processing (parseArg) is called.
       *
       * @example
       * new Option('--color').default('GREYSCALE').preset('RGB');
       * new Option('--donate [amount]').preset('20').argParser(parseFloat);
       *
       * @param {*} arg
       * @return {Option}
       */
      preset(arg) {
        this.presetArg = arg;
        return this;
      }
      /**
       * Add option name(s) that conflict with this option.
       * An error will be displayed if conflicting options are found during parsing.
       *
       * @example
       * new Option('--rgb').conflicts('cmyk');
       * new Option('--js').conflicts(['ts', 'jsx']);
       *
       * @param {string | string[]} names
       * @return {Option}
       */
      conflicts(names) {
        this.conflictsWith = this.conflictsWith.concat(names);
        return this;
      }
      /**
       * Specify implied option values for when this option is set and the implied options are not.
       *
       * The custom processing (parseArg) is not called on the implied values.
       *
       * @example
       * program
       *   .addOption(new Option('--log', 'write logging information to file'))
       *   .addOption(new Option('--trace', 'log extra details').implies({ log: 'trace.txt' }));
       *
       * @param {Object} impliedOptionValues
       * @return {Option}
       */
      implies(impliedOptionValues) {
        let newImplied = impliedOptionValues;
        if (typeof impliedOptionValues === "string") {
          newImplied = { [impliedOptionValues]: true };
        }
        this.implied = Object.assign(this.implied || {}, newImplied);
        return this;
      }
      /**
       * Set environment variable to check for option value.
       *
       * An environment variable is only used if when processed the current option value is
       * undefined, or the source of the current value is 'default' or 'config' or 'env'.
       *
       * @param {string} name
       * @return {Option}
       */
      env(name) {
        this.envVar = name;
        return this;
      }
      /**
       * Set the custom handler for processing CLI option arguments into option values.
       *
       * @param {Function} [fn]
       * @return {Option}
       */
      argParser(fn) {
        this.parseArg = fn;
        return this;
      }
      /**
       * Whether the option is mandatory and must have a value after parsing.
       *
       * @param {boolean} [mandatory=true]
       * @return {Option}
       */
      makeOptionMandatory(mandatory = true) {
        this.mandatory = !!mandatory;
        return this;
      }
      /**
       * Hide option in help.
       *
       * @param {boolean} [hide=true]
       * @return {Option}
       */
      hideHelp(hide = true) {
        this.hidden = !!hide;
        return this;
      }
      /**
       * @api private
       */
      _concatValue(value, previous) {
        if (previous === this.defaultValue || !Array.isArray(previous)) {
          return [value];
        }
        return previous.concat(value);
      }
      /**
       * Only allow option value to be one of choices.
       *
       * @param {string[]} values
       * @return {Option}
       */
      choices(values) {
        this.argChoices = values.slice();
        this.parseArg = (arg, previous) => {
          if (!this.argChoices.includes(arg)) {
            throw new InvalidArgumentError2(`Allowed choices are ${this.argChoices.join(", ")}.`);
          }
          if (this.variadic) {
            return this._concatValue(arg, previous);
          }
          return arg;
        };
        return this;
      }
      /**
       * Return option name.
       *
       * @return {string}
       */
      name() {
        if (this.long) {
          return this.long.replace(/^--/, "");
        }
        return this.short.replace(/^-/, "");
      }
      /**
       * Return option name, in a camelcase format that can be used
       * as a object attribute key.
       *
       * @return {string}
       * @api private
       */
      attributeName() {
        return camelcase(this.name().replace(/^no-/, ""));
      }
      /**
       * Check if `arg` matches the short or long flag.
       *
       * @param {string} arg
       * @return {boolean}
       * @api private
       */
      is(arg) {
        return this.short === arg || this.long === arg;
      }
      /**
       * Return whether a boolean option.
       *
       * Options are one of boolean, negated, required argument, or optional argument.
       *
       * @return {boolean}
       * @api private
       */
      isBoolean() {
        return !this.required && !this.optional && !this.negate;
      }
    };
    var DualOptions = class {
      /**
       * @param {Option[]} options
       */
      constructor(options) {
        this.positiveOptions = /* @__PURE__ */ new Map();
        this.negativeOptions = /* @__PURE__ */ new Map();
        this.dualOptions = /* @__PURE__ */ new Set();
        options.forEach((option) => {
          if (option.negate) {
            this.negativeOptions.set(option.attributeName(), option);
          } else {
            this.positiveOptions.set(option.attributeName(), option);
          }
        });
        this.negativeOptions.forEach((value, key) => {
          if (this.positiveOptions.has(key)) {
            this.dualOptions.add(key);
          }
        });
      }
      /**
       * Did the value come from the option, and not from possible matching dual option?
       *
       * @param {*} value
       * @param {Option} option
       * @returns {boolean}
       */
      valueFromOption(value, option) {
        const optionKey = option.attributeName();
        if (!this.dualOptions.has(optionKey))
          return true;
        const preset = this.negativeOptions.get(optionKey).presetArg;
        const negativeValue = preset !== void 0 ? preset : false;
        return option.negate === (negativeValue === value);
      }
    };
    function camelcase(str) {
      return str.split("-").reduce((str2, word) => {
        return str2 + word[0].toUpperCase() + word.slice(1);
      });
    }
    function splitOptionFlags(flags) {
      let shortFlag;
      let longFlag;
      const flagParts = flags.split(/[ |,]+/);
      if (flagParts.length > 1 && !/^[[<]/.test(flagParts[1]))
        shortFlag = flagParts.shift();
      longFlag = flagParts.shift();
      if (!shortFlag && /^-[^-]$/.test(longFlag)) {
        shortFlag = longFlag;
        longFlag = void 0;
      }
      return { shortFlag, longFlag };
    }
    exports.Option = Option2;
    exports.splitOptionFlags = splitOptionFlags;
    exports.DualOptions = DualOptions;
  }
});

// ../../../node_modules/.pnpm/commander@11.1.0/node_modules/commander/lib/suggestSimilar.js
var require_suggestSimilar = __commonJS({
  "../../../node_modules/.pnpm/commander@11.1.0/node_modules/commander/lib/suggestSimilar.js"(exports) {
    init_define_ENV_DEFINED_IN_BUILD_STEP();
    var maxDistance = 3;
    function editDistance(a3, b) {
      if (Math.abs(a3.length - b.length) > maxDistance)
        return Math.max(a3.length, b.length);
      const d2 = [];
      for (let i2 = 0; i2 <= a3.length; i2++) {
        d2[i2] = [i2];
      }
      for (let j2 = 0; j2 <= b.length; j2++) {
        d2[0][j2] = j2;
      }
      for (let j2 = 1; j2 <= b.length; j2++) {
        for (let i2 = 1; i2 <= a3.length; i2++) {
          let cost = 1;
          if (a3[i2 - 1] === b[j2 - 1]) {
            cost = 0;
          } else {
            cost = 1;
          }
          d2[i2][j2] = Math.min(
            d2[i2 - 1][j2] + 1,
            // deletion
            d2[i2][j2 - 1] + 1,
            // insertion
            d2[i2 - 1][j2 - 1] + cost
            // substitution
          );
          if (i2 > 1 && j2 > 1 && a3[i2 - 1] === b[j2 - 2] && a3[i2 - 2] === b[j2 - 1]) {
            d2[i2][j2] = Math.min(d2[i2][j2], d2[i2 - 2][j2 - 2] + 1);
          }
        }
      }
      return d2[a3.length][b.length];
    }
    function suggestSimilar(word, candidates) {
      if (!candidates || candidates.length === 0)
        return "";
      candidates = Array.from(new Set(candidates));
      const searchingOptions = word.startsWith("--");
      if (searchingOptions) {
        word = word.slice(2);
        candidates = candidates.map((candidate) => candidate.slice(2));
      }
      let similar = [];
      let bestDistance = maxDistance;
      const minSimilarity = 0.4;
      candidates.forEach((candidate) => {
        if (candidate.length <= 1)
          return;
        const distance = editDistance(word, candidate);
        const length = Math.max(word.length, candidate.length);
        const similarity = (length - distance) / length;
        if (similarity > minSimilarity) {
          if (distance < bestDistance) {
            bestDistance = distance;
            similar = [candidate];
          } else if (distance === bestDistance) {
            similar.push(candidate);
          }
        }
      });
      similar.sort((a3, b) => a3.localeCompare(b));
      if (searchingOptions) {
        similar = similar.map((candidate) => `--${candidate}`);
      }
      if (similar.length > 1) {
        return `
(Did you mean one of ${similar.join(", ")}?)`;
      }
      if (similar.length === 1) {
        return `
(Did you mean ${similar[0]}?)`;
      }
      return "";
    }
    exports.suggestSimilar = suggestSimilar;
  }
});

// ../../../node_modules/.pnpm/commander@11.1.0/node_modules/commander/lib/command.js
var require_command = __commonJS({
  "../../../node_modules/.pnpm/commander@11.1.0/node_modules/commander/lib/command.js"(exports) {
    init_define_ENV_DEFINED_IN_BUILD_STEP();
    var EventEmitter = __require("events").EventEmitter;
    var childProcess = __require("child_process");
    var path2 = __require("path");
    var fs3 = __require("fs");
    var process2 = __require("process");
    var { Argument: Argument3, humanReadableArgName } = require_argument();
    var { CommanderError: CommanderError2 } = require_error();
    var { Help: Help2 } = require_help();
    var { Option: Option2, splitOptionFlags, DualOptions } = require_option();
    var { suggestSimilar } = require_suggestSimilar();
    var Command2 = class _Command extends EventEmitter {
      /**
       * Initialize a new `Command`.
       *
       * @param {string} [name]
       */
      constructor(name) {
        super();
        this.commands = [];
        this.options = [];
        this.parent = null;
        this._allowUnknownOption = false;
        this._allowExcessArguments = true;
        this.registeredArguments = [];
        this._args = this.registeredArguments;
        this.args = [];
        this.rawArgs = [];
        this.processedArgs = [];
        this._scriptPath = null;
        this._name = name || "";
        this._optionValues = {};
        this._optionValueSources = {};
        this._storeOptionsAsProperties = false;
        this._actionHandler = null;
        this._executableHandler = false;
        this._executableFile = null;
        this._executableDir = null;
        this._defaultCommandName = null;
        this._exitCallback = null;
        this._aliases = [];
        this._combineFlagAndOptionalValue = true;
        this._description = "";
        this._summary = "";
        this._argsDescription = void 0;
        this._enablePositionalOptions = false;
        this._passThroughOptions = false;
        this._lifeCycleHooks = {};
        this._showHelpAfterError = false;
        this._showSuggestionAfterError = true;
        this._outputConfiguration = {
          writeOut: (str) => process2.stdout.write(str),
          writeErr: (str) => process2.stderr.write(str),
          getOutHelpWidth: () => process2.stdout.isTTY ? process2.stdout.columns : void 0,
          getErrHelpWidth: () => process2.stderr.isTTY ? process2.stderr.columns : void 0,
          outputError: (str, write) => write(str)
        };
        this._hidden = false;
        this._hasHelpOption = true;
        this._helpFlags = "-h, --help";
        this._helpDescription = "display help for command";
        this._helpShortFlag = "-h";
        this._helpLongFlag = "--help";
        this._addImplicitHelpCommand = void 0;
        this._helpCommandName = "help";
        this._helpCommandnameAndArgs = "help [command]";
        this._helpCommandDescription = "display help for command";
        this._helpConfiguration = {};
      }
      /**
       * Copy settings that are useful to have in common across root command and subcommands.
       *
       * (Used internally when adding a command using `.command()` so subcommands inherit parent settings.)
       *
       * @param {Command} sourceCommand
       * @return {Command} `this` command for chaining
       */
      copyInheritedSettings(sourceCommand) {
        this._outputConfiguration = sourceCommand._outputConfiguration;
        this._hasHelpOption = sourceCommand._hasHelpOption;
        this._helpFlags = sourceCommand._helpFlags;
        this._helpDescription = sourceCommand._helpDescription;
        this._helpShortFlag = sourceCommand._helpShortFlag;
        this._helpLongFlag = sourceCommand._helpLongFlag;
        this._helpCommandName = sourceCommand._helpCommandName;
        this._helpCommandnameAndArgs = sourceCommand._helpCommandnameAndArgs;
        this._helpCommandDescription = sourceCommand._helpCommandDescription;
        this._helpConfiguration = sourceCommand._helpConfiguration;
        this._exitCallback = sourceCommand._exitCallback;
        this._storeOptionsAsProperties = sourceCommand._storeOptionsAsProperties;
        this._combineFlagAndOptionalValue = sourceCommand._combineFlagAndOptionalValue;
        this._allowExcessArguments = sourceCommand._allowExcessArguments;
        this._enablePositionalOptions = sourceCommand._enablePositionalOptions;
        this._showHelpAfterError = sourceCommand._showHelpAfterError;
        this._showSuggestionAfterError = sourceCommand._showSuggestionAfterError;
        return this;
      }
      /**
       * @returns {Command[]}
       * @api private
       */
      _getCommandAndAncestors() {
        const result = [];
        for (let command = this; command; command = command.parent) {
          result.push(command);
        }
        return result;
      }
      /**
       * Define a command.
       *
       * There are two styles of command: pay attention to where to put the description.
       *
       * @example
       * // Command implemented using action handler (description is supplied separately to `.command`)
       * program
       *   .command('clone <source> [destination]')
       *   .description('clone a repository into a newly created directory')
       *   .action((source, destination) => {
       *     console.log('clone command called');
       *   });
       *
       * // Command implemented using separate executable file (description is second parameter to `.command`)
       * program
       *   .command('start <service>', 'start named service')
       *   .command('stop [service]', 'stop named service, or all if no name supplied');
       *
       * @param {string} nameAndArgs - command name and arguments, args are `<required>` or `[optional]` and last may also be `variadic...`
       * @param {Object|string} [actionOptsOrExecDesc] - configuration options (for action), or description (for executable)
       * @param {Object} [execOpts] - configuration options (for executable)
       * @return {Command} returns new command for action handler, or `this` for executable command
       */
      command(nameAndArgs, actionOptsOrExecDesc, execOpts) {
        let desc = actionOptsOrExecDesc;
        let opts = execOpts;
        if (typeof desc === "object" && desc !== null) {
          opts = desc;
          desc = null;
        }
        opts = opts || {};
        const [, name, args] = nameAndArgs.match(/([^ ]+) *(.*)/);
        const cmd = this.createCommand(name);
        if (desc) {
          cmd.description(desc);
          cmd._executableHandler = true;
        }
        if (opts.isDefault)
          this._defaultCommandName = cmd._name;
        cmd._hidden = !!(opts.noHelp || opts.hidden);
        cmd._executableFile = opts.executableFile || null;
        if (args)
          cmd.arguments(args);
        this.commands.push(cmd);
        cmd.parent = this;
        cmd.copyInheritedSettings(this);
        if (desc)
          return this;
        return cmd;
      }
      /**
       * Factory routine to create a new unattached command.
       *
       * See .command() for creating an attached subcommand, which uses this routine to
       * create the command. You can override createCommand to customise subcommands.
       *
       * @param {string} [name]
       * @return {Command} new command
       */
      createCommand(name) {
        return new _Command(name);
      }
      /**
       * You can customise the help with a subclass of Help by overriding createHelp,
       * or by overriding Help properties using configureHelp().
       *
       * @return {Help}
       */
      createHelp() {
        return Object.assign(new Help2(), this.configureHelp());
      }
      /**
       * You can customise the help by overriding Help properties using configureHelp(),
       * or with a subclass of Help by overriding createHelp().
       *
       * @param {Object} [configuration] - configuration options
       * @return {Command|Object} `this` command for chaining, or stored configuration
       */
      configureHelp(configuration) {
        if (configuration === void 0)
          return this._helpConfiguration;
        this._helpConfiguration = configuration;
        return this;
      }
      /**
       * The default output goes to stdout and stderr. You can customise this for special
       * applications. You can also customise the display of errors by overriding outputError.
       *
       * The configuration properties are all functions:
       *
       *     // functions to change where being written, stdout and stderr
       *     writeOut(str)
       *     writeErr(str)
       *     // matching functions to specify width for wrapping help
       *     getOutHelpWidth()
       *     getErrHelpWidth()
       *     // functions based on what is being written out
       *     outputError(str, write) // used for displaying errors, and not used for displaying help
       *
       * @param {Object} [configuration] - configuration options
       * @return {Command|Object} `this` command for chaining, or stored configuration
       */
      configureOutput(configuration) {
        if (configuration === void 0)
          return this._outputConfiguration;
        Object.assign(this._outputConfiguration, configuration);
        return this;
      }
      /**
       * Display the help or a custom message after an error occurs.
       *
       * @param {boolean|string} [displayHelp]
       * @return {Command} `this` command for chaining
       */
      showHelpAfterError(displayHelp = true) {
        if (typeof displayHelp !== "string")
          displayHelp = !!displayHelp;
        this._showHelpAfterError = displayHelp;
        return this;
      }
      /**
       * Display suggestion of similar commands for unknown commands, or options for unknown options.
       *
       * @param {boolean} [displaySuggestion]
       * @return {Command} `this` command for chaining
       */
      showSuggestionAfterError(displaySuggestion = true) {
        this._showSuggestionAfterError = !!displaySuggestion;
        return this;
      }
      /**
       * Add a prepared subcommand.
       *
       * See .command() for creating an attached subcommand which inherits settings from its parent.
       *
       * @param {Command} cmd - new subcommand
       * @param {Object} [opts] - configuration options
       * @return {Command} `this` command for chaining
       */
      addCommand(cmd, opts) {
        if (!cmd._name) {
          throw new Error(`Command passed to .addCommand() must have a name
- specify the name in Command constructor or using .name()`);
        }
        opts = opts || {};
        if (opts.isDefault)
          this._defaultCommandName = cmd._name;
        if (opts.noHelp || opts.hidden)
          cmd._hidden = true;
        this.commands.push(cmd);
        cmd.parent = this;
        return this;
      }
      /**
       * Factory routine to create a new unattached argument.
       *
       * See .argument() for creating an attached argument, which uses this routine to
       * create the argument. You can override createArgument to return a custom argument.
       *
       * @param {string} name
       * @param {string} [description]
       * @return {Argument} new argument
       */
      createArgument(name, description) {
        return new Argument3(name, description);
      }
      /**
       * Define argument syntax for command.
       *
       * The default is that the argument is required, and you can explicitly
       * indicate this with <> around the name. Put [] around the name for an optional argument.
       *
       * @example
       * program.argument('<input-file>');
       * program.argument('[output-file]');
       *
       * @param {string} name
       * @param {string} [description]
       * @param {Function|*} [fn] - custom argument processing function
       * @param {*} [defaultValue]
       * @return {Command} `this` command for chaining
       */
      argument(name, description, fn, defaultValue) {
        const argument = this.createArgument(name, description);
        if (typeof fn === "function") {
          argument.default(defaultValue).argParser(fn);
        } else {
          argument.default(fn);
        }
        this.addArgument(argument);
        return this;
      }
      /**
       * Define argument syntax for command, adding multiple at once (without descriptions).
       *
       * See also .argument().
       *
       * @example
       * program.arguments('<cmd> [env]');
       *
       * @param {string} names
       * @return {Command} `this` command for chaining
       */
      arguments(names) {
        names.trim().split(/ +/).forEach((detail) => {
          this.argument(detail);
        });
        return this;
      }
      /**
       * Define argument syntax for command, adding a prepared argument.
       *
       * @param {Argument} argument
       * @return {Command} `this` command for chaining
       */
      addArgument(argument) {
        const previousArgument = this.registeredArguments.slice(-1)[0];
        if (previousArgument && previousArgument.variadic) {
          throw new Error(`only the last argument can be variadic '${previousArgument.name()}'`);
        }
        if (argument.required && argument.defaultValue !== void 0 && argument.parseArg === void 0) {
          throw new Error(`a default value for a required argument is never used: '${argument.name()}'`);
        }
        this.registeredArguments.push(argument);
        return this;
      }
      /**
       * Override default decision whether to add implicit help command.
       *
       *    addHelpCommand() // force on
       *    addHelpCommand(false); // force off
       *    addHelpCommand('help [cmd]', 'display help for [cmd]'); // force on with custom details
       *
       * @return {Command} `this` command for chaining
       */
      addHelpCommand(enableOrNameAndArgs, description) {
        if (enableOrNameAndArgs === false) {
          this._addImplicitHelpCommand = false;
        } else {
          this._addImplicitHelpCommand = true;
          if (typeof enableOrNameAndArgs === "string") {
            this._helpCommandName = enableOrNameAndArgs.split(" ")[0];
            this._helpCommandnameAndArgs = enableOrNameAndArgs;
          }
          this._helpCommandDescription = description || this._helpCommandDescription;
        }
        return this;
      }
      /**
       * @return {boolean}
       * @api private
       */
      _hasImplicitHelpCommand() {
        if (this._addImplicitHelpCommand === void 0) {
          return this.commands.length && !this._actionHandler && !this._findCommand("help");
        }
        return this._addImplicitHelpCommand;
      }
      /**
       * Add hook for life cycle event.
       *
       * @param {string} event
       * @param {Function} listener
       * @return {Command} `this` command for chaining
       */
      hook(event, listener) {
        const allowedValues = ["preSubcommand", "preAction", "postAction"];
        if (!allowedValues.includes(event)) {
          throw new Error(`Unexpected value for event passed to hook : '${event}'.
Expecting one of '${allowedValues.join("', '")}'`);
        }
        if (this._lifeCycleHooks[event]) {
          this._lifeCycleHooks[event].push(listener);
        } else {
          this._lifeCycleHooks[event] = [listener];
        }
        return this;
      }
      /**
       * Register callback to use as replacement for calling process.exit.
       *
       * @param {Function} [fn] optional callback which will be passed a CommanderError, defaults to throwing
       * @return {Command} `this` command for chaining
       */
      exitOverride(fn) {
        if (fn) {
          this._exitCallback = fn;
        } else {
          this._exitCallback = (err) => {
            if (err.code !== "commander.executeSubCommandAsync") {
              throw err;
            } else {
            }
          };
        }
        return this;
      }
      /**
       * Call process.exit, and _exitCallback if defined.
       *
       * @param {number} exitCode exit code for using with process.exit
       * @param {string} code an id string representing the error
       * @param {string} message human-readable description of the error
       * @return never
       * @api private
       */
      _exit(exitCode, code, message) {
        if (this._exitCallback) {
          this._exitCallback(new CommanderError2(exitCode, code, message));
        }
        process2.exit(exitCode);
      }
      /**
       * Register callback `fn` for the command.
       *
       * @example
       * program
       *   .command('serve')
       *   .description('start service')
       *   .action(function() {
       *      // do work here
       *   });
       *
       * @param {Function} fn
       * @return {Command} `this` command for chaining
       */
      action(fn) {
        const listener = (args) => {
          const expectedArgsCount = this.registeredArguments.length;
          const actionArgs = args.slice(0, expectedArgsCount);
          if (this._storeOptionsAsProperties) {
            actionArgs[expectedArgsCount] = this;
          } else {
            actionArgs[expectedArgsCount] = this.opts();
          }
          actionArgs.push(this);
          return fn.apply(this, actionArgs);
        };
        this._actionHandler = listener;
        return this;
      }
      /**
       * Factory routine to create a new unattached option.
       *
       * See .option() for creating an attached option, which uses this routine to
       * create the option. You can override createOption to return a custom option.
       *
       * @param {string} flags
       * @param {string} [description]
       * @return {Option} new option
       */
      createOption(flags, description) {
        return new Option2(flags, description);
      }
      /**
       * Wrap parseArgs to catch 'commander.invalidArgument'.
       *
       * @param {Option | Argument} target
       * @param {string} value
       * @param {*} previous
       * @param {string} invalidArgumentMessage
       * @api private
       */
      _callParseArg(target, value, previous, invalidArgumentMessage) {
        try {
          return target.parseArg(value, previous);
        } catch (err) {
          if (err.code === "commander.invalidArgument") {
            const message = `${invalidArgumentMessage} ${err.message}`;
            this.error(message, { exitCode: err.exitCode, code: err.code });
          }
          throw err;
        }
      }
      /**
       * Add an option.
       *
       * @param {Option} option
       * @return {Command} `this` command for chaining
       */
      addOption(option) {
        const oname = option.name();
        const name = option.attributeName();
        if (option.negate) {
          const positiveLongFlag = option.long.replace(/^--no-/, "--");
          if (!this._findOption(positiveLongFlag)) {
            this.setOptionValueWithSource(name, option.defaultValue === void 0 ? true : option.defaultValue, "default");
          }
        } else if (option.defaultValue !== void 0) {
          this.setOptionValueWithSource(name, option.defaultValue, "default");
        }
        this.options.push(option);
        const handleOptionValue = (val, invalidValueMessage, valueSource) => {
          if (val == null && option.presetArg !== void 0) {
            val = option.presetArg;
          }
          const oldValue = this.getOptionValue(name);
          if (val !== null && option.parseArg) {
            val = this._callParseArg(option, val, oldValue, invalidValueMessage);
          } else if (val !== null && option.variadic) {
            val = option._concatValue(val, oldValue);
          }
          if (val == null) {
            if (option.negate) {
              val = false;
            } else if (option.isBoolean() || option.optional) {
              val = true;
            } else {
              val = "";
            }
          }
          this.setOptionValueWithSource(name, val, valueSource);
        };
        this.on("option:" + oname, (val) => {
          const invalidValueMessage = `error: option '${option.flags}' argument '${val}' is invalid.`;
          handleOptionValue(val, invalidValueMessage, "cli");
        });
        if (option.envVar) {
          this.on("optionEnv:" + oname, (val) => {
            const invalidValueMessage = `error: option '${option.flags}' value '${val}' from env '${option.envVar}' is invalid.`;
            handleOptionValue(val, invalidValueMessage, "env");
          });
        }
        return this;
      }
      /**
       * Internal implementation shared by .option() and .requiredOption()
       *
       * @api private
       */
      _optionEx(config, flags, description, fn, defaultValue) {
        if (typeof flags === "object" && flags instanceof Option2) {
          throw new Error("To add an Option object use addOption() instead of option() or requiredOption()");
        }
        const option = this.createOption(flags, description);
        option.makeOptionMandatory(!!config.mandatory);
        if (typeof fn === "function") {
          option.default(defaultValue).argParser(fn);
        } else if (fn instanceof RegExp) {
          const regex2 = fn;
          fn = (val, def) => {
            const m2 = regex2.exec(val);
            return m2 ? m2[0] : def;
          };
          option.default(defaultValue).argParser(fn);
        } else {
          option.default(fn);
        }
        return this.addOption(option);
      }
      /**
       * Define option with `flags`, `description`, and optional argument parsing function or `defaultValue` or both.
       *
       * The `flags` string contains the short and/or long flags, separated by comma, a pipe or space. A required
       * option-argument is indicated by `<>` and an optional option-argument by `[]`.
       *
       * See the README for more details, and see also addOption() and requiredOption().
       *
       * @example
       * program
       *     .option('-p, --pepper', 'add pepper')
       *     .option('-p, --pizza-type <TYPE>', 'type of pizza') // required option-argument
       *     .option('-c, --cheese [CHEESE]', 'add extra cheese', 'mozzarella') // optional option-argument with default
       *     .option('-t, --tip <VALUE>', 'add tip to purchase cost', parseFloat) // custom parse function
       *
       * @param {string} flags
       * @param {string} [description]
       * @param {Function|*} [parseArg] - custom option processing function or default value
       * @param {*} [defaultValue]
       * @return {Command} `this` command for chaining
       */
      option(flags, description, parseArg, defaultValue) {
        return this._optionEx({}, flags, description, parseArg, defaultValue);
      }
      /**
      * Add a required option which must have a value after parsing. This usually means
      * the option must be specified on the command line. (Otherwise the same as .option().)
      *
      * The `flags` string contains the short and/or long flags, separated by comma, a pipe or space.
      *
      * @param {string} flags
      * @param {string} [description]
      * @param {Function|*} [parseArg] - custom option processing function or default value
      * @param {*} [defaultValue]
      * @return {Command} `this` command for chaining
      */
      requiredOption(flags, description, parseArg, defaultValue) {
        return this._optionEx({ mandatory: true }, flags, description, parseArg, defaultValue);
      }
      /**
       * Alter parsing of short flags with optional values.
       *
       * @example
       * // for `.option('-f,--flag [value]'):
       * program.combineFlagAndOptionalValue(true);  // `-f80` is treated like `--flag=80`, this is the default behaviour
       * program.combineFlagAndOptionalValue(false) // `-fb` is treated like `-f -b`
       *
       * @param {Boolean} [combine=true] - if `true` or omitted, an optional value can be specified directly after the flag.
       */
      combineFlagAndOptionalValue(combine = true) {
        this._combineFlagAndOptionalValue = !!combine;
        return this;
      }
      /**
       * Allow unknown options on the command line.
       *
       * @param {Boolean} [allowUnknown=true] - if `true` or omitted, no error will be thrown
       * for unknown options.
       */
      allowUnknownOption(allowUnknown = true) {
        this._allowUnknownOption = !!allowUnknown;
        return this;
      }
      /**
       * Allow excess command-arguments on the command line. Pass false to make excess arguments an error.
       *
       * @param {Boolean} [allowExcess=true] - if `true` or omitted, no error will be thrown
       * for excess arguments.
       */
      allowExcessArguments(allowExcess = true) {
        this._allowExcessArguments = !!allowExcess;
        return this;
      }
      /**
       * Enable positional options. Positional means global options are specified before subcommands which lets
       * subcommands reuse the same option names, and also enables subcommands to turn on passThroughOptions.
       * The default behaviour is non-positional and global options may appear anywhere on the command line.
       *
       * @param {Boolean} [positional=true]
       */
      enablePositionalOptions(positional = true) {
        this._enablePositionalOptions = !!positional;
        return this;
      }
      /**
       * Pass through options that come after command-arguments rather than treat them as command-options,
       * so actual command-options come before command-arguments. Turning this on for a subcommand requires
       * positional options to have been enabled on the program (parent commands).
       * The default behaviour is non-positional and options may appear before or after command-arguments.
       *
       * @param {Boolean} [passThrough=true]
       * for unknown options.
       */
      passThroughOptions(passThrough = true) {
        this._passThroughOptions = !!passThrough;
        if (!!this.parent && passThrough && !this.parent._enablePositionalOptions) {
          throw new Error("passThroughOptions can not be used without turning on enablePositionalOptions for parent command(s)");
        }
        return this;
      }
      /**
        * Whether to store option values as properties on command object,
        * or store separately (specify false). In both cases the option values can be accessed using .opts().
        *
        * @param {boolean} [storeAsProperties=true]
        * @return {Command} `this` command for chaining
        */
      storeOptionsAsProperties(storeAsProperties = true) {
        if (this.options.length) {
          throw new Error("call .storeOptionsAsProperties() before adding options");
        }
        this._storeOptionsAsProperties = !!storeAsProperties;
        return this;
      }
      /**
       * Retrieve option value.
       *
       * @param {string} key
       * @return {Object} value
       */
      getOptionValue(key) {
        if (this._storeOptionsAsProperties) {
          return this[key];
        }
        return this._optionValues[key];
      }
      /**
       * Store option value.
       *
       * @param {string} key
       * @param {Object} value
       * @return {Command} `this` command for chaining
       */
      setOptionValue(key, value) {
        return this.setOptionValueWithSource(key, value, void 0);
      }
      /**
        * Store option value and where the value came from.
        *
        * @param {string} key
        * @param {Object} value
        * @param {string} source - expected values are default/config/env/cli/implied
        * @return {Command} `this` command for chaining
        */
      setOptionValueWithSource(key, value, source) {
        if (this._storeOptionsAsProperties) {
          this[key] = value;
        } else {
          this._optionValues[key] = value;
        }
        this._optionValueSources[key] = source;
        return this;
      }
      /**
        * Get source of option value.
        * Expected values are default | config | env | cli | implied
        *
        * @param {string} key
        * @return {string}
        */
      getOptionValueSource(key) {
        return this._optionValueSources[key];
      }
      /**
        * Get source of option value. See also .optsWithGlobals().
        * Expected values are default | config | env | cli | implied
        *
        * @param {string} key
        * @return {string}
        */
      getOptionValueSourceWithGlobals(key) {
        let source;
        this._getCommandAndAncestors().forEach((cmd) => {
          if (cmd.getOptionValueSource(key) !== void 0) {
            source = cmd.getOptionValueSource(key);
          }
        });
        return source;
      }
      /**
       * Get user arguments from implied or explicit arguments.
       * Side-effects: set _scriptPath if args included script. Used for default program name, and subcommand searches.
       *
       * @api private
       */
      _prepareUserArgs(argv2, parseOptions) {
        if (argv2 !== void 0 && !Array.isArray(argv2)) {
          throw new Error("first parameter to parse must be array or undefined");
        }
        parseOptions = parseOptions || {};
        if (argv2 === void 0) {
          argv2 = process2.argv;
          if (process2.versions && process2.versions.electron) {
            parseOptions.from = "electron";
          }
        }
        this.rawArgs = argv2.slice();
        let userArgs;
        switch (parseOptions.from) {
          case void 0:
          case "node":
            this._scriptPath = argv2[1];
            userArgs = argv2.slice(2);
            break;
          case "electron":
            if (process2.defaultApp) {
              this._scriptPath = argv2[1];
              userArgs = argv2.slice(2);
            } else {
              userArgs = argv2.slice(1);
            }
            break;
          case "user":
            userArgs = argv2.slice(0);
            break;
          default:
            throw new Error(`unexpected parse option { from: '${parseOptions.from}' }`);
        }
        if (!this._name && this._scriptPath)
          this.nameFromFilename(this._scriptPath);
        this._name = this._name || "program";
        return userArgs;
      }
      /**
       * Parse `argv`, setting options and invoking commands when defined.
       *
       * The default expectation is that the arguments are from node and have the application as argv[0]
       * and the script being run in argv[1], with user parameters after that.
       *
       * @example
       * program.parse(process.argv);
       * program.parse(); // implicitly use process.argv and auto-detect node vs electron conventions
       * program.parse(my-args, { from: 'user' }); // just user supplied arguments, nothing special about argv[0]
       *
       * @param {string[]} [argv] - optional, defaults to process.argv
       * @param {Object} [parseOptions] - optionally specify style of options with from: node/user/electron
       * @param {string} [parseOptions.from] - where the args are from: 'node', 'user', 'electron'
       * @return {Command} `this` command for chaining
       */
      parse(argv2, parseOptions) {
        const userArgs = this._prepareUserArgs(argv2, parseOptions);
        this._parseCommand([], userArgs);
        return this;
      }
      /**
       * Parse `argv`, setting options and invoking commands when defined.
       *
       * Use parseAsync instead of parse if any of your action handlers are async. Returns a Promise.
       *
       * The default expectation is that the arguments are from node and have the application as argv[0]
       * and the script being run in argv[1], with user parameters after that.
       *
       * @example
       * await program.parseAsync(process.argv);
       * await program.parseAsync(); // implicitly use process.argv and auto-detect node vs electron conventions
       * await program.parseAsync(my-args, { from: 'user' }); // just user supplied arguments, nothing special about argv[0]
       *
       * @param {string[]} [argv]
       * @param {Object} [parseOptions]
       * @param {string} parseOptions.from - where the args are from: 'node', 'user', 'electron'
       * @return {Promise}
       */
      async parseAsync(argv2, parseOptions) {
        const userArgs = this._prepareUserArgs(argv2, parseOptions);
        await this._parseCommand([], userArgs);
        return this;
      }
      /**
       * Execute a sub-command executable.
       *
       * @api private
       */
      _executeSubCommand(subcommand, args) {
        args = args.slice();
        let launchWithNode = false;
        const sourceExt = [".js", ".ts", ".tsx", ".mjs", ".cjs"];
        function findFile(baseDir, baseName) {
          const localBin = path2.resolve(baseDir, baseName);
          if (fs3.existsSync(localBin))
            return localBin;
          if (sourceExt.includes(path2.extname(baseName)))
            return void 0;
          const foundExt = sourceExt.find((ext) => fs3.existsSync(`${localBin}${ext}`));
          if (foundExt)
            return `${localBin}${foundExt}`;
          return void 0;
        }
        this._checkForMissingMandatoryOptions();
        this._checkForConflictingOptions();
        let executableFile = subcommand._executableFile || `${this._name}-${subcommand._name}`;
        let executableDir = this._executableDir || "";
        if (this._scriptPath) {
          let resolvedScriptPath;
          try {
            resolvedScriptPath = fs3.realpathSync(this._scriptPath);
          } catch (err) {
            resolvedScriptPath = this._scriptPath;
          }
          executableDir = path2.resolve(path2.dirname(resolvedScriptPath), executableDir);
        }
        if (executableDir) {
          let localFile = findFile(executableDir, executableFile);
          if (!localFile && !subcommand._executableFile && this._scriptPath) {
            const legacyName = path2.basename(this._scriptPath, path2.extname(this._scriptPath));
            if (legacyName !== this._name) {
              localFile = findFile(executableDir, `${legacyName}-${subcommand._name}`);
            }
          }
          executableFile = localFile || executableFile;
        }
        launchWithNode = sourceExt.includes(path2.extname(executableFile));
        let proc;
        if (process2.platform !== "win32") {
          if (launchWithNode) {
            args.unshift(executableFile);
            args = incrementNodeInspectorPort(process2.execArgv).concat(args);
            proc = childProcess.spawn(process2.argv[0], args, { stdio: "inherit" });
          } else {
            proc = childProcess.spawn(executableFile, args, { stdio: "inherit" });
          }
        } else {
          args.unshift(executableFile);
          args = incrementNodeInspectorPort(process2.execArgv).concat(args);
          proc = childProcess.spawn(process2.execPath, args, { stdio: "inherit" });
        }
        if (!proc.killed) {
          const signals = ["SIGUSR1", "SIGUSR2", "SIGTERM", "SIGINT", "SIGHUP"];
          signals.forEach((signal) => {
            process2.on(signal, () => {
              if (proc.killed === false && proc.exitCode === null) {
                proc.kill(signal);
              }
            });
          });
        }
        const exitCallback = this._exitCallback;
        if (!exitCallback) {
          proc.on("close", process2.exit.bind(process2));
        } else {
          proc.on("close", () => {
            exitCallback(new CommanderError2(process2.exitCode || 0, "commander.executeSubCommandAsync", "(close)"));
          });
        }
        proc.on("error", (err) => {
          if (err.code === "ENOENT") {
            const executableDirMessage = executableDir ? `searched for local subcommand relative to directory '${executableDir}'` : "no directory for search for local subcommand, use .executableDir() to supply a custom directory";
            const executableMissing = `'${executableFile}' does not exist
 - if '${subcommand._name}' is not meant to be an executable command, remove description parameter from '.command()' and use '.description()' instead
 - if the default executable name is not suitable, use the executableFile option to supply a custom name or path
 - ${executableDirMessage}`;
            throw new Error(executableMissing);
          } else if (err.code === "EACCES") {
            throw new Error(`'${executableFile}' not executable`);
          }
          if (!exitCallback) {
            process2.exit(1);
          } else {
            const wrappedError = new CommanderError2(1, "commander.executeSubCommandAsync", "(error)");
            wrappedError.nestedError = err;
            exitCallback(wrappedError);
          }
        });
        this.runningCommand = proc;
      }
      /**
       * @api private
       */
      _dispatchSubcommand(commandName, operands, unknown) {
        const subCommand = this._findCommand(commandName);
        if (!subCommand)
          this.help({ error: true });
        let promiseChain;
        promiseChain = this._chainOrCallSubCommandHook(promiseChain, subCommand, "preSubcommand");
        promiseChain = this._chainOrCall(promiseChain, () => {
          if (subCommand._executableHandler) {
            this._executeSubCommand(subCommand, operands.concat(unknown));
          } else {
            return subCommand._parseCommand(operands, unknown);
          }
        });
        return promiseChain;
      }
      /**
       * Invoke help directly if possible, or dispatch if necessary.
       * e.g. help foo
       *
       * @api private
       */
      _dispatchHelpCommand(subcommandName) {
        if (!subcommandName) {
          this.help();
        }
        const subCommand = this._findCommand(subcommandName);
        if (subCommand && !subCommand._executableHandler) {
          subCommand.help();
        }
        return this._dispatchSubcommand(subcommandName, [], [
          this._helpLongFlag || this._helpShortFlag
        ]);
      }
      /**
       * Check this.args against expected this.registeredArguments.
       *
       * @api private
       */
      _checkNumberOfArguments() {
        this.registeredArguments.forEach((arg, i2) => {
          if (arg.required && this.args[i2] == null) {
            this.missingArgument(arg.name());
          }
        });
        if (this.registeredArguments.length > 0 && this.registeredArguments[this.registeredArguments.length - 1].variadic) {
          return;
        }
        if (this.args.length > this.registeredArguments.length) {
          this._excessArguments(this.args);
        }
      }
      /**
       * Process this.args using this.registeredArguments and save as this.processedArgs!
       *
       * @api private
       */
      _processArguments() {
        const myParseArg = (argument, value, previous) => {
          let parsedValue = value;
          if (value !== null && argument.parseArg) {
            const invalidValueMessage = `error: command-argument value '${value}' is invalid for argument '${argument.name()}'.`;
            parsedValue = this._callParseArg(argument, value, previous, invalidValueMessage);
          }
          return parsedValue;
        };
        this._checkNumberOfArguments();
        const processedArgs = [];
        this.registeredArguments.forEach((declaredArg, index) => {
          let value = declaredArg.defaultValue;
          if (declaredArg.variadic) {
            if (index < this.args.length) {
              value = this.args.slice(index);
              if (declaredArg.parseArg) {
                value = value.reduce((processed, v3) => {
                  return myParseArg(declaredArg, v3, processed);
                }, declaredArg.defaultValue);
              }
            } else if (value === void 0) {
              value = [];
            }
          } else if (index < this.args.length) {
            value = this.args[index];
            if (declaredArg.parseArg) {
              value = myParseArg(declaredArg, value, declaredArg.defaultValue);
            }
          }
          processedArgs[index] = value;
        });
        this.processedArgs = processedArgs;
      }
      /**
       * Once we have a promise we chain, but call synchronously until then.
       *
       * @param {Promise|undefined} promise
       * @param {Function} fn
       * @return {Promise|undefined}
       * @api private
       */
      _chainOrCall(promise, fn) {
        if (promise && promise.then && typeof promise.then === "function") {
          return promise.then(() => fn());
        }
        return fn();
      }
      /**
       *
       * @param {Promise|undefined} promise
       * @param {string} event
       * @return {Promise|undefined}
       * @api private
       */
      _chainOrCallHooks(promise, event) {
        let result = promise;
        const hooks = [];
        this._getCommandAndAncestors().reverse().filter((cmd) => cmd._lifeCycleHooks[event] !== void 0).forEach((hookedCommand) => {
          hookedCommand._lifeCycleHooks[event].forEach((callback) => {
            hooks.push({ hookedCommand, callback });
          });
        });
        if (event === "postAction") {
          hooks.reverse();
        }
        hooks.forEach((hookDetail) => {
          result = this._chainOrCall(result, () => {
            return hookDetail.callback(hookDetail.hookedCommand, this);
          });
        });
        return result;
      }
      /**
       *
       * @param {Promise|undefined} promise
       * @param {Command} subCommand
       * @param {string} event
       * @return {Promise|undefined}
       * @api private
       */
      _chainOrCallSubCommandHook(promise, subCommand, event) {
        let result = promise;
        if (this._lifeCycleHooks[event] !== void 0) {
          this._lifeCycleHooks[event].forEach((hook) => {
            result = this._chainOrCall(result, () => {
              return hook(this, subCommand);
            });
          });
        }
        return result;
      }
      /**
       * Process arguments in context of this command.
       * Returns action result, in case it is a promise.
       *
       * @api private
       */
      _parseCommand(operands, unknown) {
        const parsed = this.parseOptions(unknown);
        this._parseOptionsEnv();
        this._parseOptionsImplied();
        operands = operands.concat(parsed.operands);
        unknown = parsed.unknown;
        this.args = operands.concat(unknown);
        if (operands && this._findCommand(operands[0])) {
          return this._dispatchSubcommand(operands[0], operands.slice(1), unknown);
        }
        if (this._hasImplicitHelpCommand() && operands[0] === this._helpCommandName) {
          return this._dispatchHelpCommand(operands[1]);
        }
        if (this._defaultCommandName) {
          outputHelpIfRequested(this, unknown);
          return this._dispatchSubcommand(this._defaultCommandName, operands, unknown);
        }
        if (this.commands.length && this.args.length === 0 && !this._actionHandler && !this._defaultCommandName) {
          this.help({ error: true });
        }
        outputHelpIfRequested(this, parsed.unknown);
        this._checkForMissingMandatoryOptions();
        this._checkForConflictingOptions();
        const checkForUnknownOptions = () => {
          if (parsed.unknown.length > 0) {
            this.unknownOption(parsed.unknown[0]);
          }
        };
        const commandEvent = `command:${this.name()}`;
        if (this._actionHandler) {
          checkForUnknownOptions();
          this._processArguments();
          let promiseChain;
          promiseChain = this._chainOrCallHooks(promiseChain, "preAction");
          promiseChain = this._chainOrCall(promiseChain, () => this._actionHandler(this.processedArgs));
          if (this.parent) {
            promiseChain = this._chainOrCall(promiseChain, () => {
              this.parent.emit(commandEvent, operands, unknown);
            });
          }
          promiseChain = this._chainOrCallHooks(promiseChain, "postAction");
          return promiseChain;
        }
        if (this.parent && this.parent.listenerCount(commandEvent)) {
          checkForUnknownOptions();
          this._processArguments();
          this.parent.emit(commandEvent, operands, unknown);
        } else if (operands.length) {
          if (this._findCommand("*")) {
            return this._dispatchSubcommand("*", operands, unknown);
          }
          if (this.listenerCount("command:*")) {
            this.emit("command:*", operands, unknown);
          } else if (this.commands.length) {
            this.unknownCommand();
          } else {
            checkForUnknownOptions();
            this._processArguments();
          }
        } else if (this.commands.length) {
          checkForUnknownOptions();
          this.help({ error: true });
        } else {
          checkForUnknownOptions();
          this._processArguments();
        }
      }
      /**
       * Find matching command.
       *
       * @api private
       */
      _findCommand(name) {
        if (!name)
          return void 0;
        return this.commands.find((cmd) => cmd._name === name || cmd._aliases.includes(name));
      }
      /**
       * Return an option matching `arg` if any.
       *
       * @param {string} arg
       * @return {Option}
       * @api private
       */
      _findOption(arg) {
        return this.options.find((option) => option.is(arg));
      }
      /**
       * Display an error message if a mandatory option does not have a value.
       * Called after checking for help flags in leaf subcommand.
       *
       * @api private
       */
      _checkForMissingMandatoryOptions() {
        this._getCommandAndAncestors().forEach((cmd) => {
          cmd.options.forEach((anOption) => {
            if (anOption.mandatory && cmd.getOptionValue(anOption.attributeName()) === void 0) {
              cmd.missingMandatoryOptionValue(anOption);
            }
          });
        });
      }
      /**
       * Display an error message if conflicting options are used together in this.
       *
       * @api private
       */
      _checkForConflictingLocalOptions() {
        const definedNonDefaultOptions = this.options.filter(
          (option) => {
            const optionKey = option.attributeName();
            if (this.getOptionValue(optionKey) === void 0) {
              return false;
            }
            return this.getOptionValueSource(optionKey) !== "default";
          }
        );
        const optionsWithConflicting = definedNonDefaultOptions.filter(
          (option) => option.conflictsWith.length > 0
        );
        optionsWithConflicting.forEach((option) => {
          const conflictingAndDefined = definedNonDefaultOptions.find(
            (defined) => option.conflictsWith.includes(defined.attributeName())
          );
          if (conflictingAndDefined) {
            this._conflictingOption(option, conflictingAndDefined);
          }
        });
      }
      /**
       * Display an error message if conflicting options are used together.
       * Called after checking for help flags in leaf subcommand.
       *
       * @api private
       */
      _checkForConflictingOptions() {
        this._getCommandAndAncestors().forEach((cmd) => {
          cmd._checkForConflictingLocalOptions();
        });
      }
      /**
       * Parse options from `argv` removing known options,
       * and return argv split into operands and unknown arguments.
       *
       * Examples:
       *
       *     argv => operands, unknown
       *     --known kkk op => [op], []
       *     op --known kkk => [op], []
       *     sub --unknown uuu op => [sub], [--unknown uuu op]
       *     sub -- --unknown uuu op => [sub --unknown uuu op], []
       *
       * @param {String[]} argv
       * @return {{operands: String[], unknown: String[]}}
       */
      parseOptions(argv2) {
        const operands = [];
        const unknown = [];
        let dest = operands;
        const args = argv2.slice();
        function maybeOption(arg) {
          return arg.length > 1 && arg[0] === "-";
        }
        let activeVariadicOption = null;
        while (args.length) {
          const arg = args.shift();
          if (arg === "--") {
            if (dest === unknown)
              dest.push(arg);
            dest.push(...args);
            break;
          }
          if (activeVariadicOption && !maybeOption(arg)) {
            this.emit(`option:${activeVariadicOption.name()}`, arg);
            continue;
          }
          activeVariadicOption = null;
          if (maybeOption(arg)) {
            const option = this._findOption(arg);
            if (option) {
              if (option.required) {
                const value = args.shift();
                if (value === void 0)
                  this.optionMissingArgument(option);
                this.emit(`option:${option.name()}`, value);
              } else if (option.optional) {
                let value = null;
                if (args.length > 0 && !maybeOption(args[0])) {
                  value = args.shift();
                }
                this.emit(`option:${option.name()}`, value);
              } else {
                this.emit(`option:${option.name()}`);
              }
              activeVariadicOption = option.variadic ? option : null;
              continue;
            }
          }
          if (arg.length > 2 && arg[0] === "-" && arg[1] !== "-") {
            const option = this._findOption(`-${arg[1]}`);
            if (option) {
              if (option.required || option.optional && this._combineFlagAndOptionalValue) {
                this.emit(`option:${option.name()}`, arg.slice(2));
              } else {
                this.emit(`option:${option.name()}`);
                args.unshift(`-${arg.slice(2)}`);
              }
              continue;
            }
          }
          if (/^--[^=]+=/.test(arg)) {
            const index = arg.indexOf("=");
            const option = this._findOption(arg.slice(0, index));
            if (option && (option.required || option.optional)) {
              this.emit(`option:${option.name()}`, arg.slice(index + 1));
              continue;
            }
          }
          if (maybeOption(arg)) {
            dest = unknown;
          }
          if ((this._enablePositionalOptions || this._passThroughOptions) && operands.length === 0 && unknown.length === 0) {
            if (this._findCommand(arg)) {
              operands.push(arg);
              if (args.length > 0)
                unknown.push(...args);
              break;
            } else if (arg === this._helpCommandName && this._hasImplicitHelpCommand()) {
              operands.push(arg);
              if (args.length > 0)
                operands.push(...args);
              break;
            } else if (this._defaultCommandName) {
              unknown.push(arg);
              if (args.length > 0)
                unknown.push(...args);
              break;
            }
          }
          if (this._passThroughOptions) {
            dest.push(arg);
            if (args.length > 0)
              dest.push(...args);
            break;
          }
          dest.push(arg);
        }
        return { operands, unknown };
      }
      /**
       * Return an object containing local option values as key-value pairs.
       *
       * @return {Object}
       */
      opts() {
        if (this._storeOptionsAsProperties) {
          const result = {};
          const len = this.options.length;
          for (let i2 = 0; i2 < len; i2++) {
            const key = this.options[i2].attributeName();
            result[key] = key === this._versionOptionName ? this._version : this[key];
          }
          return result;
        }
        return this._optionValues;
      }
      /**
       * Return an object containing merged local and global option values as key-value pairs.
       *
       * @return {Object}
       */
      optsWithGlobals() {
        return this._getCommandAndAncestors().reduce(
          (combinedOptions, cmd) => Object.assign(combinedOptions, cmd.opts()),
          {}
        );
      }
      /**
       * Display error message and exit (or call exitOverride).
       *
       * @param {string} message
       * @param {Object} [errorOptions]
       * @param {string} [errorOptions.code] - an id string representing the error
       * @param {number} [errorOptions.exitCode] - used with process.exit
       */
      error(message, errorOptions) {
        this._outputConfiguration.outputError(`${message}
`, this._outputConfiguration.writeErr);
        if (typeof this._showHelpAfterError === "string") {
          this._outputConfiguration.writeErr(`${this._showHelpAfterError}
`);
        } else if (this._showHelpAfterError) {
          this._outputConfiguration.writeErr("\n");
          this.outputHelp({ error: true });
        }
        const config = errorOptions || {};
        const exitCode = config.exitCode || 1;
        const code = config.code || "commander.error";
        this._exit(exitCode, code, message);
      }
      /**
       * Apply any option related environment variables, if option does
       * not have a value from cli or client code.
       *
       * @api private
       */
      _parseOptionsEnv() {
        this.options.forEach((option) => {
          if (option.envVar && option.envVar in process2.env) {
            const optionKey = option.attributeName();
            if (this.getOptionValue(optionKey) === void 0 || ["default", "config", "env"].includes(this.getOptionValueSource(optionKey))) {
              if (option.required || option.optional) {
                this.emit(`optionEnv:${option.name()}`, process2.env[option.envVar]);
              } else {
                this.emit(`optionEnv:${option.name()}`);
              }
            }
          }
        });
      }
      /**
       * Apply any implied option values, if option is undefined or default value.
       *
       * @api private
       */
      _parseOptionsImplied() {
        const dualHelper = new DualOptions(this.options);
        const hasCustomOptionValue = (optionKey) => {
          return this.getOptionValue(optionKey) !== void 0 && !["default", "implied"].includes(this.getOptionValueSource(optionKey));
        };
        this.options.filter((option) => option.implied !== void 0 && hasCustomOptionValue(option.attributeName()) && dualHelper.valueFromOption(this.getOptionValue(option.attributeName()), option)).forEach((option) => {
          Object.keys(option.implied).filter((impliedKey) => !hasCustomOptionValue(impliedKey)).forEach((impliedKey) => {
            this.setOptionValueWithSource(impliedKey, option.implied[impliedKey], "implied");
          });
        });
      }
      /**
       * Argument `name` is missing.
       *
       * @param {string} name
       * @api private
       */
      missingArgument(name) {
        const message = `error: missing required argument '${name}'`;
        this.error(message, { code: "commander.missingArgument" });
      }
      /**
       * `Option` is missing an argument.
       *
       * @param {Option} option
       * @api private
       */
      optionMissingArgument(option) {
        const message = `error: option '${option.flags}' argument missing`;
        this.error(message, { code: "commander.optionMissingArgument" });
      }
      /**
       * `Option` does not have a value, and is a mandatory option.
       *
       * @param {Option} option
       * @api private
       */
      missingMandatoryOptionValue(option) {
        const message = `error: required option '${option.flags}' not specified`;
        this.error(message, { code: "commander.missingMandatoryOptionValue" });
      }
      /**
       * `Option` conflicts with another option.
       *
       * @param {Option} option
       * @param {Option} conflictingOption
       * @api private
       */
      _conflictingOption(option, conflictingOption) {
        const findBestOptionFromValue = (option2) => {
          const optionKey = option2.attributeName();
          const optionValue = this.getOptionValue(optionKey);
          const negativeOption = this.options.find((target) => target.negate && optionKey === target.attributeName());
          const positiveOption = this.options.find((target) => !target.negate && optionKey === target.attributeName());
          if (negativeOption && (negativeOption.presetArg === void 0 && optionValue === false || negativeOption.presetArg !== void 0 && optionValue === negativeOption.presetArg)) {
            return negativeOption;
          }
          return positiveOption || option2;
        };
        const getErrorMessage = (option2) => {
          const bestOption = findBestOptionFromValue(option2);
          const optionKey = bestOption.attributeName();
          const source = this.getOptionValueSource(optionKey);
          if (source === "env") {
            return `environment variable '${bestOption.envVar}'`;
          }
          return `option '${bestOption.flags}'`;
        };
        const message = `error: ${getErrorMessage(option)} cannot be used with ${getErrorMessage(conflictingOption)}`;
        this.error(message, { code: "commander.conflictingOption" });
      }
      /**
       * Unknown option `flag`.
       *
       * @param {string} flag
       * @api private
       */
      unknownOption(flag) {
        if (this._allowUnknownOption)
          return;
        let suggestion = "";
        if (flag.startsWith("--") && this._showSuggestionAfterError) {
          let candidateFlags = [];
          let command = this;
          do {
            const moreFlags = command.createHelp().visibleOptions(command).filter((option) => option.long).map((option) => option.long);
            candidateFlags = candidateFlags.concat(moreFlags);
            command = command.parent;
          } while (command && !command._enablePositionalOptions);
          suggestion = suggestSimilar(flag, candidateFlags);
        }
        const message = `error: unknown option '${flag}'${suggestion}`;
        this.error(message, { code: "commander.unknownOption" });
      }
      /**
       * Excess arguments, more than expected.
       *
       * @param {string[]} receivedArgs
       * @api private
       */
      _excessArguments(receivedArgs) {
        if (this._allowExcessArguments)
          return;
        const expected = this.registeredArguments.length;
        const s2 = expected === 1 ? "" : "s";
        const forSubcommand = this.parent ? ` for '${this.name()}'` : "";
        const message = `error: too many arguments${forSubcommand}. Expected ${expected} argument${s2} but got ${receivedArgs.length}.`;
        this.error(message, { code: "commander.excessArguments" });
      }
      /**
       * Unknown command.
       *
       * @api private
       */
      unknownCommand() {
        const unknownName = this.args[0];
        let suggestion = "";
        if (this._showSuggestionAfterError) {
          const candidateNames = [];
          this.createHelp().visibleCommands(this).forEach((command) => {
            candidateNames.push(command.name());
            if (command.alias())
              candidateNames.push(command.alias());
          });
          suggestion = suggestSimilar(unknownName, candidateNames);
        }
        const message = `error: unknown command '${unknownName}'${suggestion}`;
        this.error(message, { code: "commander.unknownCommand" });
      }
      /**
       * Get or set the program version.
       *
       * This method auto-registers the "-V, --version" option which will print the version number.
       *
       * You can optionally supply the flags and description to override the defaults.
       *
       * @param {string} [str]
       * @param {string} [flags]
       * @param {string} [description]
       * @return {this | string | undefined} `this` command for chaining, or version string if no arguments
       */
      version(str, flags, description) {
        if (str === void 0)
          return this._version;
        this._version = str;
        flags = flags || "-V, --version";
        description = description || "output the version number";
        const versionOption = this.createOption(flags, description);
        this._versionOptionName = versionOption.attributeName();
        this.options.push(versionOption);
        this.on("option:" + versionOption.name(), () => {
          this._outputConfiguration.writeOut(`${str}
`);
          this._exit(0, "commander.version", str);
        });
        return this;
      }
      /**
       * Set the description.
       *
       * @param {string} [str]
       * @param {Object} [argsDescription]
       * @return {string|Command}
       */
      description(str, argsDescription) {
        if (str === void 0 && argsDescription === void 0)
          return this._description;
        this._description = str;
        if (argsDescription) {
          this._argsDescription = argsDescription;
        }
        return this;
      }
      /**
       * Set the summary. Used when listed as subcommand of parent.
       *
       * @param {string} [str]
       * @return {string|Command}
       */
      summary(str) {
        if (str === void 0)
          return this._summary;
        this._summary = str;
        return this;
      }
      /**
       * Set an alias for the command.
       *
       * You may call more than once to add multiple aliases. Only the first alias is shown in the auto-generated help.
       *
       * @param {string} [alias]
       * @return {string|Command}
       */
      alias(alias) {
        if (alias === void 0)
          return this._aliases[0];
        let command = this;
        if (this.commands.length !== 0 && this.commands[this.commands.length - 1]._executableHandler) {
          command = this.commands[this.commands.length - 1];
        }
        if (alias === command._name)
          throw new Error("Command alias can't be the same as its name");
        command._aliases.push(alias);
        return this;
      }
      /**
       * Set aliases for the command.
       *
       * Only the first alias is shown in the auto-generated help.
       *
       * @param {string[]} [aliases]
       * @return {string[]|Command}
       */
      aliases(aliases) {
        if (aliases === void 0)
          return this._aliases;
        aliases.forEach((alias) => this.alias(alias));
        return this;
      }
      /**
       * Set / get the command usage `str`.
       *
       * @param {string} [str]
       * @return {String|Command}
       */
      usage(str) {
        if (str === void 0) {
          if (this._usage)
            return this._usage;
          const args = this.registeredArguments.map((arg) => {
            return humanReadableArgName(arg);
          });
          return [].concat(
            this.options.length || this._hasHelpOption ? "[options]" : [],
            this.commands.length ? "[command]" : [],
            this.registeredArguments.length ? args : []
          ).join(" ");
        }
        this._usage = str;
        return this;
      }
      /**
       * Get or set the name of the command.
       *
       * @param {string} [str]
       * @return {string|Command}
       */
      name(str) {
        if (str === void 0)
          return this._name;
        this._name = str;
        return this;
      }
      /**
       * Set the name of the command from script filename, such as process.argv[1],
       * or require.main.filename, or __filename.
       *
       * (Used internally and public although not documented in README.)
       *
       * @example
       * program.nameFromFilename(require.main.filename);
       *
       * @param {string} filename
       * @return {Command}
       */
      nameFromFilename(filename) {
        this._name = path2.basename(filename, path2.extname(filename));
        return this;
      }
      /**
       * Get or set the directory for searching for executable subcommands of this command.
       *
       * @example
       * program.executableDir(__dirname);
       * // or
       * program.executableDir('subcommands');
       *
       * @param {string} [path]
       * @return {string|null|Command}
       */
      executableDir(path3) {
        if (path3 === void 0)
          return this._executableDir;
        this._executableDir = path3;
        return this;
      }
      /**
       * Return program help documentation.
       *
       * @param {{ error: boolean }} [contextOptions] - pass {error:true} to wrap for stderr instead of stdout
       * @return {string}
       */
      helpInformation(contextOptions) {
        const helper = this.createHelp();
        if (helper.helpWidth === void 0) {
          helper.helpWidth = contextOptions && contextOptions.error ? this._outputConfiguration.getErrHelpWidth() : this._outputConfiguration.getOutHelpWidth();
        }
        return helper.formatHelp(this, helper);
      }
      /**
       * @api private
       */
      _getHelpContext(contextOptions) {
        contextOptions = contextOptions || {};
        const context2 = { error: !!contextOptions.error };
        let write;
        if (context2.error) {
          write = (arg) => this._outputConfiguration.writeErr(arg);
        } else {
          write = (arg) => this._outputConfiguration.writeOut(arg);
        }
        context2.write = contextOptions.write || write;
        context2.command = this;
        return context2;
      }
      /**
       * Output help information for this command.
       *
       * Outputs built-in help, and custom text added using `.addHelpText()`.
       *
       * @param {{ error: boolean } | Function} [contextOptions] - pass {error:true} to write to stderr instead of stdout
       */
      outputHelp(contextOptions) {
        let deprecatedCallback;
        if (typeof contextOptions === "function") {
          deprecatedCallback = contextOptions;
          contextOptions = void 0;
        }
        const context2 = this._getHelpContext(contextOptions);
        this._getCommandAndAncestors().reverse().forEach((command) => command.emit("beforeAllHelp", context2));
        this.emit("beforeHelp", context2);
        let helpInformation = this.helpInformation(context2);
        if (deprecatedCallback) {
          helpInformation = deprecatedCallback(helpInformation);
          if (typeof helpInformation !== "string" && !Buffer.isBuffer(helpInformation)) {
            throw new Error("outputHelp callback must return a string or a Buffer");
          }
        }
        context2.write(helpInformation);
        if (this._helpLongFlag) {
          this.emit(this._helpLongFlag);
        }
        this.emit("afterHelp", context2);
        this._getCommandAndAncestors().forEach((command) => command.emit("afterAllHelp", context2));
      }
      /**
       * You can pass in flags and a description to override the help
       * flags and help description for your command. Pass in false to
       * disable the built-in help option.
       *
       * @param {string | boolean} [flags]
       * @param {string} [description]
       * @return {Command} `this` command for chaining
       */
      helpOption(flags, description) {
        if (typeof flags === "boolean") {
          this._hasHelpOption = flags;
          return this;
        }
        this._helpFlags = flags || this._helpFlags;
        this._helpDescription = description || this._helpDescription;
        const helpFlags = splitOptionFlags(this._helpFlags);
        this._helpShortFlag = helpFlags.shortFlag;
        this._helpLongFlag = helpFlags.longFlag;
        return this;
      }
      /**
       * Output help information and exit.
       *
       * Outputs built-in help, and custom text added using `.addHelpText()`.
       *
       * @param {{ error: boolean }} [contextOptions] - pass {error:true} to write to stderr instead of stdout
       */
      help(contextOptions) {
        this.outputHelp(contextOptions);
        let exitCode = process2.exitCode || 0;
        if (exitCode === 0 && contextOptions && typeof contextOptions !== "function" && contextOptions.error) {
          exitCode = 1;
        }
        this._exit(exitCode, "commander.help", "(outputHelp)");
      }
      /**
       * Add additional text to be displayed with the built-in help.
       *
       * Position is 'before' or 'after' to affect just this command,
       * and 'beforeAll' or 'afterAll' to affect this command and all its subcommands.
       *
       * @param {string} position - before or after built-in help
       * @param {string | Function} text - string to add, or a function returning a string
       * @return {Command} `this` command for chaining
       */
      addHelpText(position, text) {
        const allowedValues = ["beforeAll", "before", "after", "afterAll"];
        if (!allowedValues.includes(position)) {
          throw new Error(`Unexpected value for position to addHelpText.
Expecting one of '${allowedValues.join("', '")}'`);
        }
        const helpEvent = `${position}Help`;
        this.on(helpEvent, (context2) => {
          let helpStr;
          if (typeof text === "function") {
            helpStr = text({ error: context2.error, command: context2.command });
          } else {
            helpStr = text;
          }
          if (helpStr) {
            context2.write(`${helpStr}
`);
          }
        });
        return this;
      }
    };
    function outputHelpIfRequested(cmd, args) {
      const helpOption = cmd._hasHelpOption && args.find((arg) => arg === cmd._helpLongFlag || arg === cmd._helpShortFlag);
      if (helpOption) {
        cmd.outputHelp();
        cmd._exit(0, "commander.helpDisplayed", "(outputHelp)");
      }
    }
    function incrementNodeInspectorPort(args) {
      return args.map((arg) => {
        if (!arg.startsWith("--inspect")) {
          return arg;
        }
        let debugOption;
        let debugHost = "127.0.0.1";
        let debugPort = "9229";
        let match;
        if ((match = arg.match(/^(--inspect(-brk)?)$/)) !== null) {
          debugOption = match[1];
        } else if ((match = arg.match(/^(--inspect(-brk|-port)?)=([^:]+)$/)) !== null) {
          debugOption = match[1];
          if (/^\d+$/.test(match[3])) {
            debugPort = match[3];
          } else {
            debugHost = match[3];
          }
        } else if ((match = arg.match(/^(--inspect(-brk|-port)?)=([^:]+):(\d+)$/)) !== null) {
          debugOption = match[1];
          debugHost = match[3];
          debugPort = match[4];
        }
        if (debugOption && debugPort !== "0") {
          return `${debugOption}=${debugHost}:${parseInt(debugPort) + 1}`;
        }
        return arg;
      });
    }
    exports.Command = Command2;
  }
});

// ../../../node_modules/.pnpm/commander@11.1.0/node_modules/commander/index.js
var require_commander = __commonJS({
  "../../../node_modules/.pnpm/commander@11.1.0/node_modules/commander/index.js"(exports, module) {
    init_define_ENV_DEFINED_IN_BUILD_STEP();
    var { Argument: Argument3 } = require_argument();
    var { Command: Command2 } = require_command();
    var { CommanderError: CommanderError2, InvalidArgumentError: InvalidArgumentError2 } = require_error();
    var { Help: Help2 } = require_help();
    var { Option: Option2 } = require_option();
    exports = module.exports = new Command2();
    exports.program = exports;
    exports.Command = Command2;
    exports.Option = Option2;
    exports.Argument = Argument3;
    exports.Help = Help2;
    exports.CommanderError = CommanderError2;
    exports.InvalidArgumentError = InvalidArgumentError2;
    exports.InvalidOptionArgumentError = InvalidArgumentError2;
  }
});

// ../../../node_modules/.pnpm/typed-rpc@3.0.0/node_modules/typed-rpc/lib/client.js
var require_client = __commonJS({
  "../../../node_modules/.pnpm/typed-rpc@3.0.0/node_modules/typed-rpc/lib/client.js"(exports) {
    "use strict";
    init_define_ENV_DEFINED_IN_BUILD_STEP();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.rpcClient = exports.RpcError = void 0;
    var RpcError = class _RpcError extends Error {
      constructor(message, code, data) {
        super(message);
        this.code = code;
        this.data = data;
        Object.setPrototypeOf(this, _RpcError.prototype);
      }
    };
    exports.RpcError = RpcError;
    function rpcClient2(url, options) {
      const request = async (method, params) => {
        const id = Date.now();
        const headers = (options == null ? void 0 : options.getHeaders) ? await options.getHeaders() : {};
        const res = await fetch(url, {
          method: "POST",
          headers: {
            Accept: "application/json",
            "Content-Type": "application/json",
            ...headers
          },
          body: JSON.stringify({
            jsonrpc: "2.0",
            id,
            method,
            params: removeTrailingUndefs(params)
          }),
          credentials: options == null ? void 0 : options.credentials
        });
        if (!res.ok) {
          throw new RpcError(res.statusText, res.status);
        }
        const { result, error } = await res.json();
        if (error) {
          const { code, message, data } = error;
          throw new RpcError(message, code, data);
        }
        return result;
      };
      return new Proxy({}, {
        /* istanbul ignore next */
        get(target, prop, receiver) {
          if (isRemote(prop)) {
            return (...args) => request(prop.toString(), args);
          }
        }
      });
    }
    exports.rpcClient = rpcClient2;
    function isRemote(prop) {
      if (typeof prop === "symbol")
        return false;
      if (prop.startsWith("$"))
        return false;
      if (prop in Object.prototype)
        return false;
      if (prop === "toJSON")
        return false;
      return true;
    }
    function removeTrailingUndefs(values) {
      const a3 = [...values];
      while (a3.length && a3[a3.length - 1] === void 0)
        a3.length--;
      return a3;
    }
  }
});

// ../../../node_modules/.pnpm/human-id@4.1.1/node_modules/human-id/dist/index.js
var require_dist = __commonJS({
  "../../../node_modules/.pnpm/human-id@4.1.1/node_modules/human-id/dist/index.js"(exports) {
    "use strict";
    init_define_ENV_DEFINED_IN_BUILD_STEP();
    var __spreadArray = exports && exports.__spreadArray || function(to, from, pack) {
      if (pack || arguments.length === 2)
        for (var i2 = 0, l2 = from.length, ar; i2 < l2; i2++) {
          if (ar || !(i2 in from)) {
            if (!ar)
              ar = Array.prototype.slice.call(from, 0, i2);
            ar[i2] = from[i2];
          }
        }
      return to.concat(ar || Array.prototype.slice.call(from));
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.minLength = exports.maxLength = exports.poolSize = exports.humanId = exports.adverbs = exports.verbs = exports.nouns = exports.adjectives = void 0;
    exports.adjectives = ["afraid", "all", "angry", "beige", "big", "better", "bitter", "blue", "brave", "breezy", "bright", "brown", "bumpy", "busy", "calm", "chatty", "chilly", "chubby", "clean", "clear", "clever", "cold", "crazy", "cruel", "cuddly", "curly", "curvy", "cute", "common", "cold", "cool", "cyan", "dark", "deep", "dirty", "dry", "dull", "eager", "early", "easy", "eight", "eighty", "eleven", "empty", "every", "evil", "fair", "famous", "fast", "fancy", "few", "fine", "fifty", "five", "flat", "fluffy", "floppy", "forty", "four", "free", "fresh", "fruity", "full", "funny", "fuzzy", "gentle", "giant", "gold", "good", "great", "green", "grumpy", "happy", "heavy", "hip", "honest", "hot", "huge", "hungry", "icy", "itchy", "khaki", "kind", "large", "late", "lazy", "lemon", "legal", "light", "little", "long", "loose", "loud", "lovely", "lucky", "major", "many", "mean", "metal", "mighty", "modern", "moody", "nasty", "neat", "new", "nice", "nine", "ninety", "odd", "old", "olive", "open", "orange", "pink", "plain", "plenty", "polite", "poor", "pretty", "proud", "public", "puny", "petite", "purple", "quick", "quiet", "rare", "real", "ready", "red", "rich", "ripe", "rotten", "rude", "sad", "salty", "seven", "shaggy", "shaky", "sharp", "shiny", "short", "shy", "silent", "silly", "silver", "six", "sixty", "slick", "slimy", "slow", "small", "smart", "smooth", "social", "soft", "solid", "some", "sour", "spicy", "spotty", "stale", "strong", "stupid", "sweet", "swift", "tall", "tame", "tangy", "tasty", "ten", "tender", "thick", "thin", "thirty", "three", "tidy", "tiny", "tired", "tough", "tricky", "true", "twelve", "twenty", "two", "upset", "vast", "violet", "warm", "weak", "wet", "whole", "wicked", "wide", "wild", "wise", "witty", "yellow", "young", "yummy"];
    exports.nouns = ["apes", "animals", "areas", "bars", "banks", "baths", "breads", "bushes", "cloths", "clowns", "clubs", "hoops", "loops", "memes", "papers", "parks", "paths", "showers", "sides", "signs", "sites", "streets", "teeth", "tires", "webs", "actors", "ads", "adults", "aliens", "ants", "apples", "baboons", "badgers", "bags", "bananas", "bats", "beans", "bears", "beds", "beers", "bees", "berries", "bikes", "birds", "boats", "bobcats", "books", "bottles", "boxes", "brooms", "buckets", "bugs", "buses", "buttons", "camels", "cases", "cameras", "candies", "candles", "carpets", "carrots", "carrots", "cars", "cats", "chairs", "chefs", "chicken", "clocks", "clouds", "coats", "cobras", "coins", "corners", "colts", "comics", "cooks", "cougars", "regions", "results", "cows", "crabs", "crabs", "crews", "cups", "cities", "cycles", "dancers", "days", "deer", "dingos", "dodos", "dogs", "dolls", "donkeys", "donuts", "doodles", "doors", "dots", "dragons", "drinks", "dryers", "ducks", "ducks", "eagles", "ears", "eels", "eggs", "ends", "mammals", "emus", "experts", "eyes", "facts", "falcons", "fans", "feet", "files", "flies", "flowers", "forks", "foxes", "friends", "frogs", "games", "garlics", "geckos", "geese", "ghosts", "ghosts", "gifts", "glasses", "goats", "grapes", "groups", "guests", "hairs", "hands", "hats", "heads", "hornets", "horses", "hotels", "hounds", "houses", "humans", "icons", "ideas", "impalas", "insects", "islands", "items", "jars", "jeans", "jobs", "jokes", "keys", "kids", "kings", "kiwis", "knives", "lamps", "lands", "laws", "lemons", "lies", "lights", "lines", "lions", "lizards", "llamas", "mails", "mangos", "maps", "masks", "meals", "melons", "mice", "mirrors", "moments", "moles", "monkeys", "months", "moons", "moose", "mugs", "nails", "needles", "news", "nights", "numbers", "olives", "onions", "oranges", "otters", "owls", "pandas", "pans", "pants", "papayas", "parents", "parts", "parrots", "paws", "peaches", "pears", "peas", "pens", "pets", "phones", "pianos", "pigs", "pillows", "places", "planes", "planets", "plants", "plums", "poems", "poets", "points", "pots", "pugs", "pumas", "queens", "rabbits", "radios", "rats", "ravens", "readers", "rice", "rings", "rivers", "rockets", "rocks", "rooms", "roses", "rules", "schools", "bats", "seals", "seas", "sheep", "shirts", "shoes", "shrimps", "singers", "sloths", "snails", "snakes", "socks", "spiders", "spies", "spoons", "squids", "stars", "states", "steaks", "wings", "suits", "suns", "swans", "symbols", "tables", "taxes", "taxis", "teams", "terms", "things", "ties", "tigers", "times", "tips", "toes", "towns", "tools", "toys", "trains", "trams", "trees", "turkeys", "turtles", "vans", "views", "walls", "walls", "wasps", "waves", "ways", "weeks", "windows", "wolves", "women", "wombats", "words", "worlds", "worms", "yaks", "years", "zebras", "zoos"];
    exports.verbs = ["accept", "act", "add", "admire", "agree", "allow", "appear", "argue", "arrive", "ask", "attack", "attend", "bake", "bathe", "battle", "beam", "beg", "begin", "behave", "bet", "boil", "bow", "brake", "brush", "build", "burn", "buy", "call", "camp", "care", "carry", "change", "cheat", "check", "cheer", "chew", "clap", "clean", "cough", "count", "cover", "crash", "create", "cross", "cry", "cut", "dance", "decide", "deny", "design", "dig", "divide", "do", "double", "doubt", "draw", "dream", "dress", "drive", "drop", "drum", "eat", "end", "enter", "enjoy", "exist", "fail", "fall", "feel", "fetch", "film", "find", "fix", "flash", "float", "flow", "fly", "fold", "follow", "fry", "give", "glow", "go", "grab", "greet", "grin", "grow", "guess", "hammer", "hang", "happen", "heal", "hear", "help", "hide", "hope", "hug", "hunt", "invent", "invite", "itch", "jam", "jog", "join", "joke", "judge", "juggle", "jump", "kick", "kiss", "kneel", "knock", "know", "laugh", "lay", "lead", "learn", "leave", "lick", "like", "lie", "listen", "live", "look", "lose", "love", "make", "march", "marry", "mate", "matter", "melt", "mix", "move", "nail", "notice", "obey", "occur", "open", "own", "pay", "peel", "play", "poke", "post", "press", "prove", "pull", "pump", "pick", "punch", "push", "raise", "read", "refuse", "relate", "relax", "remain", "repair", "repeat", "reply", "report", "rescue", "rest", "retire", "return", "rhyme", "ring", "roll", "rule", "run", "rush", "say", "scream", "see", "search", "sell", "send", "serve", "shake", "share", "shave", "shine", "show", "shop", "shout", "sin", "sink", "sing", "sip", "sit", "sleep", "slide", "smash", "smell", "smile", "smoke", "sneeze", "sniff", "sort", "speak", "spend", "stand", "start", "stay", "stick", "stop", "stare", "study", "strive", "swim", "switch", "take", "talk", "tan", "tap", "taste", "teach", "tease", "tell", "thank", "think", "throw", "tickle", "tie", "trade", "train", "travel", "try", "turn", "type", "unite", "vanish", "visit", "wait", "walk", "warn", "wash", "watch", "wave", "wear", "win", "wink", "wish", "wonder", "work", "worry", "write", "yawn", "yell"];
    exports.adverbs = ["bravely", "brightly", "busily", "daily", "freely", "hungrily", "joyously", "knowlingly", "lazily", "oddly", "mysteriously", "noisily", "politely", "quickly", "quietly", "rapidly", "safely", "sleepily", "slowly", "truly", "yearly"];
    function random2(arr) {
      return arr[Math.floor(Math.random() * arr.length)];
    }
    function longest(arr) {
      return arr.reduce(function(a3, b) {
        return a3.length > b.length ? a3 : b;
      });
    }
    function shortest(arr) {
      return arr.reduce(function(a3, b) {
        return a3.length < b.length ? a3 : b;
      });
    }
    function humanId4(options) {
      if (options === void 0) {
        options = {};
      }
      if (typeof options === "string")
        options = { separator: options };
      if (typeof options === "boolean")
        options = { capitalize: options };
      var _a8 = options.separator, separator = _a8 === void 0 ? "" : _a8, _b5 = options.capitalize, capitalize = _b5 === void 0 ? true : _b5, _c = options.adjectiveCount, adjectiveCount = _c === void 0 ? 1 : _c, _d = options.addAdverb, addAdverb = _d === void 0 ? false : _d;
      var res = __spreadArray(__spreadArray(__spreadArray([], __spreadArray([], Array(adjectiveCount), true).map(function(_3) {
        return random2(exports.adjectives);
      }), true), [
        random2(exports.nouns),
        random2(exports.verbs)
      ], false), addAdverb ? [random2(exports.adverbs)] : [], true);
      if (capitalize)
        res = res.map(function(r3) {
          return r3.charAt(0).toUpperCase() + r3.substr(1);
        });
      return res.join(separator);
    }
    exports.humanId = humanId4;
    function poolSize(options) {
      if (options === void 0) {
        options = {};
      }
      var _a8 = options.adjectiveCount, adjectiveCount = _a8 === void 0 ? 1 : _a8, _b5 = options.addAdverb, addAdverb = _b5 === void 0 ? false : _b5;
      return exports.adjectives.length * adjectiveCount * exports.nouns.length * exports.verbs.length * (addAdverb ? exports.adverbs.length : 1);
    }
    exports.poolSize = poolSize;
    function maxLength(options) {
      if (options === void 0) {
        options = {};
      }
      var _a8 = options.adjectiveCount, adjectiveCount = _a8 === void 0 ? 1 : _a8, _b5 = options.addAdverb, addAdverb = _b5 === void 0 ? false : _b5, _c = options.separator, separator = _c === void 0 ? "" : _c;
      return longest(exports.adjectives).length * adjectiveCount + adjectiveCount * separator.length + longest(exports.nouns).length + separator.length + longest(exports.verbs).length + (addAdverb ? longest(exports.adverbs).length + separator.length : 0);
    }
    exports.maxLength = maxLength;
    function minLength(options) {
      if (options === void 0) {
        options = {};
      }
      var _a8 = options.adjectiveCount, adjectiveCount = _a8 === void 0 ? 1 : _a8, _b5 = options.addAdverb, addAdverb = _b5 === void 0 ? false : _b5, _c = options.separator, separator = _c === void 0 ? "" : _c;
      return shortest(exports.adjectives).length * adjectiveCount + adjectiveCount * separator.length + shortest(exports.nouns).length + separator.length + shortest(exports.verbs).length + (addAdverb ? shortest(exports.adverbs).length + separator.length : 0);
    }
    exports.minLength = minLength;
    exports.default = humanId4;
  }
});

// ../../../node_modules/.pnpm/js-sha256@0.11.0/node_modules/js-sha256/src/sha256.js
var require_sha256 = __commonJS({
  "../../../node_modules/.pnpm/js-sha256@0.11.0/node_modules/js-sha256/src/sha256.js"(exports, module) {
    init_define_ENV_DEFINED_IN_BUILD_STEP();
    (function() {
      "use strict";
      var ERROR = "input is invalid type";
      var WINDOW = typeof window === "object";
      var root = WINDOW ? window : {};
      if (root.JS_SHA256_NO_WINDOW) {
        WINDOW = false;
      }
      var WEB_WORKER = !WINDOW && typeof self === "object";
      var NODE_JS = !root.JS_SHA256_NO_NODE_JS && typeof process === "object" && process.versions && process.versions.node;
      if (NODE_JS) {
        root = global;
      } else if (WEB_WORKER) {
        root = self;
      }
      var COMMON_JS = !root.JS_SHA256_NO_COMMON_JS && typeof module === "object" && module.exports;
      var AMD = typeof define === "function" && define.amd;
      var ARRAY_BUFFER = !root.JS_SHA256_NO_ARRAY_BUFFER && typeof ArrayBuffer !== "undefined";
      var HEX_CHARS = "0123456789abcdef".split("");
      var EXTRA = [-2147483648, 8388608, 32768, 128];
      var SHIFT = [24, 16, 8, 0];
      var K = [
        1116352408,
        1899447441,
        3049323471,
        3921009573,
        961987163,
        1508970993,
        2453635748,
        2870763221,
        3624381080,
        310598401,
        607225278,
        1426881987,
        1925078388,
        2162078206,
        2614888103,
        3248222580,
        3835390401,
        4022224774,
        264347078,
        604807628,
        770255983,
        1249150122,
        1555081692,
        1996064986,
        2554220882,
        2821834349,
        2952996808,
        3210313671,
        3336571891,
        3584528711,
        113926993,
        338241895,
        666307205,
        773529912,
        1294757372,
        1396182291,
        1695183700,
        1986661051,
        2177026350,
        2456956037,
        2730485921,
        2820302411,
        3259730800,
        3345764771,
        3516065817,
        3600352804,
        4094571909,
        275423344,
        430227734,
        506948616,
        659060556,
        883997877,
        958139571,
        1322822218,
        1537002063,
        1747873779,
        1955562222,
        2024104815,
        2227730452,
        2361852424,
        2428436474,
        2756734187,
        3204031479,
        3329325298
      ];
      var OUTPUT_TYPES = ["hex", "array", "digest", "arrayBuffer"];
      var blocks = [];
      if (root.JS_SHA256_NO_NODE_JS || !Array.isArray) {
        Array.isArray = function(obj) {
          return Object.prototype.toString.call(obj) === "[object Array]";
        };
      }
      if (ARRAY_BUFFER && (root.JS_SHA256_NO_ARRAY_BUFFER_IS_VIEW || !ArrayBuffer.isView)) {
        ArrayBuffer.isView = function(obj) {
          return typeof obj === "object" && obj.buffer && obj.buffer.constructor === ArrayBuffer;
        };
      }
      var createOutputMethod = function(outputType, is224) {
        return function(message) {
          return new Sha256(is224, true).update(message)[outputType]();
        };
      };
      var createMethod = function(is224) {
        var method = createOutputMethod("hex", is224);
        if (NODE_JS) {
          method = nodeWrap(method, is224);
        }
        method.create = function() {
          return new Sha256(is224);
        };
        method.update = function(message) {
          return method.create().update(message);
        };
        for (var i2 = 0; i2 < OUTPUT_TYPES.length; ++i2) {
          var type = OUTPUT_TYPES[i2];
          method[type] = createOutputMethod(type, is224);
        }
        return method;
      };
      var nodeWrap = function(method, is224) {
        var crypto4 = __require("crypto");
        var Buffer2 = __require("buffer").Buffer;
        var algorithm = is224 ? "sha224" : "sha256";
        var bufferFrom;
        if (Buffer2.from && !root.JS_SHA256_NO_BUFFER_FROM) {
          bufferFrom = Buffer2.from;
        } else {
          bufferFrom = function(message) {
            return new Buffer2(message);
          };
        }
        var nodeMethod = function(message) {
          if (typeof message === "string") {
            return crypto4.createHash(algorithm).update(message, "utf8").digest("hex");
          } else {
            if (message === null || message === void 0) {
              throw new Error(ERROR);
            } else if (message.constructor === ArrayBuffer) {
              message = new Uint8Array(message);
            }
          }
          if (Array.isArray(message) || ArrayBuffer.isView(message) || message.constructor === Buffer2) {
            return crypto4.createHash(algorithm).update(bufferFrom(message)).digest("hex");
          } else {
            return method(message);
          }
        };
        return nodeMethod;
      };
      var createHmacOutputMethod = function(outputType, is224) {
        return function(key, message) {
          return new HmacSha256(key, is224, true).update(message)[outputType]();
        };
      };
      var createHmacMethod = function(is224) {
        var method = createHmacOutputMethod("hex", is224);
        method.create = function(key) {
          return new HmacSha256(key, is224);
        };
        method.update = function(key, message) {
          return method.create(key).update(message);
        };
        for (var i2 = 0; i2 < OUTPUT_TYPES.length; ++i2) {
          var type = OUTPUT_TYPES[i2];
          method[type] = createHmacOutputMethod(type, is224);
        }
        return method;
      };
      function Sha256(is224, sharedMemory) {
        if (sharedMemory) {
          blocks[0] = blocks[16] = blocks[1] = blocks[2] = blocks[3] = blocks[4] = blocks[5] = blocks[6] = blocks[7] = blocks[8] = blocks[9] = blocks[10] = blocks[11] = blocks[12] = blocks[13] = blocks[14] = blocks[15] = 0;
          this.blocks = blocks;
        } else {
          this.blocks = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0];
        }
        if (is224) {
          this.h0 = 3238371032;
          this.h1 = 914150663;
          this.h2 = 812702999;
          this.h3 = 4144912697;
          this.h4 = 4290775857;
          this.h5 = 1750603025;
          this.h6 = 1694076839;
          this.h7 = 3204075428;
        } else {
          this.h0 = 1779033703;
          this.h1 = 3144134277;
          this.h2 = 1013904242;
          this.h3 = 2773480762;
          this.h4 = 1359893119;
          this.h5 = 2600822924;
          this.h6 = 528734635;
          this.h7 = 1541459225;
        }
        this.block = this.start = this.bytes = this.hBytes = 0;
        this.finalized = this.hashed = false;
        this.first = true;
        this.is224 = is224;
      }
      Sha256.prototype.update = function(message) {
        if (this.finalized) {
          return;
        }
        var notString, type = typeof message;
        if (type !== "string") {
          if (type === "object") {
            if (message === null) {
              throw new Error(ERROR);
            } else if (ARRAY_BUFFER && message.constructor === ArrayBuffer) {
              message = new Uint8Array(message);
            } else if (!Array.isArray(message)) {
              if (!ARRAY_BUFFER || !ArrayBuffer.isView(message)) {
                throw new Error(ERROR);
              }
            }
          } else {
            throw new Error(ERROR);
          }
          notString = true;
        }
        var code, index = 0, i2, length = message.length, blocks2 = this.blocks;
        while (index < length) {
          if (this.hashed) {
            this.hashed = false;
            blocks2[0] = this.block;
            this.block = blocks2[16] = blocks2[1] = blocks2[2] = blocks2[3] = blocks2[4] = blocks2[5] = blocks2[6] = blocks2[7] = blocks2[8] = blocks2[9] = blocks2[10] = blocks2[11] = blocks2[12] = blocks2[13] = blocks2[14] = blocks2[15] = 0;
          }
          if (notString) {
            for (i2 = this.start; index < length && i2 < 64; ++index) {
              blocks2[i2 >>> 2] |= message[index] << SHIFT[i2++ & 3];
            }
          } else {
            for (i2 = this.start; index < length && i2 < 64; ++index) {
              code = message.charCodeAt(index);
              if (code < 128) {
                blocks2[i2 >>> 2] |= code << SHIFT[i2++ & 3];
              } else if (code < 2048) {
                blocks2[i2 >>> 2] |= (192 | code >>> 6) << SHIFT[i2++ & 3];
                blocks2[i2 >>> 2] |= (128 | code & 63) << SHIFT[i2++ & 3];
              } else if (code < 55296 || code >= 57344) {
                blocks2[i2 >>> 2] |= (224 | code >>> 12) << SHIFT[i2++ & 3];
                blocks2[i2 >>> 2] |= (128 | code >>> 6 & 63) << SHIFT[i2++ & 3];
                blocks2[i2 >>> 2] |= (128 | code & 63) << SHIFT[i2++ & 3];
              } else {
                code = 65536 + ((code & 1023) << 10 | message.charCodeAt(++index) & 1023);
                blocks2[i2 >>> 2] |= (240 | code >>> 18) << SHIFT[i2++ & 3];
                blocks2[i2 >>> 2] |= (128 | code >>> 12 & 63) << SHIFT[i2++ & 3];
                blocks2[i2 >>> 2] |= (128 | code >>> 6 & 63) << SHIFT[i2++ & 3];
                blocks2[i2 >>> 2] |= (128 | code & 63) << SHIFT[i2++ & 3];
              }
            }
          }
          this.lastByteIndex = i2;
          this.bytes += i2 - this.start;
          if (i2 >= 64) {
            this.block = blocks2[16];
            this.start = i2 - 64;
            this.hash();
            this.hashed = true;
          } else {
            this.start = i2;
          }
        }
        if (this.bytes > 4294967295) {
          this.hBytes += this.bytes / 4294967296 << 0;
          this.bytes = this.bytes % 4294967296;
        }
        return this;
      };
      Sha256.prototype.finalize = function() {
        if (this.finalized) {
          return;
        }
        this.finalized = true;
        var blocks2 = this.blocks, i2 = this.lastByteIndex;
        blocks2[16] = this.block;
        blocks2[i2 >>> 2] |= EXTRA[i2 & 3];
        this.block = blocks2[16];
        if (i2 >= 56) {
          if (!this.hashed) {
            this.hash();
          }
          blocks2[0] = this.block;
          blocks2[16] = blocks2[1] = blocks2[2] = blocks2[3] = blocks2[4] = blocks2[5] = blocks2[6] = blocks2[7] = blocks2[8] = blocks2[9] = blocks2[10] = blocks2[11] = blocks2[12] = blocks2[13] = blocks2[14] = blocks2[15] = 0;
        }
        blocks2[14] = this.hBytes << 3 | this.bytes >>> 29;
        blocks2[15] = this.bytes << 3;
        this.hash();
      };
      Sha256.prototype.hash = function() {
        var a3 = this.h0, b = this.h1, c3 = this.h2, d2 = this.h3, e2 = this.h4, f2 = this.h5, g = this.h6, h2 = this.h7, blocks2 = this.blocks, j2, s0, s1, maj, t1, t2, ch, ab, da, cd, bc;
        for (j2 = 16; j2 < 64; ++j2) {
          t1 = blocks2[j2 - 15];
          s0 = (t1 >>> 7 | t1 << 25) ^ (t1 >>> 18 | t1 << 14) ^ t1 >>> 3;
          t1 = blocks2[j2 - 2];
          s1 = (t1 >>> 17 | t1 << 15) ^ (t1 >>> 19 | t1 << 13) ^ t1 >>> 10;
          blocks2[j2] = blocks2[j2 - 16] + s0 + blocks2[j2 - 7] + s1 << 0;
        }
        bc = b & c3;
        for (j2 = 0; j2 < 64; j2 += 4) {
          if (this.first) {
            if (this.is224) {
              ab = 300032;
              t1 = blocks2[0] - 1413257819;
              h2 = t1 - 150054599 << 0;
              d2 = t1 + 24177077 << 0;
            } else {
              ab = 704751109;
              t1 = blocks2[0] - 210244248;
              h2 = t1 - 1521486534 << 0;
              d2 = t1 + 143694565 << 0;
            }
            this.first = false;
          } else {
            s0 = (a3 >>> 2 | a3 << 30) ^ (a3 >>> 13 | a3 << 19) ^ (a3 >>> 22 | a3 << 10);
            s1 = (e2 >>> 6 | e2 << 26) ^ (e2 >>> 11 | e2 << 21) ^ (e2 >>> 25 | e2 << 7);
            ab = a3 & b;
            maj = ab ^ a3 & c3 ^ bc;
            ch = e2 & f2 ^ ~e2 & g;
            t1 = h2 + s1 + ch + K[j2] + blocks2[j2];
            t2 = s0 + maj;
            h2 = d2 + t1 << 0;
            d2 = t1 + t2 << 0;
          }
          s0 = (d2 >>> 2 | d2 << 30) ^ (d2 >>> 13 | d2 << 19) ^ (d2 >>> 22 | d2 << 10);
          s1 = (h2 >>> 6 | h2 << 26) ^ (h2 >>> 11 | h2 << 21) ^ (h2 >>> 25 | h2 << 7);
          da = d2 & a3;
          maj = da ^ d2 & b ^ ab;
          ch = h2 & e2 ^ ~h2 & f2;
          t1 = g + s1 + ch + K[j2 + 1] + blocks2[j2 + 1];
          t2 = s0 + maj;
          g = c3 + t1 << 0;
          c3 = t1 + t2 << 0;
          s0 = (c3 >>> 2 | c3 << 30) ^ (c3 >>> 13 | c3 << 19) ^ (c3 >>> 22 | c3 << 10);
          s1 = (g >>> 6 | g << 26) ^ (g >>> 11 | g << 21) ^ (g >>> 25 | g << 7);
          cd = c3 & d2;
          maj = cd ^ c3 & a3 ^ da;
          ch = g & h2 ^ ~g & e2;
          t1 = f2 + s1 + ch + K[j2 + 2] + blocks2[j2 + 2];
          t2 = s0 + maj;
          f2 = b + t1 << 0;
          b = t1 + t2 << 0;
          s0 = (b >>> 2 | b << 30) ^ (b >>> 13 | b << 19) ^ (b >>> 22 | b << 10);
          s1 = (f2 >>> 6 | f2 << 26) ^ (f2 >>> 11 | f2 << 21) ^ (f2 >>> 25 | f2 << 7);
          bc = b & c3;
          maj = bc ^ b & d2 ^ cd;
          ch = f2 & g ^ ~f2 & h2;
          t1 = e2 + s1 + ch + K[j2 + 3] + blocks2[j2 + 3];
          t2 = s0 + maj;
          e2 = a3 + t1 << 0;
          a3 = t1 + t2 << 0;
          this.chromeBugWorkAround = true;
        }
        this.h0 = this.h0 + a3 << 0;
        this.h1 = this.h1 + b << 0;
        this.h2 = this.h2 + c3 << 0;
        this.h3 = this.h3 + d2 << 0;
        this.h4 = this.h4 + e2 << 0;
        this.h5 = this.h5 + f2 << 0;
        this.h6 = this.h6 + g << 0;
        this.h7 = this.h7 + h2 << 0;
      };
      Sha256.prototype.hex = function() {
        this.finalize();
        var h0 = this.h0, h1 = this.h1, h2 = this.h2, h3 = this.h3, h4 = this.h4, h5 = this.h5, h6 = this.h6, h7 = this.h7;
        var hex = HEX_CHARS[h0 >>> 28 & 15] + HEX_CHARS[h0 >>> 24 & 15] + HEX_CHARS[h0 >>> 20 & 15] + HEX_CHARS[h0 >>> 16 & 15] + HEX_CHARS[h0 >>> 12 & 15] + HEX_CHARS[h0 >>> 8 & 15] + HEX_CHARS[h0 >>> 4 & 15] + HEX_CHARS[h0 & 15] + HEX_CHARS[h1 >>> 28 & 15] + HEX_CHARS[h1 >>> 24 & 15] + HEX_CHARS[h1 >>> 20 & 15] + HEX_CHARS[h1 >>> 16 & 15] + HEX_CHARS[h1 >>> 12 & 15] + HEX_CHARS[h1 >>> 8 & 15] + HEX_CHARS[h1 >>> 4 & 15] + HEX_CHARS[h1 & 15] + HEX_CHARS[h2 >>> 28 & 15] + HEX_CHARS[h2 >>> 24 & 15] + HEX_CHARS[h2 >>> 20 & 15] + HEX_CHARS[h2 >>> 16 & 15] + HEX_CHARS[h2 >>> 12 & 15] + HEX_CHARS[h2 >>> 8 & 15] + HEX_CHARS[h2 >>> 4 & 15] + HEX_CHARS[h2 & 15] + HEX_CHARS[h3 >>> 28 & 15] + HEX_CHARS[h3 >>> 24 & 15] + HEX_CHARS[h3 >>> 20 & 15] + HEX_CHARS[h3 >>> 16 & 15] + HEX_CHARS[h3 >>> 12 & 15] + HEX_CHARS[h3 >>> 8 & 15] + HEX_CHARS[h3 >>> 4 & 15] + HEX_CHARS[h3 & 15] + HEX_CHARS[h4 >>> 28 & 15] + HEX_CHARS[h4 >>> 24 & 15] + HEX_CHARS[h4 >>> 20 & 15] + HEX_CHARS[h4 >>> 16 & 15] + HEX_CHARS[h4 >>> 12 & 15] + HEX_CHARS[h4 >>> 8 & 15] + HEX_CHARS[h4 >>> 4 & 15] + HEX_CHARS[h4 & 15] + HEX_CHARS[h5 >>> 28 & 15] + HEX_CHARS[h5 >>> 24 & 15] + HEX_CHARS[h5 >>> 20 & 15] + HEX_CHARS[h5 >>> 16 & 15] + HEX_CHARS[h5 >>> 12 & 15] + HEX_CHARS[h5 >>> 8 & 15] + HEX_CHARS[h5 >>> 4 & 15] + HEX_CHARS[h5 & 15] + HEX_CHARS[h6 >>> 28 & 15] + HEX_CHARS[h6 >>> 24 & 15] + HEX_CHARS[h6 >>> 20 & 15] + HEX_CHARS[h6 >>> 16 & 15] + HEX_CHARS[h6 >>> 12 & 15] + HEX_CHARS[h6 >>> 8 & 15] + HEX_CHARS[h6 >>> 4 & 15] + HEX_CHARS[h6 & 15];
        if (!this.is224) {
          hex += HEX_CHARS[h7 >>> 28 & 15] + HEX_CHARS[h7 >>> 24 & 15] + HEX_CHARS[h7 >>> 20 & 15] + HEX_CHARS[h7 >>> 16 & 15] + HEX_CHARS[h7 >>> 12 & 15] + HEX_CHARS[h7 >>> 8 & 15] + HEX_CHARS[h7 >>> 4 & 15] + HEX_CHARS[h7 & 15];
        }
        return hex;
      };
      Sha256.prototype.toString = Sha256.prototype.hex;
      Sha256.prototype.digest = function() {
        this.finalize();
        var h0 = this.h0, h1 = this.h1, h2 = this.h2, h3 = this.h3, h4 = this.h4, h5 = this.h5, h6 = this.h6, h7 = this.h7;
        var arr = [
          h0 >>> 24 & 255,
          h0 >>> 16 & 255,
          h0 >>> 8 & 255,
          h0 & 255,
          h1 >>> 24 & 255,
          h1 >>> 16 & 255,
          h1 >>> 8 & 255,
          h1 & 255,
          h2 >>> 24 & 255,
          h2 >>> 16 & 255,
          h2 >>> 8 & 255,
          h2 & 255,
          h3 >>> 24 & 255,
          h3 >>> 16 & 255,
          h3 >>> 8 & 255,
          h3 & 255,
          h4 >>> 24 & 255,
          h4 >>> 16 & 255,
          h4 >>> 8 & 255,
          h4 & 255,
          h5 >>> 24 & 255,
          h5 >>> 16 & 255,
          h5 >>> 8 & 255,
          h5 & 255,
          h6 >>> 24 & 255,
          h6 >>> 16 & 255,
          h6 >>> 8 & 255,
          h6 & 255
        ];
        if (!this.is224) {
          arr.push(h7 >>> 24 & 255, h7 >>> 16 & 255, h7 >>> 8 & 255, h7 & 255);
        }
        return arr;
      };
      Sha256.prototype.array = Sha256.prototype.digest;
      Sha256.prototype.arrayBuffer = function() {
        this.finalize();
        var buffer = new ArrayBuffer(this.is224 ? 28 : 32);
        var dataView = new DataView(buffer);
        dataView.setUint32(0, this.h0);
        dataView.setUint32(4, this.h1);
        dataView.setUint32(8, this.h2);
        dataView.setUint32(12, this.h3);
        dataView.setUint32(16, this.h4);
        dataView.setUint32(20, this.h5);
        dataView.setUint32(24, this.h6);
        if (!this.is224) {
          dataView.setUint32(28, this.h7);
        }
        return buffer;
      };
      function HmacSha256(key, is224, sharedMemory) {
        var i2, type = typeof key;
        if (type === "string") {
          var bytes = [], length = key.length, index = 0, code;
          for (i2 = 0; i2 < length; ++i2) {
            code = key.charCodeAt(i2);
            if (code < 128) {
              bytes[index++] = code;
            } else if (code < 2048) {
              bytes[index++] = 192 | code >>> 6;
              bytes[index++] = 128 | code & 63;
            } else if (code < 55296 || code >= 57344) {
              bytes[index++] = 224 | code >>> 12;
              bytes[index++] = 128 | code >>> 6 & 63;
              bytes[index++] = 128 | code & 63;
            } else {
              code = 65536 + ((code & 1023) << 10 | key.charCodeAt(++i2) & 1023);
              bytes[index++] = 240 | code >>> 18;
              bytes[index++] = 128 | code >>> 12 & 63;
              bytes[index++] = 128 | code >>> 6 & 63;
              bytes[index++] = 128 | code & 63;
            }
          }
          key = bytes;
        } else {
          if (type === "object") {
            if (key === null) {
              throw new Error(ERROR);
            } else if (ARRAY_BUFFER && key.constructor === ArrayBuffer) {
              key = new Uint8Array(key);
            } else if (!Array.isArray(key)) {
              if (!ARRAY_BUFFER || !ArrayBuffer.isView(key)) {
                throw new Error(ERROR);
              }
            }
          } else {
            throw new Error(ERROR);
          }
        }
        if (key.length > 64) {
          key = new Sha256(is224, true).update(key).array();
        }
        var oKeyPad = [], iKeyPad = [];
        for (i2 = 0; i2 < 64; ++i2) {
          var b = key[i2] || 0;
          oKeyPad[i2] = 92 ^ b;
          iKeyPad[i2] = 54 ^ b;
        }
        Sha256.call(this, is224, sharedMemory);
        this.update(iKeyPad);
        this.oKeyPad = oKeyPad;
        this.inner = true;
        this.sharedMemory = sharedMemory;
      }
      HmacSha256.prototype = new Sha256();
      HmacSha256.prototype.finalize = function() {
        Sha256.prototype.finalize.call(this);
        if (this.inner) {
          this.inner = false;
          var innerHash = this.array();
          Sha256.call(this, this.is224, this.sharedMemory);
          this.update(this.oKeyPad);
          this.update(innerHash);
          Sha256.prototype.finalize.call(this);
        }
      };
      var exports2 = createMethod();
      exports2.sha256 = exports2;
      exports2.sha224 = createMethod(true);
      exports2.sha256.hmac = createHmacMethod();
      exports2.sha224.hmac = createHmacMethod(true);
      if (COMMON_JS) {
        module.exports = exports2;
      } else {
        root.sha256 = exports2.sha256;
        root.sha224 = exports2.sha224;
        if (AMD) {
          define(function() {
            return exports2;
          });
        }
      }
    })();
  }
});

// ../../../node_modules/.pnpm/consola@3.4.0/node_modules/consola/dist/chunks/prompt.mjs
var prompt_exports = {};
__export(prompt_exports, {
  kCancel: () => kCancel,
  prompt: () => prompt
});
import p, { stdin, stdout } from "node:process";
import f from "node:readline";
import { WriteStream } from "node:tty";
function getDefaultExportFromCjs(x2) {
  return x2 && x2.__esModule && Object.prototype.hasOwnProperty.call(x2, "default") ? x2["default"] : x2;
}
function requireSrc() {
  if (hasRequiredSrc)
    return src;
  hasRequiredSrc = 1;
  const ESC = "\x1B";
  const CSI = `${ESC}[`;
  const beep = "\x07";
  const cursor = {
    to(x2, y3) {
      if (!y3)
        return `${CSI}${x2 + 1}G`;
      return `${CSI}${y3 + 1};${x2 + 1}H`;
    },
    move(x2, y3) {
      let ret = "";
      if (x2 < 0)
        ret += `${CSI}${-x2}D`;
      else if (x2 > 0)
        ret += `${CSI}${x2}C`;
      if (y3 < 0)
        ret += `${CSI}${-y3}A`;
      else if (y3 > 0)
        ret += `${CSI}${y3}B`;
      return ret;
    },
    up: (count = 1) => `${CSI}${count}A`,
    down: (count = 1) => `${CSI}${count}B`,
    forward: (count = 1) => `${CSI}${count}C`,
    backward: (count = 1) => `${CSI}${count}D`,
    nextLine: (count = 1) => `${CSI}E`.repeat(count),
    prevLine: (count = 1) => `${CSI}F`.repeat(count),
    left: `${CSI}G`,
    hide: `${CSI}?25l`,
    show: `${CSI}?25h`,
    save: `${ESC}7`,
    restore: `${ESC}8`
  };
  const scroll = {
    up: (count = 1) => `${CSI}S`.repeat(count),
    down: (count = 1) => `${CSI}T`.repeat(count)
  };
  const erase = {
    screen: `${CSI}2J`,
    up: (count = 1) => `${CSI}1J`.repeat(count),
    down: (count = 1) => `${CSI}J`.repeat(count),
    line: `${CSI}2K`,
    lineEnd: `${CSI}K`,
    lineStart: `${CSI}1K`,
    lines(count) {
      let clear = "";
      for (let i2 = 0; i2 < count; i2++)
        clear += this.line + (i2 < count - 1 ? cursor.up() : "");
      if (count)
        clear += cursor.left;
      return clear;
    }
  };
  src = { cursor, scroll, erase, beep };
  return src;
}
function requirePicocolors() {
  if (hasRequiredPicocolors)
    return picocolors.exports;
  hasRequiredPicocolors = 1;
  let p3 = process || {}, argv2 = p3.argv || [], env2 = p3.env || {};
  let isColorSupported2 = !(!!env2.NO_COLOR || argv2.includes("--no-color")) && (!!env2.FORCE_COLOR || argv2.includes("--color") || p3.platform === "win32" || (p3.stdout || {}).isTTY && env2.TERM !== "dumb" || !!env2.CI);
  let formatter = (open, close, replace = open) => (input) => {
    let string = "" + input, index = string.indexOf(close, open.length);
    return ~index ? open + replaceClose2(string, close, replace, index) + close : open + string + close;
  };
  let replaceClose2 = (string, close, replace, index) => {
    let result = "", cursor = 0;
    do {
      result += string.substring(cursor, index) + replace;
      cursor = index + close.length;
      index = string.indexOf(close, cursor);
    } while (~index);
    return result + string.substring(cursor);
  };
  let createColors2 = (enabled = isColorSupported2) => {
    let f2 = enabled ? formatter : () => String;
    return {
      isColorSupported: enabled,
      reset: f2("\x1B[0m", "\x1B[0m"),
      bold: f2("\x1B[1m", "\x1B[22m", "\x1B[22m\x1B[1m"),
      dim: f2("\x1B[2m", "\x1B[22m", "\x1B[22m\x1B[2m"),
      italic: f2("\x1B[3m", "\x1B[23m"),
      underline: f2("\x1B[4m", "\x1B[24m"),
      inverse: f2("\x1B[7m", "\x1B[27m"),
      hidden: f2("\x1B[8m", "\x1B[28m"),
      strikethrough: f2("\x1B[9m", "\x1B[29m"),
      black: f2("\x1B[30m", "\x1B[39m"),
      red: f2("\x1B[31m", "\x1B[39m"),
      green: f2("\x1B[32m", "\x1B[39m"),
      yellow: f2("\x1B[33m", "\x1B[39m"),
      blue: f2("\x1B[34m", "\x1B[39m"),
      magenta: f2("\x1B[35m", "\x1B[39m"),
      cyan: f2("\x1B[36m", "\x1B[39m"),
      white: f2("\x1B[37m", "\x1B[39m"),
      gray: f2("\x1B[90m", "\x1B[39m"),
      bgBlack: f2("\x1B[40m", "\x1B[49m"),
      bgRed: f2("\x1B[41m", "\x1B[49m"),
      bgGreen: f2("\x1B[42m", "\x1B[49m"),
      bgYellow: f2("\x1B[43m", "\x1B[49m"),
      bgBlue: f2("\x1B[44m", "\x1B[49m"),
      bgMagenta: f2("\x1B[45m", "\x1B[49m"),
      bgCyan: f2("\x1B[46m", "\x1B[49m"),
      bgWhite: f2("\x1B[47m", "\x1B[49m"),
      blackBright: f2("\x1B[90m", "\x1B[39m"),
      redBright: f2("\x1B[91m", "\x1B[39m"),
      greenBright: f2("\x1B[92m", "\x1B[39m"),
      yellowBright: f2("\x1B[93m", "\x1B[39m"),
      blueBright: f2("\x1B[94m", "\x1B[39m"),
      magentaBright: f2("\x1B[95m", "\x1B[39m"),
      cyanBright: f2("\x1B[96m", "\x1B[39m"),
      whiteBright: f2("\x1B[97m", "\x1B[39m"),
      bgBlackBright: f2("\x1B[100m", "\x1B[49m"),
      bgRedBright: f2("\x1B[101m", "\x1B[49m"),
      bgGreenBright: f2("\x1B[102m", "\x1B[49m"),
      bgYellowBright: f2("\x1B[103m", "\x1B[49m"),
      bgBlueBright: f2("\x1B[104m", "\x1B[49m"),
      bgMagentaBright: f2("\x1B[105m", "\x1B[49m"),
      bgCyanBright: f2("\x1B[106m", "\x1B[49m"),
      bgWhiteBright: f2("\x1B[107m", "\x1B[49m")
    };
  };
  picocolors.exports = createColors2();
  picocolors.exports.createColors = createColors2;
  return picocolors.exports;
}
function J({ onlyFirst: t2 = false } = {}) {
  const F2 = ["[\\u001B\\u009B][[\\]()#;?]*(?:(?:(?:(?:;[-a-zA-Z\\d\\/#&.:=?%@~_]+)*|[a-zA-Z\\d]+(?:;[-a-zA-Z\\d\\/#&.:=?%@~_]*)*)?(?:\\u0007|\\u001B\\u005C|\\u009C))", "(?:(?:\\d{1,4}(?:;\\d{0,4})*)?[\\dA-PR-TZcf-nq-uy=><~]))"].join("|");
  return new RegExp(F2, t2 ? void 0 : "g");
}
function T(t2) {
  if (typeof t2 != "string")
    throw new TypeError(`Expected a \`string\`, got \`${typeof t2}\``);
  return t2.replace(Q, "");
}
function O(t2) {
  return t2 && t2.__esModule && Object.prototype.hasOwnProperty.call(t2, "default") ? t2.default : t2;
}
function A$1(t2, u3 = {}) {
  if (typeof t2 != "string" || t2.length === 0 || (u3 = { ambiguousIsNarrow: true, ...u3 }, t2 = T(t2), t2.length === 0))
    return 0;
  t2 = t2.replace(FD(), "  ");
  const F2 = u3.ambiguousIsNarrow ? 1 : 2;
  let e2 = 0;
  for (const s2 of t2) {
    const i2 = s2.codePointAt(0);
    if (i2 <= 31 || i2 >= 127 && i2 <= 159 || i2 >= 768 && i2 <= 879)
      continue;
    switch (DD.eastAsianWidth(s2)) {
      case "F":
      case "W":
        e2 += 2;
        break;
      case "A":
        e2 += F2;
        break;
      default:
        e2 += 1;
    }
  }
  return e2;
}
function sD() {
  const t2 = /* @__PURE__ */ new Map();
  for (const [u3, F2] of Object.entries(r)) {
    for (const [e2, s2] of Object.entries(F2))
      r[e2] = { open: `\x1B[${s2[0]}m`, close: `\x1B[${s2[1]}m` }, F2[e2] = r[e2], t2.set(s2[0], s2[1]);
    Object.defineProperty(r, u3, { value: F2, enumerable: false });
  }
  return Object.defineProperty(r, "codes", { value: t2, enumerable: false }), r.color.close = "\x1B[39m", r.bgColor.close = "\x1B[49m", r.color.ansi = L(), r.color.ansi256 = N(), r.color.ansi16m = I(), r.bgColor.ansi = L(m$1), r.bgColor.ansi256 = N(m$1), r.bgColor.ansi16m = I(m$1), Object.defineProperties(r, { rgbToAnsi256: { value: (u3, F2, e2) => u3 === F2 && F2 === e2 ? u3 < 8 ? 16 : u3 > 248 ? 231 : Math.round((u3 - 8) / 247 * 24) + 232 : 16 + 36 * Math.round(u3 / 255 * 5) + 6 * Math.round(F2 / 255 * 5) + Math.round(e2 / 255 * 5), enumerable: false }, hexToRgb: { value: (u3) => {
    const F2 = /[a-f\d]{6}|[a-f\d]{3}/i.exec(u3.toString(16));
    if (!F2)
      return [0, 0, 0];
    let [e2] = F2;
    e2.length === 3 && (e2 = [...e2].map((i2) => i2 + i2).join(""));
    const s2 = Number.parseInt(e2, 16);
    return [s2 >> 16 & 255, s2 >> 8 & 255, s2 & 255];
  }, enumerable: false }, hexToAnsi256: { value: (u3) => r.rgbToAnsi256(...r.hexToRgb(u3)), enumerable: false }, ansi256ToAnsi: { value: (u3) => {
    if (u3 < 8)
      return 30 + u3;
    if (u3 < 16)
      return 90 + (u3 - 8);
    let F2, e2, s2;
    if (u3 >= 232)
      F2 = ((u3 - 232) * 10 + 8) / 255, e2 = F2, s2 = F2;
    else {
      u3 -= 16;
      const C2 = u3 % 36;
      F2 = Math.floor(u3 / 36) / 5, e2 = Math.floor(C2 / 6) / 5, s2 = C2 % 6 / 5;
    }
    const i2 = Math.max(F2, e2, s2) * 2;
    if (i2 === 0)
      return 30;
    let D2 = 30 + (Math.round(s2) << 2 | Math.round(e2) << 1 | Math.round(F2));
    return i2 === 2 && (D2 += 60), D2;
  }, enumerable: false }, rgbToAnsi: { value: (u3, F2, e2) => r.ansi256ToAnsi(r.rgbToAnsi256(u3, F2, e2)), enumerable: false }, hexToAnsi: { value: (u3) => r.ansi256ToAnsi(r.hexToAnsi256(u3)), enumerable: false } }), r;
}
function G$1(t2, u3, F2) {
  return String(t2).normalize().replace(/\r\n/g, `
`).split(`
`).map((e2) => oD(e2, u3, F2)).join(`
`);
}
function k$1(t2, u3) {
  if (typeof t2 == "string")
    return c.aliases.get(t2) === u3;
  for (const F2 of t2)
    if (F2 !== void 0 && k$1(F2, u3))
      return true;
  return false;
}
function lD(t2, u3) {
  if (t2 === u3)
    return;
  const F2 = t2.split(`
`), e2 = u3.split(`
`), s2 = [];
  for (let i2 = 0; i2 < Math.max(F2.length, e2.length); i2++)
    F2[i2] !== e2[i2] && s2.push(i2);
  return s2;
}
function d(t2, u3) {
  const F2 = t2;
  F2.isTTY && F2.setRawMode(u3);
}
function X() {
  return p.platform !== "win32" ? p.env.TERM !== "linux" : !!p.env.CI || !!p.env.WT_SESSION || !!p.env.TERMINUS_SUBLIME || p.env.ConEmuTask === "{cmd::Cmder}" || p.env.TERM_PROGRAM === "Terminus-Sublime" || p.env.TERM_PROGRAM === "vscode" || p.env.TERM === "xterm-256color" || p.env.TERM === "alacritty" || p.env.TERMINAL_EMULATOR === "JetBrains-JediTerm";
}
async function prompt(message, opts = {}) {
  const handleCancel = (value) => {
    if (typeof value !== "symbol" || value.toString() !== "Symbol(clack:cancel)") {
      return value;
    }
    switch (opts.cancel) {
      case "reject": {
        const error = new Error("Prompt cancelled.");
        error.name = "ConsolaPromptCancelledError";
        if (Error.captureStackTrace) {
          Error.captureStackTrace(error, prompt);
        }
        throw error;
      }
      case "undefined": {
        return void 0;
      }
      case "null": {
        return null;
      }
      case "symbol": {
        return kCancel;
      }
      default:
      case "default": {
        return opts.default ?? opts.initial;
      }
    }
  };
  if (!opts.type || opts.type === "text") {
    return await ue({
      message,
      defaultValue: opts.default,
      placeholder: opts.placeholder,
      initialValue: opts.initial
    }).then(handleCancel);
  }
  if (opts.type === "confirm") {
    return await me({
      message,
      initialValue: opts.initial
    }).then(handleCancel);
  }
  if (opts.type === "select") {
    return await de({
      message,
      options: opts.options.map(
        (o) => typeof o === "string" ? { value: o, label: o } : o
      ),
      initialValue: opts.initial
    }).then(handleCancel);
  }
  if (opts.type === "multiselect") {
    return await pe({
      message,
      options: opts.options.map(
        (o) => typeof o === "string" ? { value: o, label: o } : o
      ),
      required: opts.required,
      initialValues: opts.initial
    }).then(handleCancel);
  }
  throw new Error(`Unknown prompt type: ${opts.type}`);
}
var src, hasRequiredSrc, srcExports, picocolors, hasRequiredPicocolors, picocolorsExports, e, Q, P, X$1, DD, uD, FD, m$1, L, N, I, r, tD, eD, iD, v2, CD, w, W, rD, R$1, y$1, V$1, z, ED, _, nD, oD, aD, c, S$1, AD, pD, h, x, fD, bD, mD, Y, wD, SD, $D, q, jD, PD, E, u, ee, A, B, S, a, m, j, R, V, M, G, y, k, ue, me, de, pe, kCancel;
var init_prompt = __esm({
  "../../../node_modules/.pnpm/consola@3.4.0/node_modules/consola/dist/chunks/prompt.mjs"() {
    init_define_ENV_DEFINED_IN_BUILD_STEP();
    srcExports = requireSrc();
    picocolors = { exports: {} };
    picocolorsExports = /* @__PURE__ */ requirePicocolors();
    e = /* @__PURE__ */ getDefaultExportFromCjs(picocolorsExports);
    Q = J();
    P = { exports: {} };
    (function(t2) {
      var u3 = {};
      t2.exports = u3, u3.eastAsianWidth = function(e2) {
        var s2 = e2.charCodeAt(0), i2 = e2.length == 2 ? e2.charCodeAt(1) : 0, D2 = s2;
        return 55296 <= s2 && s2 <= 56319 && 56320 <= i2 && i2 <= 57343 && (s2 &= 1023, i2 &= 1023, D2 = s2 << 10 | i2, D2 += 65536), D2 == 12288 || 65281 <= D2 && D2 <= 65376 || 65504 <= D2 && D2 <= 65510 ? "F" : D2 == 8361 || 65377 <= D2 && D2 <= 65470 || 65474 <= D2 && D2 <= 65479 || 65482 <= D2 && D2 <= 65487 || 65490 <= D2 && D2 <= 65495 || 65498 <= D2 && D2 <= 65500 || 65512 <= D2 && D2 <= 65518 ? "H" : 4352 <= D2 && D2 <= 4447 || 4515 <= D2 && D2 <= 4519 || 4602 <= D2 && D2 <= 4607 || 9001 <= D2 && D2 <= 9002 || 11904 <= D2 && D2 <= 11929 || 11931 <= D2 && D2 <= 12019 || 12032 <= D2 && D2 <= 12245 || 12272 <= D2 && D2 <= 12283 || 12289 <= D2 && D2 <= 12350 || 12353 <= D2 && D2 <= 12438 || 12441 <= D2 && D2 <= 12543 || 12549 <= D2 && D2 <= 12589 || 12593 <= D2 && D2 <= 12686 || 12688 <= D2 && D2 <= 12730 || 12736 <= D2 && D2 <= 12771 || 12784 <= D2 && D2 <= 12830 || 12832 <= D2 && D2 <= 12871 || 12880 <= D2 && D2 <= 13054 || 13056 <= D2 && D2 <= 19903 || 19968 <= D2 && D2 <= 42124 || 42128 <= D2 && D2 <= 42182 || 43360 <= D2 && D2 <= 43388 || 44032 <= D2 && D2 <= 55203 || 55216 <= D2 && D2 <= 55238 || 55243 <= D2 && D2 <= 55291 || 63744 <= D2 && D2 <= 64255 || 65040 <= D2 && D2 <= 65049 || 65072 <= D2 && D2 <= 65106 || 65108 <= D2 && D2 <= 65126 || 65128 <= D2 && D2 <= 65131 || 110592 <= D2 && D2 <= 110593 || 127488 <= D2 && D2 <= 127490 || 127504 <= D2 && D2 <= 127546 || 127552 <= D2 && D2 <= 127560 || 127568 <= D2 && D2 <= 127569 || 131072 <= D2 && D2 <= 194367 || 177984 <= D2 && D2 <= 196605 || 196608 <= D2 && D2 <= 262141 ? "W" : 32 <= D2 && D2 <= 126 || 162 <= D2 && D2 <= 163 || 165 <= D2 && D2 <= 166 || D2 == 172 || D2 == 175 || 10214 <= D2 && D2 <= 10221 || 10629 <= D2 && D2 <= 10630 ? "Na" : D2 == 161 || D2 == 164 || 167 <= D2 && D2 <= 168 || D2 == 170 || 173 <= D2 && D2 <= 174 || 176 <= D2 && D2 <= 180 || 182 <= D2 && D2 <= 186 || 188 <= D2 && D2 <= 191 || D2 == 198 || D2 == 208 || 215 <= D2 && D2 <= 216 || 222 <= D2 && D2 <= 225 || D2 == 230 || 232 <= D2 && D2 <= 234 || 236 <= D2 && D2 <= 237 || D2 == 240 || 242 <= D2 && D2 <= 243 || 247 <= D2 && D2 <= 250 || D2 == 252 || D2 == 254 || D2 == 257 || D2 == 273 || D2 == 275 || D2 == 283 || 294 <= D2 && D2 <= 295 || D2 == 299 || 305 <= D2 && D2 <= 307 || D2 == 312 || 319 <= D2 && D2 <= 322 || D2 == 324 || 328 <= D2 && D2 <= 331 || D2 == 333 || 338 <= D2 && D2 <= 339 || 358 <= D2 && D2 <= 359 || D2 == 363 || D2 == 462 || D2 == 464 || D2 == 466 || D2 == 468 || D2 == 470 || D2 == 472 || D2 == 474 || D2 == 476 || D2 == 593 || D2 == 609 || D2 == 708 || D2 == 711 || 713 <= D2 && D2 <= 715 || D2 == 717 || D2 == 720 || 728 <= D2 && D2 <= 731 || D2 == 733 || D2 == 735 || 768 <= D2 && D2 <= 879 || 913 <= D2 && D2 <= 929 || 931 <= D2 && D2 <= 937 || 945 <= D2 && D2 <= 961 || 963 <= D2 && D2 <= 969 || D2 == 1025 || 1040 <= D2 && D2 <= 1103 || D2 == 1105 || D2 == 8208 || 8211 <= D2 && D2 <= 8214 || 8216 <= D2 && D2 <= 8217 || 8220 <= D2 && D2 <= 8221 || 8224 <= D2 && D2 <= 8226 || 8228 <= D2 && D2 <= 8231 || D2 == 8240 || 8242 <= D2 && D2 <= 8243 || D2 == 8245 || D2 == 8251 || D2 == 8254 || D2 == 8308 || D2 == 8319 || 8321 <= D2 && D2 <= 8324 || D2 == 8364 || D2 == 8451 || D2 == 8453 || D2 == 8457 || D2 == 8467 || D2 == 8470 || 8481 <= D2 && D2 <= 8482 || D2 == 8486 || D2 == 8491 || 8531 <= D2 && D2 <= 8532 || 8539 <= D2 && D2 <= 8542 || 8544 <= D2 && D2 <= 8555 || 8560 <= D2 && D2 <= 8569 || D2 == 8585 || 8592 <= D2 && D2 <= 8601 || 8632 <= D2 && D2 <= 8633 || D2 == 8658 || D2 == 8660 || D2 == 8679 || D2 == 8704 || 8706 <= D2 && D2 <= 8707 || 8711 <= D2 && D2 <= 8712 || D2 == 8715 || D2 == 8719 || D2 == 8721 || D2 == 8725 || D2 == 8730 || 8733 <= D2 && D2 <= 8736 || D2 == 8739 || D2 == 8741 || 8743 <= D2 && D2 <= 8748 || D2 == 8750 || 8756 <= D2 && D2 <= 8759 || 8764 <= D2 && D2 <= 8765 || D2 == 8776 || D2 == 8780 || D2 == 8786 || 8800 <= D2 && D2 <= 8801 || 8804 <= D2 && D2 <= 8807 || 8810 <= D2 && D2 <= 8811 || 8814 <= D2 && D2 <= 8815 || 8834 <= D2 && D2 <= 8835 || 8838 <= D2 && D2 <= 8839 || D2 == 8853 || D2 == 8857 || D2 == 8869 || D2 == 8895 || D2 == 8978 || 9312 <= D2 && D2 <= 9449 || 9451 <= D2 && D2 <= 9547 || 9552 <= D2 && D2 <= 9587 || 9600 <= D2 && D2 <= 9615 || 9618 <= D2 && D2 <= 9621 || 9632 <= D2 && D2 <= 9633 || 9635 <= D2 && D2 <= 9641 || 9650 <= D2 && D2 <= 9651 || 9654 <= D2 && D2 <= 9655 || 9660 <= D2 && D2 <= 9661 || 9664 <= D2 && D2 <= 9665 || 9670 <= D2 && D2 <= 9672 || D2 == 9675 || 9678 <= D2 && D2 <= 9681 || 9698 <= D2 && D2 <= 9701 || D2 == 9711 || 9733 <= D2 && D2 <= 9734 || D2 == 9737 || 9742 <= D2 && D2 <= 9743 || 9748 <= D2 && D2 <= 9749 || D2 == 9756 || D2 == 9758 || D2 == 9792 || D2 == 9794 || 9824 <= D2 && D2 <= 9825 || 9827 <= D2 && D2 <= 9829 || 9831 <= D2 && D2 <= 9834 || 9836 <= D2 && D2 <= 9837 || D2 == 9839 || 9886 <= D2 && D2 <= 9887 || 9918 <= D2 && D2 <= 9919 || 9924 <= D2 && D2 <= 9933 || 9935 <= D2 && D2 <= 9953 || D2 == 9955 || 9960 <= D2 && D2 <= 9983 || D2 == 10045 || D2 == 10071 || 10102 <= D2 && D2 <= 10111 || 11093 <= D2 && D2 <= 11097 || 12872 <= D2 && D2 <= 12879 || 57344 <= D2 && D2 <= 63743 || 65024 <= D2 && D2 <= 65039 || D2 == 65533 || 127232 <= D2 && D2 <= 127242 || 127248 <= D2 && D2 <= 127277 || 127280 <= D2 && D2 <= 127337 || 127344 <= D2 && D2 <= 127386 || 917760 <= D2 && D2 <= 917999 || 983040 <= D2 && D2 <= 1048573 || 1048576 <= D2 && D2 <= 1114109 ? "A" : "N";
      }, u3.characterLength = function(e2) {
        var s2 = this.eastAsianWidth(e2);
        return s2 == "F" || s2 == "W" || s2 == "A" ? 2 : 1;
      };
      function F2(e2) {
        return e2.match(/[\uD800-\uDBFF][\uDC00-\uDFFF]|[^\uD800-\uDFFF]/g) || [];
      }
      u3.length = function(e2) {
        for (var s2 = F2(e2), i2 = 0, D2 = 0; D2 < s2.length; D2++)
          i2 = i2 + this.characterLength(s2[D2]);
        return i2;
      }, u3.slice = function(e2, s2, i2) {
        textLen = u3.length(e2), s2 = s2 || 0, i2 = i2 || 1, s2 < 0 && (s2 = textLen + s2), i2 < 0 && (i2 = textLen + i2);
        for (var D2 = "", C2 = 0, o = F2(e2), E2 = 0; E2 < o.length; E2++) {
          var a3 = o[E2], n2 = u3.length(a3);
          if (C2 >= s2 - (n2 == 2 ? 1 : 0))
            if (C2 + n2 <= i2)
              D2 += a3;
            else
              break;
          C2 += n2;
        }
        return D2;
      };
    })(P);
    X$1 = P.exports;
    DD = O(X$1);
    uD = function() {
      return /\uD83C\uDFF4\uDB40\uDC67\uDB40\uDC62(?:\uDB40\uDC77\uDB40\uDC6C\uDB40\uDC73|\uDB40\uDC73\uDB40\uDC63\uDB40\uDC74|\uDB40\uDC65\uDB40\uDC6E\uDB40\uDC67)\uDB40\uDC7F|(?:\uD83E\uDDD1\uD83C\uDFFF\u200D\u2764\uFE0F\u200D(?:\uD83D\uDC8B\u200D)?\uD83E\uDDD1|\uD83D\uDC69\uD83C\uDFFF\u200D\uD83E\uDD1D\u200D(?:\uD83D[\uDC68\uDC69]))(?:\uD83C[\uDFFB-\uDFFE])|(?:\uD83E\uDDD1\uD83C\uDFFE\u200D\u2764\uFE0F\u200D(?:\uD83D\uDC8B\u200D)?\uD83E\uDDD1|\uD83D\uDC69\uD83C\uDFFE\u200D\uD83E\uDD1D\u200D(?:\uD83D[\uDC68\uDC69]))(?:\uD83C[\uDFFB-\uDFFD\uDFFF])|(?:\uD83E\uDDD1\uD83C\uDFFD\u200D\u2764\uFE0F\u200D(?:\uD83D\uDC8B\u200D)?\uD83E\uDDD1|\uD83D\uDC69\uD83C\uDFFD\u200D\uD83E\uDD1D\u200D(?:\uD83D[\uDC68\uDC69]))(?:\uD83C[\uDFFB\uDFFC\uDFFE\uDFFF])|(?:\uD83E\uDDD1\uD83C\uDFFC\u200D\u2764\uFE0F\u200D(?:\uD83D\uDC8B\u200D)?\uD83E\uDDD1|\uD83D\uDC69\uD83C\uDFFC\u200D\uD83E\uDD1D\u200D(?:\uD83D[\uDC68\uDC69]))(?:\uD83C[\uDFFB\uDFFD-\uDFFF])|(?:\uD83E\uDDD1\uD83C\uDFFB\u200D\u2764\uFE0F\u200D(?:\uD83D\uDC8B\u200D)?\uD83E\uDDD1|\uD83D\uDC69\uD83C\uDFFB\u200D\uD83E\uDD1D\u200D(?:\uD83D[\uDC68\uDC69]))(?:\uD83C[\uDFFC-\uDFFF])|\uD83D\uDC68(?:\uD83C\uDFFB(?:\u200D(?:\u2764\uFE0F\u200D(?:\uD83D\uDC8B\u200D\uD83D\uDC68(?:\uD83C[\uDFFB-\uDFFF])|\uD83D\uDC68(?:\uD83C[\uDFFB-\uDFFF]))|\uD83E\uDD1D\u200D\uD83D\uDC68(?:\uD83C[\uDFFC-\uDFFF])|[\u2695\u2696\u2708]\uFE0F|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD]))?|(?:\uD83C[\uDFFC-\uDFFF])\u200D\u2764\uFE0F\u200D(?:\uD83D\uDC8B\u200D\uD83D\uDC68(?:\uD83C[\uDFFB-\uDFFF])|\uD83D\uDC68(?:\uD83C[\uDFFB-\uDFFF]))|\u200D(?:\u2764\uFE0F\u200D(?:\uD83D\uDC8B\u200D)?\uD83D\uDC68|(?:\uD83D[\uDC68\uDC69])\u200D(?:\uD83D\uDC66\u200D\uD83D\uDC66|\uD83D\uDC67\u200D(?:\uD83D[\uDC66\uDC67]))|\uD83D\uDC66\u200D\uD83D\uDC66|\uD83D\uDC67\u200D(?:\uD83D[\uDC66\uDC67])|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFF\u200D(?:\uD83E\uDD1D\u200D\uD83D\uDC68(?:\uD83C[\uDFFB-\uDFFE])|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFE\u200D(?:\uD83E\uDD1D\u200D\uD83D\uDC68(?:\uD83C[\uDFFB-\uDFFD\uDFFF])|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFD\u200D(?:\uD83E\uDD1D\u200D\uD83D\uDC68(?:\uD83C[\uDFFB\uDFFC\uDFFE\uDFFF])|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFC\u200D(?:\uD83E\uDD1D\u200D\uD83D\uDC68(?:\uD83C[\uDFFB\uDFFD-\uDFFF])|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|(?:\uD83C\uDFFF\u200D[\u2695\u2696\u2708]|\uD83C\uDFFE\u200D[\u2695\u2696\u2708]|\uD83C\uDFFD\u200D[\u2695\u2696\u2708]|\uD83C\uDFFC\u200D[\u2695\u2696\u2708]|\u200D[\u2695\u2696\u2708])\uFE0F|\u200D(?:(?:\uD83D[\uDC68\uDC69])\u200D(?:\uD83D[\uDC66\uDC67])|\uD83D[\uDC66\uDC67])|\uD83C\uDFFF|\uD83C\uDFFE|\uD83C\uDFFD|\uD83C\uDFFC)?|(?:\uD83D\uDC69(?:\uD83C\uDFFB\u200D\u2764\uFE0F\u200D(?:\uD83D\uDC8B\u200D(?:\uD83D[\uDC68\uDC69])|\uD83D[\uDC68\uDC69])|(?:\uD83C[\uDFFC-\uDFFF])\u200D\u2764\uFE0F\u200D(?:\uD83D\uDC8B\u200D(?:\uD83D[\uDC68\uDC69])|\uD83D[\uDC68\uDC69]))|\uD83E\uDDD1(?:\uD83C[\uDFFB-\uDFFF])\u200D\uD83E\uDD1D\u200D\uD83E\uDDD1)(?:\uD83C[\uDFFB-\uDFFF])|\uD83D\uDC69\u200D\uD83D\uDC69\u200D(?:\uD83D\uDC66\u200D\uD83D\uDC66|\uD83D\uDC67\u200D(?:\uD83D[\uDC66\uDC67]))|\uD83D\uDC69(?:\u200D(?:\u2764\uFE0F\u200D(?:\uD83D\uDC8B\u200D(?:\uD83D[\uDC68\uDC69])|\uD83D[\uDC68\uDC69])|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFF\u200D(?:\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFE\u200D(?:\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFD\u200D(?:\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFC\u200D(?:\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFB\u200D(?:\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD]))|\uD83E\uDDD1(?:\u200D(?:\uD83E\uDD1D\u200D\uD83E\uDDD1|\uD83C[\uDF3E\uDF73\uDF7C\uDF84\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFF\u200D(?:\uD83C[\uDF3E\uDF73\uDF7C\uDF84\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFE\u200D(?:\uD83C[\uDF3E\uDF73\uDF7C\uDF84\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFD\u200D(?:\uD83C[\uDF3E\uDF73\uDF7C\uDF84\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFC\u200D(?:\uD83C[\uDF3E\uDF73\uDF7C\uDF84\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFB\u200D(?:\uD83C[\uDF3E\uDF73\uDF7C\uDF84\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD]))|\uD83D\uDC69\u200D\uD83D\uDC66\u200D\uD83D\uDC66|\uD83D\uDC69\u200D\uD83D\uDC69\u200D(?:\uD83D[\uDC66\uDC67])|\uD83D\uDC69\u200D\uD83D\uDC67\u200D(?:\uD83D[\uDC66\uDC67])|(?:\uD83D\uDC41\uFE0F\u200D\uD83D\uDDE8|\uD83E\uDDD1(?:\uD83C\uDFFF\u200D[\u2695\u2696\u2708]|\uD83C\uDFFE\u200D[\u2695\u2696\u2708]|\uD83C\uDFFD\u200D[\u2695\u2696\u2708]|\uD83C\uDFFC\u200D[\u2695\u2696\u2708]|\uD83C\uDFFB\u200D[\u2695\u2696\u2708]|\u200D[\u2695\u2696\u2708])|\uD83D\uDC69(?:\uD83C\uDFFF\u200D[\u2695\u2696\u2708]|\uD83C\uDFFE\u200D[\u2695\u2696\u2708]|\uD83C\uDFFD\u200D[\u2695\u2696\u2708]|\uD83C\uDFFC\u200D[\u2695\u2696\u2708]|\uD83C\uDFFB\u200D[\u2695\u2696\u2708]|\u200D[\u2695\u2696\u2708])|\uD83D\uDE36\u200D\uD83C\uDF2B|\uD83C\uDFF3\uFE0F\u200D\u26A7|\uD83D\uDC3B\u200D\u2744|(?:(?:\uD83C[\uDFC3\uDFC4\uDFCA]|\uD83D[\uDC6E\uDC70\uDC71\uDC73\uDC77\uDC81\uDC82\uDC86\uDC87\uDE45-\uDE47\uDE4B\uDE4D\uDE4E\uDEA3\uDEB4-\uDEB6]|\uD83E[\uDD26\uDD35\uDD37-\uDD39\uDD3D\uDD3E\uDDB8\uDDB9\uDDCD-\uDDCF\uDDD4\uDDD6-\uDDDD])(?:\uD83C[\uDFFB-\uDFFF])|\uD83D\uDC6F|\uD83E[\uDD3C\uDDDE\uDDDF])\u200D[\u2640\u2642]|(?:\u26F9|\uD83C[\uDFCB\uDFCC]|\uD83D\uDD75)(?:\uFE0F|\uD83C[\uDFFB-\uDFFF])\u200D[\u2640\u2642]|\uD83C\uDFF4\u200D\u2620|(?:\uD83C[\uDFC3\uDFC4\uDFCA]|\uD83D[\uDC6E\uDC70\uDC71\uDC73\uDC77\uDC81\uDC82\uDC86\uDC87\uDE45-\uDE47\uDE4B\uDE4D\uDE4E\uDEA3\uDEB4-\uDEB6]|\uD83E[\uDD26\uDD35\uDD37-\uDD39\uDD3D\uDD3E\uDDB8\uDDB9\uDDCD-\uDDCF\uDDD4\uDDD6-\uDDDD])\u200D[\u2640\u2642]|[\xA9\xAE\u203C\u2049\u2122\u2139\u2194-\u2199\u21A9\u21AA\u2328\u23CF\u23ED-\u23EF\u23F1\u23F2\u23F8-\u23FA\u24C2\u25AA\u25AB\u25B6\u25C0\u25FB\u25FC\u2600-\u2604\u260E\u2611\u2618\u2620\u2622\u2623\u2626\u262A\u262E\u262F\u2638-\u263A\u2640\u2642\u265F\u2660\u2663\u2665\u2666\u2668\u267B\u267E\u2692\u2694-\u2697\u2699\u269B\u269C\u26A0\u26A7\u26B0\u26B1\u26C8\u26CF\u26D1\u26D3\u26E9\u26F0\u26F1\u26F4\u26F7\u26F8\u2702\u2708\u2709\u270F\u2712\u2714\u2716\u271D\u2721\u2733\u2734\u2744\u2747\u2763\u27A1\u2934\u2935\u2B05-\u2B07\u3030\u303D\u3297\u3299]|\uD83C[\uDD70\uDD71\uDD7E\uDD7F\uDE02\uDE37\uDF21\uDF24-\uDF2C\uDF36\uDF7D\uDF96\uDF97\uDF99-\uDF9B\uDF9E\uDF9F\uDFCD\uDFCE\uDFD4-\uDFDF\uDFF5\uDFF7]|\uD83D[\uDC3F\uDCFD\uDD49\uDD4A\uDD6F\uDD70\uDD73\uDD76-\uDD79\uDD87\uDD8A-\uDD8D\uDDA5\uDDA8\uDDB1\uDDB2\uDDBC\uDDC2-\uDDC4\uDDD1-\uDDD3\uDDDC-\uDDDE\uDDE1\uDDE3\uDDE8\uDDEF\uDDF3\uDDFA\uDECB\uDECD-\uDECF\uDEE0-\uDEE5\uDEE9\uDEF0\uDEF3])\uFE0F|\uD83C\uDFF3\uFE0F\u200D\uD83C\uDF08|\uD83D\uDC69\u200D\uD83D\uDC67|\uD83D\uDC69\u200D\uD83D\uDC66|\uD83D\uDE35\u200D\uD83D\uDCAB|\uD83D\uDE2E\u200D\uD83D\uDCA8|\uD83D\uDC15\u200D\uD83E\uDDBA|\uD83E\uDDD1(?:\uD83C\uDFFF|\uD83C\uDFFE|\uD83C\uDFFD|\uD83C\uDFFC|\uD83C\uDFFB)?|\uD83D\uDC69(?:\uD83C\uDFFF|\uD83C\uDFFE|\uD83C\uDFFD|\uD83C\uDFFC|\uD83C\uDFFB)?|\uD83C\uDDFD\uD83C\uDDF0|\uD83C\uDDF6\uD83C\uDDE6|\uD83C\uDDF4\uD83C\uDDF2|\uD83D\uDC08\u200D\u2B1B|\u2764\uFE0F\u200D(?:\uD83D\uDD25|\uD83E\uDE79)|\uD83D\uDC41\uFE0F|\uD83C\uDFF3\uFE0F|\uD83C\uDDFF(?:\uD83C[\uDDE6\uDDF2\uDDFC])|\uD83C\uDDFE(?:\uD83C[\uDDEA\uDDF9])|\uD83C\uDDFC(?:\uD83C[\uDDEB\uDDF8])|\uD83C\uDDFB(?:\uD83C[\uDDE6\uDDE8\uDDEA\uDDEC\uDDEE\uDDF3\uDDFA])|\uD83C\uDDFA(?:\uD83C[\uDDE6\uDDEC\uDDF2\uDDF3\uDDF8\uDDFE\uDDFF])|\uD83C\uDDF9(?:\uD83C[\uDDE6\uDDE8\uDDE9\uDDEB-\uDDED\uDDEF-\uDDF4\uDDF7\uDDF9\uDDFB\uDDFC\uDDFF])|\uD83C\uDDF8(?:\uD83C[\uDDE6-\uDDEA\uDDEC-\uDDF4\uDDF7-\uDDF9\uDDFB\uDDFD-\uDDFF])|\uD83C\uDDF7(?:\uD83C[\uDDEA\uDDF4\uDDF8\uDDFA\uDDFC])|\uD83C\uDDF5(?:\uD83C[\uDDE6\uDDEA-\uDDED\uDDF0-\uDDF3\uDDF7-\uDDF9\uDDFC\uDDFE])|\uD83C\uDDF3(?:\uD83C[\uDDE6\uDDE8\uDDEA-\uDDEC\uDDEE\uDDF1\uDDF4\uDDF5\uDDF7\uDDFA\uDDFF])|\uD83C\uDDF2(?:\uD83C[\uDDE6\uDDE8-\uDDED\uDDF0-\uDDFF])|\uD83C\uDDF1(?:\uD83C[\uDDE6-\uDDE8\uDDEE\uDDF0\uDDF7-\uDDFB\uDDFE])|\uD83C\uDDF0(?:\uD83C[\uDDEA\uDDEC-\uDDEE\uDDF2\uDDF3\uDDF5\uDDF7\uDDFC\uDDFE\uDDFF])|\uD83C\uDDEF(?:\uD83C[\uDDEA\uDDF2\uDDF4\uDDF5])|\uD83C\uDDEE(?:\uD83C[\uDDE8-\uDDEA\uDDF1-\uDDF4\uDDF6-\uDDF9])|\uD83C\uDDED(?:\uD83C[\uDDF0\uDDF2\uDDF3\uDDF7\uDDF9\uDDFA])|\uD83C\uDDEC(?:\uD83C[\uDDE6\uDDE7\uDDE9-\uDDEE\uDDF1-\uDDF3\uDDF5-\uDDFA\uDDFC\uDDFE])|\uD83C\uDDEB(?:\uD83C[\uDDEE-\uDDF0\uDDF2\uDDF4\uDDF7])|\uD83C\uDDEA(?:\uD83C[\uDDE6\uDDE8\uDDEA\uDDEC\uDDED\uDDF7-\uDDFA])|\uD83C\uDDE9(?:\uD83C[\uDDEA\uDDEC\uDDEF\uDDF0\uDDF2\uDDF4\uDDFF])|\uD83C\uDDE8(?:\uD83C[\uDDE6\uDDE8\uDDE9\uDDEB-\uDDEE\uDDF0-\uDDF5\uDDF7\uDDFA-\uDDFF])|\uD83C\uDDE7(?:\uD83C[\uDDE6\uDDE7\uDDE9-\uDDEF\uDDF1-\uDDF4\uDDF6-\uDDF9\uDDFB\uDDFC\uDDFE\uDDFF])|\uD83C\uDDE6(?:\uD83C[\uDDE8-\uDDEC\uDDEE\uDDF1\uDDF2\uDDF4\uDDF6-\uDDFA\uDDFC\uDDFD\uDDFF])|[#\*0-9]\uFE0F\u20E3|\u2764\uFE0F|(?:\uD83C[\uDFC3\uDFC4\uDFCA]|\uD83D[\uDC6E\uDC70\uDC71\uDC73\uDC77\uDC81\uDC82\uDC86\uDC87\uDE45-\uDE47\uDE4B\uDE4D\uDE4E\uDEA3\uDEB4-\uDEB6]|\uD83E[\uDD26\uDD35\uDD37-\uDD39\uDD3D\uDD3E\uDDB8\uDDB9\uDDCD-\uDDCF\uDDD4\uDDD6-\uDDDD])(?:\uD83C[\uDFFB-\uDFFF])|(?:\u26F9|\uD83C[\uDFCB\uDFCC]|\uD83D\uDD75)(?:\uFE0F|\uD83C[\uDFFB-\uDFFF])|\uD83C\uDFF4|(?:[\u270A\u270B]|\uD83C[\uDF85\uDFC2\uDFC7]|\uD83D[\uDC42\uDC43\uDC46-\uDC50\uDC66\uDC67\uDC6B-\uDC6D\uDC72\uDC74-\uDC76\uDC78\uDC7C\uDC83\uDC85\uDC8F\uDC91\uDCAA\uDD7A\uDD95\uDD96\uDE4C\uDE4F\uDEC0\uDECC]|\uD83E[\uDD0C\uDD0F\uDD18-\uDD1C\uDD1E\uDD1F\uDD30-\uDD34\uDD36\uDD77\uDDB5\uDDB6\uDDBB\uDDD2\uDDD3\uDDD5])(?:\uD83C[\uDFFB-\uDFFF])|(?:[\u261D\u270C\u270D]|\uD83D[\uDD74\uDD90])(?:\uFE0F|\uD83C[\uDFFB-\uDFFF])|[\u270A\u270B]|\uD83C[\uDF85\uDFC2\uDFC7]|\uD83D[\uDC08\uDC15\uDC3B\uDC42\uDC43\uDC46-\uDC50\uDC66\uDC67\uDC6B-\uDC6D\uDC72\uDC74-\uDC76\uDC78\uDC7C\uDC83\uDC85\uDC8F\uDC91\uDCAA\uDD7A\uDD95\uDD96\uDE2E\uDE35\uDE36\uDE4C\uDE4F\uDEC0\uDECC]|\uD83E[\uDD0C\uDD0F\uDD18-\uDD1C\uDD1E\uDD1F\uDD30-\uDD34\uDD36\uDD77\uDDB5\uDDB6\uDDBB\uDDD2\uDDD3\uDDD5]|\uD83C[\uDFC3\uDFC4\uDFCA]|\uD83D[\uDC6E\uDC70\uDC71\uDC73\uDC77\uDC81\uDC82\uDC86\uDC87\uDE45-\uDE47\uDE4B\uDE4D\uDE4E\uDEA3\uDEB4-\uDEB6]|\uD83E[\uDD26\uDD35\uDD37-\uDD39\uDD3D\uDD3E\uDDB8\uDDB9\uDDCD-\uDDCF\uDDD4\uDDD6-\uDDDD]|\uD83D\uDC6F|\uD83E[\uDD3C\uDDDE\uDDDF]|[\u231A\u231B\u23E9-\u23EC\u23F0\u23F3\u25FD\u25FE\u2614\u2615\u2648-\u2653\u267F\u2693\u26A1\u26AA\u26AB\u26BD\u26BE\u26C4\u26C5\u26CE\u26D4\u26EA\u26F2\u26F3\u26F5\u26FA\u26FD\u2705\u2728\u274C\u274E\u2753-\u2755\u2757\u2795-\u2797\u27B0\u27BF\u2B1B\u2B1C\u2B50\u2B55]|\uD83C[\uDC04\uDCCF\uDD8E\uDD91-\uDD9A\uDE01\uDE1A\uDE2F\uDE32-\uDE36\uDE38-\uDE3A\uDE50\uDE51\uDF00-\uDF20\uDF2D-\uDF35\uDF37-\uDF7C\uDF7E-\uDF84\uDF86-\uDF93\uDFA0-\uDFC1\uDFC5\uDFC6\uDFC8\uDFC9\uDFCF-\uDFD3\uDFE0-\uDFF0\uDFF8-\uDFFF]|\uD83D[\uDC00-\uDC07\uDC09-\uDC14\uDC16-\uDC3A\uDC3C-\uDC3E\uDC40\uDC44\uDC45\uDC51-\uDC65\uDC6A\uDC79-\uDC7B\uDC7D-\uDC80\uDC84\uDC88-\uDC8E\uDC90\uDC92-\uDCA9\uDCAB-\uDCFC\uDCFF-\uDD3D\uDD4B-\uDD4E\uDD50-\uDD67\uDDA4\uDDFB-\uDE2D\uDE2F-\uDE34\uDE37-\uDE44\uDE48-\uDE4A\uDE80-\uDEA2\uDEA4-\uDEB3\uDEB7-\uDEBF\uDEC1-\uDEC5\uDED0-\uDED2\uDED5-\uDED7\uDEEB\uDEEC\uDEF4-\uDEFC\uDFE0-\uDFEB]|\uD83E[\uDD0D\uDD0E\uDD10-\uDD17\uDD1D\uDD20-\uDD25\uDD27-\uDD2F\uDD3A\uDD3F-\uDD45\uDD47-\uDD76\uDD78\uDD7A-\uDDB4\uDDB7\uDDBA\uDDBC-\uDDCB\uDDD0\uDDE0-\uDDFF\uDE70-\uDE74\uDE78-\uDE7A\uDE80-\uDE86\uDE90-\uDEA8\uDEB0-\uDEB6\uDEC0-\uDEC2\uDED0-\uDED6]|(?:[\u231A\u231B\u23E9-\u23EC\u23F0\u23F3\u25FD\u25FE\u2614\u2615\u2648-\u2653\u267F\u2693\u26A1\u26AA\u26AB\u26BD\u26BE\u26C4\u26C5\u26CE\u26D4\u26EA\u26F2\u26F3\u26F5\u26FA\u26FD\u2705\u270A\u270B\u2728\u274C\u274E\u2753-\u2755\u2757\u2795-\u2797\u27B0\u27BF\u2B1B\u2B1C\u2B50\u2B55]|\uD83C[\uDC04\uDCCF\uDD8E\uDD91-\uDD9A\uDDE6-\uDDFF\uDE01\uDE1A\uDE2F\uDE32-\uDE36\uDE38-\uDE3A\uDE50\uDE51\uDF00-\uDF20\uDF2D-\uDF35\uDF37-\uDF7C\uDF7E-\uDF93\uDFA0-\uDFCA\uDFCF-\uDFD3\uDFE0-\uDFF0\uDFF4\uDFF8-\uDFFF]|\uD83D[\uDC00-\uDC3E\uDC40\uDC42-\uDCFC\uDCFF-\uDD3D\uDD4B-\uDD4E\uDD50-\uDD67\uDD7A\uDD95\uDD96\uDDA4\uDDFB-\uDE4F\uDE80-\uDEC5\uDECC\uDED0-\uDED2\uDED5-\uDED7\uDEEB\uDEEC\uDEF4-\uDEFC\uDFE0-\uDFEB]|\uD83E[\uDD0C-\uDD3A\uDD3C-\uDD45\uDD47-\uDD78\uDD7A-\uDDCB\uDDCD-\uDDFF\uDE70-\uDE74\uDE78-\uDE7A\uDE80-\uDE86\uDE90-\uDEA8\uDEB0-\uDEB6\uDEC0-\uDEC2\uDED0-\uDED6])|(?:[#\*0-9\xA9\xAE\u203C\u2049\u2122\u2139\u2194-\u2199\u21A9\u21AA\u231A\u231B\u2328\u23CF\u23E9-\u23F3\u23F8-\u23FA\u24C2\u25AA\u25AB\u25B6\u25C0\u25FB-\u25FE\u2600-\u2604\u260E\u2611\u2614\u2615\u2618\u261D\u2620\u2622\u2623\u2626\u262A\u262E\u262F\u2638-\u263A\u2640\u2642\u2648-\u2653\u265F\u2660\u2663\u2665\u2666\u2668\u267B\u267E\u267F\u2692-\u2697\u2699\u269B\u269C\u26A0\u26A1\u26A7\u26AA\u26AB\u26B0\u26B1\u26BD\u26BE\u26C4\u26C5\u26C8\u26CE\u26CF\u26D1\u26D3\u26D4\u26E9\u26EA\u26F0-\u26F5\u26F7-\u26FA\u26FD\u2702\u2705\u2708-\u270D\u270F\u2712\u2714\u2716\u271D\u2721\u2728\u2733\u2734\u2744\u2747\u274C\u274E\u2753-\u2755\u2757\u2763\u2764\u2795-\u2797\u27A1\u27B0\u27BF\u2934\u2935\u2B05-\u2B07\u2B1B\u2B1C\u2B50\u2B55\u3030\u303D\u3297\u3299]|\uD83C[\uDC04\uDCCF\uDD70\uDD71\uDD7E\uDD7F\uDD8E\uDD91-\uDD9A\uDDE6-\uDDFF\uDE01\uDE02\uDE1A\uDE2F\uDE32-\uDE3A\uDE50\uDE51\uDF00-\uDF21\uDF24-\uDF93\uDF96\uDF97\uDF99-\uDF9B\uDF9E-\uDFF0\uDFF3-\uDFF5\uDFF7-\uDFFF]|\uD83D[\uDC00-\uDCFD\uDCFF-\uDD3D\uDD49-\uDD4E\uDD50-\uDD67\uDD6F\uDD70\uDD73-\uDD7A\uDD87\uDD8A-\uDD8D\uDD90\uDD95\uDD96\uDDA4\uDDA5\uDDA8\uDDB1\uDDB2\uDDBC\uDDC2-\uDDC4\uDDD1-\uDDD3\uDDDC-\uDDDE\uDDE1\uDDE3\uDDE8\uDDEF\uDDF3\uDDFA-\uDE4F\uDE80-\uDEC5\uDECB-\uDED2\uDED5-\uDED7\uDEE0-\uDEE5\uDEE9\uDEEB\uDEEC\uDEF0\uDEF3-\uDEFC\uDFE0-\uDFEB]|\uD83E[\uDD0C-\uDD3A\uDD3C-\uDD45\uDD47-\uDD78\uDD7A-\uDDCB\uDDCD-\uDDFF\uDE70-\uDE74\uDE78-\uDE7A\uDE80-\uDE86\uDE90-\uDEA8\uDEB0-\uDEB6\uDEC0-\uDEC2\uDED0-\uDED6])\uFE0F|(?:[\u261D\u26F9\u270A-\u270D]|\uD83C[\uDF85\uDFC2-\uDFC4\uDFC7\uDFCA-\uDFCC]|\uD83D[\uDC42\uDC43\uDC46-\uDC50\uDC66-\uDC78\uDC7C\uDC81-\uDC83\uDC85-\uDC87\uDC8F\uDC91\uDCAA\uDD74\uDD75\uDD7A\uDD90\uDD95\uDD96\uDE45-\uDE47\uDE4B-\uDE4F\uDEA3\uDEB4-\uDEB6\uDEC0\uDECC]|\uD83E[\uDD0C\uDD0F\uDD18-\uDD1F\uDD26\uDD30-\uDD39\uDD3C-\uDD3E\uDD77\uDDB5\uDDB6\uDDB8\uDDB9\uDDBB\uDDCD-\uDDCF\uDDD1-\uDDDD])/g;
    };
    FD = O(uD);
    m$1 = 10;
    L = (t2 = 0) => (u3) => `\x1B[${u3 + t2}m`;
    N = (t2 = 0) => (u3) => `\x1B[${38 + t2};5;${u3}m`;
    I = (t2 = 0) => (u3, F2, e2) => `\x1B[${38 + t2};2;${u3};${F2};${e2}m`;
    r = { modifier: { reset: [0, 0], bold: [1, 22], dim: [2, 22], italic: [3, 23], underline: [4, 24], overline: [53, 55], inverse: [7, 27], hidden: [8, 28], strikethrough: [9, 29] }, color: { black: [30, 39], red: [31, 39], green: [32, 39], yellow: [33, 39], blue: [34, 39], magenta: [35, 39], cyan: [36, 39], white: [37, 39], blackBright: [90, 39], gray: [90, 39], grey: [90, 39], redBright: [91, 39], greenBright: [92, 39], yellowBright: [93, 39], blueBright: [94, 39], magentaBright: [95, 39], cyanBright: [96, 39], whiteBright: [97, 39] }, bgColor: { bgBlack: [40, 49], bgRed: [41, 49], bgGreen: [42, 49], bgYellow: [43, 49], bgBlue: [44, 49], bgMagenta: [45, 49], bgCyan: [46, 49], bgWhite: [47, 49], bgBlackBright: [100, 49], bgGray: [100, 49], bgGrey: [100, 49], bgRedBright: [101, 49], bgGreenBright: [102, 49], bgYellowBright: [103, 49], bgBlueBright: [104, 49], bgMagentaBright: [105, 49], bgCyanBright: [106, 49], bgWhiteBright: [107, 49] } };
    Object.keys(r.modifier);
    tD = Object.keys(r.color);
    eD = Object.keys(r.bgColor);
    [...tD, ...eD];
    iD = sD();
    v2 = /* @__PURE__ */ new Set(["\x1B", "\x9B"]);
    CD = 39;
    w = "\x07";
    W = "[";
    rD = "]";
    R$1 = "m";
    y$1 = `${rD}8;;`;
    V$1 = (t2) => `${v2.values().next().value}${W}${t2}${R$1}`;
    z = (t2) => `${v2.values().next().value}${y$1}${t2}${w}`;
    ED = (t2) => t2.split(" ").map((u3) => A$1(u3));
    _ = (t2, u3, F2) => {
      const e2 = [...u3];
      let s2 = false, i2 = false, D2 = A$1(T(t2[t2.length - 1]));
      for (const [C2, o] of e2.entries()) {
        const E2 = A$1(o);
        if (D2 + E2 <= F2 ? t2[t2.length - 1] += o : (t2.push(o), D2 = 0), v2.has(o) && (s2 = true, i2 = e2.slice(C2 + 1).join("").startsWith(y$1)), s2) {
          i2 ? o === w && (s2 = false, i2 = false) : o === R$1 && (s2 = false);
          continue;
        }
        D2 += E2, D2 === F2 && C2 < e2.length - 1 && (t2.push(""), D2 = 0);
      }
      !D2 && t2[t2.length - 1].length > 0 && t2.length > 1 && (t2[t2.length - 2] += t2.pop());
    };
    nD = (t2) => {
      const u3 = t2.split(" ");
      let F2 = u3.length;
      for (; F2 > 0 && !(A$1(u3[F2 - 1]) > 0); )
        F2--;
      return F2 === u3.length ? t2 : u3.slice(0, F2).join(" ") + u3.slice(F2).join("");
    };
    oD = (t2, u3, F2 = {}) => {
      if (F2.trim !== false && t2.trim() === "")
        return "";
      let e2 = "", s2, i2;
      const D2 = ED(t2);
      let C2 = [""];
      for (const [E2, a3] of t2.split(" ").entries()) {
        F2.trim !== false && (C2[C2.length - 1] = C2[C2.length - 1].trimStart());
        let n2 = A$1(C2[C2.length - 1]);
        if (E2 !== 0 && (n2 >= u3 && (F2.wordWrap === false || F2.trim === false) && (C2.push(""), n2 = 0), (n2 > 0 || F2.trim === false) && (C2[C2.length - 1] += " ", n2++)), F2.hard && D2[E2] > u3) {
          const B3 = u3 - n2, p3 = 1 + Math.floor((D2[E2] - B3 - 1) / u3);
          Math.floor((D2[E2] - 1) / u3) < p3 && C2.push(""), _(C2, a3, u3);
          continue;
        }
        if (n2 + D2[E2] > u3 && n2 > 0 && D2[E2] > 0) {
          if (F2.wordWrap === false && n2 < u3) {
            _(C2, a3, u3);
            continue;
          }
          C2.push("");
        }
        if (n2 + D2[E2] > u3 && F2.wordWrap === false) {
          _(C2, a3, u3);
          continue;
        }
        C2[C2.length - 1] += a3;
      }
      F2.trim !== false && (C2 = C2.map((E2) => nD(E2)));
      const o = [...C2.join(`
`)];
      for (const [E2, a3] of o.entries()) {
        if (e2 += a3, v2.has(a3)) {
          const { groups: B3 } = new RegExp(`(?:\\${W}(?<code>\\d+)m|\\${y$1}(?<uri>.*)${w})`).exec(o.slice(E2).join("")) || { groups: {} };
          if (B3.code !== void 0) {
            const p3 = Number.parseFloat(B3.code);
            s2 = p3 === CD ? void 0 : p3;
          } else
            B3.uri !== void 0 && (i2 = B3.uri.length === 0 ? void 0 : B3.uri);
        }
        const n2 = iD.codes.get(Number(s2));
        o[E2 + 1] === `
` ? (i2 && (e2 += z("")), s2 && n2 && (e2 += V$1(n2))) : a3 === `
` && (s2 && n2 && (e2 += V$1(s2)), i2 && (e2 += z(i2)));
      }
      return e2;
    };
    aD = ["up", "down", "left", "right", "space", "enter", "cancel"];
    c = { actions: new Set(aD), aliases: /* @__PURE__ */ new Map([["k", "up"], ["j", "down"], ["h", "left"], ["l", "right"], ["", "cancel"], ["escape", "cancel"]]) };
    globalThis.process.platform.startsWith("win");
    S$1 = Symbol("clack:cancel");
    AD = Object.defineProperty;
    pD = (t2, u3, F2) => u3 in t2 ? AD(t2, u3, { enumerable: true, configurable: true, writable: true, value: F2 }) : t2[u3] = F2;
    h = (t2, u3, F2) => (pD(t2, typeof u3 != "symbol" ? u3 + "" : u3, F2), F2);
    x = class {
      constructor(u3, F2 = true) {
        h(this, "input"), h(this, "output"), h(this, "_abortSignal"), h(this, "rl"), h(this, "opts"), h(this, "_render"), h(this, "_track", false), h(this, "_prevFrame", ""), h(this, "_subscribers", /* @__PURE__ */ new Map()), h(this, "_cursor", 0), h(this, "state", "initial"), h(this, "error", ""), h(this, "value");
        const { input: e2 = stdin, output: s2 = stdout, render: i2, signal: D2, ...C2 } = u3;
        this.opts = C2, this.onKeypress = this.onKeypress.bind(this), this.close = this.close.bind(this), this.render = this.render.bind(this), this._render = i2.bind(this), this._track = F2, this._abortSignal = D2, this.input = e2, this.output = s2;
      }
      unsubscribe() {
        this._subscribers.clear();
      }
      setSubscriber(u3, F2) {
        const e2 = this._subscribers.get(u3) ?? [];
        e2.push(F2), this._subscribers.set(u3, e2);
      }
      on(u3, F2) {
        this.setSubscriber(u3, { cb: F2 });
      }
      once(u3, F2) {
        this.setSubscriber(u3, { cb: F2, once: true });
      }
      emit(u3, ...F2) {
        const e2 = this._subscribers.get(u3) ?? [], s2 = [];
        for (const i2 of e2)
          i2.cb(...F2), i2.once && s2.push(() => e2.splice(e2.indexOf(i2), 1));
        for (const i2 of s2)
          i2();
      }
      prompt() {
        return new Promise((u3, F2) => {
          if (this._abortSignal) {
            if (this._abortSignal.aborted)
              return this.state = "cancel", this.close(), u3(S$1);
            this._abortSignal.addEventListener("abort", () => {
              this.state = "cancel", this.close();
            }, { once: true });
          }
          const e2 = new WriteStream(0);
          e2._write = (s2, i2, D2) => {
            var _a8, _b5;
            this._track && (this.value = (_a8 = this.rl) == null ? void 0 : _a8.line.replace(/\t/g, ""), this._cursor = ((_b5 = this.rl) == null ? void 0 : _b5.cursor) ?? 0, this.emit("value", this.value)), D2();
          }, this.input.pipe(e2), this.rl = f.createInterface({ input: this.input, output: e2, tabSize: 2, prompt: "", escapeCodeTimeout: 50 }), f.emitKeypressEvents(this.input, this.rl), this.rl.prompt(), this.opts.initialValue !== void 0 && this._track && this.rl.write(this.opts.initialValue), this.input.on("keypress", this.onKeypress), d(this.input, true), this.output.on("resize", this.render), this.render(), this.once("submit", () => {
            this.output.write(srcExports.cursor.show), this.output.off("resize", this.render), d(this.input, false), u3(this.value);
          }), this.once("cancel", () => {
            this.output.write(srcExports.cursor.show), this.output.off("resize", this.render), d(this.input, false), u3(S$1);
          });
        });
      }
      onKeypress(u3, F2) {
        var _a8, _b5;
        if (this.state === "error" && (this.state = "active"), (F2 == null ? void 0 : F2.name) && (!this._track && c.aliases.has(F2.name) && this.emit("cursor", c.aliases.get(F2.name)), c.actions.has(F2.name) && this.emit("cursor", F2.name)), u3 && (u3.toLowerCase() === "y" || u3.toLowerCase() === "n") && this.emit("confirm", u3.toLowerCase() === "y"), u3 === "	" && this.opts.placeholder && (this.value || ((_a8 = this.rl) == null ? void 0 : _a8.write(this.opts.placeholder), this.emit("value", this.opts.placeholder))), u3 && this.emit("key", u3.toLowerCase()), (F2 == null ? void 0 : F2.name) === "return") {
          if (this.opts.validate) {
            const e2 = this.opts.validate(this.value);
            e2 && (this.error = e2 instanceof Error ? e2.message : e2, this.state = "error", (_b5 = this.rl) == null ? void 0 : _b5.write(this.value));
          }
          this.state !== "error" && (this.state = "submit");
        }
        k$1([u3, F2 == null ? void 0 : F2.name, F2 == null ? void 0 : F2.sequence], "cancel") && (this.state = "cancel"), (this.state === "submit" || this.state === "cancel") && this.emit("finalize"), this.render(), (this.state === "submit" || this.state === "cancel") && this.close();
      }
      close() {
        var _a8;
        this.input.unpipe(), this.input.removeListener("keypress", this.onKeypress), this.output.write(`
`), d(this.input, false), (_a8 = this.rl) == null ? void 0 : _a8.close(), this.rl = void 0, this.emit(`${this.state}`, this.value), this.unsubscribe();
      }
      restoreCursor() {
        const u3 = G$1(this._prevFrame, process.stdout.columns, { hard: true }).split(`
`).length - 1;
        this.output.write(srcExports.cursor.move(-999, u3 * -1));
      }
      render() {
        const u3 = G$1(this._render(this) ?? "", process.stdout.columns, { hard: true });
        if (u3 !== this._prevFrame) {
          if (this.state === "initial")
            this.output.write(srcExports.cursor.hide);
          else {
            const F2 = lD(this._prevFrame, u3);
            if (this.restoreCursor(), F2 && (F2 == null ? void 0 : F2.length) === 1) {
              const e2 = F2[0];
              this.output.write(srcExports.cursor.move(0, e2)), this.output.write(srcExports.erase.lines(1));
              const s2 = u3.split(`
`);
              this.output.write(s2[e2]), this._prevFrame = u3, this.output.write(srcExports.cursor.move(0, s2.length - e2 - 1));
              return;
            }
            if (F2 && (F2 == null ? void 0 : F2.length) > 1) {
              const e2 = F2[0];
              this.output.write(srcExports.cursor.move(0, e2)), this.output.write(srcExports.erase.down());
              const s2 = u3.split(`
`).slice(e2);
              this.output.write(s2.join(`
`)), this._prevFrame = u3;
              return;
            }
            this.output.write(srcExports.erase.down());
          }
          this.output.write(u3), this.state === "initial" && (this.state = "active"), this._prevFrame = u3;
        }
      }
    };
    fD = class extends x {
      get cursor() {
        return this.value ? 0 : 1;
      }
      get _value() {
        return this.cursor === 0;
      }
      constructor(u3) {
        super(u3, false), this.value = !!u3.initialValue, this.on("value", () => {
          this.value = this._value;
        }), this.on("confirm", (F2) => {
          this.output.write(srcExports.cursor.move(0, -1)), this.value = F2, this.state = "submit", this.close();
        }), this.on("cursor", () => {
          this.value = !this.value;
        });
      }
    };
    bD = Object.defineProperty;
    mD = (t2, u3, F2) => u3 in t2 ? bD(t2, u3, { enumerable: true, configurable: true, writable: true, value: F2 }) : t2[u3] = F2;
    Y = (t2, u3, F2) => (mD(t2, typeof u3 != "symbol" ? u3 + "" : u3, F2), F2);
    wD = class extends x {
      constructor(u3) {
        super(u3, false), Y(this, "options"), Y(this, "cursor", 0), this.options = u3.options, this.value = [...u3.initialValues ?? []], this.cursor = Math.max(this.options.findIndex(({ value: F2 }) => F2 === u3.cursorAt), 0), this.on("key", (F2) => {
          F2 === "a" && this.toggleAll();
        }), this.on("cursor", (F2) => {
          switch (F2) {
            case "left":
            case "up":
              this.cursor = this.cursor === 0 ? this.options.length - 1 : this.cursor - 1;
              break;
            case "down":
            case "right":
              this.cursor = this.cursor === this.options.length - 1 ? 0 : this.cursor + 1;
              break;
            case "space":
              this.toggleValue();
              break;
          }
        });
      }
      get _value() {
        return this.options[this.cursor].value;
      }
      toggleAll() {
        const u3 = this.value.length === this.options.length;
        this.value = u3 ? [] : this.options.map((F2) => F2.value);
      }
      toggleValue() {
        const u3 = this.value.includes(this._value);
        this.value = u3 ? this.value.filter((F2) => F2 !== this._value) : [...this.value, this._value];
      }
    };
    SD = Object.defineProperty;
    $D = (t2, u3, F2) => u3 in t2 ? SD(t2, u3, { enumerable: true, configurable: true, writable: true, value: F2 }) : t2[u3] = F2;
    q = (t2, u3, F2) => ($D(t2, typeof u3 != "symbol" ? u3 + "" : u3, F2), F2);
    jD = class extends x {
      constructor(u3) {
        super(u3, false), q(this, "options"), q(this, "cursor", 0), this.options = u3.options, this.cursor = this.options.findIndex(({ value: F2 }) => F2 === u3.initialValue), this.cursor === -1 && (this.cursor = 0), this.changeValue(), this.on("cursor", (F2) => {
          switch (F2) {
            case "left":
            case "up":
              this.cursor = this.cursor === 0 ? this.options.length - 1 : this.cursor - 1;
              break;
            case "down":
            case "right":
              this.cursor = this.cursor === this.options.length - 1 ? 0 : this.cursor + 1;
              break;
          }
          this.changeValue();
        });
      }
      get _value() {
        return this.options[this.cursor];
      }
      changeValue() {
        this.value = this._value.value;
      }
    };
    PD = class extends x {
      get valueWithCursor() {
        if (this.state === "submit")
          return this.value;
        if (this.cursor >= this.value.length)
          return `${this.value}\u2588`;
        const u3 = this.value.slice(0, this.cursor), [F2, ...e$1] = this.value.slice(this.cursor);
        return `${u3}${e.inverse(F2)}${e$1.join("")}`;
      }
      get cursor() {
        return this._cursor;
      }
      constructor(u3) {
        super(u3), this.on("finalize", () => {
          this.value || (this.value = u3.defaultValue);
        });
      }
    };
    E = X();
    u = (s2, n2) => E ? s2 : n2;
    ee = u("\u276F", ">");
    A = u("\u25A0", "x");
    B = u("\u25B2", "x");
    S = u("\u2714", "\u221A");
    a = u("");
    m = u("");
    j = u("\u25CF", ">");
    R = u("\u25CB", " ");
    V = u("\u25FB", "[\u2022]");
    M = u("\u25FC", "[+]");
    G = u("\u25FB", "[ ]");
    y = (s2) => {
      switch (s2) {
        case "initial":
        case "active":
          return e.cyan(ee);
        case "cancel":
          return e.red(A);
        case "error":
          return e.yellow(B);
        case "submit":
          return e.green(S);
      }
    };
    k = (s2) => {
      const { cursor: n2, options: t2, style: i2 } = s2, r3 = s2.maxItems ?? Number.POSITIVE_INFINITY, c3 = Math.max(process.stdout.rows - 4, 0), o = Math.min(c3, Math.max(r3, 5));
      let l2 = 0;
      n2 >= l2 + o - 3 ? l2 = Math.max(Math.min(n2 - o + 3, t2.length - o), 0) : n2 < l2 + 2 && (l2 = Math.max(n2 - 2, 0));
      const $ = o < t2.length && l2 > 0, d2 = o < t2.length && l2 + o < t2.length;
      return t2.slice(l2, l2 + o).map((w2, b, C2) => {
        const I3 = b === 0 && $, x2 = b === C2.length - 1 && d2;
        return I3 || x2 ? e.dim("...") : i2(w2, b + l2 === n2);
      });
    };
    ue = (s2) => new PD({ validate: s2.validate, placeholder: s2.placeholder, defaultValue: s2.defaultValue, initialValue: s2.initialValue, render() {
      var _a8;
      const n2 = `${e.gray(a)}
${y(this.state)} ${s2.message}
`, t2 = s2.placeholder ? e.inverse(s2.placeholder[0]) + e.dim(s2.placeholder.slice(1)) : e.inverse(e.hidden("_")), i2 = this.value ? this.valueWithCursor : t2;
      switch (this.state) {
        case "error":
          return `${n2.trim()}
${e.yellow(a)} ${i2}
${e.yellow(m)} ${e.yellow(this.error)}
`;
        case "submit":
          return `${n2}${e.gray(a)} ${e.dim(this.value || s2.placeholder)}`;
        case "cancel":
          return `${n2}${e.gray(a)} ${e.strikethrough(e.dim(this.value ?? ""))}${((_a8 = this.value) == null ? void 0 : _a8.trim()) ? `
${e.gray(a)}` : ""}`;
        default:
          return `${n2}${e.cyan(a)} ${i2}
${e.cyan(m)}
`;
      }
    } }).prompt();
    me = (s2) => {
      const n2 = s2.active ?? "Yes", t2 = s2.inactive ?? "No";
      return new fD({ active: n2, inactive: t2, initialValue: s2.initialValue ?? true, render() {
        const i2 = `${e.gray(a)}
${y(this.state)} ${s2.message}
`, r3 = this.value ? n2 : t2;
        switch (this.state) {
          case "submit":
            return `${i2}${e.gray(a)} ${e.dim(r3)}`;
          case "cancel":
            return `${i2}${e.gray(a)} ${e.strikethrough(e.dim(r3))}
${e.gray(a)}`;
          default:
            return `${i2}${e.cyan(a)} ${this.value ? `${e.green(j)} ${n2}` : `${e.dim(R)} ${e.dim(n2)}`} ${e.dim("/")} ${this.value ? `${e.dim(R)} ${e.dim(t2)}` : `${e.green(j)} ${t2}`}
${e.cyan(m)}
`;
        }
      } }).prompt();
    };
    de = (s2) => {
      const n2 = (t2, i2) => {
        const r3 = t2.label ?? String(t2.value);
        switch (i2) {
          case "selected":
            return `${e.dim(r3)}`;
          case "active":
            return `${e.green(j)} ${r3} ${t2.hint ? e.dim(`(${t2.hint})`) : ""}`;
          case "cancelled":
            return `${e.strikethrough(e.dim(r3))}`;
          default:
            return `${e.dim(R)} ${e.dim(r3)}`;
        }
      };
      return new jD({ options: s2.options, initialValue: s2.initialValue, render() {
        const t2 = `${e.gray(a)}
${y(this.state)} ${s2.message}
`;
        switch (this.state) {
          case "submit":
            return `${t2}${e.gray(a)} ${n2(this.options[this.cursor], "selected")}`;
          case "cancel":
            return `${t2}${e.gray(a)} ${n2(this.options[this.cursor], "cancelled")}
${e.gray(a)}`;
          default:
            return `${t2}${e.cyan(a)} ${k({ cursor: this.cursor, options: this.options, maxItems: s2.maxItems, style: (i2, r3) => n2(i2, r3 ? "active" : "inactive") }).join(`
${e.cyan(a)}  `)}
${e.cyan(m)}
`;
        }
      } }).prompt();
    };
    pe = (s2) => {
      const n2 = (t2, i2) => {
        const r3 = t2.label ?? String(t2.value);
        return i2 === "active" ? `${e.cyan(V)} ${r3} ${t2.hint ? e.dim(`(${t2.hint})`) : ""}` : i2 === "selected" ? `${e.green(M)} ${e.dim(r3)}` : i2 === "cancelled" ? `${e.strikethrough(e.dim(r3))}` : i2 === "active-selected" ? `${e.green(M)} ${r3} ${t2.hint ? e.dim(`(${t2.hint})`) : ""}` : i2 === "submitted" ? `${e.dim(r3)}` : `${e.dim(G)} ${e.dim(r3)}`;
      };
      return new wD({ options: s2.options, initialValues: s2.initialValues, required: s2.required ?? true, cursorAt: s2.cursorAt, validate(t2) {
        if (this.required && t2.length === 0)
          return `Please select at least one option.
${e.reset(e.dim(`Press ${e.gray(e.bgWhite(e.inverse(" space ")))} to select, ${e.gray(e.bgWhite(e.inverse(" enter ")))} to submit`))}`;
      }, render() {
        const t2 = `${e.gray(a)}
${y(this.state)} ${s2.message}
`, i2 = (r3, c3) => {
          const o = this.value.includes(r3.value);
          return c3 && o ? n2(r3, "active-selected") : o ? n2(r3, "selected") : n2(r3, c3 ? "active" : "inactive");
        };
        switch (this.state) {
          case "submit":
            return `${t2}${e.gray(a)} ${this.options.filter(({ value: r3 }) => this.value.includes(r3)).map((r3) => n2(r3, "submitted")).join(e.dim(", ")) || e.dim("none")}`;
          case "cancel": {
            const r3 = this.options.filter(({ value: c3 }) => this.value.includes(c3)).map((c3) => n2(c3, "cancelled")).join(e.dim(", "));
            return `${t2}${e.gray(a)} ${r3.trim() ? `${r3}
${e.gray(a)}` : ""}`;
          }
          case "error": {
            const r3 = this.error.split(`
`).map((c3, o) => o === 0 ? `${e.yellow(m)} ${e.yellow(c3)}` : `   ${c3}`).join(`
`);
            return `${t2 + e.yellow(a)} ${k({ options: this.options, cursor: this.cursor, maxItems: s2.maxItems, style: i2 }).join(`
${e.yellow(a)}  `)}
${r3}
`;
          }
          default:
            return `${t2}${e.cyan(a)} ${k({ options: this.options, cursor: this.cursor, maxItems: s2.maxItems, style: i2 }).join(`
${e.cyan(a)}  `)}
${e.cyan(m)}
`;
        }
      } }).prompt();
    };
    kCancel = Symbol.for("cancel");
  }
});

// ../../../node_modules/.pnpm/cli-progress@3.12.0/node_modules/cli-progress/lib/eta.js
var require_eta = __commonJS({
  "../../../node_modules/.pnpm/cli-progress@3.12.0/node_modules/cli-progress/lib/eta.js"(exports, module) {
    init_define_ENV_DEFINED_IN_BUILD_STEP();
    var ETA = class {
      constructor(length, initTime, initValue) {
        this.etaBufferLength = length || 100;
        this.valueBuffer = [initValue];
        this.timeBuffer = [initTime];
        this.eta = "0";
      }
      // add new values to calculation buffer
      update(time, value, total) {
        this.valueBuffer.push(value);
        this.timeBuffer.push(time);
        this.calculate(total - value);
      }
      // fetch estimated time
      getTime() {
        return this.eta;
      }
      // eta calculation - request number of remaining events
      calculate(remaining) {
        const currentBufferSize = this.valueBuffer.length;
        const buffer = Math.min(this.etaBufferLength, currentBufferSize);
        const v_diff = this.valueBuffer[currentBufferSize - 1] - this.valueBuffer[currentBufferSize - buffer];
        const t_diff = this.timeBuffer[currentBufferSize - 1] - this.timeBuffer[currentBufferSize - buffer];
        const vt_rate = v_diff / t_diff;
        this.valueBuffer = this.valueBuffer.slice(-this.etaBufferLength);
        this.timeBuffer = this.timeBuffer.slice(-this.etaBufferLength);
        const eta = Math.ceil(remaining / vt_rate / 1e3);
        if (isNaN(eta)) {
          this.eta = "NULL";
        } else if (!isFinite(eta)) {
          this.eta = "INF";
        } else if (eta > 1e7) {
          this.eta = "INF";
        } else if (eta < 0) {
          this.eta = 0;
        } else {
          this.eta = eta;
        }
      }
    };
    module.exports = ETA;
  }
});

// ../../../node_modules/.pnpm/cli-progress@3.12.0/node_modules/cli-progress/lib/terminal.js
var require_terminal = __commonJS({
  "../../../node_modules/.pnpm/cli-progress@3.12.0/node_modules/cli-progress/lib/terminal.js"(exports, module) {
    init_define_ENV_DEFINED_IN_BUILD_STEP();
    var _readline = __require("readline");
    var Terminal = class {
      constructor(outputStream) {
        this.stream = outputStream;
        this.linewrap = true;
        this.dy = 0;
      }
      // save cursor position + settings
      cursorSave() {
        if (!this.stream.isTTY) {
          return;
        }
        this.stream.write("\x1B7");
      }
      // restore last cursor position + settings
      cursorRestore() {
        if (!this.stream.isTTY) {
          return;
        }
        this.stream.write("\x1B8");
      }
      // show/hide cursor
      cursor(enabled) {
        if (!this.stream.isTTY) {
          return;
        }
        if (enabled) {
          this.stream.write("\x1B[?25h");
        } else {
          this.stream.write("\x1B[?25l");
        }
      }
      // change cursor positionn
      cursorTo(x2 = null, y3 = null) {
        if (!this.stream.isTTY) {
          return;
        }
        _readline.cursorTo(this.stream, x2, y3);
      }
      // change relative cursor position
      cursorRelative(dx = null, dy = null) {
        if (!this.stream.isTTY) {
          return;
        }
        this.dy = this.dy + dy;
        _readline.moveCursor(this.stream, dx, dy);
      }
      // relative reset
      cursorRelativeReset() {
        if (!this.stream.isTTY) {
          return;
        }
        _readline.moveCursor(this.stream, 0, -this.dy);
        _readline.cursorTo(this.stream, 0, null);
        this.dy = 0;
      }
      // clear to the right from cursor
      clearRight() {
        if (!this.stream.isTTY) {
          return;
        }
        _readline.clearLine(this.stream, 1);
      }
      // clear the full line
      clearLine() {
        if (!this.stream.isTTY) {
          return;
        }
        _readline.clearLine(this.stream, 0);
      }
      // clear everyting beyond the current line
      clearBottom() {
        if (!this.stream.isTTY) {
          return;
        }
        _readline.clearScreenDown(this.stream);
      }
      // add new line; increment counter
      newline() {
        this.stream.write("\n");
        this.dy++;
      }
      // write content to output stream
      // @TODO use string-width to strip length
      write(s2, rawWrite = false) {
        if (this.linewrap === true && rawWrite === false) {
          this.stream.write(s2.substr(0, this.getWidth()));
        } else {
          this.stream.write(s2);
        }
      }
      // control line wrapping
      lineWrapping(enabled) {
        if (!this.stream.isTTY) {
          return;
        }
        this.linewrap = enabled;
        if (enabled) {
          this.stream.write("\x1B[?7h");
        } else {
          this.stream.write("\x1B[?7l");
        }
      }
      // tty environment ?
      isTTY() {
        return this.stream.isTTY === true;
      }
      // get terminal width
      getWidth() {
        return this.stream.columns || (this.stream.isTTY ? 80 : 200);
      }
    };
    module.exports = Terminal;
  }
});

// ../../../node_modules/.pnpm/ansi-regex@5.0.1/node_modules/ansi-regex/index.js
var require_ansi_regex = __commonJS({
  "../../../node_modules/.pnpm/ansi-regex@5.0.1/node_modules/ansi-regex/index.js"(exports, module) {
    "use strict";
    init_define_ENV_DEFINED_IN_BUILD_STEP();
    module.exports = ({ onlyFirst = false } = {}) => {
      const pattern = [
        "[\\u001B\\u009B][[\\]()#;?]*(?:(?:(?:(?:;[-a-zA-Z\\d\\/#&.:=?%@~_]+)*|[a-zA-Z\\d]+(?:;[-a-zA-Z\\d\\/#&.:=?%@~_]*)*)?\\u0007)",
        "(?:(?:\\d{1,4}(?:;\\d{0,4})*)?[\\dA-PR-TZcf-ntqry=><~]))"
      ].join("|");
      return new RegExp(pattern, onlyFirst ? void 0 : "g");
    };
  }
});

// ../../../node_modules/.pnpm/strip-ansi@6.0.1/node_modules/strip-ansi/index.js
var require_strip_ansi = __commonJS({
  "../../../node_modules/.pnpm/strip-ansi@6.0.1/node_modules/strip-ansi/index.js"(exports, module) {
    "use strict";
    init_define_ENV_DEFINED_IN_BUILD_STEP();
    var ansiRegex3 = require_ansi_regex();
    module.exports = (string) => typeof string === "string" ? string.replace(ansiRegex3(), "") : string;
  }
});

// ../../../node_modules/.pnpm/is-fullwidth-code-point@3.0.0/node_modules/is-fullwidth-code-point/index.js
var require_is_fullwidth_code_point = __commonJS({
  "../../../node_modules/.pnpm/is-fullwidth-code-point@3.0.0/node_modules/is-fullwidth-code-point/index.js"(exports, module) {
    "use strict";
    init_define_ENV_DEFINED_IN_BUILD_STEP();
    var isFullwidthCodePoint = (codePoint) => {
      if (Number.isNaN(codePoint)) {
        return false;
      }
      if (codePoint >= 4352 && (codePoint <= 4447 || // Hangul Jamo
      codePoint === 9001 || // LEFT-POINTING ANGLE BRACKET
      codePoint === 9002 || // RIGHT-POINTING ANGLE BRACKET
      // CJK Radicals Supplement .. Enclosed CJK Letters and Months
      11904 <= codePoint && codePoint <= 12871 && codePoint !== 12351 || // Enclosed CJK Letters and Months .. CJK Unified Ideographs Extension A
      12880 <= codePoint && codePoint <= 19903 || // CJK Unified Ideographs .. Yi Radicals
      19968 <= codePoint && codePoint <= 42182 || // Hangul Jamo Extended-A
      43360 <= codePoint && codePoint <= 43388 || // Hangul Syllables
      44032 <= codePoint && codePoint <= 55203 || // CJK Compatibility Ideographs
      63744 <= codePoint && codePoint <= 64255 || // Vertical Forms
      65040 <= codePoint && codePoint <= 65049 || // CJK Compatibility Forms .. Small Form Variants
      65072 <= codePoint && codePoint <= 65131 || // Halfwidth and Fullwidth Forms
      65281 <= codePoint && codePoint <= 65376 || 65504 <= codePoint && codePoint <= 65510 || // Kana Supplement
      110592 <= codePoint && codePoint <= 110593 || // Enclosed Ideographic Supplement
      127488 <= codePoint && codePoint <= 127569 || // CJK Unified Ideographs Extension B .. Tertiary Ideographic Plane
      131072 <= codePoint && codePoint <= 262141)) {
        return true;
      }
      return false;
    };
    module.exports = isFullwidthCodePoint;
    module.exports.default = isFullwidthCodePoint;
  }
});

// ../../../node_modules/.pnpm/emoji-regex@8.0.0/node_modules/emoji-regex/index.js
var require_emoji_regex = __commonJS({
  "../../../node_modules/.pnpm/emoji-regex@8.0.0/node_modules/emoji-regex/index.js"(exports, module) {
    "use strict";
    init_define_ENV_DEFINED_IN_BUILD_STEP();
    module.exports = function() {
      return /\uD83C\uDFF4\uDB40\uDC67\uDB40\uDC62(?:\uDB40\uDC65\uDB40\uDC6E\uDB40\uDC67|\uDB40\uDC73\uDB40\uDC63\uDB40\uDC74|\uDB40\uDC77\uDB40\uDC6C\uDB40\uDC73)\uDB40\uDC7F|\uD83D\uDC68(?:\uD83C\uDFFC\u200D(?:\uD83E\uDD1D\u200D\uD83D\uDC68\uD83C\uDFFB|\uD83C[\uDF3E\uDF73\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFF\u200D(?:\uD83E\uDD1D\u200D\uD83D\uDC68(?:\uD83C[\uDFFB-\uDFFE])|\uD83C[\uDF3E\uDF73\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFE\u200D(?:\uD83E\uDD1D\u200D\uD83D\uDC68(?:\uD83C[\uDFFB-\uDFFD])|\uD83C[\uDF3E\uDF73\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFD\u200D(?:\uD83E\uDD1D\u200D\uD83D\uDC68(?:\uD83C[\uDFFB\uDFFC])|\uD83C[\uDF3E\uDF73\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\u200D(?:\u2764\uFE0F\u200D(?:\uD83D\uDC8B\u200D)?\uD83D\uDC68|(?:\uD83D[\uDC68\uDC69])\u200D(?:\uD83D\uDC66\u200D\uD83D\uDC66|\uD83D\uDC67\u200D(?:\uD83D[\uDC66\uDC67]))|\uD83D\uDC66\u200D\uD83D\uDC66|\uD83D\uDC67\u200D(?:\uD83D[\uDC66\uDC67])|(?:\uD83D[\uDC68\uDC69])\u200D(?:\uD83D[\uDC66\uDC67])|[\u2695\u2696\u2708]\uFE0F|\uD83D[\uDC66\uDC67]|\uD83C[\uDF3E\uDF73\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|(?:\uD83C\uDFFB\u200D[\u2695\u2696\u2708]|\uD83C\uDFFF\u200D[\u2695\u2696\u2708]|\uD83C\uDFFE\u200D[\u2695\u2696\u2708]|\uD83C\uDFFD\u200D[\u2695\u2696\u2708]|\uD83C\uDFFC\u200D[\u2695\u2696\u2708])\uFE0F|\uD83C\uDFFB\u200D(?:\uD83C[\uDF3E\uDF73\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C[\uDFFB-\uDFFF])|(?:\uD83E\uDDD1\uD83C\uDFFB\u200D\uD83E\uDD1D\u200D\uD83E\uDDD1|\uD83D\uDC69\uD83C\uDFFC\u200D\uD83E\uDD1D\u200D\uD83D\uDC69)\uD83C\uDFFB|\uD83E\uDDD1(?:\uD83C\uDFFF\u200D\uD83E\uDD1D\u200D\uD83E\uDDD1(?:\uD83C[\uDFFB-\uDFFF])|\u200D\uD83E\uDD1D\u200D\uD83E\uDDD1)|(?:\uD83E\uDDD1\uD83C\uDFFE\u200D\uD83E\uDD1D\u200D\uD83E\uDDD1|\uD83D\uDC69\uD83C\uDFFF\u200D\uD83E\uDD1D\u200D(?:\uD83D[\uDC68\uDC69]))(?:\uD83C[\uDFFB-\uDFFE])|(?:\uD83E\uDDD1\uD83C\uDFFC\u200D\uD83E\uDD1D\u200D\uD83E\uDDD1|\uD83D\uDC69\uD83C\uDFFD\u200D\uD83E\uDD1D\u200D\uD83D\uDC69)(?:\uD83C[\uDFFB\uDFFC])|\uD83D\uDC69(?:\uD83C\uDFFE\u200D(?:\uD83E\uDD1D\u200D\uD83D\uDC68(?:\uD83C[\uDFFB-\uDFFD\uDFFF])|\uD83C[\uDF3E\uDF73\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFC\u200D(?:\uD83E\uDD1D\u200D\uD83D\uDC68(?:\uD83C[\uDFFB\uDFFD-\uDFFF])|\uD83C[\uDF3E\uDF73\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFB\u200D(?:\uD83E\uDD1D\u200D\uD83D\uDC68(?:\uD83C[\uDFFC-\uDFFF])|\uD83C[\uDF3E\uDF73\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFD\u200D(?:\uD83E\uDD1D\u200D\uD83D\uDC68(?:\uD83C[\uDFFB\uDFFC\uDFFE\uDFFF])|\uD83C[\uDF3E\uDF73\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\u200D(?:\u2764\uFE0F\u200D(?:\uD83D\uDC8B\u200D(?:\uD83D[\uDC68\uDC69])|\uD83D[\uDC68\uDC69])|\uD83C[\uDF3E\uDF73\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFF\u200D(?:\uD83C[\uDF3E\uDF73\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD]))|\uD83D\uDC69\u200D\uD83D\uDC69\u200D(?:\uD83D\uDC66\u200D\uD83D\uDC66|\uD83D\uDC67\u200D(?:\uD83D[\uDC66\uDC67]))|(?:\uD83E\uDDD1\uD83C\uDFFD\u200D\uD83E\uDD1D\u200D\uD83E\uDDD1|\uD83D\uDC69\uD83C\uDFFE\u200D\uD83E\uDD1D\u200D\uD83D\uDC69)(?:\uD83C[\uDFFB-\uDFFD])|\uD83D\uDC69\u200D\uD83D\uDC66\u200D\uD83D\uDC66|\uD83D\uDC69\u200D\uD83D\uDC69\u200D(?:\uD83D[\uDC66\uDC67])|(?:\uD83D\uDC41\uFE0F\u200D\uD83D\uDDE8|\uD83D\uDC69(?:\uD83C\uDFFF\u200D[\u2695\u2696\u2708]|\uD83C\uDFFE\u200D[\u2695\u2696\u2708]|\uD83C\uDFFC\u200D[\u2695\u2696\u2708]|\uD83C\uDFFB\u200D[\u2695\u2696\u2708]|\uD83C\uDFFD\u200D[\u2695\u2696\u2708]|\u200D[\u2695\u2696\u2708])|(?:(?:\u26F9|\uD83C[\uDFCB\uDFCC]|\uD83D\uDD75)\uFE0F|\uD83D\uDC6F|\uD83E[\uDD3C\uDDDE\uDDDF])\u200D[\u2640\u2642]|(?:\u26F9|\uD83C[\uDFCB\uDFCC]|\uD83D\uDD75)(?:\uD83C[\uDFFB-\uDFFF])\u200D[\u2640\u2642]|(?:\uD83C[\uDFC3\uDFC4\uDFCA]|\uD83D[\uDC6E\uDC71\uDC73\uDC77\uDC81\uDC82\uDC86\uDC87\uDE45-\uDE47\uDE4B\uDE4D\uDE4E\uDEA3\uDEB4-\uDEB6]|\uD83E[\uDD26\uDD37-\uDD39\uDD3D\uDD3E\uDDB8\uDDB9\uDDCD-\uDDCF\uDDD6-\uDDDD])(?:(?:\uD83C[\uDFFB-\uDFFF])\u200D[\u2640\u2642]|\u200D[\u2640\u2642])|\uD83C\uDFF4\u200D\u2620)\uFE0F|\uD83D\uDC69\u200D\uD83D\uDC67\u200D(?:\uD83D[\uDC66\uDC67])|\uD83C\uDFF3\uFE0F\u200D\uD83C\uDF08|\uD83D\uDC15\u200D\uD83E\uDDBA|\uD83D\uDC69\u200D\uD83D\uDC66|\uD83D\uDC69\u200D\uD83D\uDC67|\uD83C\uDDFD\uD83C\uDDF0|\uD83C\uDDF4\uD83C\uDDF2|\uD83C\uDDF6\uD83C\uDDE6|[#\*0-9]\uFE0F\u20E3|\uD83C\uDDE7(?:\uD83C[\uDDE6\uDDE7\uDDE9-\uDDEF\uDDF1-\uDDF4\uDDF6-\uDDF9\uDDFB\uDDFC\uDDFE\uDDFF])|\uD83C\uDDF9(?:\uD83C[\uDDE6\uDDE8\uDDE9\uDDEB-\uDDED\uDDEF-\uDDF4\uDDF7\uDDF9\uDDFB\uDDFC\uDDFF])|\uD83C\uDDEA(?:\uD83C[\uDDE6\uDDE8\uDDEA\uDDEC\uDDED\uDDF7-\uDDFA])|\uD83E\uDDD1(?:\uD83C[\uDFFB-\uDFFF])|\uD83C\uDDF7(?:\uD83C[\uDDEA\uDDF4\uDDF8\uDDFA\uDDFC])|\uD83D\uDC69(?:\uD83C[\uDFFB-\uDFFF])|\uD83C\uDDF2(?:\uD83C[\uDDE6\uDDE8-\uDDED\uDDF0-\uDDFF])|\uD83C\uDDE6(?:\uD83C[\uDDE8-\uDDEC\uDDEE\uDDF1\uDDF2\uDDF4\uDDF6-\uDDFA\uDDFC\uDDFD\uDDFF])|\uD83C\uDDF0(?:\uD83C[\uDDEA\uDDEC-\uDDEE\uDDF2\uDDF3\uDDF5\uDDF7\uDDFC\uDDFE\uDDFF])|\uD83C\uDDED(?:\uD83C[\uDDF0\uDDF2\uDDF3\uDDF7\uDDF9\uDDFA])|\uD83C\uDDE9(?:\uD83C[\uDDEA\uDDEC\uDDEF\uDDF0\uDDF2\uDDF4\uDDFF])|\uD83C\uDDFE(?:\uD83C[\uDDEA\uDDF9])|\uD83C\uDDEC(?:\uD83C[\uDDE6\uDDE7\uDDE9-\uDDEE\uDDF1-\uDDF3\uDDF5-\uDDFA\uDDFC\uDDFE])|\uD83C\uDDF8(?:\uD83C[\uDDE6-\uDDEA\uDDEC-\uDDF4\uDDF7-\uDDF9\uDDFB\uDDFD-\uDDFF])|\uD83C\uDDEB(?:\uD83C[\uDDEE-\uDDF0\uDDF2\uDDF4\uDDF7])|\uD83C\uDDF5(?:\uD83C[\uDDE6\uDDEA-\uDDED\uDDF0-\uDDF3\uDDF7-\uDDF9\uDDFC\uDDFE])|\uD83C\uDDFB(?:\uD83C[\uDDE6\uDDE8\uDDEA\uDDEC\uDDEE\uDDF3\uDDFA])|\uD83C\uDDF3(?:\uD83C[\uDDE6\uDDE8\uDDEA-\uDDEC\uDDEE\uDDF1\uDDF4\uDDF5\uDDF7\uDDFA\uDDFF])|\uD83C\uDDE8(?:\uD83C[\uDDE6\uDDE8\uDDE9\uDDEB-\uDDEE\uDDF0-\uDDF5\uDDF7\uDDFA-\uDDFF])|\uD83C\uDDF1(?:\uD83C[\uDDE6-\uDDE8\uDDEE\uDDF0\uDDF7-\uDDFB\uDDFE])|\uD83C\uDDFF(?:\uD83C[\uDDE6\uDDF2\uDDFC])|\uD83C\uDDFC(?:\uD83C[\uDDEB\uDDF8])|\uD83C\uDDFA(?:\uD83C[\uDDE6\uDDEC\uDDF2\uDDF3\uDDF8\uDDFE\uDDFF])|\uD83C\uDDEE(?:\uD83C[\uDDE8-\uDDEA\uDDF1-\uDDF4\uDDF6-\uDDF9])|\uD83C\uDDEF(?:\uD83C[\uDDEA\uDDF2\uDDF4\uDDF5])|(?:\uD83C[\uDFC3\uDFC4\uDFCA]|\uD83D[\uDC6E\uDC71\uDC73\uDC77\uDC81\uDC82\uDC86\uDC87\uDE45-\uDE47\uDE4B\uDE4D\uDE4E\uDEA3\uDEB4-\uDEB6]|\uD83E[\uDD26\uDD37-\uDD39\uDD3D\uDD3E\uDDB8\uDDB9\uDDCD-\uDDCF\uDDD6-\uDDDD])(?:\uD83C[\uDFFB-\uDFFF])|(?:\u26F9|\uD83C[\uDFCB\uDFCC]|\uD83D\uDD75)(?:\uD83C[\uDFFB-\uDFFF])|(?:[\u261D\u270A-\u270D]|\uD83C[\uDF85\uDFC2\uDFC7]|\uD83D[\uDC42\uDC43\uDC46-\uDC50\uDC66\uDC67\uDC6B-\uDC6D\uDC70\uDC72\uDC74-\uDC76\uDC78\uDC7C\uDC83\uDC85\uDCAA\uDD74\uDD7A\uDD90\uDD95\uDD96\uDE4C\uDE4F\uDEC0\uDECC]|\uD83E[\uDD0F\uDD18-\uDD1C\uDD1E\uDD1F\uDD30-\uDD36\uDDB5\uDDB6\uDDBB\uDDD2-\uDDD5])(?:\uD83C[\uDFFB-\uDFFF])|(?:[\u231A\u231B\u23E9-\u23EC\u23F0\u23F3\u25FD\u25FE\u2614\u2615\u2648-\u2653\u267F\u2693\u26A1\u26AA\u26AB\u26BD\u26BE\u26C4\u26C5\u26CE\u26D4\u26EA\u26F2\u26F3\u26F5\u26FA\u26FD\u2705\u270A\u270B\u2728\u274C\u274E\u2753-\u2755\u2757\u2795-\u2797\u27B0\u27BF\u2B1B\u2B1C\u2B50\u2B55]|\uD83C[\uDC04\uDCCF\uDD8E\uDD91-\uDD9A\uDDE6-\uDDFF\uDE01\uDE1A\uDE2F\uDE32-\uDE36\uDE38-\uDE3A\uDE50\uDE51\uDF00-\uDF20\uDF2D-\uDF35\uDF37-\uDF7C\uDF7E-\uDF93\uDFA0-\uDFCA\uDFCF-\uDFD3\uDFE0-\uDFF0\uDFF4\uDFF8-\uDFFF]|\uD83D[\uDC00-\uDC3E\uDC40\uDC42-\uDCFC\uDCFF-\uDD3D\uDD4B-\uDD4E\uDD50-\uDD67\uDD7A\uDD95\uDD96\uDDA4\uDDFB-\uDE4F\uDE80-\uDEC5\uDECC\uDED0-\uDED2\uDED5\uDEEB\uDEEC\uDEF4-\uDEFA\uDFE0-\uDFEB]|\uD83E[\uDD0D-\uDD3A\uDD3C-\uDD45\uDD47-\uDD71\uDD73-\uDD76\uDD7A-\uDDA2\uDDA5-\uDDAA\uDDAE-\uDDCA\uDDCD-\uDDFF\uDE70-\uDE73\uDE78-\uDE7A\uDE80-\uDE82\uDE90-\uDE95])|(?:[#\*0-9\xA9\xAE\u203C\u2049\u2122\u2139\u2194-\u2199\u21A9\u21AA\u231A\u231B\u2328\u23CF\u23E9-\u23F3\u23F8-\u23FA\u24C2\u25AA\u25AB\u25B6\u25C0\u25FB-\u25FE\u2600-\u2604\u260E\u2611\u2614\u2615\u2618\u261D\u2620\u2622\u2623\u2626\u262A\u262E\u262F\u2638-\u263A\u2640\u2642\u2648-\u2653\u265F\u2660\u2663\u2665\u2666\u2668\u267B\u267E\u267F\u2692-\u2697\u2699\u269B\u269C\u26A0\u26A1\u26AA\u26AB\u26B0\u26B1\u26BD\u26BE\u26C4\u26C5\u26C8\u26CE\u26CF\u26D1\u26D3\u26D4\u26E9\u26EA\u26F0-\u26F5\u26F7-\u26FA\u26FD\u2702\u2705\u2708-\u270D\u270F\u2712\u2714\u2716\u271D\u2721\u2728\u2733\u2734\u2744\u2747\u274C\u274E\u2753-\u2755\u2757\u2763\u2764\u2795-\u2797\u27A1\u27B0\u27BF\u2934\u2935\u2B05-\u2B07\u2B1B\u2B1C\u2B50\u2B55\u3030\u303D\u3297\u3299]|\uD83C[\uDC04\uDCCF\uDD70\uDD71\uDD7E\uDD7F\uDD8E\uDD91-\uDD9A\uDDE6-\uDDFF\uDE01\uDE02\uDE1A\uDE2F\uDE32-\uDE3A\uDE50\uDE51\uDF00-\uDF21\uDF24-\uDF93\uDF96\uDF97\uDF99-\uDF9B\uDF9E-\uDFF0\uDFF3-\uDFF5\uDFF7-\uDFFF]|\uD83D[\uDC00-\uDCFD\uDCFF-\uDD3D\uDD49-\uDD4E\uDD50-\uDD67\uDD6F\uDD70\uDD73-\uDD7A\uDD87\uDD8A-\uDD8D\uDD90\uDD95\uDD96\uDDA4\uDDA5\uDDA8\uDDB1\uDDB2\uDDBC\uDDC2-\uDDC4\uDDD1-\uDDD3\uDDDC-\uDDDE\uDDE1\uDDE3\uDDE8\uDDEF\uDDF3\uDDFA-\uDE4F\uDE80-\uDEC5\uDECB-\uDED2\uDED5\uDEE0-\uDEE5\uDEE9\uDEEB\uDEEC\uDEF0\uDEF3-\uDEFA\uDFE0-\uDFEB]|\uD83E[\uDD0D-\uDD3A\uDD3C-\uDD45\uDD47-\uDD71\uDD73-\uDD76\uDD7A-\uDDA2\uDDA5-\uDDAA\uDDAE-\uDDCA\uDDCD-\uDDFF\uDE70-\uDE73\uDE78-\uDE7A\uDE80-\uDE82\uDE90-\uDE95])\uFE0F|(?:[\u261D\u26F9\u270A-\u270D]|\uD83C[\uDF85\uDFC2-\uDFC4\uDFC7\uDFCA-\uDFCC]|\uD83D[\uDC42\uDC43\uDC46-\uDC50\uDC66-\uDC78\uDC7C\uDC81-\uDC83\uDC85-\uDC87\uDC8F\uDC91\uDCAA\uDD74\uDD75\uDD7A\uDD90\uDD95\uDD96\uDE45-\uDE47\uDE4B-\uDE4F\uDEA3\uDEB4-\uDEB6\uDEC0\uDECC]|\uD83E[\uDD0F\uDD18-\uDD1F\uDD26\uDD30-\uDD39\uDD3C-\uDD3E\uDDB5\uDDB6\uDDB8\uDDB9\uDDBB\uDDCD-\uDDCF\uDDD1-\uDDDD])/g;
    };
  }
});

// ../../../node_modules/.pnpm/string-width@4.2.3/node_modules/string-width/index.js
var require_string_width = __commonJS({
  "../../../node_modules/.pnpm/string-width@4.2.3/node_modules/string-width/index.js"(exports, module) {
    "use strict";
    init_define_ENV_DEFINED_IN_BUILD_STEP();
    var stripAnsi3 = require_strip_ansi();
    var isFullwidthCodePoint = require_is_fullwidth_code_point();
    var emojiRegex2 = require_emoji_regex();
    var stringWidth2 = (string) => {
      if (typeof string !== "string" || string.length === 0) {
        return 0;
      }
      string = stripAnsi3(string);
      if (string.length === 0) {
        return 0;
      }
      string = string.replace(emojiRegex2(), "  ");
      let width = 0;
      for (let i2 = 0; i2 < string.length; i2++) {
        const code = string.codePointAt(i2);
        if (code <= 31 || code >= 127 && code <= 159) {
          continue;
        }
        if (code >= 768 && code <= 879) {
          continue;
        }
        if (code > 65535) {
          i2++;
        }
        width += isFullwidthCodePoint(code) ? 2 : 1;
      }
      return width;
    };
    module.exports = stringWidth2;
    module.exports.default = stringWidth2;
  }
});

// ../../../node_modules/.pnpm/cli-progress@3.12.0/node_modules/cli-progress/lib/format-value.js
var require_format_value = __commonJS({
  "../../../node_modules/.pnpm/cli-progress@3.12.0/node_modules/cli-progress/lib/format-value.js"(exports, module) {
    init_define_ENV_DEFINED_IN_BUILD_STEP();
    module.exports = function formatValue(v3, options, type) {
      if (options.autopadding !== true) {
        return v3;
      }
      function autopadding(value, length) {
        return (options.autopaddingChar + value).slice(-length);
      }
      switch (type) {
        case "percentage":
          return autopadding(v3, 3);
        default:
          return v3;
      }
    };
  }
});

// ../../../node_modules/.pnpm/cli-progress@3.12.0/node_modules/cli-progress/lib/format-bar.js
var require_format_bar = __commonJS({
  "../../../node_modules/.pnpm/cli-progress@3.12.0/node_modules/cli-progress/lib/format-bar.js"(exports, module) {
    init_define_ENV_DEFINED_IN_BUILD_STEP();
    module.exports = function formatBar(progress, options) {
      const completeSize = Math.round(progress * options.barsize);
      const incompleteSize = options.barsize - completeSize;
      return options.barCompleteString.substr(0, completeSize) + options.barGlue + options.barIncompleteString.substr(0, incompleteSize);
    };
  }
});

// ../../../node_modules/.pnpm/cli-progress@3.12.0/node_modules/cli-progress/lib/format-time.js
var require_format_time = __commonJS({
  "../../../node_modules/.pnpm/cli-progress@3.12.0/node_modules/cli-progress/lib/format-time.js"(exports, module) {
    init_define_ENV_DEFINED_IN_BUILD_STEP();
    module.exports = function formatTime(t2, options, roundToMultipleOf) {
      function round(input) {
        if (roundToMultipleOf) {
          return roundToMultipleOf * Math.round(input / roundToMultipleOf);
        } else {
          return input;
        }
      }
      function autopadding(v3) {
        return (options.autopaddingChar + v3).slice(-2);
      }
      if (t2 > 3600) {
        return autopadding(Math.floor(t2 / 3600)) + "h" + autopadding(round(t2 % 3600 / 60)) + "m";
      } else if (t2 > 60) {
        return autopadding(Math.floor(t2 / 60)) + "m" + autopadding(round(t2 % 60)) + "s";
      } else if (t2 > 10) {
        return autopadding(round(t2)) + "s";
      } else {
        return autopadding(t2) + "s";
      }
    };
  }
});

// ../../../node_modules/.pnpm/cli-progress@3.12.0/node_modules/cli-progress/lib/formatter.js
var require_formatter = __commonJS({
  "../../../node_modules/.pnpm/cli-progress@3.12.0/node_modules/cli-progress/lib/formatter.js"(exports, module) {
    init_define_ENV_DEFINED_IN_BUILD_STEP();
    var _stringWidth = require_string_width();
    var _defaultFormatValue = require_format_value();
    var _defaultFormatBar = require_format_bar();
    var _defaultFormatTime = require_format_time();
    module.exports = function defaultFormatter(options, params, payload) {
      let s2 = options.format;
      const formatTime = options.formatTime || _defaultFormatTime;
      const formatValue = options.formatValue || _defaultFormatValue;
      const formatBar = options.formatBar || _defaultFormatBar;
      const percentage = Math.floor(params.progress * 100) + "";
      const stopTime = params.stopTime || Date.now();
      const elapsedTime = Math.round((stopTime - params.startTime) / 1e3);
      const context2 = Object.assign({}, payload, {
        bar: formatBar(params.progress, options),
        percentage: formatValue(percentage, options, "percentage"),
        total: formatValue(params.total, options, "total"),
        value: formatValue(params.value, options, "value"),
        eta: formatValue(params.eta, options, "eta"),
        eta_formatted: formatTime(params.eta, options, 5),
        duration: formatValue(elapsedTime, options, "duration"),
        duration_formatted: formatTime(elapsedTime, options, 1)
      });
      s2 = s2.replace(/\{(\w+)\}/g, function(match, key) {
        if (typeof context2[key] !== "undefined") {
          return context2[key];
        }
        return match;
      });
      const fullMargin = Math.max(0, params.maxWidth - _stringWidth(s2) - 2);
      const halfMargin = Math.floor(fullMargin / 2);
      switch (options.align) {
        case "right":
          s2 = fullMargin > 0 ? " ".repeat(fullMargin) + s2 : s2;
          break;
        case "center":
          s2 = halfMargin > 0 ? " ".repeat(halfMargin) + s2 : s2;
          break;
        case "left":
        default:
          break;
      }
      return s2;
    };
  }
});

// ../../../node_modules/.pnpm/cli-progress@3.12.0/node_modules/cli-progress/lib/options.js
var require_options = __commonJS({
  "../../../node_modules/.pnpm/cli-progress@3.12.0/node_modules/cli-progress/lib/options.js"(exports, module) {
    init_define_ENV_DEFINED_IN_BUILD_STEP();
    function mergeOption(v3, defaultValue) {
      if (typeof v3 === "undefined" || v3 === null) {
        return defaultValue;
      } else {
        return v3;
      }
    }
    module.exports = {
      // set global options
      parse: function parse2(rawOptions, preset) {
        const options = {};
        const opt = Object.assign({}, preset, rawOptions);
        options.throttleTime = 1e3 / mergeOption(opt.fps, 10);
        options.stream = mergeOption(opt.stream, process.stderr);
        options.terminal = mergeOption(opt.terminal, null);
        options.clearOnComplete = mergeOption(opt.clearOnComplete, false);
        options.stopOnComplete = mergeOption(opt.stopOnComplete, false);
        options.barsize = mergeOption(opt.barsize, 40);
        options.align = mergeOption(opt.align, "left");
        options.hideCursor = mergeOption(opt.hideCursor, false);
        options.linewrap = mergeOption(opt.linewrap, false);
        options.barGlue = mergeOption(opt.barGlue, "");
        options.barCompleteChar = mergeOption(opt.barCompleteChar, "=");
        options.barIncompleteChar = mergeOption(opt.barIncompleteChar, "-");
        options.format = mergeOption(opt.format, "progress [{bar}] {percentage}% | ETA: {eta}s | {value}/{total}");
        options.formatTime = mergeOption(opt.formatTime, null);
        options.formatValue = mergeOption(opt.formatValue, null);
        options.formatBar = mergeOption(opt.formatBar, null);
        options.etaBufferLength = mergeOption(opt.etaBuffer, 10);
        options.etaAsynchronousUpdate = mergeOption(opt.etaAsynchronousUpdate, false);
        options.progressCalculationRelative = mergeOption(opt.progressCalculationRelative, false);
        options.synchronousUpdate = mergeOption(opt.synchronousUpdate, true);
        options.noTTYOutput = mergeOption(opt.noTTYOutput, false);
        options.notTTYSchedule = mergeOption(opt.notTTYSchedule, 2e3);
        options.emptyOnZero = mergeOption(opt.emptyOnZero, false);
        options.forceRedraw = mergeOption(opt.forceRedraw, false);
        options.autopadding = mergeOption(opt.autopadding, false);
        options.gracefulExit = mergeOption(opt.gracefulExit, false);
        return options;
      },
      // derived options: instance specific, has to be created for every bar element
      assignDerivedOptions: function assignDerivedOptions(options) {
        options.barCompleteString = options.barCompleteChar.repeat(options.barsize + 1);
        options.barIncompleteString = options.barIncompleteChar.repeat(options.barsize + 1);
        options.autopaddingChar = options.autopadding ? mergeOption(options.autopaddingChar, "   ") : "";
        return options;
      }
    };
  }
});

// ../../../node_modules/.pnpm/cli-progress@3.12.0/node_modules/cli-progress/lib/generic-bar.js
var require_generic_bar = __commonJS({
  "../../../node_modules/.pnpm/cli-progress@3.12.0/node_modules/cli-progress/lib/generic-bar.js"(exports, module) {
    init_define_ENV_DEFINED_IN_BUILD_STEP();
    var _ETA = require_eta();
    var _Terminal = require_terminal();
    var _formatter = require_formatter();
    var _options = require_options();
    var _EventEmitter = __require("events");
    module.exports = class GenericBar extends _EventEmitter {
      constructor(options) {
        super();
        this.options = _options.assignDerivedOptions(options);
        this.terminal = this.options.terminal ? this.options.terminal : new _Terminal(this.options.stream);
        this.value = 0;
        this.startValue = 0;
        this.total = 100;
        this.lastDrawnString = null;
        this.startTime = null;
        this.stopTime = null;
        this.lastRedraw = Date.now();
        this.eta = new _ETA(this.options.etaBufferLength, 0, 0);
        this.payload = {};
        this.isActive = false;
        this.formatter = typeof this.options.format === "function" ? this.options.format : _formatter;
      }
      // internal render function
      render(forceRendering = false) {
        const params = {
          progress: this.getProgress(),
          eta: this.eta.getTime(),
          startTime: this.startTime,
          stopTime: this.stopTime,
          total: this.total,
          value: this.value,
          maxWidth: this.terminal.getWidth()
        };
        if (this.options.etaAsynchronousUpdate) {
          this.updateETA();
        }
        const s2 = this.formatter(this.options, params, this.payload);
        const forceRedraw = forceRendering || this.options.forceRedraw || this.options.noTTYOutput && !this.terminal.isTTY();
        if (forceRedraw || this.lastDrawnString != s2) {
          this.emit("redraw-pre");
          this.terminal.cursorTo(0, null);
          this.terminal.write(s2);
          this.terminal.clearRight();
          this.lastDrawnString = s2;
          this.lastRedraw = Date.now();
          this.emit("redraw-post");
        }
      }
      // start the progress bar
      start(total, startValue, payload) {
        this.value = startValue || 0;
        this.total = typeof total !== "undefined" && total >= 0 ? total : 100;
        this.startValue = startValue || 0;
        this.payload = payload || {};
        this.startTime = Date.now();
        this.stopTime = null;
        this.lastDrawnString = "";
        this.eta = new _ETA(this.options.etaBufferLength, this.startTime, this.value);
        this.isActive = true;
        this.emit("start", total, startValue);
      }
      // stop the bar
      stop() {
        this.isActive = false;
        this.stopTime = Date.now();
        this.emit("stop", this.total, this.value);
      }
      // update the bar value
      // update(value, payload)
      // update(payload)
      update(arg0, arg1 = {}) {
        if (typeof arg0 === "number") {
          this.value = arg0;
          this.eta.update(Date.now(), arg0, this.total);
        }
        const payloadData = (typeof arg0 === "object" ? arg0 : arg1) || {};
        this.emit("update", this.total, this.value);
        for (const key in payloadData) {
          this.payload[key] = payloadData[key];
        }
        if (this.value >= this.getTotal() && this.options.stopOnComplete) {
          this.stop();
        }
      }
      // calculate the actual progress value
      getProgress() {
        let progress = this.value / this.total;
        if (this.options.progressCalculationRelative) {
          progress = (this.value - this.startValue) / (this.total - this.startValue);
        }
        if (isNaN(progress)) {
          progress = this.options && this.options.emptyOnZero ? 0 : 1;
        }
        progress = Math.min(Math.max(progress, 0), 1);
        return progress;
      }
      // update the bar value
      // increment(delta, payload)
      // increment(payload)
      increment(arg0 = 1, arg1 = {}) {
        if (typeof arg0 === "object") {
          this.update(this.value + 1, arg0);
        } else {
          this.update(this.value + arg0, arg1);
        }
      }
      // get the total (limit) value
      getTotal() {
        return this.total;
      }
      // set the total (limit) value
      setTotal(total) {
        if (typeof total !== "undefined" && total >= 0) {
          this.total = total;
        }
      }
      // force eta calculation update (long running processes)
      updateETA() {
        this.eta.update(Date.now(), this.value, this.total);
      }
    };
  }
});

// ../../../node_modules/.pnpm/cli-progress@3.12.0/node_modules/cli-progress/lib/single-bar.js
var require_single_bar = __commonJS({
  "../../../node_modules/.pnpm/cli-progress@3.12.0/node_modules/cli-progress/lib/single-bar.js"(exports, module) {
    init_define_ENV_DEFINED_IN_BUILD_STEP();
    var _GenericBar = require_generic_bar();
    var _options = require_options();
    module.exports = class SingleBar extends _GenericBar {
      constructor(options, preset) {
        super(_options.parse(options, preset));
        this.timer = null;
        if (this.options.noTTYOutput && this.terminal.isTTY() === false) {
          this.options.synchronousUpdate = false;
        }
        this.schedulingRate = this.terminal.isTTY() ? this.options.throttleTime : this.options.notTTYSchedule;
        this.sigintCallback = null;
      }
      // internal render function
      render() {
        if (this.timer) {
          clearTimeout(this.timer);
          this.timer = null;
        }
        super.render();
        if (this.options.noTTYOutput && this.terminal.isTTY() === false) {
          this.terminal.newline();
        }
        this.timer = setTimeout(this.render.bind(this), this.schedulingRate);
      }
      update(current, payload) {
        if (!this.timer) {
          return;
        }
        super.update(current, payload);
        if (this.options.synchronousUpdate && this.lastRedraw + this.options.throttleTime * 2 < Date.now()) {
          this.render();
        }
      }
      // start the progress bar
      start(total, startValue, payload) {
        if (this.options.noTTYOutput === false && this.terminal.isTTY() === false) {
          return;
        }
        if (this.sigintCallback === null && this.options.gracefulExit) {
          this.sigintCallback = this.stop.bind(this);
          process.once("SIGINT", this.sigintCallback);
          process.once("SIGTERM", this.sigintCallback);
        }
        this.terminal.cursorSave();
        if (this.options.hideCursor === true) {
          this.terminal.cursor(false);
        }
        if (this.options.linewrap === false) {
          this.terminal.lineWrapping(false);
        }
        super.start(total, startValue, payload);
        this.render();
      }
      // stop the bar
      stop() {
        if (!this.timer) {
          return;
        }
        if (this.sigintCallback) {
          process.removeListener("SIGINT", this.sigintCallback);
          process.removeListener("SIGTERM", this.sigintCallback);
          this.sigintCallback = null;
        }
        this.render();
        super.stop();
        clearTimeout(this.timer);
        this.timer = null;
        if (this.options.hideCursor === true) {
          this.terminal.cursor(true);
        }
        if (this.options.linewrap === false) {
          this.terminal.lineWrapping(true);
        }
        this.terminal.cursorRestore();
        if (this.options.clearOnComplete) {
          this.terminal.cursorTo(0, null);
          this.terminal.clearLine();
        } else {
          this.terminal.newline();
        }
      }
    };
  }
});

// ../../../node_modules/.pnpm/cli-progress@3.12.0/node_modules/cli-progress/lib/multi-bar.js
var require_multi_bar = __commonJS({
  "../../../node_modules/.pnpm/cli-progress@3.12.0/node_modules/cli-progress/lib/multi-bar.js"(exports, module) {
    init_define_ENV_DEFINED_IN_BUILD_STEP();
    var _Terminal = require_terminal();
    var _BarElement = require_generic_bar();
    var _options = require_options();
    var _EventEmitter = __require("events");
    module.exports = class MultiBar extends _EventEmitter {
      constructor(options, preset) {
        super();
        this.bars = [];
        this.options = _options.parse(options, preset);
        this.options.synchronousUpdate = false;
        this.terminal = this.options.terminal ? this.options.terminal : new _Terminal(this.options.stream);
        this.timer = null;
        this.isActive = false;
        this.schedulingRate = this.terminal.isTTY() ? this.options.throttleTime : this.options.notTTYSchedule;
        this.loggingBuffer = [];
        this.sigintCallback = null;
      }
      // add a new bar to the stack
      create(total, startValue, payload, barOptions = {}) {
        const bar = new _BarElement(Object.assign(
          {},
          // global options
          this.options,
          // terminal instance
          {
            terminal: this.terminal
          },
          // overrides
          barOptions
        ));
        this.bars.push(bar);
        if (this.options.noTTYOutput === false && this.terminal.isTTY() === false) {
          return bar;
        }
        if (this.sigintCallback === null && this.options.gracefulExit) {
          this.sigintCallback = this.stop.bind(this);
          process.once("SIGINT", this.sigintCallback);
          process.once("SIGTERM", this.sigintCallback);
        }
        if (!this.isActive) {
          if (this.options.hideCursor === true) {
            this.terminal.cursor(false);
          }
          if (this.options.linewrap === false) {
            this.terminal.lineWrapping(false);
          }
          this.timer = setTimeout(this.update.bind(this), this.schedulingRate);
        }
        this.isActive = true;
        bar.start(total, startValue, payload);
        this.emit("start");
        return bar;
      }
      // remove a bar from the stack
      remove(bar) {
        const index = this.bars.indexOf(bar);
        if (index < 0) {
          return false;
        }
        this.bars.splice(index, 1);
        this.update();
        this.terminal.newline();
        this.terminal.clearBottom();
        return true;
      }
      // internal update routine
      update() {
        if (this.timer) {
          clearTimeout(this.timer);
          this.timer = null;
        }
        this.emit("update-pre");
        this.terminal.cursorRelativeReset();
        this.emit("redraw-pre");
        if (this.loggingBuffer.length > 0) {
          this.terminal.clearLine();
          while (this.loggingBuffer.length > 0) {
            this.terminal.write(this.loggingBuffer.shift(), true);
          }
        }
        for (let i2 = 0; i2 < this.bars.length; i2++) {
          if (i2 > 0) {
            this.terminal.newline();
          }
          this.bars[i2].render();
        }
        this.emit("redraw-post");
        if (this.options.noTTYOutput && this.terminal.isTTY() === false) {
          this.terminal.newline();
          this.terminal.newline();
        }
        this.timer = setTimeout(this.update.bind(this), this.schedulingRate);
        this.emit("update-post");
        if (this.options.stopOnComplete && !this.bars.find((bar) => bar.isActive)) {
          this.stop();
        }
      }
      stop() {
        clearTimeout(this.timer);
        this.timer = null;
        if (this.sigintCallback) {
          process.removeListener("SIGINT", this.sigintCallback);
          process.removeListener("SIGTERM", this.sigintCallback);
          this.sigintCallback = null;
        }
        this.isActive = false;
        if (this.options.hideCursor === true) {
          this.terminal.cursor(true);
        }
        if (this.options.linewrap === false) {
          this.terminal.lineWrapping(true);
        }
        this.terminal.cursorRelativeReset();
        this.emit("stop-pre-clear");
        if (this.options.clearOnComplete) {
          this.terminal.clearBottom();
        } else {
          for (let i2 = 0; i2 < this.bars.length; i2++) {
            if (i2 > 0) {
              this.terminal.newline();
            }
            this.bars[i2].render();
            this.bars[i2].stop();
          }
          this.terminal.newline();
        }
        this.emit("stop");
      }
      log(s2) {
        this.loggingBuffer.push(s2);
      }
    };
  }
});

// ../../../node_modules/.pnpm/cli-progress@3.12.0/node_modules/cli-progress/presets/legacy.js
var require_legacy = __commonJS({
  "../../../node_modules/.pnpm/cli-progress@3.12.0/node_modules/cli-progress/presets/legacy.js"(exports, module) {
    init_define_ENV_DEFINED_IN_BUILD_STEP();
    module.exports = {
      format: "progress [{bar}] {percentage}% | ETA: {eta}s | {value}/{total}",
      barCompleteChar: "=",
      barIncompleteChar: "-"
    };
  }
});

// ../../../node_modules/.pnpm/cli-progress@3.12.0/node_modules/cli-progress/presets/shades-classic.js
var require_shades_classic = __commonJS({
  "../../../node_modules/.pnpm/cli-progress@3.12.0/node_modules/cli-progress/presets/shades-classic.js"(exports, module) {
    init_define_ENV_DEFINED_IN_BUILD_STEP();
    module.exports = {
      format: " {bar} {percentage}% | ETA: {eta}s | {value}/{total}",
      barCompleteChar: "\u2588",
      barIncompleteChar: "\u2591"
    };
  }
});

// ../../../node_modules/.pnpm/cli-progress@3.12.0/node_modules/cli-progress/presets/shades-grey.js
var require_shades_grey = __commonJS({
  "../../../node_modules/.pnpm/cli-progress@3.12.0/node_modules/cli-progress/presets/shades-grey.js"(exports, module) {
    init_define_ENV_DEFINED_IN_BUILD_STEP();
    module.exports = {
      format: " \x1B[90m{bar}\x1B[0m {percentage}% | ETA: {eta}s | {value}/{total}",
      barCompleteChar: "\u2588",
      barIncompleteChar: "\u2591"
    };
  }
});

// ../../../node_modules/.pnpm/cli-progress@3.12.0/node_modules/cli-progress/presets/rect.js
var require_rect = __commonJS({
  "../../../node_modules/.pnpm/cli-progress@3.12.0/node_modules/cli-progress/presets/rect.js"(exports, module) {
    init_define_ENV_DEFINED_IN_BUILD_STEP();
    module.exports = {
      format: " {bar}\u25A0 {percentage}% | ETA: {eta}s | {value}/{total}",
      barCompleteChar: "\u25A0",
      barIncompleteChar: " "
    };
  }
});

// ../../../node_modules/.pnpm/cli-progress@3.12.0/node_modules/cli-progress/presets/index.js
var require_presets = __commonJS({
  "../../../node_modules/.pnpm/cli-progress@3.12.0/node_modules/cli-progress/presets/index.js"(exports, module) {
    init_define_ENV_DEFINED_IN_BUILD_STEP();
    var _legacy = require_legacy();
    var _shades_classic = require_shades_classic();
    var _shades_grey = require_shades_grey();
    var _rect = require_rect();
    module.exports = {
      legacy: _legacy,
      shades_classic: _shades_classic,
      shades_grey: _shades_grey,
      rect: _rect
    };
  }
});

// ../../../node_modules/.pnpm/cli-progress@3.12.0/node_modules/cli-progress/cli-progress.js
var require_cli_progress = __commonJS({
  "../../../node_modules/.pnpm/cli-progress@3.12.0/node_modules/cli-progress/cli-progress.js"(exports, module) {
    init_define_ENV_DEFINED_IN_BUILD_STEP();
    var _SingleBar = require_single_bar();
    var _MultiBar = require_multi_bar();
    var _Presets = require_presets();
    var _Formatter = require_formatter();
    var _defaultFormatValue = require_format_value();
    var _defaultFormatBar = require_format_bar();
    var _defaultFormatTime = require_format_time();
    module.exports = {
      Bar: _SingleBar,
      SingleBar: _SingleBar,
      MultiBar: _MultiBar,
      Presets: _Presets,
      Format: {
        Formatter: _Formatter,
        BarFormat: _defaultFormatBar,
        ValueFormat: _defaultFormatValue,
        TimeFormat: _defaultFormatTime
      }
    };
  }
});

// ../../../node_modules/.pnpm/@sentry+utils@7.120.2/node_modules/@sentry/utils/cjs/is.js
var require_is = __commonJS({
  "../../../node_modules/.pnpm/@sentry+utils@7.120.2/node_modules/@sentry/utils/cjs/is.js"(exports) {
    init_define_ENV_DEFINED_IN_BUILD_STEP();
    Object.defineProperty(exports, "__esModule", { value: true });
    var objectToString = Object.prototype.toString;
    function isError(wat) {
      switch (objectToString.call(wat)) {
        case "[object Error]":
        case "[object Exception]":
        case "[object DOMException]":
          return true;
        default:
          return isInstanceOf(wat, Error);
      }
    }
    function isBuiltin(wat, className) {
      return objectToString.call(wat) === `[object ${className}]`;
    }
    function isErrorEvent(wat) {
      return isBuiltin(wat, "ErrorEvent");
    }
    function isDOMError(wat) {
      return isBuiltin(wat, "DOMError");
    }
    function isDOMException(wat) {
      return isBuiltin(wat, "DOMException");
    }
    function isString2(wat) {
      return isBuiltin(wat, "String");
    }
    function isParameterizedString(wat) {
      return typeof wat === "object" && wat !== null && "__sentry_template_string__" in wat && "__sentry_template_values__" in wat;
    }
    function isPrimitive(wat) {
      return wat === null || isParameterizedString(wat) || typeof wat !== "object" && typeof wat !== "function";
    }
    function isPlainObject3(wat) {
      return isBuiltin(wat, "Object");
    }
    function isEvent(wat) {
      return typeof Event !== "undefined" && isInstanceOf(wat, Event);
    }
    function isElement(wat) {
      return typeof Element !== "undefined" && isInstanceOf(wat, Element);
    }
    function isRegExp(wat) {
      return isBuiltin(wat, "RegExp");
    }
    function isThenable(wat) {
      return Boolean(wat && wat.then && typeof wat.then === "function");
    }
    function isSyntheticEvent(wat) {
      return isPlainObject3(wat) && "nativeEvent" in wat && "preventDefault" in wat && "stopPropagation" in wat;
    }
    function isNaN2(wat) {
      return typeof wat === "number" && wat !== wat;
    }
    function isInstanceOf(wat, base) {
      try {
        return wat instanceof base;
      } catch (_e) {
        return false;
      }
    }
    function isVueViewModel(wat) {
      return !!(typeof wat === "object" && wat !== null && (wat.__isVue || wat._isVue));
    }
    exports.isDOMError = isDOMError;
    exports.isDOMException = isDOMException;
    exports.isElement = isElement;
    exports.isError = isError;
    exports.isErrorEvent = isErrorEvent;
    exports.isEvent = isEvent;
    exports.isInstanceOf = isInstanceOf;
    exports.isNaN = isNaN2;
    exports.isParameterizedString = isParameterizedString;
    exports.isPlainObject = isPlainObject3;
    exports.isPrimitive = isPrimitive;
    exports.isRegExp = isRegExp;
    exports.isString = isString2;
    exports.isSyntheticEvent = isSyntheticEvent;
    exports.isThenable = isThenable;
    exports.isVueViewModel = isVueViewModel;
  }
});

// ../../../node_modules/.pnpm/@sentry+utils@7.120.2/node_modules/@sentry/utils/cjs/string.js
var require_string = __commonJS({
  "../../../node_modules/.pnpm/@sentry+utils@7.120.2/node_modules/@sentry/utils/cjs/string.js"(exports) {
    init_define_ENV_DEFINED_IN_BUILD_STEP();
    Object.defineProperty(exports, "__esModule", { value: true });
    var is = require_is();
    function truncate(str, max = 0) {
      if (typeof str !== "string" || max === 0) {
        return str;
      }
      return str.length <= max ? str : `${str.slice(0, max)}...`;
    }
    function snipLine(line, colno) {
      let newLine = line;
      const lineLength = newLine.length;
      if (lineLength <= 150) {
        return newLine;
      }
      if (colno > lineLength) {
        colno = lineLength;
      }
      let start = Math.max(colno - 60, 0);
      if (start < 5) {
        start = 0;
      }
      let end = Math.min(start + 140, lineLength);
      if (end > lineLength - 5) {
        end = lineLength;
      }
      if (end === lineLength) {
        start = Math.max(end - 140, 0);
      }
      newLine = newLine.slice(start, end);
      if (start > 0) {
        newLine = `'{snip} ${newLine}`;
      }
      if (end < lineLength) {
        newLine += " {snip}";
      }
      return newLine;
    }
    function safeJoin(input, delimiter) {
      if (!Array.isArray(input)) {
        return "";
      }
      const output = [];
      for (let i2 = 0; i2 < input.length; i2++) {
        const value = input[i2];
        try {
          if (is.isVueViewModel(value)) {
            output.push("[VueViewModel]");
          } else {
            output.push(String(value));
          }
        } catch (e2) {
          output.push("[value cannot be serialized]");
        }
      }
      return output.join(delimiter);
    }
    function isMatchingPattern(value, pattern, requireExactStringMatch = false) {
      if (!is.isString(value)) {
        return false;
      }
      if (is.isRegExp(pattern)) {
        return pattern.test(value);
      }
      if (is.isString(pattern)) {
        return requireExactStringMatch ? value === pattern : value.includes(pattern);
      }
      return false;
    }
    function stringMatchesSomePattern(testString, patterns = [], requireExactStringMatch = false) {
      return patterns.some((pattern) => isMatchingPattern(testString, pattern, requireExactStringMatch));
    }
    exports.isMatchingPattern = isMatchingPattern;
    exports.safeJoin = safeJoin;
    exports.snipLine = snipLine;
    exports.stringMatchesSomePattern = stringMatchesSomePattern;
    exports.truncate = truncate;
  }
});

// ../../../node_modules/.pnpm/@sentry+utils@7.120.2/node_modules/@sentry/utils/cjs/aggregate-errors.js
var require_aggregate_errors = __commonJS({
  "../../../node_modules/.pnpm/@sentry+utils@7.120.2/node_modules/@sentry/utils/cjs/aggregate-errors.js"(exports) {
    init_define_ENV_DEFINED_IN_BUILD_STEP();
    Object.defineProperty(exports, "__esModule", { value: true });
    var is = require_is();
    var string = require_string();
    function applyAggregateErrorsToEvent(exceptionFromErrorImplementation, parser, maxValueLimit = 250, key, limit, event, hint) {
      if (!event.exception || !event.exception.values || !hint || !is.isInstanceOf(hint.originalException, Error)) {
        return;
      }
      const originalException = event.exception.values.length > 0 ? event.exception.values[event.exception.values.length - 1] : void 0;
      if (originalException) {
        event.exception.values = truncateAggregateExceptions(
          aggregateExceptionsFromError(
            exceptionFromErrorImplementation,
            parser,
            limit,
            hint.originalException,
            key,
            event.exception.values,
            originalException,
            0
          ),
          maxValueLimit
        );
      }
    }
    function aggregateExceptionsFromError(exceptionFromErrorImplementation, parser, limit, error, key, prevExceptions, exception, exceptionId) {
      if (prevExceptions.length >= limit + 1) {
        return prevExceptions;
      }
      let newExceptions = [...prevExceptions];
      if (is.isInstanceOf(error[key], Error)) {
        applyExceptionGroupFieldsForParentException(exception, exceptionId);
        const newException = exceptionFromErrorImplementation(parser, error[key]);
        const newExceptionId = newExceptions.length;
        applyExceptionGroupFieldsForChildException(newException, key, newExceptionId, exceptionId);
        newExceptions = aggregateExceptionsFromError(
          exceptionFromErrorImplementation,
          parser,
          limit,
          error[key],
          key,
          [newException, ...newExceptions],
          newException,
          newExceptionId
        );
      }
      if (Array.isArray(error.errors)) {
        error.errors.forEach((childError, i2) => {
          if (is.isInstanceOf(childError, Error)) {
            applyExceptionGroupFieldsForParentException(exception, exceptionId);
            const newException = exceptionFromErrorImplementation(parser, childError);
            const newExceptionId = newExceptions.length;
            applyExceptionGroupFieldsForChildException(newException, `errors[${i2}]`, newExceptionId, exceptionId);
            newExceptions = aggregateExceptionsFromError(
              exceptionFromErrorImplementation,
              parser,
              limit,
              childError,
              key,
              [newException, ...newExceptions],
              newException,
              newExceptionId
            );
          }
        });
      }
      return newExceptions;
    }
    function applyExceptionGroupFieldsForParentException(exception, exceptionId) {
      exception.mechanism = exception.mechanism || { type: "generic", handled: true };
      exception.mechanism = {
        ...exception.mechanism,
        ...exception.type === "AggregateError" && { is_exception_group: true },
        exception_id: exceptionId
      };
    }
    function applyExceptionGroupFieldsForChildException(exception, source, exceptionId, parentId) {
      exception.mechanism = exception.mechanism || { type: "generic", handled: true };
      exception.mechanism = {
        ...exception.mechanism,
        type: "chained",
        source,
        exception_id: exceptionId,
        parent_id: parentId
      };
    }
    function truncateAggregateExceptions(exceptions, maxValueLength) {
      return exceptions.map((exception) => {
        if (exception.value) {
          exception.value = string.truncate(exception.value, maxValueLength);
        }
        return exception;
      });
    }
    exports.applyAggregateErrorsToEvent = applyAggregateErrorsToEvent;
  }
});

// ../../../node_modules/.pnpm/@sentry+utils@7.120.2/node_modules/@sentry/utils/cjs/worldwide.js
var require_worldwide = __commonJS({
  "../../../node_modules/.pnpm/@sentry+utils@7.120.2/node_modules/@sentry/utils/cjs/worldwide.js"(exports) {
    init_define_ENV_DEFINED_IN_BUILD_STEP();
    Object.defineProperty(exports, "__esModule", { value: true });
    function isGlobalObj(obj) {
      return obj && obj.Math == Math ? obj : void 0;
    }
    var GLOBAL_OBJ = typeof globalThis == "object" && isGlobalObj(globalThis) || // eslint-disable-next-line no-restricted-globals
    typeof window == "object" && isGlobalObj(window) || typeof self == "object" && isGlobalObj(self) || typeof global == "object" && isGlobalObj(global) || /* @__PURE__ */ function() {
      return this;
    }() || {};
    function getGlobalObject() {
      return GLOBAL_OBJ;
    }
    function getGlobalSingleton(name, creator, obj) {
      const gbl = obj || GLOBAL_OBJ;
      const __SENTRY__ = gbl.__SENTRY__ = gbl.__SENTRY__ || {};
      const singleton = __SENTRY__[name] || (__SENTRY__[name] = creator());
      return singleton;
    }
    exports.GLOBAL_OBJ = GLOBAL_OBJ;
    exports.getGlobalObject = getGlobalObject;
    exports.getGlobalSingleton = getGlobalSingleton;
  }
});

// ../../../node_modules/.pnpm/@sentry+utils@7.120.2/node_modules/@sentry/utils/cjs/browser.js
var require_browser = __commonJS({
  "../../../node_modules/.pnpm/@sentry+utils@7.120.2/node_modules/@sentry/utils/cjs/browser.js"(exports) {
    init_define_ENV_DEFINED_IN_BUILD_STEP();
    Object.defineProperty(exports, "__esModule", { value: true });
    var is = require_is();
    var worldwide = require_worldwide();
    var WINDOW = worldwide.getGlobalObject();
    var DEFAULT_MAX_STRING_LENGTH = 80;
    function htmlTreeAsString(elem, options = {}) {
      if (!elem) {
        return "<unknown>";
      }
      try {
        let currentElem = elem;
        const MAX_TRAVERSE_HEIGHT = 5;
        const out = [];
        let height = 0;
        let len = 0;
        const separator = " > ";
        const sepLength = separator.length;
        let nextStr;
        const keyAttrs = Array.isArray(options) ? options : options.keyAttrs;
        const maxStringLength = !Array.isArray(options) && options.maxStringLength || DEFAULT_MAX_STRING_LENGTH;
        while (currentElem && height++ < MAX_TRAVERSE_HEIGHT) {
          nextStr = _htmlElementAsString(currentElem, keyAttrs);
          if (nextStr === "html" || height > 1 && len + out.length * sepLength + nextStr.length >= maxStringLength) {
            break;
          }
          out.push(nextStr);
          len += nextStr.length;
          currentElem = currentElem.parentNode;
        }
        return out.reverse().join(separator);
      } catch (_oO) {
        return "<unknown>";
      }
    }
    function _htmlElementAsString(el, keyAttrs) {
      const elem = el;
      const out = [];
      let className;
      let classes;
      let key;
      let attr;
      let i2;
      if (!elem || !elem.tagName) {
        return "";
      }
      if (WINDOW.HTMLElement) {
        if (elem instanceof HTMLElement && elem.dataset && elem.dataset["sentryComponent"]) {
          return elem.dataset["sentryComponent"];
        }
      }
      out.push(elem.tagName.toLowerCase());
      const keyAttrPairs = keyAttrs && keyAttrs.length ? keyAttrs.filter((keyAttr) => elem.getAttribute(keyAttr)).map((keyAttr) => [keyAttr, elem.getAttribute(keyAttr)]) : null;
      if (keyAttrPairs && keyAttrPairs.length) {
        keyAttrPairs.forEach((keyAttrPair) => {
          out.push(`[${keyAttrPair[0]}="${keyAttrPair[1]}"]`);
        });
      } else {
        if (elem.id) {
          out.push(`#${elem.id}`);
        }
        className = elem.className;
        if (className && is.isString(className)) {
          classes = className.split(/\s+/);
          for (i2 = 0; i2 < classes.length; i2++) {
            out.push(`.${classes[i2]}`);
          }
        }
      }
      const allowedAttrs = ["aria-label", "type", "name", "title", "alt"];
      for (i2 = 0; i2 < allowedAttrs.length; i2++) {
        key = allowedAttrs[i2];
        attr = elem.getAttribute(key);
        if (attr) {
          out.push(`[${key}="${attr}"]`);
        }
      }
      return out.join("");
    }
    function getLocationHref() {
      try {
        return WINDOW.document.location.href;
      } catch (oO) {
        return "";
      }
    }
    function getDomElement(selector) {
      if (WINDOW.document && WINDOW.document.querySelector) {
        return WINDOW.document.querySelector(selector);
      }
      return null;
    }
    function getComponentName(elem) {
      if (!WINDOW.HTMLElement) {
        return null;
      }
      let currentElem = elem;
      const MAX_TRAVERSE_HEIGHT = 5;
      for (let i2 = 0; i2 < MAX_TRAVERSE_HEIGHT; i2++) {
        if (!currentElem) {
          return null;
        }
        if (currentElem instanceof HTMLElement && currentElem.dataset["sentryComponent"]) {
          return currentElem.dataset["sentryComponent"];
        }
        currentElem = currentElem.parentNode;
      }
      return null;
    }
    exports.getComponentName = getComponentName;
    exports.getDomElement = getDomElement;
    exports.getLocationHref = getLocationHref;
    exports.htmlTreeAsString = htmlTreeAsString;
  }
});

// ../../../node_modules/.pnpm/@sentry+utils@7.120.2/node_modules/@sentry/utils/cjs/debug-build.js
var require_debug_build = __commonJS({
  "../../../node_modules/.pnpm/@sentry+utils@7.120.2/node_modules/@sentry/utils/cjs/debug-build.js"(exports) {
    init_define_ENV_DEFINED_IN_BUILD_STEP();
    Object.defineProperty(exports, "__esModule", { value: true });
    var DEBUG_BUILD = typeof __SENTRY_DEBUG__ === "undefined" || __SENTRY_DEBUG__;
    exports.DEBUG_BUILD = DEBUG_BUILD;
  }
});

// ../../../node_modules/.pnpm/@sentry+utils@7.120.2/node_modules/@sentry/utils/cjs/logger.js
var require_logger = __commonJS({
  "../../../node_modules/.pnpm/@sentry+utils@7.120.2/node_modules/@sentry/utils/cjs/logger.js"(exports) {
    init_define_ENV_DEFINED_IN_BUILD_STEP();
    Object.defineProperty(exports, "__esModule", { value: true });
    var debugBuild = require_debug_build();
    var worldwide = require_worldwide();
    var PREFIX = "Sentry Logger ";
    var CONSOLE_LEVELS = [
      "debug",
      "info",
      "warn",
      "error",
      "log",
      "assert",
      "trace"
    ];
    var originalConsoleMethods = {};
    function consoleSandbox(callback) {
      if (!("console" in worldwide.GLOBAL_OBJ)) {
        return callback();
      }
      const console2 = worldwide.GLOBAL_OBJ.console;
      const wrappedFuncs = {};
      const wrappedLevels = Object.keys(originalConsoleMethods);
      wrappedLevels.forEach((level) => {
        const originalConsoleMethod = originalConsoleMethods[level];
        wrappedFuncs[level] = console2[level];
        console2[level] = originalConsoleMethod;
      });
      try {
        return callback();
      } finally {
        wrappedLevels.forEach((level) => {
          console2[level] = wrappedFuncs[level];
        });
      }
    }
    function makeLogger() {
      let enabled = false;
      const logger2 = {
        enable: () => {
          enabled = true;
        },
        disable: () => {
          enabled = false;
        },
        isEnabled: () => enabled
      };
      if (debugBuild.DEBUG_BUILD) {
        CONSOLE_LEVELS.forEach((name) => {
          logger2[name] = (...args) => {
            if (enabled) {
              consoleSandbox(() => {
                worldwide.GLOBAL_OBJ.console[name](`${PREFIX}[${name}]:`, ...args);
              });
            }
          };
        });
      } else {
        CONSOLE_LEVELS.forEach((name) => {
          logger2[name] = () => void 0;
        });
      }
      return logger2;
    }
    var logger = makeLogger();
    exports.CONSOLE_LEVELS = CONSOLE_LEVELS;
    exports.consoleSandbox = consoleSandbox;
    exports.logger = logger;
    exports.originalConsoleMethods = originalConsoleMethods;
  }
});

// ../../../node_modules/.pnpm/@sentry+utils@7.120.2/node_modules/@sentry/utils/cjs/dsn.js
var require_dsn = __commonJS({
  "../../../node_modules/.pnpm/@sentry+utils@7.120.2/node_modules/@sentry/utils/cjs/dsn.js"(exports) {
    init_define_ENV_DEFINED_IN_BUILD_STEP();
    Object.defineProperty(exports, "__esModule", { value: true });
    var debugBuild = require_debug_build();
    var logger = require_logger();
    var DSN_REGEX = /^(?:(\w+):)\/\/(?:(\w+)(?::(\w+)?)?@)([\w.-]+)(?::(\d+))?\/(.+)/;
    function isValidProtocol(protocol) {
      return protocol === "http" || protocol === "https";
    }
    function dsnToString(dsn, withPassword = false) {
      const { host, path: path2, pass, port, projectId, protocol, publicKey } = dsn;
      return `${protocol}://${publicKey}${withPassword && pass ? `:${pass}` : ""}@${host}${port ? `:${port}` : ""}/${path2 ? `${path2}/` : path2}${projectId}`;
    }
    function dsnFromString(str) {
      const match = DSN_REGEX.exec(str);
      if (!match) {
        logger.consoleSandbox(() => {
          console.error(`Invalid Sentry Dsn: ${str}`);
        });
        return void 0;
      }
      const [protocol, publicKey, pass = "", host, port = "", lastPath] = match.slice(1);
      let path2 = "";
      let projectId = lastPath;
      const split = projectId.split("/");
      if (split.length > 1) {
        path2 = split.slice(0, -1).join("/");
        projectId = split.pop();
      }
      if (projectId) {
        const projectMatch = projectId.match(/^\d+/);
        if (projectMatch) {
          projectId = projectMatch[0];
        }
      }
      return dsnFromComponents({ host, pass, path: path2, projectId, port, protocol, publicKey });
    }
    function dsnFromComponents(components) {
      return {
        protocol: components.protocol,
        publicKey: components.publicKey || "",
        pass: components.pass || "",
        host: components.host,
        port: components.port || "",
        path: components.path || "",
        projectId: components.projectId
      };
    }
    function validateDsn(dsn) {
      if (!debugBuild.DEBUG_BUILD) {
        return true;
      }
      const { port, projectId, protocol } = dsn;
      const requiredComponents = ["protocol", "publicKey", "host", "projectId"];
      const hasMissingRequiredComponent = requiredComponents.find((component) => {
        if (!dsn[component]) {
          logger.logger.error(`Invalid Sentry Dsn: ${component} missing`);
          return true;
        }
        return false;
      });
      if (hasMissingRequiredComponent) {
        return false;
      }
      if (!projectId.match(/^\d+$/)) {
        logger.logger.error(`Invalid Sentry Dsn: Invalid projectId ${projectId}`);
        return false;
      }
      if (!isValidProtocol(protocol)) {
        logger.logger.error(`Invalid Sentry Dsn: Invalid protocol ${protocol}`);
        return false;
      }
      if (port && isNaN(parseInt(port, 10))) {
        logger.logger.error(`Invalid Sentry Dsn: Invalid port ${port}`);
        return false;
      }
      return true;
    }
    function makeDsn(from) {
      const components = typeof from === "string" ? dsnFromString(from) : dsnFromComponents(from);
      if (!components || !validateDsn(components)) {
        return void 0;
      }
      return components;
    }
    exports.dsnFromString = dsnFromString;
    exports.dsnToString = dsnToString;
    exports.makeDsn = makeDsn;
  }
});

// ../../../node_modules/.pnpm/@sentry+utils@7.120.2/node_modules/@sentry/utils/cjs/error.js
var require_error2 = __commonJS({
  "../../../node_modules/.pnpm/@sentry+utils@7.120.2/node_modules/@sentry/utils/cjs/error.js"(exports) {
    init_define_ENV_DEFINED_IN_BUILD_STEP();
    Object.defineProperty(exports, "__esModule", { value: true });
    var SentryError = class extends Error {
      /** Display name of this error instance. */
      constructor(message, logLevel = "warn") {
        super(message);
        this.message = message;
        this.name = new.target.prototype.constructor.name;
        Object.setPrototypeOf(this, new.target.prototype);
        this.logLevel = logLevel;
      }
    };
    exports.SentryError = SentryError;
  }
});

// ../../../node_modules/.pnpm/@sentry+utils@7.120.2/node_modules/@sentry/utils/cjs/object.js
var require_object = __commonJS({
  "../../../node_modules/.pnpm/@sentry+utils@7.120.2/node_modules/@sentry/utils/cjs/object.js"(exports) {
    init_define_ENV_DEFINED_IN_BUILD_STEP();
    Object.defineProperty(exports, "__esModule", { value: true });
    var browser = require_browser();
    var debugBuild = require_debug_build();
    var is = require_is();
    var logger = require_logger();
    var string = require_string();
    function fill(source, name, replacementFactory) {
      if (!(name in source)) {
        return;
      }
      const original = source[name];
      const wrapped = replacementFactory(original);
      if (typeof wrapped === "function") {
        markFunctionWrapped(wrapped, original);
      }
      source[name] = wrapped;
    }
    function addNonEnumerableProperty(obj, name, value) {
      try {
        Object.defineProperty(obj, name, {
          // enumerable: false, // the default, so we can save on bundle size by not explicitly setting it
          value,
          writable: true,
          configurable: true
        });
      } catch (o_O) {
        debugBuild.DEBUG_BUILD && logger.logger.log(`Failed to add non-enumerable property "${name}" to object`, obj);
      }
    }
    function markFunctionWrapped(wrapped, original) {
      try {
        const proto = original.prototype || {};
        wrapped.prototype = original.prototype = proto;
        addNonEnumerableProperty(wrapped, "__sentry_original__", original);
      } catch (o_O) {
      }
    }
    function getOriginalFunction(func) {
      return func.__sentry_original__;
    }
    function urlEncode(object) {
      return Object.keys(object).map((key) => `${encodeURIComponent(key)}=${encodeURIComponent(object[key])}`).join("&");
    }
    function convertToPlainObject(value) {
      if (is.isError(value)) {
        return {
          message: value.message,
          name: value.name,
          stack: value.stack,
          ...getOwnProperties(value)
        };
      } else if (is.isEvent(value)) {
        const newObj = {
          type: value.type,
          target: serializeEventTarget(value.target),
          currentTarget: serializeEventTarget(value.currentTarget),
          ...getOwnProperties(value)
        };
        if (typeof CustomEvent !== "undefined" && is.isInstanceOf(value, CustomEvent)) {
          newObj.detail = value.detail;
        }
        return newObj;
      } else {
        return value;
      }
    }
    function serializeEventTarget(target) {
      try {
        return is.isElement(target) ? browser.htmlTreeAsString(target) : Object.prototype.toString.call(target);
      } catch (_oO) {
        return "<unknown>";
      }
    }
    function getOwnProperties(obj) {
      if (typeof obj === "object" && obj !== null) {
        const extractedProps = {};
        for (const property in obj) {
          if (Object.prototype.hasOwnProperty.call(obj, property)) {
            extractedProps[property] = obj[property];
          }
        }
        return extractedProps;
      } else {
        return {};
      }
    }
    function extractExceptionKeysForMessage(exception, maxLength = 40) {
      const keys = Object.keys(convertToPlainObject(exception));
      keys.sort();
      if (!keys.length) {
        return "[object has no keys]";
      }
      if (keys[0].length >= maxLength) {
        return string.truncate(keys[0], maxLength);
      }
      for (let includedKeys = keys.length; includedKeys > 0; includedKeys--) {
        const serialized = keys.slice(0, includedKeys).join(", ");
        if (serialized.length > maxLength) {
          continue;
        }
        if (includedKeys === keys.length) {
          return serialized;
        }
        return string.truncate(serialized, maxLength);
      }
      return "";
    }
    function dropUndefinedKeys(inputValue) {
      const memoizationMap = /* @__PURE__ */ new Map();
      return _dropUndefinedKeys(inputValue, memoizationMap);
    }
    function _dropUndefinedKeys(inputValue, memoizationMap) {
      if (isPojo(inputValue)) {
        const memoVal = memoizationMap.get(inputValue);
        if (memoVal !== void 0) {
          return memoVal;
        }
        const returnValue = {};
        memoizationMap.set(inputValue, returnValue);
        for (const key of Object.keys(inputValue)) {
          if (typeof inputValue[key] !== "undefined") {
            returnValue[key] = _dropUndefinedKeys(inputValue[key], memoizationMap);
          }
        }
        return returnValue;
      }
      if (Array.isArray(inputValue)) {
        const memoVal = memoizationMap.get(inputValue);
        if (memoVal !== void 0) {
          return memoVal;
        }
        const returnValue = [];
        memoizationMap.set(inputValue, returnValue);
        inputValue.forEach((item) => {
          returnValue.push(_dropUndefinedKeys(item, memoizationMap));
        });
        return returnValue;
      }
      return inputValue;
    }
    function isPojo(input) {
      if (!is.isPlainObject(input)) {
        return false;
      }
      try {
        const name = Object.getPrototypeOf(input).constructor.name;
        return !name || name === "Object";
      } catch (e2) {
        return true;
      }
    }
    function objectify(wat) {
      let objectified;
      switch (true) {
        case (wat === void 0 || wat === null):
          objectified = new String(wat);
          break;
        case (typeof wat === "symbol" || typeof wat === "bigint"):
          objectified = Object(wat);
          break;
        case is.isPrimitive(wat):
          objectified = new wat.constructor(wat);
          break;
        default:
          objectified = wat;
          break;
      }
      return objectified;
    }
    exports.addNonEnumerableProperty = addNonEnumerableProperty;
    exports.convertToPlainObject = convertToPlainObject;
    exports.dropUndefinedKeys = dropUndefinedKeys;
    exports.extractExceptionKeysForMessage = extractExceptionKeysForMessage;
    exports.fill = fill;
    exports.getOriginalFunction = getOriginalFunction;
    exports.markFunctionWrapped = markFunctionWrapped;
    exports.objectify = objectify;
    exports.urlEncode = urlEncode;
  }
});

// ../../../node_modules/.pnpm/@sentry+utils@7.120.2/node_modules/@sentry/utils/cjs/node-stack-trace.js
var require_node_stack_trace = __commonJS({
  "../../../node_modules/.pnpm/@sentry+utils@7.120.2/node_modules/@sentry/utils/cjs/node-stack-trace.js"(exports) {
    init_define_ENV_DEFINED_IN_BUILD_STEP();
    Object.defineProperty(exports, "__esModule", { value: true });
    function filenameIsInApp(filename, isNative = false) {
      const isInternal = isNative || filename && // It's not internal if it's an absolute linux path
      !filename.startsWith("/") && // It's not internal if it's an absolute windows path
      !filename.match(/^[A-Z]:/) && // It's not internal if the path is starting with a dot
      !filename.startsWith(".") && // It's not internal if the frame has a protocol. In node, this is usually the case if the file got pre-processed with a bundler like webpack
      !filename.match(/^[a-zA-Z]([a-zA-Z0-9.\-+])*:\/\//);
      return !isInternal && filename !== void 0 && !filename.includes("node_modules/");
    }
    function node(getModule) {
      const FILENAME_MATCH = /^\s*[-]{4,}$/;
      const FULL_MATCH = /at (?:async )?(?:(.+?)\s+\()?(?:(.+):(\d+):(\d+)?|([^)]+))\)?/;
      return (line) => {
        const lineMatch = line.match(FULL_MATCH);
        if (lineMatch) {
          let object;
          let method;
          let functionName;
          let typeName;
          let methodName;
          if (lineMatch[1]) {
            functionName = lineMatch[1];
            let methodStart = functionName.lastIndexOf(".");
            if (functionName[methodStart - 1] === ".") {
              methodStart--;
            }
            if (methodStart > 0) {
              object = functionName.slice(0, methodStart);
              method = functionName.slice(methodStart + 1);
              const objectEnd = object.indexOf(".Module");
              if (objectEnd > 0) {
                functionName = functionName.slice(objectEnd + 1);
                object = object.slice(0, objectEnd);
              }
            }
            typeName = void 0;
          }
          if (method) {
            typeName = object;
            methodName = method;
          }
          if (method === "<anonymous>") {
            methodName = void 0;
            functionName = void 0;
          }
          if (functionName === void 0) {
            methodName = methodName || "<anonymous>";
            functionName = typeName ? `${typeName}.${methodName}` : methodName;
          }
          let filename = lineMatch[2] && lineMatch[2].startsWith("file://") ? lineMatch[2].slice(7) : lineMatch[2];
          const isNative = lineMatch[5] === "native";
          if (filename && filename.match(/\/[A-Z]:/)) {
            filename = filename.slice(1);
          }
          if (!filename && lineMatch[5] && !isNative) {
            filename = lineMatch[5];
          }
          return {
            filename,
            module: getModule ? getModule(filename) : void 0,
            function: functionName,
            lineno: parseInt(lineMatch[3], 10) || void 0,
            colno: parseInt(lineMatch[4], 10) || void 0,
            in_app: filenameIsInApp(filename, isNative)
          };
        }
        if (line.match(FILENAME_MATCH)) {
          return {
            filename: line
          };
        }
        return void 0;
      };
    }
    exports.filenameIsInApp = filenameIsInApp;
    exports.node = node;
  }
});

// ../../../node_modules/.pnpm/@sentry+utils@7.120.2/node_modules/@sentry/utils/cjs/stacktrace.js
var require_stacktrace = __commonJS({
  "../../../node_modules/.pnpm/@sentry+utils@7.120.2/node_modules/@sentry/utils/cjs/stacktrace.js"(exports) {
    init_define_ENV_DEFINED_IN_BUILD_STEP();
    Object.defineProperty(exports, "__esModule", { value: true });
    var nodeStackTrace = require_node_stack_trace();
    var STACKTRACE_FRAME_LIMIT = 50;
    var WEBPACK_ERROR_REGEXP = /\(error: (.*)\)/;
    var STRIP_FRAME_REGEXP = /captureMessage|captureException/;
    function createStackParser(...parsers) {
      const sortedParsers = parsers.sort((a3, b) => a3[0] - b[0]).map((p3) => p3[1]);
      return (stack, skipFirst = 0) => {
        const frames = [];
        const lines = stack.split("\n");
        for (let i2 = skipFirst; i2 < lines.length; i2++) {
          const line = lines[i2];
          if (line.length > 1024) {
            continue;
          }
          const cleanedLine = WEBPACK_ERROR_REGEXP.test(line) ? line.replace(WEBPACK_ERROR_REGEXP, "$1") : line;
          if (cleanedLine.match(/\S*Error: /)) {
            continue;
          }
          for (const parser of sortedParsers) {
            const frame = parser(cleanedLine);
            if (frame) {
              frames.push(frame);
              break;
            }
          }
          if (frames.length >= STACKTRACE_FRAME_LIMIT) {
            break;
          }
        }
        return stripSentryFramesAndReverse(frames);
      };
    }
    function stackParserFromStackParserOptions(stackParser) {
      if (Array.isArray(stackParser)) {
        return createStackParser(...stackParser);
      }
      return stackParser;
    }
    function stripSentryFramesAndReverse(stack) {
      if (!stack.length) {
        return [];
      }
      const localStack = Array.from(stack);
      if (/sentryWrapped/.test(localStack[localStack.length - 1].function || "")) {
        localStack.pop();
      }
      localStack.reverse();
      if (STRIP_FRAME_REGEXP.test(localStack[localStack.length - 1].function || "")) {
        localStack.pop();
        if (STRIP_FRAME_REGEXP.test(localStack[localStack.length - 1].function || "")) {
          localStack.pop();
        }
      }
      return localStack.slice(0, STACKTRACE_FRAME_LIMIT).map((frame) => ({
        ...frame,
        filename: frame.filename || localStack[localStack.length - 1].filename,
        function: frame.function || "?"
      }));
    }
    var defaultFunctionName = "<anonymous>";
    function getFunctionName(fn) {
      try {
        if (!fn || typeof fn !== "function") {
          return defaultFunctionName;
        }
        return fn.name || defaultFunctionName;
      } catch (e2) {
        return defaultFunctionName;
      }
    }
    function nodeStackLineParser(getModule) {
      return [90, nodeStackTrace.node(getModule)];
    }
    exports.filenameIsInApp = nodeStackTrace.filenameIsInApp;
    exports.createStackParser = createStackParser;
    exports.getFunctionName = getFunctionName;
    exports.nodeStackLineParser = nodeStackLineParser;
    exports.stackParserFromStackParserOptions = stackParserFromStackParserOptions;
    exports.stripSentryFramesAndReverse = stripSentryFramesAndReverse;
  }
});

// ../../../node_modules/.pnpm/@sentry+utils@7.120.2/node_modules/@sentry/utils/cjs/instrument/_handlers.js
var require_handlers = __commonJS({
  "../../../node_modules/.pnpm/@sentry+utils@7.120.2/node_modules/@sentry/utils/cjs/instrument/_handlers.js"(exports) {
    init_define_ENV_DEFINED_IN_BUILD_STEP();
    Object.defineProperty(exports, "__esModule", { value: true });
    var debugBuild = require_debug_build();
    var logger = require_logger();
    var stacktrace = require_stacktrace();
    var handlers = {};
    var instrumented = {};
    function addHandler(type, handler) {
      handlers[type] = handlers[type] || [];
      handlers[type].push(handler);
    }
    function resetInstrumentationHandlers() {
      Object.keys(handlers).forEach((key) => {
        handlers[key] = void 0;
      });
    }
    function maybeInstrument(type, instrumentFn) {
      if (!instrumented[type]) {
        instrumentFn();
        instrumented[type] = true;
      }
    }
    function triggerHandlers(type, data) {
      const typeHandlers = type && handlers[type];
      if (!typeHandlers) {
        return;
      }
      for (const handler of typeHandlers) {
        try {
          handler(data);
        } catch (e2) {
          debugBuild.DEBUG_BUILD && logger.logger.error(
            `Error while triggering instrumentation handler.
Type: ${type}
Name: ${stacktrace.getFunctionName(handler)}
Error:`,
            e2
          );
        }
      }
    }
    exports.addHandler = addHandler;
    exports.maybeInstrument = maybeInstrument;
    exports.resetInstrumentationHandlers = resetInstrumentationHandlers;
    exports.triggerHandlers = triggerHandlers;
  }
});

// ../../../node_modules/.pnpm/@sentry+utils@7.120.2/node_modules/@sentry/utils/cjs/instrument/console.js
var require_console = __commonJS({
  "../../../node_modules/.pnpm/@sentry+utils@7.120.2/node_modules/@sentry/utils/cjs/instrument/console.js"(exports) {
    init_define_ENV_DEFINED_IN_BUILD_STEP();
    Object.defineProperty(exports, "__esModule", { value: true });
    var logger = require_logger();
    var object = require_object();
    var worldwide = require_worldwide();
    var _handlers = require_handlers();
    function addConsoleInstrumentationHandler(handler) {
      const type = "console";
      _handlers.addHandler(type, handler);
      _handlers.maybeInstrument(type, instrumentConsole);
    }
    function instrumentConsole() {
      if (!("console" in worldwide.GLOBAL_OBJ)) {
        return;
      }
      logger.CONSOLE_LEVELS.forEach(function(level) {
        if (!(level in worldwide.GLOBAL_OBJ.console)) {
          return;
        }
        object.fill(worldwide.GLOBAL_OBJ.console, level, function(originalConsoleMethod) {
          logger.originalConsoleMethods[level] = originalConsoleMethod;
          return function(...args) {
            const handlerData = { args, level };
            _handlers.triggerHandlers("console", handlerData);
            const log2 = logger.originalConsoleMethods[level];
            log2 && log2.apply(worldwide.GLOBAL_OBJ.console, args);
          };
        });
      });
    }
    exports.addConsoleInstrumentationHandler = addConsoleInstrumentationHandler;
  }
});

// ../../../node_modules/.pnpm/@sentry+utils@7.120.2/node_modules/@sentry/utils/cjs/misc.js
var require_misc = __commonJS({
  "../../../node_modules/.pnpm/@sentry+utils@7.120.2/node_modules/@sentry/utils/cjs/misc.js"(exports) {
    init_define_ENV_DEFINED_IN_BUILD_STEP();
    Object.defineProperty(exports, "__esModule", { value: true });
    var object = require_object();
    var string = require_string();
    var worldwide = require_worldwide();
    function uuid4() {
      const gbl = worldwide.GLOBAL_OBJ;
      const crypto4 = gbl.crypto || gbl.msCrypto;
      let getRandomByte = () => Math.random() * 16;
      try {
        if (crypto4 && crypto4.randomUUID) {
          return crypto4.randomUUID().replace(/-/g, "");
        }
        if (crypto4 && crypto4.getRandomValues) {
          getRandomByte = () => {
            const typedArray = new Uint8Array(1);
            crypto4.getRandomValues(typedArray);
            return typedArray[0];
          };
        }
      } catch (_3) {
      }
      return ("10000000100040008000" + 1e11).replace(
        /[018]/g,
        (c3) => (
          // eslint-disable-next-line no-bitwise
          (c3 ^ (getRandomByte() & 15) >> c3 / 4).toString(16)
        )
      );
    }
    function getFirstException(event) {
      return event.exception && event.exception.values ? event.exception.values[0] : void 0;
    }
    function getEventDescription(event) {
      const { message, event_id: eventId } = event;
      if (message) {
        return message;
      }
      const firstException = getFirstException(event);
      if (firstException) {
        if (firstException.type && firstException.value) {
          return `${firstException.type}: ${firstException.value}`;
        }
        return firstException.type || firstException.value || eventId || "<unknown>";
      }
      return eventId || "<unknown>";
    }
    function addExceptionTypeValue(event, value, type) {
      const exception = event.exception = event.exception || {};
      const values = exception.values = exception.values || [];
      const firstException = values[0] = values[0] || {};
      if (!firstException.value) {
        firstException.value = value || "";
      }
      if (!firstException.type) {
        firstException.type = type || "Error";
      }
    }
    function addExceptionMechanism(event, newMechanism) {
      const firstException = getFirstException(event);
      if (!firstException) {
        return;
      }
      const defaultMechanism = { type: "generic", handled: true };
      const currentMechanism = firstException.mechanism;
      firstException.mechanism = { ...defaultMechanism, ...currentMechanism, ...newMechanism };
      if (newMechanism && "data" in newMechanism) {
        const mergedData = { ...currentMechanism && currentMechanism.data, ...newMechanism.data };
        firstException.mechanism.data = mergedData;
      }
    }
    var SEMVER_REGEXP = /^(0|[1-9]\d*)\.(0|[1-9]\d*)\.(0|[1-9]\d*)(?:-((?:0|[1-9]\d*|\d*[a-zA-Z-][0-9a-zA-Z-]*)(?:\.(?:0|[1-9]\d*|\d*[a-zA-Z-][0-9a-zA-Z-]*))*))?(?:\+([0-9a-zA-Z-]+(?:\.[0-9a-zA-Z-]+)*))?$/;
    function parseSemver(input) {
      const match = input.match(SEMVER_REGEXP) || [];
      const major = parseInt(match[1], 10);
      const minor = parseInt(match[2], 10);
      const patch = parseInt(match[3], 10);
      return {
        buildmetadata: match[5],
        major: isNaN(major) ? void 0 : major,
        minor: isNaN(minor) ? void 0 : minor,
        patch: isNaN(patch) ? void 0 : patch,
        prerelease: match[4]
      };
    }
    function addContextToFrame(lines, frame, linesOfContext = 5) {
      if (frame.lineno === void 0) {
        return;
      }
      const maxLines = lines.length;
      const sourceLine = Math.max(Math.min(maxLines - 1, frame.lineno - 1), 0);
      frame.pre_context = lines.slice(Math.max(0, sourceLine - linesOfContext), sourceLine).map((line) => string.snipLine(line, 0));
      frame.context_line = string.snipLine(lines[Math.min(maxLines - 1, sourceLine)], frame.colno || 0);
      frame.post_context = lines.slice(Math.min(sourceLine + 1, maxLines), sourceLine + 1 + linesOfContext).map((line) => string.snipLine(line, 0));
    }
    function checkOrSetAlreadyCaught(exception) {
      if (exception && exception.__sentry_captured__) {
        return true;
      }
      try {
        object.addNonEnumerableProperty(exception, "__sentry_captured__", true);
      } catch (err) {
      }
      return false;
    }
    function arrayify(maybeArray) {
      return Array.isArray(maybeArray) ? maybeArray : [maybeArray];
    }
    exports.addContextToFrame = addContextToFrame;
    exports.addExceptionMechanism = addExceptionMechanism;
    exports.addExceptionTypeValue = addExceptionTypeValue;
    exports.arrayify = arrayify;
    exports.checkOrSetAlreadyCaught = checkOrSetAlreadyCaught;
    exports.getEventDescription = getEventDescription;
    exports.parseSemver = parseSemver;
    exports.uuid4 = uuid4;
  }
});

// ../../../node_modules/.pnpm/@sentry+utils@7.120.2/node_modules/@sentry/utils/cjs/instrument/dom.js
var require_dom = __commonJS({
  "../../../node_modules/.pnpm/@sentry+utils@7.120.2/node_modules/@sentry/utils/cjs/instrument/dom.js"(exports) {
    init_define_ENV_DEFINED_IN_BUILD_STEP();
    Object.defineProperty(exports, "__esModule", { value: true });
    var misc = require_misc();
    var object = require_object();
    var worldwide = require_worldwide();
    var _handlers = require_handlers();
    var WINDOW = worldwide.GLOBAL_OBJ;
    var DEBOUNCE_DURATION = 1e3;
    var debounceTimerID;
    var lastCapturedEventType;
    var lastCapturedEventTargetId;
    function addClickKeypressInstrumentationHandler(handler) {
      const type = "dom";
      _handlers.addHandler(type, handler);
      _handlers.maybeInstrument(type, instrumentDOM);
    }
    function instrumentDOM() {
      if (!WINDOW.document) {
        return;
      }
      const triggerDOMHandler = _handlers.triggerHandlers.bind(null, "dom");
      const globalDOMEventHandler = makeDOMEventHandler(triggerDOMHandler, true);
      WINDOW.document.addEventListener("click", globalDOMEventHandler, false);
      WINDOW.document.addEventListener("keypress", globalDOMEventHandler, false);
      ["EventTarget", "Node"].forEach((target) => {
        const proto = WINDOW[target] && WINDOW[target].prototype;
        if (!proto || !proto.hasOwnProperty || !proto.hasOwnProperty("addEventListener")) {
          return;
        }
        object.fill(proto, "addEventListener", function(originalAddEventListener) {
          return function(type, listener, options) {
            if (type === "click" || type == "keypress") {
              try {
                const el = this;
                const handlers = el.__sentry_instrumentation_handlers__ = el.__sentry_instrumentation_handlers__ || {};
                const handlerForType = handlers[type] = handlers[type] || { refCount: 0 };
                if (!handlerForType.handler) {
                  const handler = makeDOMEventHandler(triggerDOMHandler);
                  handlerForType.handler = handler;
                  originalAddEventListener.call(this, type, handler, options);
                }
                handlerForType.refCount++;
              } catch (e2) {
              }
            }
            return originalAddEventListener.call(this, type, listener, options);
          };
        });
        object.fill(
          proto,
          "removeEventListener",
          function(originalRemoveEventListener) {
            return function(type, listener, options) {
              if (type === "click" || type == "keypress") {
                try {
                  const el = this;
                  const handlers = el.__sentry_instrumentation_handlers__ || {};
                  const handlerForType = handlers[type];
                  if (handlerForType) {
                    handlerForType.refCount--;
                    if (handlerForType.refCount <= 0) {
                      originalRemoveEventListener.call(this, type, handlerForType.handler, options);
                      handlerForType.handler = void 0;
                      delete handlers[type];
                    }
                    if (Object.keys(handlers).length === 0) {
                      delete el.__sentry_instrumentation_handlers__;
                    }
                  }
                } catch (e2) {
                }
              }
              return originalRemoveEventListener.call(this, type, listener, options);
            };
          }
        );
      });
    }
    function isSimilarToLastCapturedEvent(event) {
      if (event.type !== lastCapturedEventType) {
        return false;
      }
      try {
        if (!event.target || event.target._sentryId !== lastCapturedEventTargetId) {
          return false;
        }
      } catch (e2) {
      }
      return true;
    }
    function shouldSkipDOMEvent(eventType, target) {
      if (eventType !== "keypress") {
        return false;
      }
      if (!target || !target.tagName) {
        return true;
      }
      if (target.tagName === "INPUT" || target.tagName === "TEXTAREA" || target.isContentEditable) {
        return false;
      }
      return true;
    }
    function makeDOMEventHandler(handler, globalListener = false) {
      return (event) => {
        if (!event || event["_sentryCaptured"]) {
          return;
        }
        const target = getEventTarget(event);
        if (shouldSkipDOMEvent(event.type, target)) {
          return;
        }
        object.addNonEnumerableProperty(event, "_sentryCaptured", true);
        if (target && !target._sentryId) {
          object.addNonEnumerableProperty(target, "_sentryId", misc.uuid4());
        }
        const name = event.type === "keypress" ? "input" : event.type;
        if (!isSimilarToLastCapturedEvent(event)) {
          const handlerData = { event, name, global: globalListener };
          handler(handlerData);
          lastCapturedEventType = event.type;
          lastCapturedEventTargetId = target ? target._sentryId : void 0;
        }
        clearTimeout(debounceTimerID);
        debounceTimerID = WINDOW.setTimeout(() => {
          lastCapturedEventTargetId = void 0;
          lastCapturedEventType = void 0;
        }, DEBOUNCE_DURATION);
      };
    }
    function getEventTarget(event) {
      try {
        return event.target;
      } catch (e2) {
        return null;
      }
    }
    exports.addClickKeypressInstrumentationHandler = addClickKeypressInstrumentationHandler;
    exports.instrumentDOM = instrumentDOM;
  }
});

// ../../../node_modules/.pnpm/@sentry+utils@7.120.2/node_modules/@sentry/utils/cjs/supports.js
var require_supports = __commonJS({
  "../../../node_modules/.pnpm/@sentry+utils@7.120.2/node_modules/@sentry/utils/cjs/supports.js"(exports) {
    init_define_ENV_DEFINED_IN_BUILD_STEP();
    Object.defineProperty(exports, "__esModule", { value: true });
    var debugBuild = require_debug_build();
    var logger = require_logger();
    var worldwide = require_worldwide();
    var WINDOW = worldwide.getGlobalObject();
    function supportsErrorEvent() {
      try {
        new ErrorEvent("");
        return true;
      } catch (e2) {
        return false;
      }
    }
    function supportsDOMError() {
      try {
        new DOMError("");
        return true;
      } catch (e2) {
        return false;
      }
    }
    function supportsDOMException() {
      try {
        new DOMException("");
        return true;
      } catch (e2) {
        return false;
      }
    }
    function supportsFetch() {
      if (!("fetch" in WINDOW)) {
        return false;
      }
      try {
        new Headers();
        new Request("http://www.example.com");
        new Response();
        return true;
      } catch (e2) {
        return false;
      }
    }
    function isNativeFetch(func) {
      return func && /^function fetch\(\)\s+\{\s+\[native code\]\s+\}$/.test(func.toString());
    }
    function supportsNativeFetch() {
      if (typeof EdgeRuntime === "string") {
        return true;
      }
      if (!supportsFetch()) {
        return false;
      }
      if (isNativeFetch(WINDOW.fetch)) {
        return true;
      }
      let result = false;
      const doc = WINDOW.document;
      if (doc && typeof doc.createElement === "function") {
        try {
          const sandbox = doc.createElement("iframe");
          sandbox.hidden = true;
          doc.head.appendChild(sandbox);
          if (sandbox.contentWindow && sandbox.contentWindow.fetch) {
            result = isNativeFetch(sandbox.contentWindow.fetch);
          }
          doc.head.removeChild(sandbox);
        } catch (err) {
          debugBuild.DEBUG_BUILD && logger.logger.warn("Could not create sandbox iframe for pure fetch check, bailing to window.fetch: ", err);
        }
      }
      return result;
    }
    function supportsReportingObserver() {
      return "ReportingObserver" in WINDOW;
    }
    function supportsReferrerPolicy() {
      if (!supportsFetch()) {
        return false;
      }
      try {
        new Request("_", {
          referrerPolicy: "origin"
        });
        return true;
      } catch (e2) {
        return false;
      }
    }
    exports.isNativeFetch = isNativeFetch;
    exports.supportsDOMError = supportsDOMError;
    exports.supportsDOMException = supportsDOMException;
    exports.supportsErrorEvent = supportsErrorEvent;
    exports.supportsFetch = supportsFetch;
    exports.supportsNativeFetch = supportsNativeFetch;
    exports.supportsReferrerPolicy = supportsReferrerPolicy;
    exports.supportsReportingObserver = supportsReportingObserver;
  }
});

// ../../../node_modules/.pnpm/@sentry+utils@7.120.2/node_modules/@sentry/utils/cjs/instrument/fetch.js
var require_fetch = __commonJS({
  "../../../node_modules/.pnpm/@sentry+utils@7.120.2/node_modules/@sentry/utils/cjs/instrument/fetch.js"(exports) {
    init_define_ENV_DEFINED_IN_BUILD_STEP();
    Object.defineProperty(exports, "__esModule", { value: true });
    var object = require_object();
    var supports = require_supports();
    var worldwide = require_worldwide();
    var _handlers = require_handlers();
    function addFetchInstrumentationHandler(handler) {
      const type = "fetch";
      _handlers.addHandler(type, handler);
      _handlers.maybeInstrument(type, instrumentFetch);
    }
    function instrumentFetch() {
      if (!supports.supportsNativeFetch()) {
        return;
      }
      object.fill(worldwide.GLOBAL_OBJ, "fetch", function(originalFetch) {
        return function(...args) {
          const { method, url } = parseFetchArgs(args);
          const handlerData = {
            args,
            fetchData: {
              method,
              url
            },
            startTimestamp: Date.now()
          };
          _handlers.triggerHandlers("fetch", {
            ...handlerData
          });
          return originalFetch.apply(worldwide.GLOBAL_OBJ, args).then(
            (response) => {
              const finishedHandlerData = {
                ...handlerData,
                endTimestamp: Date.now(),
                response
              };
              _handlers.triggerHandlers("fetch", finishedHandlerData);
              return response;
            },
            (error) => {
              const erroredHandlerData = {
                ...handlerData,
                endTimestamp: Date.now(),
                error
              };
              _handlers.triggerHandlers("fetch", erroredHandlerData);
              throw error;
            }
          );
        };
      });
    }
    function hasProp(obj, prop) {
      return !!obj && typeof obj === "object" && !!obj[prop];
    }
    function getUrlFromResource(resource) {
      if (typeof resource === "string") {
        return resource;
      }
      if (!resource) {
        return "";
      }
      if (hasProp(resource, "url")) {
        return resource.url;
      }
      if (resource.toString) {
        return resource.toString();
      }
      return "";
    }
    function parseFetchArgs(fetchArgs) {
      if (fetchArgs.length === 0) {
        return { method: "GET", url: "" };
      }
      if (fetchArgs.length === 2) {
        const [url, options] = fetchArgs;
        return {
          url: getUrlFromResource(url),
          method: hasProp(options, "method") ? String(options.method).toUpperCase() : "GET"
        };
      }
      const arg = fetchArgs[0];
      return {
        url: getUrlFromResource(arg),
        method: hasProp(arg, "method") ? String(arg.method).toUpperCase() : "GET"
      };
    }
    exports.addFetchInstrumentationHandler = addFetchInstrumentationHandler;
    exports.parseFetchArgs = parseFetchArgs;
  }
});

// ../../../node_modules/.pnpm/@sentry+utils@7.120.2/node_modules/@sentry/utils/cjs/instrument/globalError.js
var require_globalError = __commonJS({
  "../../../node_modules/.pnpm/@sentry+utils@7.120.2/node_modules/@sentry/utils/cjs/instrument/globalError.js"(exports) {
    init_define_ENV_DEFINED_IN_BUILD_STEP();
    Object.defineProperty(exports, "__esModule", { value: true });
    var worldwide = require_worldwide();
    var _handlers = require_handlers();
    var _oldOnErrorHandler = null;
    function addGlobalErrorInstrumentationHandler(handler) {
      const type = "error";
      _handlers.addHandler(type, handler);
      _handlers.maybeInstrument(type, instrumentError);
    }
    function instrumentError() {
      _oldOnErrorHandler = worldwide.GLOBAL_OBJ.onerror;
      worldwide.GLOBAL_OBJ.onerror = function(msg, url, line, column, error) {
        const handlerData = {
          column,
          error,
          line,
          msg,
          url
        };
        _handlers.triggerHandlers("error", handlerData);
        if (_oldOnErrorHandler && !_oldOnErrorHandler.__SENTRY_LOADER__) {
          return _oldOnErrorHandler.apply(this, arguments);
        }
        return false;
      };
      worldwide.GLOBAL_OBJ.onerror.__SENTRY_INSTRUMENTED__ = true;
    }
    exports.addGlobalErrorInstrumentationHandler = addGlobalErrorInstrumentationHandler;
  }
});

// ../../../node_modules/.pnpm/@sentry+utils@7.120.2/node_modules/@sentry/utils/cjs/instrument/globalUnhandledRejection.js
var require_globalUnhandledRejection = __commonJS({
  "../../../node_modules/.pnpm/@sentry+utils@7.120.2/node_modules/@sentry/utils/cjs/instrument/globalUnhandledRejection.js"(exports) {
    init_define_ENV_DEFINED_IN_BUILD_STEP();
    Object.defineProperty(exports, "__esModule", { value: true });
    var worldwide = require_worldwide();
    var _handlers = require_handlers();
    var _oldOnUnhandledRejectionHandler = null;
    function addGlobalUnhandledRejectionInstrumentationHandler(handler) {
      const type = "unhandledrejection";
      _handlers.addHandler(type, handler);
      _handlers.maybeInstrument(type, instrumentUnhandledRejection);
    }
    function instrumentUnhandledRejection() {
      _oldOnUnhandledRejectionHandler = worldwide.GLOBAL_OBJ.onunhandledrejection;
      worldwide.GLOBAL_OBJ.onunhandledrejection = function(e2) {
        const handlerData = e2;
        _handlers.triggerHandlers("unhandledrejection", handlerData);
        if (_oldOnUnhandledRejectionHandler && !_oldOnUnhandledRejectionHandler.__SENTRY_LOADER__) {
          return _oldOnUnhandledRejectionHandler.apply(this, arguments);
        }
        return true;
      };
      worldwide.GLOBAL_OBJ.onunhandledrejection.__SENTRY_INSTRUMENTED__ = true;
    }
    exports.addGlobalUnhandledRejectionInstrumentationHandler = addGlobalUnhandledRejectionInstrumentationHandler;
  }
});

// ../../../node_modules/.pnpm/@sentry+utils@7.120.2/node_modules/@sentry/utils/cjs/vendor/supportsHistory.js
var require_supportsHistory = __commonJS({
  "../../../node_modules/.pnpm/@sentry+utils@7.120.2/node_modules/@sentry/utils/cjs/vendor/supportsHistory.js"(exports) {
    init_define_ENV_DEFINED_IN_BUILD_STEP();
    Object.defineProperty(exports, "__esModule", { value: true });
    var worldwide = require_worldwide();
    var WINDOW = worldwide.getGlobalObject();
    function supportsHistory() {
      const chromeVar = WINDOW.chrome;
      const isChromePackagedApp = chromeVar && chromeVar.app && chromeVar.app.runtime;
      const hasHistoryApi = "history" in WINDOW && !!WINDOW.history.pushState && !!WINDOW.history.replaceState;
      return !isChromePackagedApp && hasHistoryApi;
    }
    exports.supportsHistory = supportsHistory;
  }
});

// ../../../node_modules/.pnpm/@sentry+utils@7.120.2/node_modules/@sentry/utils/cjs/instrument/history.js
var require_history = __commonJS({
  "../../../node_modules/.pnpm/@sentry+utils@7.120.2/node_modules/@sentry/utils/cjs/instrument/history.js"(exports) {
    init_define_ENV_DEFINED_IN_BUILD_STEP();
    Object.defineProperty(exports, "__esModule", { value: true });
    var object = require_object();
    require_debug_build();
    require_logger();
    var worldwide = require_worldwide();
    var supportsHistory = require_supportsHistory();
    var _handlers = require_handlers();
    var WINDOW = worldwide.GLOBAL_OBJ;
    var lastHref;
    function addHistoryInstrumentationHandler(handler) {
      const type = "history";
      _handlers.addHandler(type, handler);
      _handlers.maybeInstrument(type, instrumentHistory);
    }
    function instrumentHistory() {
      if (!supportsHistory.supportsHistory()) {
        return;
      }
      const oldOnPopState = WINDOW.onpopstate;
      WINDOW.onpopstate = function(...args) {
        const to = WINDOW.location.href;
        const from = lastHref;
        lastHref = to;
        const handlerData = { from, to };
        _handlers.triggerHandlers("history", handlerData);
        if (oldOnPopState) {
          try {
            return oldOnPopState.apply(this, args);
          } catch (_oO) {
          }
        }
      };
      function historyReplacementFunction(originalHistoryFunction) {
        return function(...args) {
          const url = args.length > 2 ? args[2] : void 0;
          if (url) {
            const from = lastHref;
            const to = String(url);
            lastHref = to;
            const handlerData = { from, to };
            _handlers.triggerHandlers("history", handlerData);
          }
          return originalHistoryFunction.apply(this, args);
        };
      }
      object.fill(WINDOW.history, "pushState", historyReplacementFunction);
      object.fill(WINDOW.history, "replaceState", historyReplacementFunction);
    }
    exports.addHistoryInstrumentationHandler = addHistoryInstrumentationHandler;
  }
});

// ../../../node_modules/.pnpm/@sentry+utils@7.120.2/node_modules/@sentry/utils/cjs/instrument/xhr.js
var require_xhr = __commonJS({
  "../../../node_modules/.pnpm/@sentry+utils@7.120.2/node_modules/@sentry/utils/cjs/instrument/xhr.js"(exports) {
    init_define_ENV_DEFINED_IN_BUILD_STEP();
    Object.defineProperty(exports, "__esModule", { value: true });
    var is = require_is();
    var object = require_object();
    var worldwide = require_worldwide();
    var _handlers = require_handlers();
    var WINDOW = worldwide.GLOBAL_OBJ;
    var SENTRY_XHR_DATA_KEY = "__sentry_xhr_v3__";
    function addXhrInstrumentationHandler(handler) {
      const type = "xhr";
      _handlers.addHandler(type, handler);
      _handlers.maybeInstrument(type, instrumentXHR);
    }
    function instrumentXHR() {
      if (!WINDOW.XMLHttpRequest) {
        return;
      }
      const xhrproto = XMLHttpRequest.prototype;
      object.fill(xhrproto, "open", function(originalOpen) {
        return function(...args) {
          const startTimestamp = Date.now();
          const method = is.isString(args[0]) ? args[0].toUpperCase() : void 0;
          const url = parseUrl(args[1]);
          if (!method || !url) {
            return originalOpen.apply(this, args);
          }
          this[SENTRY_XHR_DATA_KEY] = {
            method,
            url,
            request_headers: {}
          };
          if (method === "POST" && url.match(/sentry_key/)) {
            this.__sentry_own_request__ = true;
          }
          const onreadystatechangeHandler = () => {
            const xhrInfo = this[SENTRY_XHR_DATA_KEY];
            if (!xhrInfo) {
              return;
            }
            if (this.readyState === 4) {
              try {
                xhrInfo.status_code = this.status;
              } catch (e2) {
              }
              const handlerData = {
                args: [method, url],
                endTimestamp: Date.now(),
                startTimestamp,
                xhr: this
              };
              _handlers.triggerHandlers("xhr", handlerData);
            }
          };
          if ("onreadystatechange" in this && typeof this.onreadystatechange === "function") {
            object.fill(this, "onreadystatechange", function(original) {
              return function(...readyStateArgs) {
                onreadystatechangeHandler();
                return original.apply(this, readyStateArgs);
              };
            });
          } else {
            this.addEventListener("readystatechange", onreadystatechangeHandler);
          }
          object.fill(this, "setRequestHeader", function(original) {
            return function(...setRequestHeaderArgs) {
              const [header, value] = setRequestHeaderArgs;
              const xhrInfo = this[SENTRY_XHR_DATA_KEY];
              if (xhrInfo && is.isString(header) && is.isString(value)) {
                xhrInfo.request_headers[header.toLowerCase()] = value;
              }
              return original.apply(this, setRequestHeaderArgs);
            };
          });
          return originalOpen.apply(this, args);
        };
      });
      object.fill(xhrproto, "send", function(originalSend) {
        return function(...args) {
          const sentryXhrData = this[SENTRY_XHR_DATA_KEY];
          if (!sentryXhrData) {
            return originalSend.apply(this, args);
          }
          if (args[0] !== void 0) {
            sentryXhrData.body = args[0];
          }
          const handlerData = {
            args: [sentryXhrData.method, sentryXhrData.url],
            startTimestamp: Date.now(),
            xhr: this
          };
          _handlers.triggerHandlers("xhr", handlerData);
          return originalSend.apply(this, args);
        };
      });
    }
    function parseUrl(url) {
      if (is.isString(url)) {
        return url;
      }
      try {
        return url.toString();
      } catch (e2) {
      }
      return void 0;
    }
    exports.SENTRY_XHR_DATA_KEY = SENTRY_XHR_DATA_KEY;
    exports.addXhrInstrumentationHandler = addXhrInstrumentationHandler;
    exports.instrumentXHR = instrumentXHR;
  }
});

// ../../../node_modules/.pnpm/@sentry+utils@7.120.2/node_modules/@sentry/utils/cjs/instrument/index.js
var require_instrument = __commonJS({
  "../../../node_modules/.pnpm/@sentry+utils@7.120.2/node_modules/@sentry/utils/cjs/instrument/index.js"(exports) {
    init_define_ENV_DEFINED_IN_BUILD_STEP();
    Object.defineProperty(exports, "__esModule", { value: true });
    var debugBuild = require_debug_build();
    var logger = require_logger();
    var console2 = require_console();
    var dom = require_dom();
    var fetch2 = require_fetch();
    var globalError = require_globalError();
    var globalUnhandledRejection = require_globalUnhandledRejection();
    var history = require_history();
    var xhr = require_xhr();
    function addInstrumentationHandler(type, callback) {
      switch (type) {
        case "console":
          return console2.addConsoleInstrumentationHandler(callback);
        case "dom":
          return dom.addClickKeypressInstrumentationHandler(callback);
        case "xhr":
          return xhr.addXhrInstrumentationHandler(callback);
        case "fetch":
          return fetch2.addFetchInstrumentationHandler(callback);
        case "history":
          return history.addHistoryInstrumentationHandler(callback);
        case "error":
          return globalError.addGlobalErrorInstrumentationHandler(callback);
        case "unhandledrejection":
          return globalUnhandledRejection.addGlobalUnhandledRejectionInstrumentationHandler(callback);
        default:
          debugBuild.DEBUG_BUILD && logger.logger.warn("unknown instrumentation type:", type);
      }
    }
    exports.addConsoleInstrumentationHandler = console2.addConsoleInstrumentationHandler;
    exports.addClickKeypressInstrumentationHandler = dom.addClickKeypressInstrumentationHandler;
    exports.addFetchInstrumentationHandler = fetch2.addFetchInstrumentationHandler;
    exports.addGlobalErrorInstrumentationHandler = globalError.addGlobalErrorInstrumentationHandler;
    exports.addGlobalUnhandledRejectionInstrumentationHandler = globalUnhandledRejection.addGlobalUnhandledRejectionInstrumentationHandler;
    exports.addHistoryInstrumentationHandler = history.addHistoryInstrumentationHandler;
    exports.SENTRY_XHR_DATA_KEY = xhr.SENTRY_XHR_DATA_KEY;
    exports.addXhrInstrumentationHandler = xhr.addXhrInstrumentationHandler;
    exports.addInstrumentationHandler = addInstrumentationHandler;
  }
});

// ../../../node_modules/.pnpm/@sentry+utils@7.120.2/node_modules/@sentry/utils/cjs/env.js
var require_env = __commonJS({
  "../../../node_modules/.pnpm/@sentry+utils@7.120.2/node_modules/@sentry/utils/cjs/env.js"(exports) {
    init_define_ENV_DEFINED_IN_BUILD_STEP();
    Object.defineProperty(exports, "__esModule", { value: true });
    function isBrowserBundle() {
      return typeof __SENTRY_BROWSER_BUNDLE__ !== "undefined" && !!__SENTRY_BROWSER_BUNDLE__;
    }
    function getSDKSource() {
      return "npm";
    }
    exports.getSDKSource = getSDKSource;
    exports.isBrowserBundle = isBrowserBundle;
  }
});

// ../../../node_modules/.pnpm/@sentry+utils@7.120.2/node_modules/@sentry/utils/cjs/node.js
var require_node = __commonJS({
  "../../../node_modules/.pnpm/@sentry+utils@7.120.2/node_modules/@sentry/utils/cjs/node.js"(exports, module) {
    init_define_ENV_DEFINED_IN_BUILD_STEP();
    Object.defineProperty(exports, "__esModule", { value: true });
    var env2 = require_env();
    function isNodeEnv() {
      return !env2.isBrowserBundle() && Object.prototype.toString.call(typeof process !== "undefined" ? process : 0) === "[object process]";
    }
    function dynamicRequire(mod, request) {
      return mod.require(request);
    }
    function loadModule(moduleName) {
      let mod;
      try {
        mod = dynamicRequire(module, moduleName);
      } catch (e2) {
      }
      try {
        const { cwd } = dynamicRequire(module, "process");
        mod = dynamicRequire(module, `${cwd()}/node_modules/${moduleName}`);
      } catch (e2) {
      }
      return mod;
    }
    exports.dynamicRequire = dynamicRequire;
    exports.isNodeEnv = isNodeEnv;
    exports.loadModule = loadModule;
  }
});

// ../../../node_modules/.pnpm/@sentry+utils@7.120.2/node_modules/@sentry/utils/cjs/isBrowser.js
var require_isBrowser = __commonJS({
  "../../../node_modules/.pnpm/@sentry+utils@7.120.2/node_modules/@sentry/utils/cjs/isBrowser.js"(exports) {
    init_define_ENV_DEFINED_IN_BUILD_STEP();
    Object.defineProperty(exports, "__esModule", { value: true });
    var node = require_node();
    var worldwide = require_worldwide();
    function isBrowser() {
      return typeof window !== "undefined" && (!node.isNodeEnv() || isElectronNodeRenderer());
    }
    function isElectronNodeRenderer() {
      return (
        // eslint-disable-next-line @typescript-eslint/no-unsafe-member-access, @typescript-eslint/no-explicit-any
        worldwide.GLOBAL_OBJ.process !== void 0 && worldwide.GLOBAL_OBJ.process.type === "renderer"
      );
    }
    exports.isBrowser = isBrowser;
  }
});

// ../../../node_modules/.pnpm/@sentry+utils@7.120.2/node_modules/@sentry/utils/cjs/memo.js
var require_memo = __commonJS({
  "../../../node_modules/.pnpm/@sentry+utils@7.120.2/node_modules/@sentry/utils/cjs/memo.js"(exports) {
    init_define_ENV_DEFINED_IN_BUILD_STEP();
    Object.defineProperty(exports, "__esModule", { value: true });
    function memoBuilder() {
      const hasWeakSet = typeof WeakSet === "function";
      const inner = hasWeakSet ? /* @__PURE__ */ new WeakSet() : [];
      function memoize2(obj) {
        if (hasWeakSet) {
          if (inner.has(obj)) {
            return true;
          }
          inner.add(obj);
          return false;
        }
        for (let i2 = 0; i2 < inner.length; i2++) {
          const value = inner[i2];
          if (value === obj) {
            return true;
          }
        }
        inner.push(obj);
        return false;
      }
      function unmemoize(obj) {
        if (hasWeakSet) {
          inner.delete(obj);
        } else {
          for (let i2 = 0; i2 < inner.length; i2++) {
            if (inner[i2] === obj) {
              inner.splice(i2, 1);
              break;
            }
          }
        }
      }
      return [memoize2, unmemoize];
    }
    exports.memoBuilder = memoBuilder;
  }
});

// ../../../node_modules/.pnpm/@sentry+utils@7.120.2/node_modules/@sentry/utils/cjs/normalize.js
var require_normalize = __commonJS({
  "../../../node_modules/.pnpm/@sentry+utils@7.120.2/node_modules/@sentry/utils/cjs/normalize.js"(exports) {
    init_define_ENV_DEFINED_IN_BUILD_STEP();
    Object.defineProperty(exports, "__esModule", { value: true });
    var is = require_is();
    var memo = require_memo();
    var object = require_object();
    var stacktrace = require_stacktrace();
    function normalize(input, depth = 100, maxProperties = Infinity) {
      try {
        return visit("", input, depth, maxProperties);
      } catch (err) {
        return { ERROR: `**non-serializable** (${err})` };
      }
    }
    function normalizeToSize(object2, depth = 3, maxSize = 100 * 1024) {
      const normalized = normalize(object2, depth);
      if (jsonSize(normalized) > maxSize) {
        return normalizeToSize(object2, depth - 1, maxSize);
      }
      return normalized;
    }
    function visit(key, value, depth = Infinity, maxProperties = Infinity, memo$1 = memo.memoBuilder()) {
      const [memoize2, unmemoize] = memo$1;
      if (value == null || // this matches null and undefined -> eqeq not eqeqeq
      ["number", "boolean", "string"].includes(typeof value) && !is.isNaN(value)) {
        return value;
      }
      const stringified = stringifyValue(key, value);
      if (!stringified.startsWith("[object ")) {
        return stringified;
      }
      if (value["__sentry_skip_normalization__"]) {
        return value;
      }
      const remainingDepth = typeof value["__sentry_override_normalization_depth__"] === "number" ? value["__sentry_override_normalization_depth__"] : depth;
      if (remainingDepth === 0) {
        return stringified.replace("object ", "");
      }
      if (memoize2(value)) {
        return "[Circular ~]";
      }
      const valueWithToJSON = value;
      if (valueWithToJSON && typeof valueWithToJSON.toJSON === "function") {
        try {
          const jsonValue = valueWithToJSON.toJSON();
          return visit("", jsonValue, remainingDepth - 1, maxProperties, memo$1);
        } catch (err) {
        }
      }
      const normalized = Array.isArray(value) ? [] : {};
      let numAdded = 0;
      const visitable = object.convertToPlainObject(value);
      for (const visitKey in visitable) {
        if (!Object.prototype.hasOwnProperty.call(visitable, visitKey)) {
          continue;
        }
        if (numAdded >= maxProperties) {
          normalized[visitKey] = "[MaxProperties ~]";
          break;
        }
        const visitValue = visitable[visitKey];
        normalized[visitKey] = visit(visitKey, visitValue, remainingDepth - 1, maxProperties, memo$1);
        numAdded++;
      }
      unmemoize(value);
      return normalized;
    }
    function stringifyValue(key, value) {
      try {
        if (key === "domain" && value && typeof value === "object" && value._events) {
          return "[Domain]";
        }
        if (key === "domainEmitter") {
          return "[DomainEmitter]";
        }
        if (typeof global !== "undefined" && value === global) {
          return "[Global]";
        }
        if (typeof window !== "undefined" && value === window) {
          return "[Window]";
        }
        if (typeof document !== "undefined" && value === document) {
          return "[Document]";
        }
        if (is.isVueViewModel(value)) {
          return "[VueViewModel]";
        }
        if (is.isSyntheticEvent(value)) {
          return "[SyntheticEvent]";
        }
        if (typeof value === "number" && value !== value) {
          return "[NaN]";
        }
        if (typeof value === "function") {
          return `[Function: ${stacktrace.getFunctionName(value)}]`;
        }
        if (typeof value === "symbol") {
          return `[${String(value)}]`;
        }
        if (typeof value === "bigint") {
          return `[BigInt: ${String(value)}]`;
        }
        const objName = getConstructorName(value);
        if (/^HTML(\w*)Element$/.test(objName)) {
          return `[HTMLElement: ${objName}]`;
        }
        return `[object ${objName}]`;
      } catch (err) {
        return `**non-serializable** (${err})`;
      }
    }
    function getConstructorName(value) {
      const prototype = Object.getPrototypeOf(value);
      return prototype ? prototype.constructor.name : "null prototype";
    }
    function utf8Length(value) {
      return ~-encodeURI(value).split(/%..|./).length;
    }
    function jsonSize(value) {
      return utf8Length(JSON.stringify(value));
    }
    function normalizeUrlToBase(url, basePath) {
      const escapedBase = basePath.replace(/\\/g, "/").replace(/[|\\{}()[\]^$+*?.]/g, "\\$&");
      let newUrl = url;
      try {
        newUrl = decodeURI(url);
      } catch (_Oo) {
      }
      return newUrl.replace(/\\/g, "/").replace(/webpack:\/?/g, "").replace(new RegExp(`(file://)?/*${escapedBase}/*`, "ig"), "app:///");
    }
    exports.normalize = normalize;
    exports.normalizeToSize = normalizeToSize;
    exports.normalizeUrlToBase = normalizeUrlToBase;
    exports.walk = visit;
  }
});

// ../../../node_modules/.pnpm/@sentry+utils@7.120.2/node_modules/@sentry/utils/cjs/path.js
var require_path = __commonJS({
  "../../../node_modules/.pnpm/@sentry+utils@7.120.2/node_modules/@sentry/utils/cjs/path.js"(exports) {
    init_define_ENV_DEFINED_IN_BUILD_STEP();
    Object.defineProperty(exports, "__esModule", { value: true });
    function normalizeArray(parts, allowAboveRoot) {
      let up = 0;
      for (let i2 = parts.length - 1; i2 >= 0; i2--) {
        const last = parts[i2];
        if (last === ".") {
          parts.splice(i2, 1);
        } else if (last === "..") {
          parts.splice(i2, 1);
          up++;
        } else if (up) {
          parts.splice(i2, 1);
          up--;
        }
      }
      if (allowAboveRoot) {
        for (; up--; up) {
          parts.unshift("..");
        }
      }
      return parts;
    }
    var splitPathRe = /^(\S+:\\|\/?)([\s\S]*?)((?:\.{1,2}|[^/\\]+?|)(\.[^./\\]*|))(?:[/\\]*)$/;
    function splitPath(filename) {
      const truncated = filename.length > 1024 ? `<truncated>${filename.slice(-1024)}` : filename;
      const parts = splitPathRe.exec(truncated);
      return parts ? parts.slice(1) : [];
    }
    function resolve2(...args) {
      let resolvedPath = "";
      let resolvedAbsolute = false;
      for (let i2 = args.length - 1; i2 >= -1 && !resolvedAbsolute; i2--) {
        const path2 = i2 >= 0 ? args[i2] : "/";
        if (!path2) {
          continue;
        }
        resolvedPath = `${path2}/${resolvedPath}`;
        resolvedAbsolute = path2.charAt(0) === "/";
      }
      resolvedPath = normalizeArray(
        resolvedPath.split("/").filter((p3) => !!p3),
        !resolvedAbsolute
      ).join("/");
      return (resolvedAbsolute ? "/" : "") + resolvedPath || ".";
    }
    function trim4(arr) {
      let start = 0;
      for (; start < arr.length; start++) {
        if (arr[start] !== "") {
          break;
        }
      }
      let end = arr.length - 1;
      for (; end >= 0; end--) {
        if (arr[end] !== "") {
          break;
        }
      }
      if (start > end) {
        return [];
      }
      return arr.slice(start, end - start + 1);
    }
    function relative(from, to) {
      from = resolve2(from).slice(1);
      to = resolve2(to).slice(1);
      const fromParts = trim4(from.split("/"));
      const toParts = trim4(to.split("/"));
      const length = Math.min(fromParts.length, toParts.length);
      let samePartsLength = length;
      for (let i2 = 0; i2 < length; i2++) {
        if (fromParts[i2] !== toParts[i2]) {
          samePartsLength = i2;
          break;
        }
      }
      let outputParts = [];
      for (let i2 = samePartsLength; i2 < fromParts.length; i2++) {
        outputParts.push("..");
      }
      outputParts = outputParts.concat(toParts.slice(samePartsLength));
      return outputParts.join("/");
    }
    function normalizePath(path2) {
      const isPathAbsolute = isAbsolute(path2);
      const trailingSlash = path2.slice(-1) === "/";
      let normalizedPath = normalizeArray(
        path2.split("/").filter((p3) => !!p3),
        !isPathAbsolute
      ).join("/");
      if (!normalizedPath && !isPathAbsolute) {
        normalizedPath = ".";
      }
      if (normalizedPath && trailingSlash) {
        normalizedPath += "/";
      }
      return (isPathAbsolute ? "/" : "") + normalizedPath;
    }
    function isAbsolute(path2) {
      return path2.charAt(0) === "/";
    }
    function join(...args) {
      return normalizePath(args.join("/"));
    }
    function dirname(path2) {
      const result = splitPath(path2);
      const root = result[0];
      let dir = result[1];
      if (!root && !dir) {
        return ".";
      }
      if (dir) {
        dir = dir.slice(0, dir.length - 1);
      }
      return root + dir;
    }
    function basename(path2, ext) {
      let f2 = splitPath(path2)[2];
      if (ext && f2.slice(ext.length * -1) === ext) {
        f2 = f2.slice(0, f2.length - ext.length);
      }
      return f2;
    }
    exports.basename = basename;
    exports.dirname = dirname;
    exports.isAbsolute = isAbsolute;
    exports.join = join;
    exports.normalizePath = normalizePath;
    exports.relative = relative;
    exports.resolve = resolve2;
  }
});

// ../../../node_modules/.pnpm/@sentry+utils@7.120.2/node_modules/@sentry/utils/cjs/syncpromise.js
var require_syncpromise = __commonJS({
  "../../../node_modules/.pnpm/@sentry+utils@7.120.2/node_modules/@sentry/utils/cjs/syncpromise.js"(exports) {
    init_define_ENV_DEFINED_IN_BUILD_STEP();
    Object.defineProperty(exports, "__esModule", { value: true });
    var is = require_is();
    var States;
    (function(States2) {
      const PENDING = 0;
      States2[States2["PENDING"] = PENDING] = "PENDING";
      const RESOLVED = 1;
      States2[States2["RESOLVED"] = RESOLVED] = "RESOLVED";
      const REJECTED = 2;
      States2[States2["REJECTED"] = REJECTED] = "REJECTED";
    })(States || (States = {}));
    function resolvedSyncPromise(value) {
      return new SyncPromise((resolve2) => {
        resolve2(value);
      });
    }
    function rejectedSyncPromise(reason) {
      return new SyncPromise((_3, reject) => {
        reject(reason);
      });
    }
    var SyncPromise = class _SyncPromise {
      constructor(executor) {
        _SyncPromise.prototype.__init.call(this);
        _SyncPromise.prototype.__init2.call(this);
        _SyncPromise.prototype.__init3.call(this);
        _SyncPromise.prototype.__init4.call(this);
        this._state = States.PENDING;
        this._handlers = [];
        try {
          executor(this._resolve, this._reject);
        } catch (e2) {
          this._reject(e2);
        }
      }
      /** JSDoc */
      then(onfulfilled, onrejected) {
        return new _SyncPromise((resolve2, reject) => {
          this._handlers.push([
            false,
            (result) => {
              if (!onfulfilled) {
                resolve2(result);
              } else {
                try {
                  resolve2(onfulfilled(result));
                } catch (e2) {
                  reject(e2);
                }
              }
            },
            (reason) => {
              if (!onrejected) {
                reject(reason);
              } else {
                try {
                  resolve2(onrejected(reason));
                } catch (e2) {
                  reject(e2);
                }
              }
            }
          ]);
          this._executeHandlers();
        });
      }
      /** JSDoc */
      catch(onrejected) {
        return this.then((val) => val, onrejected);
      }
      /** JSDoc */
      finally(onfinally) {
        return new _SyncPromise((resolve2, reject) => {
          let val;
          let isRejected;
          return this.then(
            (value) => {
              isRejected = false;
              val = value;
              if (onfinally) {
                onfinally();
              }
            },
            (reason) => {
              isRejected = true;
              val = reason;
              if (onfinally) {
                onfinally();
              }
            }
          ).then(() => {
            if (isRejected) {
              reject(val);
              return;
            }
            resolve2(val);
          });
        });
      }
      /** JSDoc */
      __init() {
        this._resolve = (value) => {
          this._setResult(States.RESOLVED, value);
        };
      }
      /** JSDoc */
      __init2() {
        this._reject = (reason) => {
          this._setResult(States.REJECTED, reason);
        };
      }
      /** JSDoc */
      __init3() {
        this._setResult = (state, value) => {
          if (this._state !== States.PENDING) {
            return;
          }
          if (is.isThenable(value)) {
            void value.then(this._resolve, this._reject);
            return;
          }
          this._state = state;
          this._value = value;
          this._executeHandlers();
        };
      }
      /** JSDoc */
      __init4() {
        this._executeHandlers = () => {
          if (this._state === States.PENDING) {
            return;
          }
          const cachedHandlers = this._handlers.slice();
          this._handlers = [];
          cachedHandlers.forEach((handler) => {
            if (handler[0]) {
              return;
            }
            if (this._state === States.RESOLVED) {
              handler[1](this._value);
            }
            if (this._state === States.REJECTED) {
              handler[2](this._value);
            }
            handler[0] = true;
          });
        };
      }
    };
    exports.SyncPromise = SyncPromise;
    exports.rejectedSyncPromise = rejectedSyncPromise;
    exports.resolvedSyncPromise = resolvedSyncPromise;
  }
});

// ../../../node_modules/.pnpm/@sentry+utils@7.120.2/node_modules/@sentry/utils/cjs/promisebuffer.js
var require_promisebuffer = __commonJS({
  "../../../node_modules/.pnpm/@sentry+utils@7.120.2/node_modules/@sentry/utils/cjs/promisebuffer.js"(exports) {
    init_define_ENV_DEFINED_IN_BUILD_STEP();
    Object.defineProperty(exports, "__esModule", { value: true });
    var error = require_error2();
    var syncpromise = require_syncpromise();
    function makePromiseBuffer(limit) {
      const buffer = [];
      function isReady() {
        return limit === void 0 || buffer.length < limit;
      }
      function remove(task) {
        return buffer.splice(buffer.indexOf(task), 1)[0];
      }
      function add(taskProducer) {
        if (!isReady()) {
          return syncpromise.rejectedSyncPromise(new error.SentryError("Not adding Promise because buffer limit was reached."));
        }
        const task = taskProducer();
        if (buffer.indexOf(task) === -1) {
          buffer.push(task);
        }
        void task.then(() => remove(task)).then(
          null,
          () => remove(task).then(null, () => {
          })
        );
        return task;
      }
      function drain(timeout) {
        return new syncpromise.SyncPromise((resolve2, reject) => {
          let counter = buffer.length;
          if (!counter) {
            return resolve2(true);
          }
          const capturedSetTimeout = setTimeout(() => {
            if (timeout && timeout > 0) {
              resolve2(false);
            }
          }, timeout);
          buffer.forEach((item) => {
            void syncpromise.resolvedSyncPromise(item).then(() => {
              if (!--counter) {
                clearTimeout(capturedSetTimeout);
                resolve2(true);
              }
            }, reject);
          });
        });
      }
      return {
        $: buffer,
        add,
        drain
      };
    }
    exports.makePromiseBuffer = makePromiseBuffer;
  }
});

// ../../../node_modules/.pnpm/@sentry+utils@7.120.2/node_modules/@sentry/utils/cjs/cookie.js
var require_cookie = __commonJS({
  "../../../node_modules/.pnpm/@sentry+utils@7.120.2/node_modules/@sentry/utils/cjs/cookie.js"(exports) {
    init_define_ENV_DEFINED_IN_BUILD_STEP();
    Object.defineProperty(exports, "__esModule", { value: true });
    function parseCookie(str) {
      const obj = {};
      let index = 0;
      while (index < str.length) {
        const eqIdx = str.indexOf("=", index);
        if (eqIdx === -1) {
          break;
        }
        let endIdx = str.indexOf(";", index);
        if (endIdx === -1) {
          endIdx = str.length;
        } else if (endIdx < eqIdx) {
          index = str.lastIndexOf(";", eqIdx - 1) + 1;
          continue;
        }
        const key = str.slice(index, eqIdx).trim();
        if (void 0 === obj[key]) {
          let val = str.slice(eqIdx + 1, endIdx).trim();
          if (val.charCodeAt(0) === 34) {
            val = val.slice(1, -1);
          }
          try {
            obj[key] = val.indexOf("%") !== -1 ? decodeURIComponent(val) : val;
          } catch (e2) {
            obj[key] = val;
          }
        }
        index = endIdx + 1;
      }
      return obj;
    }
    exports.parseCookie = parseCookie;
  }
});

// ../../../node_modules/.pnpm/@sentry+utils@7.120.2/node_modules/@sentry/utils/cjs/url.js
var require_url = __commonJS({
  "../../../node_modules/.pnpm/@sentry+utils@7.120.2/node_modules/@sentry/utils/cjs/url.js"(exports) {
    init_define_ENV_DEFINED_IN_BUILD_STEP();
    Object.defineProperty(exports, "__esModule", { value: true });
    function parseUrl(url) {
      if (!url) {
        return {};
      }
      const match = url.match(/^(([^:/?#]+):)?(\/\/([^/?#]*))?([^?#]*)(\?([^#]*))?(#(.*))?$/);
      if (!match) {
        return {};
      }
      const query = match[6] || "";
      const fragment = match[8] || "";
      return {
        host: match[4],
        path: match[5],
        protocol: match[2],
        search: query,
        hash: fragment,
        relative: match[5] + query + fragment
        // everything minus origin
      };
    }
    function stripUrlQueryAndFragment(urlPath) {
      return urlPath.split(/[\?#]/, 1)[0];
    }
    function getNumberOfUrlSegments(url) {
      return url.split(/\\?\//).filter((s2) => s2.length > 0 && s2 !== ",").length;
    }
    function getSanitizedUrlString(url) {
      const { protocol, host, path: path2 } = url;
      const filteredHost = host && host.replace(/^.*@/, "[filtered]:[filtered]@").replace(/(:80)$/, "").replace(/(:443)$/, "") || "";
      return `${protocol ? `${protocol}://` : ""}${filteredHost}${path2}`;
    }
    exports.getNumberOfUrlSegments = getNumberOfUrlSegments;
    exports.getSanitizedUrlString = getSanitizedUrlString;
    exports.parseUrl = parseUrl;
    exports.stripUrlQueryAndFragment = stripUrlQueryAndFragment;
  }
});

// ../../../node_modules/.pnpm/@sentry+utils@7.120.2/node_modules/@sentry/utils/cjs/requestdata.js
var require_requestdata = __commonJS({
  "../../../node_modules/.pnpm/@sentry+utils@7.120.2/node_modules/@sentry/utils/cjs/requestdata.js"(exports) {
    init_define_ENV_DEFINED_IN_BUILD_STEP();
    Object.defineProperty(exports, "__esModule", { value: true });
    var cookie = require_cookie();
    var debugBuild = require_debug_build();
    var is = require_is();
    var logger = require_logger();
    var normalize = require_normalize();
    var url = require_url();
    var DEFAULT_INCLUDES = {
      ip: false,
      request: true,
      transaction: true,
      user: true
    };
    var DEFAULT_REQUEST_INCLUDES = ["cookies", "data", "headers", "method", "query_string", "url"];
    var DEFAULT_USER_INCLUDES = ["id", "username", "email"];
    function addRequestDataToTransaction(transaction, req, deps) {
      if (!transaction)
        return;
      if (!transaction.metadata.source || transaction.metadata.source === "url") {
        const [name, source] = extractPathForTransaction(req, { path: true, method: true });
        transaction.updateName(name);
        transaction.setMetadata({ source });
      }
      transaction.setAttribute("url", req.originalUrl || req.url);
      if (req.baseUrl) {
        transaction.setAttribute("baseUrl", req.baseUrl);
      }
      transaction.setData("query", extractQueryParams(req, deps));
    }
    function extractPathForTransaction(req, options = {}) {
      const method = req.method && req.method.toUpperCase();
      let path2 = "";
      let source = "url";
      if (options.customRoute || req.route) {
        path2 = options.customRoute || `${req.baseUrl || ""}${req.route && req.route.path}`;
        source = "route";
      } else if (req.originalUrl || req.url) {
        path2 = url.stripUrlQueryAndFragment(req.originalUrl || req.url || "");
      }
      let name = "";
      if (options.method && method) {
        name += method;
      }
      if (options.method && options.path) {
        name += " ";
      }
      if (options.path && path2) {
        name += path2;
      }
      return [name, source];
    }
    function extractTransaction(req, type) {
      switch (type) {
        case "path": {
          return extractPathForTransaction(req, { path: true })[0];
        }
        case "handler": {
          return req.route && req.route.stack && req.route.stack[0] && req.route.stack[0].name || "<anonymous>";
        }
        case "methodPath":
        default: {
          const customRoute = req._reconstructedRoute ? req._reconstructedRoute : void 0;
          return extractPathForTransaction(req, { path: true, method: true, customRoute })[0];
        }
      }
    }
    function extractUserData(user, keys) {
      const extractedUser = {};
      const attributes = Array.isArray(keys) ? keys : DEFAULT_USER_INCLUDES;
      attributes.forEach((key) => {
        if (user && key in user) {
          extractedUser[key] = user[key];
        }
      });
      return extractedUser;
    }
    function extractRequestData(req, options) {
      const { include = DEFAULT_REQUEST_INCLUDES, deps } = options || {};
      const requestData = {};
      const headers = req.headers || {};
      const method = req.method;
      const host = headers.host || req.hostname || req.host || "<no host>";
      const protocol = req.protocol === "https" || req.socket && req.socket.encrypted ? "https" : "http";
      const originalUrl = req.originalUrl || req.url || "";
      const absoluteUrl = originalUrl.startsWith(protocol) ? originalUrl : `${protocol}://${host}${originalUrl}`;
      include.forEach((key) => {
        switch (key) {
          case "headers": {
            requestData.headers = headers;
            if (!include.includes("cookies")) {
              delete requestData.headers.cookie;
            }
            break;
          }
          case "method": {
            requestData.method = method;
            break;
          }
          case "url": {
            requestData.url = absoluteUrl;
            break;
          }
          case "cookies": {
            requestData.cookies = // TODO (v8 / #5257): We're only sending the empty object for backwards compatibility, so the last bit can
            // come off in v8
            req.cookies || headers.cookie && cookie.parseCookie(headers.cookie) || {};
            break;
          }
          case "query_string": {
            requestData.query_string = extractQueryParams(req, deps);
            break;
          }
          case "data": {
            if (method === "GET" || method === "HEAD") {
              break;
            }
            if (req.body !== void 0) {
              requestData.data = is.isString(req.body) ? req.body : JSON.stringify(normalize.normalize(req.body));
            }
            break;
          }
          default: {
            if ({}.hasOwnProperty.call(req, key)) {
              requestData[key] = req[key];
            }
          }
        }
      });
      return requestData;
    }
    function addRequestDataToEvent(event, req, options) {
      const include = {
        ...DEFAULT_INCLUDES,
        ...options && options.include
      };
      if (include.request) {
        const extractedRequestData = Array.isArray(include.request) ? extractRequestData(req, { include: include.request, deps: options && options.deps }) : extractRequestData(req, { deps: options && options.deps });
        event.request = {
          ...event.request,
          ...extractedRequestData
        };
      }
      if (include.user) {
        const extractedUser = req.user && is.isPlainObject(req.user) ? extractUserData(req.user, include.user) : {};
        if (Object.keys(extractedUser).length) {
          event.user = {
            ...event.user,
            ...extractedUser
          };
        }
      }
      if (include.ip) {
        const ip = req.ip || req.socket && req.socket.remoteAddress;
        if (ip) {
          event.user = {
            ...event.user,
            ip_address: ip
          };
        }
      }
      if (include.transaction && !event.transaction) {
        event.transaction = extractTransaction(req, include.transaction);
      }
      return event;
    }
    function extractQueryParams(req, deps) {
      let originalUrl = req.originalUrl || req.url || "";
      if (!originalUrl) {
        return;
      }
      if (originalUrl.startsWith("/")) {
        originalUrl = `http://dogs.are.great${originalUrl}`;
      }
      try {
        return req.query || typeof URL !== "undefined" && new URL(originalUrl).search.slice(1) || // In Node 8, `URL` isn't in the global scope, so we have to use the built-in module from Node
        deps && deps.url && deps.url.parse(originalUrl).query || void 0;
      } catch (e2) {
        return void 0;
      }
    }
    function winterCGHeadersToDict(winterCGHeaders) {
      const headers = {};
      try {
        winterCGHeaders.forEach((value, key) => {
          if (typeof value === "string") {
            headers[key] = value;
          }
        });
      } catch (e2) {
        debugBuild.DEBUG_BUILD && logger.logger.warn("Sentry failed extracting headers from a request object. If you see this, please file an issue.");
      }
      return headers;
    }
    function winterCGRequestToRequestData(req) {
      const headers = winterCGHeadersToDict(req.headers);
      return {
        method: req.method,
        url: req.url,
        headers
      };
    }
    exports.DEFAULT_USER_INCLUDES = DEFAULT_USER_INCLUDES;
    exports.addRequestDataToEvent = addRequestDataToEvent;
    exports.addRequestDataToTransaction = addRequestDataToTransaction;
    exports.extractPathForTransaction = extractPathForTransaction;
    exports.extractRequestData = extractRequestData;
    exports.winterCGHeadersToDict = winterCGHeadersToDict;
    exports.winterCGRequestToRequestData = winterCGRequestToRequestData;
  }
});

// ../../../node_modules/.pnpm/@sentry+utils@7.120.2/node_modules/@sentry/utils/cjs/severity.js
var require_severity = __commonJS({
  "../../../node_modules/.pnpm/@sentry+utils@7.120.2/node_modules/@sentry/utils/cjs/severity.js"(exports) {
    init_define_ENV_DEFINED_IN_BUILD_STEP();
    Object.defineProperty(exports, "__esModule", { value: true });
    var validSeverityLevels = ["fatal", "error", "warning", "log", "info", "debug"];
    function severityFromString(level) {
      return severityLevelFromString(level);
    }
    function severityLevelFromString(level) {
      return level === "warn" ? "warning" : validSeverityLevels.includes(level) ? level : "log";
    }
    exports.severityFromString = severityFromString;
    exports.severityLevelFromString = severityLevelFromString;
    exports.validSeverityLevels = validSeverityLevels;
  }
});

// ../../../node_modules/.pnpm/@sentry+utils@7.120.2/node_modules/@sentry/utils/cjs/time.js
var require_time = __commonJS({
  "../../../node_modules/.pnpm/@sentry+utils@7.120.2/node_modules/@sentry/utils/cjs/time.js"(exports) {
    init_define_ENV_DEFINED_IN_BUILD_STEP();
    Object.defineProperty(exports, "__esModule", { value: true });
    var worldwide = require_worldwide();
    var ONE_SECOND_IN_MS = 1e3;
    function dateTimestampInSeconds() {
      return Date.now() / ONE_SECOND_IN_MS;
    }
    function createUnixTimestampInSecondsFunc() {
      const { performance: performance2 } = worldwide.GLOBAL_OBJ;
      if (!performance2 || !performance2.now) {
        return dateTimestampInSeconds;
      }
      const approxStartingTimeOrigin = Date.now() - performance2.now();
      const timeOrigin = performance2.timeOrigin == void 0 ? approxStartingTimeOrigin : performance2.timeOrigin;
      return () => {
        return (timeOrigin + performance2.now()) / ONE_SECOND_IN_MS;
      };
    }
    var timestampInSeconds = createUnixTimestampInSecondsFunc();
    var timestampWithMs = timestampInSeconds;
    exports._browserPerformanceTimeOriginMode = void 0;
    var browserPerformanceTimeOrigin = (() => {
      const { performance: performance2 } = worldwide.GLOBAL_OBJ;
      if (!performance2 || !performance2.now) {
        exports._browserPerformanceTimeOriginMode = "none";
        return void 0;
      }
      const threshold = 3600 * 1e3;
      const performanceNow2 = performance2.now();
      const dateNow = Date.now();
      const timeOriginDelta = performance2.timeOrigin ? Math.abs(performance2.timeOrigin + performanceNow2 - dateNow) : threshold;
      const timeOriginIsReliable = timeOriginDelta < threshold;
      const navigationStart = performance2.timing && performance2.timing.navigationStart;
      const hasNavigationStart = typeof navigationStart === "number";
      const navigationStartDelta = hasNavigationStart ? Math.abs(navigationStart + performanceNow2 - dateNow) : threshold;
      const navigationStartIsReliable = navigationStartDelta < threshold;
      if (timeOriginIsReliable || navigationStartIsReliable) {
        if (timeOriginDelta <= navigationStartDelta) {
          exports._browserPerformanceTimeOriginMode = "timeOrigin";
          return performance2.timeOrigin;
        } else {
          exports._browserPerformanceTimeOriginMode = "navigationStart";
          return navigationStart;
        }
      }
      exports._browserPerformanceTimeOriginMode = "dateNow";
      return dateNow;
    })();
    exports.browserPerformanceTimeOrigin = browserPerformanceTimeOrigin;
    exports.dateTimestampInSeconds = dateTimestampInSeconds;
    exports.timestampInSeconds = timestampInSeconds;
    exports.timestampWithMs = timestampWithMs;
  }
});

// ../../../node_modules/.pnpm/@sentry+utils@7.120.2/node_modules/@sentry/utils/cjs/baggage.js
var require_baggage = __commonJS({
  "../../../node_modules/.pnpm/@sentry+utils@7.120.2/node_modules/@sentry/utils/cjs/baggage.js"(exports) {
    init_define_ENV_DEFINED_IN_BUILD_STEP();
    Object.defineProperty(exports, "__esModule", { value: true });
    var debugBuild = require_debug_build();
    var is = require_is();
    var logger = require_logger();
    var BAGGAGE_HEADER_NAME = "baggage";
    var SENTRY_BAGGAGE_KEY_PREFIX = "sentry-";
    var SENTRY_BAGGAGE_KEY_PREFIX_REGEX = /^sentry-/;
    var MAX_BAGGAGE_STRING_LENGTH = 8192;
    function baggageHeaderToDynamicSamplingContext(baggageHeader) {
      if (!is.isString(baggageHeader) && !Array.isArray(baggageHeader)) {
        return void 0;
      }
      let baggageObject = {};
      if (Array.isArray(baggageHeader)) {
        baggageObject = baggageHeader.reduce((acc, curr) => {
          const currBaggageObject = baggageHeaderToObject(curr);
          for (const key of Object.keys(currBaggageObject)) {
            acc[key] = currBaggageObject[key];
          }
          return acc;
        }, {});
      } else {
        if (!baggageHeader) {
          return void 0;
        }
        baggageObject = baggageHeaderToObject(baggageHeader);
      }
      const dynamicSamplingContext = Object.entries(baggageObject).reduce((acc, [key, value]) => {
        if (key.match(SENTRY_BAGGAGE_KEY_PREFIX_REGEX)) {
          const nonPrefixedKey = key.slice(SENTRY_BAGGAGE_KEY_PREFIX.length);
          acc[nonPrefixedKey] = value;
        }
        return acc;
      }, {});
      if (Object.keys(dynamicSamplingContext).length > 0) {
        return dynamicSamplingContext;
      } else {
        return void 0;
      }
    }
    function dynamicSamplingContextToSentryBaggageHeader(dynamicSamplingContext) {
      if (!dynamicSamplingContext) {
        return void 0;
      }
      const sentryPrefixedDSC = Object.entries(dynamicSamplingContext).reduce(
        (acc, [dscKey, dscValue]) => {
          if (dscValue) {
            acc[`${SENTRY_BAGGAGE_KEY_PREFIX}${dscKey}`] = dscValue;
          }
          return acc;
        },
        {}
      );
      return objectToBaggageHeader(sentryPrefixedDSC);
    }
    function baggageHeaderToObject(baggageHeader) {
      return baggageHeader.split(",").map((baggageEntry) => baggageEntry.split("=").map((keyOrValue) => decodeURIComponent(keyOrValue.trim()))).reduce((acc, [key, value]) => {
        acc[key] = value;
        return acc;
      }, {});
    }
    function objectToBaggageHeader(object) {
      if (Object.keys(object).length === 0) {
        return void 0;
      }
      return Object.entries(object).reduce((baggageHeader, [objectKey, objectValue], currentIndex) => {
        const baggageEntry = `${encodeURIComponent(objectKey)}=${encodeURIComponent(objectValue)}`;
        const newBaggageHeader = currentIndex === 0 ? baggageEntry : `${baggageHeader},${baggageEntry}`;
        if (newBaggageHeader.length > MAX_BAGGAGE_STRING_LENGTH) {
          debugBuild.DEBUG_BUILD && logger.logger.warn(
            `Not adding key: ${objectKey} with val: ${objectValue} to baggage header due to exceeding baggage size limits.`
          );
          return baggageHeader;
        } else {
          return newBaggageHeader;
        }
      }, "");
    }
    exports.BAGGAGE_HEADER_NAME = BAGGAGE_HEADER_NAME;
    exports.MAX_BAGGAGE_STRING_LENGTH = MAX_BAGGAGE_STRING_LENGTH;
    exports.SENTRY_BAGGAGE_KEY_PREFIX = SENTRY_BAGGAGE_KEY_PREFIX;
    exports.SENTRY_BAGGAGE_KEY_PREFIX_REGEX = SENTRY_BAGGAGE_KEY_PREFIX_REGEX;
    exports.baggageHeaderToDynamicSamplingContext = baggageHeaderToDynamicSamplingContext;
    exports.dynamicSamplingContextToSentryBaggageHeader = dynamicSamplingContextToSentryBaggageHeader;
  }
});

// ../../../node_modules/.pnpm/@sentry+utils@7.120.2/node_modules/@sentry/utils/cjs/tracing.js
var require_tracing = __commonJS({
  "../../../node_modules/.pnpm/@sentry+utils@7.120.2/node_modules/@sentry/utils/cjs/tracing.js"(exports) {
    init_define_ENV_DEFINED_IN_BUILD_STEP();
    Object.defineProperty(exports, "__esModule", { value: true });
    var baggage = require_baggage();
    var misc = require_misc();
    var TRACEPARENT_REGEXP = new RegExp(
      "^[ \\t]*([0-9a-f]{32})?-?([0-9a-f]{16})?-?([01])?[ \\t]*$"
      // whitespace
    );
    function extractTraceparentData(traceparent) {
      if (!traceparent) {
        return void 0;
      }
      const matches = traceparent.match(TRACEPARENT_REGEXP);
      if (!matches) {
        return void 0;
      }
      let parentSampled;
      if (matches[3] === "1") {
        parentSampled = true;
      } else if (matches[3] === "0") {
        parentSampled = false;
      }
      return {
        traceId: matches[1],
        parentSampled,
        parentSpanId: matches[2]
      };
    }
    function tracingContextFromHeaders(sentryTrace, baggage$1) {
      const traceparentData = extractTraceparentData(sentryTrace);
      const dynamicSamplingContext = baggage.baggageHeaderToDynamicSamplingContext(baggage$1);
      const { traceId, parentSpanId, parentSampled } = traceparentData || {};
      if (!traceparentData) {
        return {
          traceparentData,
          dynamicSamplingContext: void 0,
          propagationContext: {
            traceId: traceId || misc.uuid4(),
            spanId: misc.uuid4().substring(16)
          }
        };
      } else {
        return {
          traceparentData,
          dynamicSamplingContext: dynamicSamplingContext || {},
          // If we have traceparent data but no DSC it means we are not head of trace and we must freeze it
          propagationContext: {
            traceId: traceId || misc.uuid4(),
            parentSpanId: parentSpanId || misc.uuid4().substring(16),
            spanId: misc.uuid4().substring(16),
            sampled: parentSampled,
            dsc: dynamicSamplingContext || {}
            // If we have traceparent data but no DSC it means we are not head of trace and we must freeze it
          }
        };
      }
    }
    function propagationContextFromHeaders(sentryTrace, baggage$1) {
      const traceparentData = extractTraceparentData(sentryTrace);
      const dynamicSamplingContext = baggage.baggageHeaderToDynamicSamplingContext(baggage$1);
      const { traceId, parentSpanId, parentSampled } = traceparentData || {};
      if (!traceparentData) {
        return {
          traceId: traceId || misc.uuid4(),
          spanId: misc.uuid4().substring(16)
        };
      } else {
        return {
          traceId: traceId || misc.uuid4(),
          parentSpanId: parentSpanId || misc.uuid4().substring(16),
          spanId: misc.uuid4().substring(16),
          sampled: parentSampled,
          dsc: dynamicSamplingContext || {}
          // If we have traceparent data but no DSC it means we are not head of trace and we must freeze it
        };
      }
    }
    function generateSentryTraceHeader(traceId = misc.uuid4(), spanId = misc.uuid4().substring(16), sampled) {
      let sampledString = "";
      if (sampled !== void 0) {
        sampledString = sampled ? "-1" : "-0";
      }
      return `${traceId}-${spanId}${sampledString}`;
    }
    exports.TRACEPARENT_REGEXP = TRACEPARENT_REGEXP;
    exports.extractTraceparentData = extractTraceparentData;
    exports.generateSentryTraceHeader = generateSentryTraceHeader;
    exports.propagationContextFromHeaders = propagationContextFromHeaders;
    exports.tracingContextFromHeaders = tracingContextFromHeaders;
  }
});

// ../../../node_modules/.pnpm/@sentry+utils@7.120.2/node_modules/@sentry/utils/cjs/envelope.js
var require_envelope = __commonJS({
  "../../../node_modules/.pnpm/@sentry+utils@7.120.2/node_modules/@sentry/utils/cjs/envelope.js"(exports) {
    init_define_ENV_DEFINED_IN_BUILD_STEP();
    Object.defineProperty(exports, "__esModule", { value: true });
    var dsn = require_dsn();
    var normalize = require_normalize();
    var object = require_object();
    function createEnvelope(headers, items = []) {
      return [headers, items];
    }
    function addItemToEnvelope(envelope, newItem) {
      const [headers, items] = envelope;
      return [headers, [...items, newItem]];
    }
    function forEachEnvelopeItem(envelope, callback) {
      const envelopeItems = envelope[1];
      for (const envelopeItem of envelopeItems) {
        const envelopeItemType = envelopeItem[0].type;
        const result = callback(envelopeItem, envelopeItemType);
        if (result) {
          return true;
        }
      }
      return false;
    }
    function envelopeContainsItemType(envelope, types) {
      return forEachEnvelopeItem(envelope, (_3, type) => types.includes(type));
    }
    function encodeUTF8(input, textEncoder) {
      const utf8 = textEncoder || new TextEncoder();
      return utf8.encode(input);
    }
    function serializeEnvelope(envelope, textEncoder) {
      const [envHeaders, items] = envelope;
      let parts = JSON.stringify(envHeaders);
      function append(next) {
        if (typeof parts === "string") {
          parts = typeof next === "string" ? parts + next : [encodeUTF8(parts, textEncoder), next];
        } else {
          parts.push(typeof next === "string" ? encodeUTF8(next, textEncoder) : next);
        }
      }
      for (const item of items) {
        const [itemHeaders, payload] = item;
        append(`
${JSON.stringify(itemHeaders)}
`);
        if (typeof payload === "string" || payload instanceof Uint8Array) {
          append(payload);
        } else {
          let stringifiedPayload;
          try {
            stringifiedPayload = JSON.stringify(payload);
          } catch (e2) {
            stringifiedPayload = JSON.stringify(normalize.normalize(payload));
          }
          append(stringifiedPayload);
        }
      }
      return typeof parts === "string" ? parts : concatBuffers(parts);
    }
    function concatBuffers(buffers) {
      const totalLength = buffers.reduce((acc, buf) => acc + buf.length, 0);
      const merged = new Uint8Array(totalLength);
      let offset = 0;
      for (const buffer of buffers) {
        merged.set(buffer, offset);
        offset += buffer.length;
      }
      return merged;
    }
    function parseEnvelope(env2, textEncoder, textDecoder) {
      let buffer = typeof env2 === "string" ? textEncoder.encode(env2) : env2;
      function readBinary(length) {
        const bin = buffer.subarray(0, length);
        buffer = buffer.subarray(length + 1);
        return bin;
      }
      function readJson() {
        let i2 = buffer.indexOf(10);
        if (i2 < 0) {
          i2 = buffer.length;
        }
        return JSON.parse(textDecoder.decode(readBinary(i2)));
      }
      const envelopeHeader = readJson();
      const items = [];
      while (buffer.length) {
        const itemHeader = readJson();
        const binaryLength = typeof itemHeader.length === "number" ? itemHeader.length : void 0;
        items.push([itemHeader, binaryLength ? readBinary(binaryLength) : readJson()]);
      }
      return [envelopeHeader, items];
    }
    function createAttachmentEnvelopeItem(attachment, textEncoder) {
      const buffer = typeof attachment.data === "string" ? encodeUTF8(attachment.data, textEncoder) : attachment.data;
      return [
        object.dropUndefinedKeys({
          type: "attachment",
          length: buffer.length,
          filename: attachment.filename,
          content_type: attachment.contentType,
          attachment_type: attachment.attachmentType
        }),
        buffer
      ];
    }
    var ITEM_TYPE_TO_DATA_CATEGORY_MAP = {
      session: "session",
      sessions: "session",
      attachment: "attachment",
      transaction: "transaction",
      event: "error",
      client_report: "internal",
      user_report: "default",
      profile: "profile",
      replay_event: "replay",
      replay_recording: "replay",
      check_in: "monitor",
      feedback: "feedback",
      span: "span",
      statsd: "metric_bucket"
    };
    function envelopeItemTypeToDataCategory(type) {
      return ITEM_TYPE_TO_DATA_CATEGORY_MAP[type];
    }
    function getSdkMetadataForEnvelopeHeader(metadataOrEvent) {
      if (!metadataOrEvent || !metadataOrEvent.sdk) {
        return;
      }
      const { name, version: version2 } = metadataOrEvent.sdk;
      return { name, version: version2 };
    }
    function createEventEnvelopeHeaders(event, sdkInfo, tunnel, dsn$1) {
      const dynamicSamplingContext = event.sdkProcessingMetadata && event.sdkProcessingMetadata.dynamicSamplingContext;
      return {
        event_id: event.event_id,
        sent_at: (/* @__PURE__ */ new Date()).toISOString(),
        ...sdkInfo && { sdk: sdkInfo },
        ...!!tunnel && dsn$1 && { dsn: dsn.dsnToString(dsn$1) },
        ...dynamicSamplingContext && {
          trace: object.dropUndefinedKeys({ ...dynamicSamplingContext })
        }
      };
    }
    exports.addItemToEnvelope = addItemToEnvelope;
    exports.createAttachmentEnvelopeItem = createAttachmentEnvelopeItem;
    exports.createEnvelope = createEnvelope;
    exports.createEventEnvelopeHeaders = createEventEnvelopeHeaders;
    exports.envelopeContainsItemType = envelopeContainsItemType;
    exports.envelopeItemTypeToDataCategory = envelopeItemTypeToDataCategory;
    exports.forEachEnvelopeItem = forEachEnvelopeItem;
    exports.getSdkMetadataForEnvelopeHeader = getSdkMetadataForEnvelopeHeader;
    exports.parseEnvelope = parseEnvelope;
    exports.serializeEnvelope = serializeEnvelope;
  }
});

// ../../../node_modules/.pnpm/@sentry+utils@7.120.2/node_modules/@sentry/utils/cjs/clientreport.js
var require_clientreport = __commonJS({
  "../../../node_modules/.pnpm/@sentry+utils@7.120.2/node_modules/@sentry/utils/cjs/clientreport.js"(exports) {
    init_define_ENV_DEFINED_IN_BUILD_STEP();
    Object.defineProperty(exports, "__esModule", { value: true });
    var envelope = require_envelope();
    var time = require_time();
    function createClientReportEnvelope(discarded_events, dsn, timestamp) {
      const clientReportItem = [
        { type: "client_report" },
        {
          timestamp: timestamp || time.dateTimestampInSeconds(),
          discarded_events
        }
      ];
      return envelope.createEnvelope(dsn ? { dsn } : {}, [clientReportItem]);
    }
    exports.createClientReportEnvelope = createClientReportEnvelope;
  }
});

// ../../../node_modules/.pnpm/@sentry+utils@7.120.2/node_modules/@sentry/utils/cjs/ratelimit.js
var require_ratelimit = __commonJS({
  "../../../node_modules/.pnpm/@sentry+utils@7.120.2/node_modules/@sentry/utils/cjs/ratelimit.js"(exports) {
    init_define_ENV_DEFINED_IN_BUILD_STEP();
    Object.defineProperty(exports, "__esModule", { value: true });
    var DEFAULT_RETRY_AFTER = 60 * 1e3;
    function parseRetryAfterHeader(header, now = Date.now()) {
      const headerDelay = parseInt(`${header}`, 10);
      if (!isNaN(headerDelay)) {
        return headerDelay * 1e3;
      }
      const headerDate = Date.parse(`${header}`);
      if (!isNaN(headerDate)) {
        return headerDate - now;
      }
      return DEFAULT_RETRY_AFTER;
    }
    function disabledUntil(limits, dataCategory) {
      return limits[dataCategory] || limits.all || 0;
    }
    function isRateLimited(limits, dataCategory, now = Date.now()) {
      return disabledUntil(limits, dataCategory) > now;
    }
    function updateRateLimits(limits, { statusCode, headers }, now = Date.now()) {
      const updatedRateLimits = {
        ...limits
      };
      const rateLimitHeader = headers && headers["x-sentry-rate-limits"];
      const retryAfterHeader = headers && headers["retry-after"];
      if (rateLimitHeader) {
        for (const limit of rateLimitHeader.trim().split(",")) {
          const [retryAfter, categories, , , namespaces] = limit.split(":", 5);
          const headerDelay = parseInt(retryAfter, 10);
          const delay = (!isNaN(headerDelay) ? headerDelay : 60) * 1e3;
          if (!categories) {
            updatedRateLimits.all = now + delay;
          } else {
            for (const category of categories.split(";")) {
              if (category === "metric_bucket") {
                if (!namespaces || namespaces.split(";").includes("custom")) {
                  updatedRateLimits[category] = now + delay;
                }
              } else {
                updatedRateLimits[category] = now + delay;
              }
            }
          }
        }
      } else if (retryAfterHeader) {
        updatedRateLimits.all = now + parseRetryAfterHeader(retryAfterHeader, now);
      } else if (statusCode === 429) {
        updatedRateLimits.all = now + 60 * 1e3;
      }
      return updatedRateLimits;
    }
    exports.DEFAULT_RETRY_AFTER = DEFAULT_RETRY_AFTER;
    exports.disabledUntil = disabledUntil;
    exports.isRateLimited = isRateLimited;
    exports.parseRetryAfterHeader = parseRetryAfterHeader;
    exports.updateRateLimits = updateRateLimits;
  }
});

// ../../../node_modules/.pnpm/@sentry+utils@7.120.2/node_modules/@sentry/utils/cjs/userIntegrations.js
var require_userIntegrations = __commonJS({
  "../../../node_modules/.pnpm/@sentry+utils@7.120.2/node_modules/@sentry/utils/cjs/userIntegrations.js"(exports) {
    init_define_ENV_DEFINED_IN_BUILD_STEP();
    Object.defineProperty(exports, "__esModule", { value: true });
    function setNestedKey(obj, keyPath, value) {
      const match = keyPath.match(/([a-z_]+)\.(.*)/i);
      if (match === null) {
        obj[keyPath] = value;
      } else {
        const innerObj = obj[match[1]];
        setNestedKey(innerObj, match[2], value);
      }
    }
    function addOrUpdateIntegration(defaultIntegrationInstance, userIntegrations, forcedOptions = {}) {
      return Array.isArray(userIntegrations) ? addOrUpdateIntegrationInArray(defaultIntegrationInstance, userIntegrations, forcedOptions) : addOrUpdateIntegrationInFunction(
        defaultIntegrationInstance,
        // Somehow TS can't figure out that not being an array makes this necessarily a function
        userIntegrations,
        forcedOptions
      );
    }
    function addOrUpdateIntegrationInArray(defaultIntegrationInstance, userIntegrations, forcedOptions) {
      const userInstance = userIntegrations.find((integration) => integration.name === defaultIntegrationInstance.name);
      if (userInstance) {
        for (const [keyPath, value] of Object.entries(forcedOptions)) {
          setNestedKey(userInstance, keyPath, value);
        }
        return userIntegrations;
      }
      return [...userIntegrations, defaultIntegrationInstance];
    }
    function addOrUpdateIntegrationInFunction(defaultIntegrationInstance, userIntegrationsFunc, forcedOptions) {
      const wrapper = (defaultIntegrations) => {
        const userFinalIntegrations = userIntegrationsFunc(defaultIntegrations);
        if (defaultIntegrationInstance.allowExclusionByUser) {
          const userFinalInstance = userFinalIntegrations.find(
            (integration) => integration.name === defaultIntegrationInstance.name
          );
          if (!userFinalInstance) {
            return userFinalIntegrations;
          }
        }
        return addOrUpdateIntegrationInArray(defaultIntegrationInstance, userFinalIntegrations, forcedOptions);
      };
      return wrapper;
    }
    exports.addOrUpdateIntegration = addOrUpdateIntegration;
  }
});

// ../../../node_modules/.pnpm/@sentry+utils@7.120.2/node_modules/@sentry/utils/cjs/cache.js
var require_cache = __commonJS({
  "../../../node_modules/.pnpm/@sentry+utils@7.120.2/node_modules/@sentry/utils/cjs/cache.js"(exports) {
    init_define_ENV_DEFINED_IN_BUILD_STEP();
    Object.defineProperty(exports, "__esModule", { value: true });
    function makeFifoCache(size) {
      let evictionOrder = [];
      let cache = {};
      return {
        add(key, value) {
          while (evictionOrder.length >= size) {
            const evictCandidate = evictionOrder.shift();
            if (evictCandidate !== void 0) {
              delete cache[evictCandidate];
            }
          }
          if (cache[key]) {
            this.delete(key);
          }
          evictionOrder.push(key);
          cache[key] = value;
        },
        clear() {
          cache = {};
          evictionOrder = [];
        },
        get(key) {
          return cache[key];
        },
        size() {
          return evictionOrder.length;
        },
        // Delete cache key and return true if it existed, false otherwise.
        delete(key) {
          if (!cache[key]) {
            return false;
          }
          delete cache[key];
          for (let i2 = 0; i2 < evictionOrder.length; i2++) {
            if (evictionOrder[i2] === key) {
              evictionOrder.splice(i2, 1);
              break;
            }
          }
          return true;
        }
      };
    }
    exports.makeFifoCache = makeFifoCache;
  }
});

// ../../../node_modules/.pnpm/@sentry+utils@7.120.2/node_modules/@sentry/utils/cjs/eventbuilder.js
var require_eventbuilder = __commonJS({
  "../../../node_modules/.pnpm/@sentry+utils@7.120.2/node_modules/@sentry/utils/cjs/eventbuilder.js"(exports) {
    init_define_ENV_DEFINED_IN_BUILD_STEP();
    Object.defineProperty(exports, "__esModule", { value: true });
    var is = require_is();
    var misc = require_misc();
    var normalize = require_normalize();
    var object = require_object();
    function parseStackFrames(stackParser, error) {
      return stackParser(error.stack || "", 1);
    }
    function exceptionFromError(stackParser, error) {
      const exception = {
        type: error.name || error.constructor.name,
        value: error.message
      };
      const frames = parseStackFrames(stackParser, error);
      if (frames.length) {
        exception.stacktrace = { frames };
      }
      return exception;
    }
    function getMessageForObject(exception) {
      if ("name" in exception && typeof exception.name === "string") {
        let message = `'${exception.name}' captured as exception`;
        if ("message" in exception && typeof exception.message === "string") {
          message += ` with message '${exception.message}'`;
        }
        return message;
      } else if ("message" in exception && typeof exception.message === "string") {
        return exception.message;
      } else {
        return `Object captured as exception with keys: ${object.extractExceptionKeysForMessage(
          exception
        )}`;
      }
    }
    function eventFromUnknownInput(getHubOrClient, stackParser, exception, hint) {
      const client = typeof getHubOrClient === "function" ? (
        // eslint-disable-next-line deprecation/deprecation
        getHubOrClient().getClient()
      ) : getHubOrClient;
      let ex = exception;
      const providedMechanism = hint && hint.data && hint.data.mechanism;
      const mechanism = providedMechanism || {
        handled: true,
        type: "generic"
      };
      let extras;
      if (!is.isError(exception)) {
        if (is.isPlainObject(exception)) {
          const normalizeDepth = client && client.getOptions().normalizeDepth;
          extras = { ["__serialized__"]: normalize.normalizeToSize(exception, normalizeDepth) };
          const message = getMessageForObject(exception);
          ex = hint && hint.syntheticException || new Error(message);
          ex.message = message;
        } else {
          ex = hint && hint.syntheticException || new Error(exception);
          ex.message = exception;
        }
        mechanism.synthetic = true;
      }
      const event = {
        exception: {
          values: [exceptionFromError(stackParser, ex)]
        }
      };
      if (extras) {
        event.extra = extras;
      }
      misc.addExceptionTypeValue(event, void 0, void 0);
      misc.addExceptionMechanism(event, mechanism);
      return {
        ...event,
        event_id: hint && hint.event_id
      };
    }
    function eventFromMessage(stackParser, message, level = "info", hint, attachStacktrace) {
      const event = {
        event_id: hint && hint.event_id,
        level
      };
      if (attachStacktrace && hint && hint.syntheticException) {
        const frames = parseStackFrames(stackParser, hint.syntheticException);
        if (frames.length) {
          event.exception = {
            values: [
              {
                value: message,
                stacktrace: { frames }
              }
            ]
          };
        }
      }
      if (is.isParameterizedString(message)) {
        const { __sentry_template_string__, __sentry_template_values__ } = message;
        event.logentry = {
          message: __sentry_template_string__,
          params: __sentry_template_values__
        };
        return event;
      }
      event.message = message;
      return event;
    }
    exports.eventFromMessage = eventFromMessage;
    exports.eventFromUnknownInput = eventFromUnknownInput;
    exports.exceptionFromError = exceptionFromError;
    exports.parseStackFrames = parseStackFrames;
  }
});

// ../../../node_modules/.pnpm/@sentry+utils@7.120.2/node_modules/@sentry/utils/cjs/anr.js
var require_anr = __commonJS({
  "../../../node_modules/.pnpm/@sentry+utils@7.120.2/node_modules/@sentry/utils/cjs/anr.js"(exports) {
    init_define_ENV_DEFINED_IN_BUILD_STEP();
    Object.defineProperty(exports, "__esModule", { value: true });
    var object = require_object();
    var nodeStackTrace = require_node_stack_trace();
    function watchdogTimer(createTimer, pollInterval, anrThreshold, callback) {
      const timer = createTimer();
      let triggered = false;
      let enabled = true;
      setInterval(() => {
        const diffMs = timer.getTimeMs();
        if (triggered === false && diffMs > pollInterval + anrThreshold) {
          triggered = true;
          if (enabled) {
            callback();
          }
        }
        if (diffMs < pollInterval + anrThreshold) {
          triggered = false;
        }
      }, 20);
      return {
        poll: () => {
          timer.reset();
        },
        enabled: (state) => {
          enabled = state;
        }
      };
    }
    function callFrameToStackFrame(frame, url, getModuleFromFilename) {
      const filename = url ? url.replace(/^file:\/\//, "") : void 0;
      const colno = frame.location.columnNumber ? frame.location.columnNumber + 1 : void 0;
      const lineno = frame.location.lineNumber ? frame.location.lineNumber + 1 : void 0;
      return object.dropUndefinedKeys({
        filename,
        module: getModuleFromFilename(filename),
        function: frame.functionName || "?",
        colno,
        lineno,
        in_app: filename ? nodeStackTrace.filenameIsInApp(filename) : void 0
      });
    }
    exports.callFrameToStackFrame = callFrameToStackFrame;
    exports.watchdogTimer = watchdogTimer;
  }
});

// ../../../node_modules/.pnpm/@sentry+utils@7.120.2/node_modules/@sentry/utils/cjs/lru.js
var require_lru = __commonJS({
  "../../../node_modules/.pnpm/@sentry+utils@7.120.2/node_modules/@sentry/utils/cjs/lru.js"(exports) {
    init_define_ENV_DEFINED_IN_BUILD_STEP();
    Object.defineProperty(exports, "__esModule", { value: true });
    var LRUMap = class {
      constructor(_maxSize) {
        this._maxSize = _maxSize;
        this._cache = /* @__PURE__ */ new Map();
      }
      /** Get the current size of the cache */
      get size() {
        return this._cache.size;
      }
      /** Get an entry or undefined if it was not in the cache. Re-inserts to update the recently used order */
      get(key) {
        const value = this._cache.get(key);
        if (value === void 0) {
          return void 0;
        }
        this._cache.delete(key);
        this._cache.set(key, value);
        return value;
      }
      /** Insert an entry and evict an older entry if we've reached maxSize */
      set(key, value) {
        if (this._cache.size >= this._maxSize) {
          this._cache.delete(this._cache.keys().next().value);
        }
        this._cache.set(key, value);
      }
      /** Remove an entry and return the entry if it was in the cache */
      remove(key) {
        const value = this._cache.get(key);
        if (value) {
          this._cache.delete(key);
        }
        return value;
      }
      /** Clear all entries */
      clear() {
        this._cache.clear();
      }
      /** Get all the keys */
      keys() {
        return Array.from(this._cache.keys());
      }
      /** Get all the values */
      values() {
        const values = [];
        this._cache.forEach((value) => values.push(value));
        return values;
      }
    };
    exports.LRUMap = LRUMap;
  }
});

// ../../../node_modules/.pnpm/@sentry+utils@7.120.2/node_modules/@sentry/utils/cjs/buildPolyfills/_nullishCoalesce.js
var require_nullishCoalesce = __commonJS({
  "../../../node_modules/.pnpm/@sentry+utils@7.120.2/node_modules/@sentry/utils/cjs/buildPolyfills/_nullishCoalesce.js"(exports) {
    init_define_ENV_DEFINED_IN_BUILD_STEP();
    Object.defineProperty(exports, "__esModule", { value: true });
    function _nullishCoalesce(lhs, rhsFn) {
      return lhs != null ? lhs : rhsFn();
    }
    exports._nullishCoalesce = _nullishCoalesce;
  }
});

// ../../../node_modules/.pnpm/@sentry+utils@7.120.2/node_modules/@sentry/utils/cjs/buildPolyfills/_asyncNullishCoalesce.js
var require_asyncNullishCoalesce = __commonJS({
  "../../../node_modules/.pnpm/@sentry+utils@7.120.2/node_modules/@sentry/utils/cjs/buildPolyfills/_asyncNullishCoalesce.js"(exports) {
    init_define_ENV_DEFINED_IN_BUILD_STEP();
    Object.defineProperty(exports, "__esModule", { value: true });
    var _nullishCoalesce = require_nullishCoalesce();
    async function _asyncNullishCoalesce(lhs, rhsFn) {
      return _nullishCoalesce._nullishCoalesce(lhs, rhsFn);
    }
    exports._asyncNullishCoalesce = _asyncNullishCoalesce;
  }
});

// ../../../node_modules/.pnpm/@sentry+utils@7.120.2/node_modules/@sentry/utils/cjs/buildPolyfills/_asyncOptionalChain.js
var require_asyncOptionalChain = __commonJS({
  "../../../node_modules/.pnpm/@sentry+utils@7.120.2/node_modules/@sentry/utils/cjs/buildPolyfills/_asyncOptionalChain.js"(exports) {
    init_define_ENV_DEFINED_IN_BUILD_STEP();
    Object.defineProperty(exports, "__esModule", { value: true });
    async function _asyncOptionalChain(ops) {
      let lastAccessLHS = void 0;
      let value = ops[0];
      let i2 = 1;
      while (i2 < ops.length) {
        const op = ops[i2];
        const fn = ops[i2 + 1];
        i2 += 2;
        if ((op === "optionalAccess" || op === "optionalCall") && value == null) {
          return;
        }
        if (op === "access" || op === "optionalAccess") {
          lastAccessLHS = value;
          value = await fn(value);
        } else if (op === "call" || op === "optionalCall") {
          value = await fn((...args) => value.call(lastAccessLHS, ...args));
          lastAccessLHS = void 0;
        }
      }
      return value;
    }
    exports._asyncOptionalChain = _asyncOptionalChain;
  }
});

// ../../../node_modules/.pnpm/@sentry+utils@7.120.2/node_modules/@sentry/utils/cjs/buildPolyfills/_asyncOptionalChainDelete.js
var require_asyncOptionalChainDelete = __commonJS({
  "../../../node_modules/.pnpm/@sentry+utils@7.120.2/node_modules/@sentry/utils/cjs/buildPolyfills/_asyncOptionalChainDelete.js"(exports) {
    init_define_ENV_DEFINED_IN_BUILD_STEP();
    Object.defineProperty(exports, "__esModule", { value: true });
    var _asyncOptionalChain = require_asyncOptionalChain();
    async function _asyncOptionalChainDelete(ops) {
      const result = await _asyncOptionalChain._asyncOptionalChain(ops);
      return result == null ? true : result;
    }
    exports._asyncOptionalChainDelete = _asyncOptionalChainDelete;
  }
});

// ../../../node_modules/.pnpm/@sentry+utils@7.120.2/node_modules/@sentry/utils/cjs/buildPolyfills/_optionalChain.js
var require_optionalChain = __commonJS({
  "../../../node_modules/.pnpm/@sentry+utils@7.120.2/node_modules/@sentry/utils/cjs/buildPolyfills/_optionalChain.js"(exports) {
    init_define_ENV_DEFINED_IN_BUILD_STEP();
    Object.defineProperty(exports, "__esModule", { value: true });
    function _optionalChain(ops) {
      let lastAccessLHS = void 0;
      let value = ops[0];
      let i2 = 1;
      while (i2 < ops.length) {
        const op = ops[i2];
        const fn = ops[i2 + 1];
        i2 += 2;
        if ((op === "optionalAccess" || op === "optionalCall") && value == null) {
          return;
        }
        if (op === "access" || op === "optionalAccess") {
          lastAccessLHS = value;
          value = fn(value);
        } else if (op === "call" || op === "optionalCall") {
          value = fn((...args) => value.call(lastAccessLHS, ...args));
          lastAccessLHS = void 0;
        }
      }
      return value;
    }
    exports._optionalChain = _optionalChain;
  }
});

// ../../../node_modules/.pnpm/@sentry+utils@7.120.2/node_modules/@sentry/utils/cjs/buildPolyfills/_optionalChainDelete.js
var require_optionalChainDelete = __commonJS({
  "../../../node_modules/.pnpm/@sentry+utils@7.120.2/node_modules/@sentry/utils/cjs/buildPolyfills/_optionalChainDelete.js"(exports) {
    init_define_ENV_DEFINED_IN_BUILD_STEP();
    Object.defineProperty(exports, "__esModule", { value: true });
    var _optionalChain = require_optionalChain();
    function _optionalChainDelete(ops) {
      const result = _optionalChain._optionalChain(ops);
      return result == null ? true : result;
    }
    exports._optionalChainDelete = _optionalChainDelete;
  }
});

// ../../../node_modules/.pnpm/@sentry+utils@7.120.2/node_modules/@sentry/utils/cjs/vendor/escapeStringForRegex.js
var require_escapeStringForRegex = __commonJS({
  "../../../node_modules/.pnpm/@sentry+utils@7.120.2/node_modules/@sentry/utils/cjs/vendor/escapeStringForRegex.js"(exports) {
    init_define_ENV_DEFINED_IN_BUILD_STEP();
    Object.defineProperty(exports, "__esModule", { value: true });
    function escapeStringForRegex(regexString) {
      return regexString.replace(/[|\\{}()[\]^$+*?.]/g, "\\$&").replace(/-/g, "\\x2d");
    }
    exports.escapeStringForRegex = escapeStringForRegex;
  }
});

// ../../../node_modules/.pnpm/@sentry+utils@7.120.2/node_modules/@sentry/utils/cjs/index.js
var require_cjs = __commonJS({
  "../../../node_modules/.pnpm/@sentry+utils@7.120.2/node_modules/@sentry/utils/cjs/index.js"(exports) {
    init_define_ENV_DEFINED_IN_BUILD_STEP();
    Object.defineProperty(exports, "__esModule", { value: true });
    var aggregateErrors = require_aggregate_errors();
    var browser = require_browser();
    var dsn = require_dsn();
    var error = require_error2();
    var worldwide = require_worldwide();
    var index = require_instrument();
    var is = require_is();
    var isBrowser = require_isBrowser();
    var logger = require_logger();
    var memo = require_memo();
    var misc = require_misc();
    var node = require_node();
    var normalize = require_normalize();
    var object = require_object();
    var path2 = require_path();
    var promisebuffer = require_promisebuffer();
    var requestdata = require_requestdata();
    var severity = require_severity();
    var stacktrace = require_stacktrace();
    var string = require_string();
    var supports = require_supports();
    var syncpromise = require_syncpromise();
    var time = require_time();
    var tracing = require_tracing();
    var env2 = require_env();
    var envelope = require_envelope();
    var clientreport = require_clientreport();
    var ratelimit = require_ratelimit();
    var baggage = require_baggage();
    var url = require_url();
    var userIntegrations = require_userIntegrations();
    var cache = require_cache();
    var eventbuilder = require_eventbuilder();
    var anr = require_anr();
    var lru = require_lru();
    var _asyncNullishCoalesce = require_asyncNullishCoalesce();
    var _asyncOptionalChain = require_asyncOptionalChain();
    var _asyncOptionalChainDelete = require_asyncOptionalChainDelete();
    var _nullishCoalesce = require_nullishCoalesce();
    var _optionalChain = require_optionalChain();
    var _optionalChainDelete = require_optionalChainDelete();
    var console2 = require_console();
    var dom = require_dom();
    var xhr = require_xhr();
    var fetch2 = require_fetch();
    var history = require_history();
    var globalError = require_globalError();
    var globalUnhandledRejection = require_globalUnhandledRejection();
    var _handlers = require_handlers();
    var nodeStackTrace = require_node_stack_trace();
    var escapeStringForRegex = require_escapeStringForRegex();
    var supportsHistory = require_supportsHistory();
    exports.applyAggregateErrorsToEvent = aggregateErrors.applyAggregateErrorsToEvent;
    exports.getComponentName = browser.getComponentName;
    exports.getDomElement = browser.getDomElement;
    exports.getLocationHref = browser.getLocationHref;
    exports.htmlTreeAsString = browser.htmlTreeAsString;
    exports.dsnFromString = dsn.dsnFromString;
    exports.dsnToString = dsn.dsnToString;
    exports.makeDsn = dsn.makeDsn;
    exports.SentryError = error.SentryError;
    exports.GLOBAL_OBJ = worldwide.GLOBAL_OBJ;
    exports.getGlobalObject = worldwide.getGlobalObject;
    exports.getGlobalSingleton = worldwide.getGlobalSingleton;
    exports.addInstrumentationHandler = index.addInstrumentationHandler;
    exports.isDOMError = is.isDOMError;
    exports.isDOMException = is.isDOMException;
    exports.isElement = is.isElement;
    exports.isError = is.isError;
    exports.isErrorEvent = is.isErrorEvent;
    exports.isEvent = is.isEvent;
    exports.isInstanceOf = is.isInstanceOf;
    exports.isNaN = is.isNaN;
    exports.isParameterizedString = is.isParameterizedString;
    exports.isPlainObject = is.isPlainObject;
    exports.isPrimitive = is.isPrimitive;
    exports.isRegExp = is.isRegExp;
    exports.isString = is.isString;
    exports.isSyntheticEvent = is.isSyntheticEvent;
    exports.isThenable = is.isThenable;
    exports.isVueViewModel = is.isVueViewModel;
    exports.isBrowser = isBrowser.isBrowser;
    exports.CONSOLE_LEVELS = logger.CONSOLE_LEVELS;
    exports.consoleSandbox = logger.consoleSandbox;
    exports.logger = logger.logger;
    exports.originalConsoleMethods = logger.originalConsoleMethods;
    exports.memoBuilder = memo.memoBuilder;
    exports.addContextToFrame = misc.addContextToFrame;
    exports.addExceptionMechanism = misc.addExceptionMechanism;
    exports.addExceptionTypeValue = misc.addExceptionTypeValue;
    exports.arrayify = misc.arrayify;
    exports.checkOrSetAlreadyCaught = misc.checkOrSetAlreadyCaught;
    exports.getEventDescription = misc.getEventDescription;
    exports.parseSemver = misc.parseSemver;
    exports.uuid4 = misc.uuid4;
    exports.dynamicRequire = node.dynamicRequire;
    exports.isNodeEnv = node.isNodeEnv;
    exports.loadModule = node.loadModule;
    exports.normalize = normalize.normalize;
    exports.normalizeToSize = normalize.normalizeToSize;
    exports.normalizeUrlToBase = normalize.normalizeUrlToBase;
    exports.walk = normalize.walk;
    exports.addNonEnumerableProperty = object.addNonEnumerableProperty;
    exports.convertToPlainObject = object.convertToPlainObject;
    exports.dropUndefinedKeys = object.dropUndefinedKeys;
    exports.extractExceptionKeysForMessage = object.extractExceptionKeysForMessage;
    exports.fill = object.fill;
    exports.getOriginalFunction = object.getOriginalFunction;
    exports.markFunctionWrapped = object.markFunctionWrapped;
    exports.objectify = object.objectify;
    exports.urlEncode = object.urlEncode;
    exports.basename = path2.basename;
    exports.dirname = path2.dirname;
    exports.isAbsolute = path2.isAbsolute;
    exports.join = path2.join;
    exports.normalizePath = path2.normalizePath;
    exports.relative = path2.relative;
    exports.resolve = path2.resolve;
    exports.makePromiseBuffer = promisebuffer.makePromiseBuffer;
    exports.DEFAULT_USER_INCLUDES = requestdata.DEFAULT_USER_INCLUDES;
    exports.addRequestDataToEvent = requestdata.addRequestDataToEvent;
    exports.addRequestDataToTransaction = requestdata.addRequestDataToTransaction;
    exports.extractPathForTransaction = requestdata.extractPathForTransaction;
    exports.extractRequestData = requestdata.extractRequestData;
    exports.winterCGHeadersToDict = requestdata.winterCGHeadersToDict;
    exports.winterCGRequestToRequestData = requestdata.winterCGRequestToRequestData;
    exports.severityFromString = severity.severityFromString;
    exports.severityLevelFromString = severity.severityLevelFromString;
    exports.validSeverityLevels = severity.validSeverityLevels;
    exports.createStackParser = stacktrace.createStackParser;
    exports.getFunctionName = stacktrace.getFunctionName;
    exports.nodeStackLineParser = stacktrace.nodeStackLineParser;
    exports.stackParserFromStackParserOptions = stacktrace.stackParserFromStackParserOptions;
    exports.stripSentryFramesAndReverse = stacktrace.stripSentryFramesAndReverse;
    exports.isMatchingPattern = string.isMatchingPattern;
    exports.safeJoin = string.safeJoin;
    exports.snipLine = string.snipLine;
    exports.stringMatchesSomePattern = string.stringMatchesSomePattern;
    exports.truncate = string.truncate;
    exports.isNativeFetch = supports.isNativeFetch;
    exports.supportsDOMError = supports.supportsDOMError;
    exports.supportsDOMException = supports.supportsDOMException;
    exports.supportsErrorEvent = supports.supportsErrorEvent;
    exports.supportsFetch = supports.supportsFetch;
    exports.supportsNativeFetch = supports.supportsNativeFetch;
    exports.supportsReferrerPolicy = supports.supportsReferrerPolicy;
    exports.supportsReportingObserver = supports.supportsReportingObserver;
    exports.SyncPromise = syncpromise.SyncPromise;
    exports.rejectedSyncPromise = syncpromise.rejectedSyncPromise;
    exports.resolvedSyncPromise = syncpromise.resolvedSyncPromise;
    Object.defineProperty(exports, "_browserPerformanceTimeOriginMode", {
      enumerable: true,
      get: () => time._browserPerformanceTimeOriginMode
    });
    exports.browserPerformanceTimeOrigin = time.browserPerformanceTimeOrigin;
    exports.dateTimestampInSeconds = time.dateTimestampInSeconds;
    exports.timestampInSeconds = time.timestampInSeconds;
    exports.timestampWithMs = time.timestampWithMs;
    exports.TRACEPARENT_REGEXP = tracing.TRACEPARENT_REGEXP;
    exports.extractTraceparentData = tracing.extractTraceparentData;
    exports.generateSentryTraceHeader = tracing.generateSentryTraceHeader;
    exports.propagationContextFromHeaders = tracing.propagationContextFromHeaders;
    exports.tracingContextFromHeaders = tracing.tracingContextFromHeaders;
    exports.getSDKSource = env2.getSDKSource;
    exports.isBrowserBundle = env2.isBrowserBundle;
    exports.addItemToEnvelope = envelope.addItemToEnvelope;
    exports.createAttachmentEnvelopeItem = envelope.createAttachmentEnvelopeItem;
    exports.createEnvelope = envelope.createEnvelope;
    exports.createEventEnvelopeHeaders = envelope.createEventEnvelopeHeaders;
    exports.envelopeContainsItemType = envelope.envelopeContainsItemType;
    exports.envelopeItemTypeToDataCategory = envelope.envelopeItemTypeToDataCategory;
    exports.forEachEnvelopeItem = envelope.forEachEnvelopeItem;
    exports.getSdkMetadataForEnvelopeHeader = envelope.getSdkMetadataForEnvelopeHeader;
    exports.parseEnvelope = envelope.parseEnvelope;
    exports.serializeEnvelope = envelope.serializeEnvelope;
    exports.createClientReportEnvelope = clientreport.createClientReportEnvelope;
    exports.DEFAULT_RETRY_AFTER = ratelimit.DEFAULT_RETRY_AFTER;
    exports.disabledUntil = ratelimit.disabledUntil;
    exports.isRateLimited = ratelimit.isRateLimited;
    exports.parseRetryAfterHeader = ratelimit.parseRetryAfterHeader;
    exports.updateRateLimits = ratelimit.updateRateLimits;
    exports.BAGGAGE_HEADER_NAME = baggage.BAGGAGE_HEADER_NAME;
    exports.MAX_BAGGAGE_STRING_LENGTH = baggage.MAX_BAGGAGE_STRING_LENGTH;
    exports.SENTRY_BAGGAGE_KEY_PREFIX = baggage.SENTRY_BAGGAGE_KEY_PREFIX;
    exports.SENTRY_BAGGAGE_KEY_PREFIX_REGEX = baggage.SENTRY_BAGGAGE_KEY_PREFIX_REGEX;
    exports.baggageHeaderToDynamicSamplingContext = baggage.baggageHeaderToDynamicSamplingContext;
    exports.dynamicSamplingContextToSentryBaggageHeader = baggage.dynamicSamplingContextToSentryBaggageHeader;
    exports.getNumberOfUrlSegments = url.getNumberOfUrlSegments;
    exports.getSanitizedUrlString = url.getSanitizedUrlString;
    exports.parseUrl = url.parseUrl;
    exports.stripUrlQueryAndFragment = url.stripUrlQueryAndFragment;
    exports.addOrUpdateIntegration = userIntegrations.addOrUpdateIntegration;
    exports.makeFifoCache = cache.makeFifoCache;
    exports.eventFromMessage = eventbuilder.eventFromMessage;
    exports.eventFromUnknownInput = eventbuilder.eventFromUnknownInput;
    exports.exceptionFromError = eventbuilder.exceptionFromError;
    exports.parseStackFrames = eventbuilder.parseStackFrames;
    exports.callFrameToStackFrame = anr.callFrameToStackFrame;
    exports.watchdogTimer = anr.watchdogTimer;
    exports.LRUMap = lru.LRUMap;
    exports._asyncNullishCoalesce = _asyncNullishCoalesce._asyncNullishCoalesce;
    exports._asyncOptionalChain = _asyncOptionalChain._asyncOptionalChain;
    exports._asyncOptionalChainDelete = _asyncOptionalChainDelete._asyncOptionalChainDelete;
    exports._nullishCoalesce = _nullishCoalesce._nullishCoalesce;
    exports._optionalChain = _optionalChain._optionalChain;
    exports._optionalChainDelete = _optionalChainDelete._optionalChainDelete;
    exports.addConsoleInstrumentationHandler = console2.addConsoleInstrumentationHandler;
    exports.addClickKeypressInstrumentationHandler = dom.addClickKeypressInstrumentationHandler;
    exports.SENTRY_XHR_DATA_KEY = xhr.SENTRY_XHR_DATA_KEY;
    exports.addXhrInstrumentationHandler = xhr.addXhrInstrumentationHandler;
    exports.addFetchInstrumentationHandler = fetch2.addFetchInstrumentationHandler;
    exports.addHistoryInstrumentationHandler = history.addHistoryInstrumentationHandler;
    exports.addGlobalErrorInstrumentationHandler = globalError.addGlobalErrorInstrumentationHandler;
    exports.addGlobalUnhandledRejectionInstrumentationHandler = globalUnhandledRejection.addGlobalUnhandledRejectionInstrumentationHandler;
    exports.resetInstrumentationHandlers = _handlers.resetInstrumentationHandlers;
    exports.filenameIsInApp = nodeStackTrace.filenameIsInApp;
    exports.escapeStringForRegex = escapeStringForRegex.escapeStringForRegex;
    exports.supportsHistory = supportsHistory.supportsHistory;
  }
});

// ../../../node_modules/.pnpm/@sentry+core@7.120.2/node_modules/@sentry/core/cjs/debug-build.js
var require_debug_build2 = __commonJS({
  "../../../node_modules/.pnpm/@sentry+core@7.120.2/node_modules/@sentry/core/cjs/debug-build.js"(exports) {
    init_define_ENV_DEFINED_IN_BUILD_STEP();
    Object.defineProperty(exports, "__esModule", { value: true });
    var DEBUG_BUILD = typeof __SENTRY_DEBUG__ === "undefined" || __SENTRY_DEBUG__;
    exports.DEBUG_BUILD = DEBUG_BUILD;
  }
});

// ../../../node_modules/.pnpm/@sentry+core@7.120.2/node_modules/@sentry/core/cjs/constants.js
var require_constants = __commonJS({
  "../../../node_modules/.pnpm/@sentry+core@7.120.2/node_modules/@sentry/core/cjs/constants.js"(exports) {
    init_define_ENV_DEFINED_IN_BUILD_STEP();
    Object.defineProperty(exports, "__esModule", { value: true });
    var DEFAULT_ENVIRONMENT = "production";
    exports.DEFAULT_ENVIRONMENT = DEFAULT_ENVIRONMENT;
  }
});

// ../../../node_modules/.pnpm/@sentry+core@7.120.2/node_modules/@sentry/core/cjs/eventProcessors.js
var require_eventProcessors = __commonJS({
  "../../../node_modules/.pnpm/@sentry+core@7.120.2/node_modules/@sentry/core/cjs/eventProcessors.js"(exports) {
    init_define_ENV_DEFINED_IN_BUILD_STEP();
    Object.defineProperty(exports, "__esModule", { value: true });
    var utils = require_cjs();
    var debugBuild = require_debug_build2();
    function getGlobalEventProcessors() {
      return utils.getGlobalSingleton("globalEventProcessors", () => []);
    }
    function addGlobalEventProcessor(callback) {
      getGlobalEventProcessors().push(callback);
    }
    function notifyEventProcessors(processors, event, hint, index = 0) {
      return new utils.SyncPromise((resolve2, reject) => {
        const processor = processors[index];
        if (event === null || typeof processor !== "function") {
          resolve2(event);
        } else {
          const result = processor({ ...event }, hint);
          debugBuild.DEBUG_BUILD && processor.id && result === null && utils.logger.log(`Event processor "${processor.id}" dropped event`);
          if (utils.isThenable(result)) {
            void result.then((final) => notifyEventProcessors(processors, final, hint, index + 1).then(resolve2)).then(null, reject);
          } else {
            void notifyEventProcessors(processors, result, hint, index + 1).then(resolve2).then(null, reject);
          }
        }
      });
    }
    exports.addGlobalEventProcessor = addGlobalEventProcessor;
    exports.getGlobalEventProcessors = getGlobalEventProcessors;
    exports.notifyEventProcessors = notifyEventProcessors;
  }
});

// ../../../node_modules/.pnpm/@sentry+core@7.120.2/node_modules/@sentry/core/cjs/session.js
var require_session = __commonJS({
  "../../../node_modules/.pnpm/@sentry+core@7.120.2/node_modules/@sentry/core/cjs/session.js"(exports) {
    init_define_ENV_DEFINED_IN_BUILD_STEP();
    Object.defineProperty(exports, "__esModule", { value: true });
    var utils = require_cjs();
    function makeSession(context2) {
      const startingTime = utils.timestampInSeconds();
      const session = {
        sid: utils.uuid4(),
        init: true,
        timestamp: startingTime,
        started: startingTime,
        duration: 0,
        status: "ok",
        errors: 0,
        ignoreDuration: false,
        toJSON: () => sessionToJSON(session)
      };
      if (context2) {
        updateSession(session, context2);
      }
      return session;
    }
    function updateSession(session, context2 = {}) {
      if (context2.user) {
        if (!session.ipAddress && context2.user.ip_address) {
          session.ipAddress = context2.user.ip_address;
        }
        if (!session.did && !context2.did) {
          session.did = context2.user.id || context2.user.email || context2.user.username;
        }
      }
      session.timestamp = context2.timestamp || utils.timestampInSeconds();
      if (context2.abnormal_mechanism) {
        session.abnormal_mechanism = context2.abnormal_mechanism;
      }
      if (context2.ignoreDuration) {
        session.ignoreDuration = context2.ignoreDuration;
      }
      if (context2.sid) {
        session.sid = context2.sid.length === 32 ? context2.sid : utils.uuid4();
      }
      if (context2.init !== void 0) {
        session.init = context2.init;
      }
      if (!session.did && context2.did) {
        session.did = `${context2.did}`;
      }
      if (typeof context2.started === "number") {
        session.started = context2.started;
      }
      if (session.ignoreDuration) {
        session.duration = void 0;
      } else if (typeof context2.duration === "number") {
        session.duration = context2.duration;
      } else {
        const duration = session.timestamp - session.started;
        session.duration = duration >= 0 ? duration : 0;
      }
      if (context2.release) {
        session.release = context2.release;
      }
      if (context2.environment) {
        session.environment = context2.environment;
      }
      if (!session.ipAddress && context2.ipAddress) {
        session.ipAddress = context2.ipAddress;
      }
      if (!session.userAgent && context2.userAgent) {
        session.userAgent = context2.userAgent;
      }
      if (typeof context2.errors === "number") {
        session.errors = context2.errors;
      }
      if (context2.status) {
        session.status = context2.status;
      }
    }
    function closeSession(session, status) {
      let context2 = {};
      if (status) {
        context2 = { status };
      } else if (session.status === "ok") {
        context2 = { status: "exited" };
      }
      updateSession(session, context2);
    }
    function sessionToJSON(session) {
      return utils.dropUndefinedKeys({
        sid: `${session.sid}`,
        init: session.init,
        // Make sure that sec is converted to ms for date constructor
        started: new Date(session.started * 1e3).toISOString(),
        timestamp: new Date(session.timestamp * 1e3).toISOString(),
        status: session.status,
        errors: session.errors,
        did: typeof session.did === "number" || typeof session.did === "string" ? `${session.did}` : void 0,
        duration: session.duration,
        abnormal_mechanism: session.abnormal_mechanism,
        attrs: {
          release: session.release,
          environment: session.environment,
          ip_address: session.ipAddress,
          user_agent: session.userAgent
        }
      });
    }
    exports.closeSession = closeSession;
    exports.makeSession = makeSession;
    exports.updateSession = updateSession;
  }
});

// ../../../node_modules/.pnpm/@sentry+core@7.120.2/node_modules/@sentry/core/cjs/utils/spanUtils.js
var require_spanUtils = __commonJS({
  "../../../node_modules/.pnpm/@sentry+core@7.120.2/node_modules/@sentry/core/cjs/utils/spanUtils.js"(exports) {
    init_define_ENV_DEFINED_IN_BUILD_STEP();
    Object.defineProperty(exports, "__esModule", { value: true });
    var utils = require_cjs();
    var TRACE_FLAG_NONE = 0;
    var TRACE_FLAG_SAMPLED = 1;
    function spanToTraceContext(span) {
      const { spanId: span_id, traceId: trace_id } = span.spanContext();
      const { data, op, parent_span_id, status, tags, origin } = spanToJSON(span);
      return utils.dropUndefinedKeys({
        data,
        op,
        parent_span_id,
        span_id,
        status,
        tags,
        trace_id,
        origin
      });
    }
    function spanToTraceHeader(span) {
      const { traceId, spanId } = span.spanContext();
      const sampled = spanIsSampled(span);
      return utils.generateSentryTraceHeader(traceId, spanId, sampled);
    }
    function spanTimeInputToSeconds(input) {
      if (typeof input === "number") {
        return ensureTimestampInSeconds(input);
      }
      if (Array.isArray(input)) {
        return input[0] + input[1] / 1e9;
      }
      if (input instanceof Date) {
        return ensureTimestampInSeconds(input.getTime());
      }
      return utils.timestampInSeconds();
    }
    function ensureTimestampInSeconds(timestamp) {
      const isMs = timestamp > 9999999999;
      return isMs ? timestamp / 1e3 : timestamp;
    }
    function spanToJSON(span) {
      if (spanIsSpanClass(span)) {
        return span.getSpanJSON();
      }
      if (typeof span.toJSON === "function") {
        return span.toJSON();
      }
      return {};
    }
    function spanIsSpanClass(span) {
      return typeof span.getSpanJSON === "function";
    }
    function spanIsSampled(span) {
      const { traceFlags } = span.spanContext();
      return Boolean(traceFlags & TRACE_FLAG_SAMPLED);
    }
    exports.TRACE_FLAG_NONE = TRACE_FLAG_NONE;
    exports.TRACE_FLAG_SAMPLED = TRACE_FLAG_SAMPLED;
    exports.spanIsSampled = spanIsSampled;
    exports.spanTimeInputToSeconds = spanTimeInputToSeconds;
    exports.spanToJSON = spanToJSON;
    exports.spanToTraceContext = spanToTraceContext;
    exports.spanToTraceHeader = spanToTraceHeader;
  }
});

// ../../../node_modules/.pnpm/@sentry+core@7.120.2/node_modules/@sentry/core/cjs/utils/prepareEvent.js
var require_prepareEvent = __commonJS({
  "../../../node_modules/.pnpm/@sentry+core@7.120.2/node_modules/@sentry/core/cjs/utils/prepareEvent.js"(exports) {
    init_define_ENV_DEFINED_IN_BUILD_STEP();
    Object.defineProperty(exports, "__esModule", { value: true });
    var utils = require_cjs();
    var constants = require_constants();
    var eventProcessors = require_eventProcessors();
    var scope = require_scope();
    var applyScopeDataToEvent = require_applyScopeDataToEvent();
    var spanUtils = require_spanUtils();
    function prepareEvent(options, event, hint, scope$1, client, isolationScope) {
      const { normalizeDepth = 3, normalizeMaxBreadth = 1e3 } = options;
      const prepared = {
        ...event,
        event_id: event.event_id || hint.event_id || utils.uuid4(),
        timestamp: event.timestamp || utils.dateTimestampInSeconds()
      };
      const integrations = hint.integrations || options.integrations.map((i2) => i2.name);
      applyClientOptions(prepared, options);
      applyIntegrationsMetadata(prepared, integrations);
      if (event.type === void 0) {
        applyDebugIds(prepared, options.stackParser);
      }
      const finalScope = getFinalScope(scope$1, hint.captureContext);
      if (hint.mechanism) {
        utils.addExceptionMechanism(prepared, hint.mechanism);
      }
      const clientEventProcessors = client && client.getEventProcessors ? client.getEventProcessors() : [];
      const data = scope.getGlobalScope().getScopeData();
      if (isolationScope) {
        const isolationData = isolationScope.getScopeData();
        applyScopeDataToEvent.mergeScopeData(data, isolationData);
      }
      if (finalScope) {
        const finalScopeData = finalScope.getScopeData();
        applyScopeDataToEvent.mergeScopeData(data, finalScopeData);
      }
      const attachments = [...hint.attachments || [], ...data.attachments];
      if (attachments.length) {
        hint.attachments = attachments;
      }
      applyScopeDataToEvent.applyScopeDataToEvent(prepared, data);
      const eventProcessors$1 = [
        ...clientEventProcessors,
        // eslint-disable-next-line deprecation/deprecation
        ...eventProcessors.getGlobalEventProcessors(),
        // Run scope event processors _after_ all other processors
        ...data.eventProcessors
      ];
      const result = eventProcessors.notifyEventProcessors(eventProcessors$1, prepared, hint);
      return result.then((evt) => {
        if (evt) {
          applyDebugMeta(evt);
        }
        if (typeof normalizeDepth === "number" && normalizeDepth > 0) {
          return normalizeEvent(evt, normalizeDepth, normalizeMaxBreadth);
        }
        return evt;
      });
    }
    function applyClientOptions(event, options) {
      const { environment, release, dist, maxValueLength = 250 } = options;
      if (!("environment" in event)) {
        event.environment = "environment" in options ? environment : constants.DEFAULT_ENVIRONMENT;
      }
      if (event.release === void 0 && release !== void 0) {
        event.release = release;
      }
      if (event.dist === void 0 && dist !== void 0) {
        event.dist = dist;
      }
      if (event.message) {
        event.message = utils.truncate(event.message, maxValueLength);
      }
      const exception = event.exception && event.exception.values && event.exception.values[0];
      if (exception && exception.value) {
        exception.value = utils.truncate(exception.value, maxValueLength);
      }
      const request = event.request;
      if (request && request.url) {
        request.url = utils.truncate(request.url, maxValueLength);
      }
    }
    var debugIdStackParserCache = /* @__PURE__ */ new WeakMap();
    function applyDebugIds(event, stackParser) {
      const debugIdMap = utils.GLOBAL_OBJ._sentryDebugIds;
      if (!debugIdMap) {
        return;
      }
      let debugIdStackFramesCache;
      const cachedDebugIdStackFrameCache = debugIdStackParserCache.get(stackParser);
      if (cachedDebugIdStackFrameCache) {
        debugIdStackFramesCache = cachedDebugIdStackFrameCache;
      } else {
        debugIdStackFramesCache = /* @__PURE__ */ new Map();
        debugIdStackParserCache.set(stackParser, debugIdStackFramesCache);
      }
      const filenameDebugIdMap = Object.keys(debugIdMap).reduce((acc, debugIdStackTrace) => {
        let parsedStack;
        const cachedParsedStack = debugIdStackFramesCache.get(debugIdStackTrace);
        if (cachedParsedStack) {
          parsedStack = cachedParsedStack;
        } else {
          parsedStack = stackParser(debugIdStackTrace);
          debugIdStackFramesCache.set(debugIdStackTrace, parsedStack);
        }
        for (let i2 = parsedStack.length - 1; i2 >= 0; i2--) {
          const stackFrame = parsedStack[i2];
          if (stackFrame.filename) {
            acc[stackFrame.filename] = debugIdMap[debugIdStackTrace];
            break;
          }
        }
        return acc;
      }, {});
      try {
        event.exception.values.forEach((exception) => {
          exception.stacktrace.frames.forEach((frame) => {
            if (frame.filename) {
              frame.debug_id = filenameDebugIdMap[frame.filename];
            }
          });
        });
      } catch (e2) {
      }
    }
    function applyDebugMeta(event) {
      const filenameDebugIdMap = {};
      try {
        event.exception.values.forEach((exception) => {
          exception.stacktrace.frames.forEach((frame) => {
            if (frame.debug_id) {
              if (frame.abs_path) {
                filenameDebugIdMap[frame.abs_path] = frame.debug_id;
              } else if (frame.filename) {
                filenameDebugIdMap[frame.filename] = frame.debug_id;
              }
              delete frame.debug_id;
            }
          });
        });
      } catch (e2) {
      }
      if (Object.keys(filenameDebugIdMap).length === 0) {
        return;
      }
      event.debug_meta = event.debug_meta || {};
      event.debug_meta.images = event.debug_meta.images || [];
      const images = event.debug_meta.images;
      Object.keys(filenameDebugIdMap).forEach((filename) => {
        images.push({
          type: "sourcemap",
          code_file: filename,
          debug_id: filenameDebugIdMap[filename]
        });
      });
    }
    function applyIntegrationsMetadata(event, integrationNames) {
      if (integrationNames.length > 0) {
        event.sdk = event.sdk || {};
        event.sdk.integrations = [...event.sdk.integrations || [], ...integrationNames];
      }
    }
    function normalizeEvent(event, depth, maxBreadth) {
      if (!event) {
        return null;
      }
      const normalized = {
        ...event,
        ...event.breadcrumbs && {
          breadcrumbs: event.breadcrumbs.map((b) => ({
            ...b,
            ...b.data && {
              data: utils.normalize(b.data, depth, maxBreadth)
            }
          }))
        },
        ...event.user && {
          user: utils.normalize(event.user, depth, maxBreadth)
        },
        ...event.contexts && {
          contexts: utils.normalize(event.contexts, depth, maxBreadth)
        },
        ...event.extra && {
          extra: utils.normalize(event.extra, depth, maxBreadth)
        }
      };
      if (event.contexts && event.contexts.trace && normalized.contexts) {
        normalized.contexts.trace = event.contexts.trace;
        if (event.contexts.trace.data) {
          normalized.contexts.trace.data = utils.normalize(event.contexts.trace.data, depth, maxBreadth);
        }
      }
      if (event.spans) {
        normalized.spans = event.spans.map((span) => {
          const data = spanUtils.spanToJSON(span).data;
          if (data) {
            span.data = utils.normalize(data, depth, maxBreadth);
          }
          return span;
        });
      }
      return normalized;
    }
    function getFinalScope(scope$1, captureContext) {
      if (!captureContext) {
        return scope$1;
      }
      const finalScope = scope$1 ? scope$1.clone() : new scope.Scope();
      finalScope.update(captureContext);
      return finalScope;
    }
    function parseEventHintOrCaptureContext(hint) {
      if (!hint) {
        return void 0;
      }
      if (hintIsScopeOrFunction(hint)) {
        return { captureContext: hint };
      }
      if (hintIsScopeContext(hint)) {
        return {
          captureContext: hint
        };
      }
      return hint;
    }
    function hintIsScopeOrFunction(hint) {
      return hint instanceof scope.Scope || typeof hint === "function";
    }
    var captureContextKeys = [
      "user",
      "level",
      "extra",
      "contexts",
      "tags",
      "fingerprint",
      "requestSession",
      "propagationContext"
    ];
    function hintIsScopeContext(hint) {
      return Object.keys(hint).some((key) => captureContextKeys.includes(key));
    }
    exports.applyDebugIds = applyDebugIds;
    exports.applyDebugMeta = applyDebugMeta;
    exports.parseEventHintOrCaptureContext = parseEventHintOrCaptureContext;
    exports.prepareEvent = prepareEvent;
  }
});

// ../../../node_modules/.pnpm/@sentry+core@7.120.2/node_modules/@sentry/core/cjs/exports.js
var require_exports = __commonJS({
  "../../../node_modules/.pnpm/@sentry+core@7.120.2/node_modules/@sentry/core/cjs/exports.js"(exports) {
    init_define_ENV_DEFINED_IN_BUILD_STEP();
    Object.defineProperty(exports, "__esModule", { value: true });
    var utils = require_cjs();
    var constants = require_constants();
    var debugBuild = require_debug_build2();
    var hub = require_hub();
    var session = require_session();
    var prepareEvent = require_prepareEvent();
    function captureException2(exception, hint) {
      return hub.getCurrentHub().captureException(exception, prepareEvent.parseEventHintOrCaptureContext(hint));
    }
    function captureMessage(message, captureContext) {
      const level = typeof captureContext === "string" ? captureContext : void 0;
      const context2 = typeof captureContext !== "string" ? { captureContext } : void 0;
      return hub.getCurrentHub().captureMessage(message, level, context2);
    }
    function captureEvent(event, hint) {
      return hub.getCurrentHub().captureEvent(event, hint);
    }
    function configureScope(callback) {
      hub.getCurrentHub().configureScope(callback);
    }
    function addBreadcrumb(breadcrumb, hint) {
      hub.getCurrentHub().addBreadcrumb(breadcrumb, hint);
    }
    function setContext(name, context2) {
      hub.getCurrentHub().setContext(name, context2);
    }
    function setExtras(extras) {
      hub.getCurrentHub().setExtras(extras);
    }
    function setExtra(key, extra) {
      hub.getCurrentHub().setExtra(key, extra);
    }
    function setTags(tags) {
      hub.getCurrentHub().setTags(tags);
    }
    function setTag(key, value) {
      hub.getCurrentHub().setTag(key, value);
    }
    function setUser(user) {
      hub.getCurrentHub().setUser(user);
    }
    function withScope(...rest) {
      const hub$1 = hub.getCurrentHub();
      if (rest.length === 2) {
        const [scope, callback] = rest;
        if (!scope) {
          return hub$1.withScope(callback);
        }
        return hub$1.withScope(() => {
          hub$1.getStackTop().scope = scope;
          return callback(scope);
        });
      }
      return hub$1.withScope(rest[0]);
    }
    function withIsolationScope(callback) {
      return hub.runWithAsyncContext(() => {
        return callback(hub.getIsolationScope());
      });
    }
    function withActiveSpan(span, callback) {
      return withScope((scope) => {
        scope.setSpan(span);
        return callback(scope);
      });
    }
    function startTransaction(context2, customSamplingContext) {
      return hub.getCurrentHub().startTransaction({ ...context2 }, customSamplingContext);
    }
    function captureCheckIn(checkIn, upsertMonitorConfig) {
      const scope = getCurrentScope();
      const client = getClient();
      if (!client) {
        debugBuild.DEBUG_BUILD && utils.logger.warn("Cannot capture check-in. No client defined.");
      } else if (!client.captureCheckIn) {
        debugBuild.DEBUG_BUILD && utils.logger.warn("Cannot capture check-in. Client does not support sending check-ins.");
      } else {
        return client.captureCheckIn(checkIn, upsertMonitorConfig, scope);
      }
      return utils.uuid4();
    }
    function withMonitor(monitorSlug, callback, upsertMonitorConfig) {
      const checkInId = captureCheckIn({ monitorSlug, status: "in_progress" }, upsertMonitorConfig);
      const now = utils.timestampInSeconds();
      function finishCheckIn(status) {
        captureCheckIn({ monitorSlug, status, checkInId, duration: utils.timestampInSeconds() - now });
      }
      let maybePromiseResult;
      try {
        maybePromiseResult = callback();
      } catch (e2) {
        finishCheckIn("error");
        throw e2;
      }
      if (utils.isThenable(maybePromiseResult)) {
        Promise.resolve(maybePromiseResult).then(
          () => {
            finishCheckIn("ok");
          },
          () => {
            finishCheckIn("error");
          }
        );
      } else {
        finishCheckIn("ok");
      }
      return maybePromiseResult;
    }
    async function flush(timeout) {
      const client = getClient();
      if (client) {
        return client.flush(timeout);
      }
      debugBuild.DEBUG_BUILD && utils.logger.warn("Cannot flush events. No client defined.");
      return Promise.resolve(false);
    }
    async function close(timeout) {
      const client = getClient();
      if (client) {
        return client.close(timeout);
      }
      debugBuild.DEBUG_BUILD && utils.logger.warn("Cannot flush events and disable SDK. No client defined.");
      return Promise.resolve(false);
    }
    function lastEventId() {
      return hub.getCurrentHub().lastEventId();
    }
    function getClient() {
      return hub.getCurrentHub().getClient();
    }
    function isInitialized() {
      return !!getClient();
    }
    function getCurrentScope() {
      return hub.getCurrentHub().getScope();
    }
    function startSession(context2) {
      const client = getClient();
      const isolationScope = hub.getIsolationScope();
      const currentScope = getCurrentScope();
      const { release, environment = constants.DEFAULT_ENVIRONMENT } = client && client.getOptions() || {};
      const { userAgent } = utils.GLOBAL_OBJ.navigator || {};
      const session$1 = session.makeSession({
        release,
        environment,
        user: currentScope.getUser() || isolationScope.getUser(),
        ...userAgent && { userAgent },
        ...context2
      });
      const currentSession = isolationScope.getSession();
      if (currentSession && currentSession.status === "ok") {
        session.updateSession(currentSession, { status: "exited" });
      }
      endSession();
      isolationScope.setSession(session$1);
      currentScope.setSession(session$1);
      return session$1;
    }
    function endSession() {
      const isolationScope = hub.getIsolationScope();
      const currentScope = getCurrentScope();
      const session$1 = currentScope.getSession() || isolationScope.getSession();
      if (session$1) {
        session.closeSession(session$1);
      }
      _sendSessionUpdate();
      isolationScope.setSession();
      currentScope.setSession();
    }
    function _sendSessionUpdate() {
      const isolationScope = hub.getIsolationScope();
      const currentScope = getCurrentScope();
      const client = getClient();
      const session2 = currentScope.getSession() || isolationScope.getSession();
      if (session2 && client && client.captureSession) {
        client.captureSession(session2);
      }
    }
    function captureSession(end = false) {
      if (end) {
        endSession();
        return;
      }
      _sendSessionUpdate();
    }
    exports.addBreadcrumb = addBreadcrumb;
    exports.captureCheckIn = captureCheckIn;
    exports.captureEvent = captureEvent;
    exports.captureException = captureException2;
    exports.captureMessage = captureMessage;
    exports.captureSession = captureSession;
    exports.close = close;
    exports.configureScope = configureScope;
    exports.endSession = endSession;
    exports.flush = flush;
    exports.getClient = getClient;
    exports.getCurrentScope = getCurrentScope;
    exports.isInitialized = isInitialized;
    exports.lastEventId = lastEventId;
    exports.setContext = setContext;
    exports.setExtra = setExtra;
    exports.setExtras = setExtras;
    exports.setTag = setTag;
    exports.setTags = setTags;
    exports.setUser = setUser;
    exports.startSession = startSession;
    exports.startTransaction = startTransaction;
    exports.withActiveSpan = withActiveSpan;
    exports.withIsolationScope = withIsolationScope;
    exports.withMonitor = withMonitor;
    exports.withScope = withScope;
  }
});

// ../../../node_modules/.pnpm/@sentry+core@7.120.2/node_modules/@sentry/core/cjs/utils/getRootSpan.js
var require_getRootSpan = __commonJS({
  "../../../node_modules/.pnpm/@sentry+core@7.120.2/node_modules/@sentry/core/cjs/utils/getRootSpan.js"(exports) {
    init_define_ENV_DEFINED_IN_BUILD_STEP();
    Object.defineProperty(exports, "__esModule", { value: true });
    function getRootSpan(span) {
      return span.transaction;
    }
    exports.getRootSpan = getRootSpan;
  }
});

// ../../../node_modules/.pnpm/@sentry+core@7.120.2/node_modules/@sentry/core/cjs/tracing/dynamicSamplingContext.js
var require_dynamicSamplingContext = __commonJS({
  "../../../node_modules/.pnpm/@sentry+core@7.120.2/node_modules/@sentry/core/cjs/tracing/dynamicSamplingContext.js"(exports) {
    init_define_ENV_DEFINED_IN_BUILD_STEP();
    Object.defineProperty(exports, "__esModule", { value: true });
    var utils = require_cjs();
    var constants = require_constants();
    var exports$1 = require_exports();
    var getRootSpan = require_getRootSpan();
    var spanUtils = require_spanUtils();
    function getDynamicSamplingContextFromClient(trace_id, client, scope) {
      const options = client.getOptions();
      const { publicKey: public_key } = client.getDsn() || {};
      const { segment: user_segment } = scope && scope.getUser() || {};
      const dsc = utils.dropUndefinedKeys({
        environment: options.environment || constants.DEFAULT_ENVIRONMENT,
        release: options.release,
        user_segment,
        public_key,
        trace_id
      });
      client.emit && client.emit("createDsc", dsc);
      return dsc;
    }
    function getDynamicSamplingContextFromSpan(span) {
      const client = exports$1.getClient();
      if (!client) {
        return {};
      }
      const dsc = getDynamicSamplingContextFromClient(spanUtils.spanToJSON(span).trace_id || "", client, exports$1.getCurrentScope());
      const txn = getRootSpan.getRootSpan(span);
      if (!txn) {
        return dsc;
      }
      const v7FrozenDsc = txn && txn._frozenDynamicSamplingContext;
      if (v7FrozenDsc) {
        return v7FrozenDsc;
      }
      const { sampleRate: maybeSampleRate, source } = txn.metadata;
      if (maybeSampleRate != null) {
        dsc.sample_rate = `${maybeSampleRate}`;
      }
      const jsonSpan = spanUtils.spanToJSON(txn);
      if (source && source !== "url") {
        dsc.transaction = jsonSpan.description;
      }
      dsc.sampled = String(spanUtils.spanIsSampled(txn));
      client.emit && client.emit("createDsc", dsc);
      return dsc;
    }
    exports.getDynamicSamplingContextFromClient = getDynamicSamplingContextFromClient;
    exports.getDynamicSamplingContextFromSpan = getDynamicSamplingContextFromSpan;
  }
});

// ../../../node_modules/.pnpm/@sentry+core@7.120.2/node_modules/@sentry/core/cjs/utils/applyScopeDataToEvent.js
var require_applyScopeDataToEvent = __commonJS({
  "../../../node_modules/.pnpm/@sentry+core@7.120.2/node_modules/@sentry/core/cjs/utils/applyScopeDataToEvent.js"(exports) {
    init_define_ENV_DEFINED_IN_BUILD_STEP();
    Object.defineProperty(exports, "__esModule", { value: true });
    var utils = require_cjs();
    var dynamicSamplingContext = require_dynamicSamplingContext();
    var getRootSpan = require_getRootSpan();
    var spanUtils = require_spanUtils();
    function applyScopeDataToEvent(event, data) {
      const { fingerprint, span, breadcrumbs, sdkProcessingMetadata } = data;
      applyDataToEvent(event, data);
      if (span) {
        applySpanToEvent(event, span);
      }
      applyFingerprintToEvent(event, fingerprint);
      applyBreadcrumbsToEvent(event, breadcrumbs);
      applySdkMetadataToEvent(event, sdkProcessingMetadata);
    }
    function mergeScopeData(data, mergeData) {
      const {
        extra,
        tags,
        user,
        contexts,
        level,
        sdkProcessingMetadata,
        breadcrumbs,
        fingerprint,
        eventProcessors,
        attachments,
        propagationContext,
        // eslint-disable-next-line deprecation/deprecation
        transactionName,
        span
      } = mergeData;
      mergeAndOverwriteScopeData(data, "extra", extra);
      mergeAndOverwriteScopeData(data, "tags", tags);
      mergeAndOverwriteScopeData(data, "user", user);
      mergeAndOverwriteScopeData(data, "contexts", contexts);
      mergeAndOverwriteScopeData(data, "sdkProcessingMetadata", sdkProcessingMetadata);
      if (level) {
        data.level = level;
      }
      if (transactionName) {
        data.transactionName = transactionName;
      }
      if (span) {
        data.span = span;
      }
      if (breadcrumbs.length) {
        data.breadcrumbs = [...data.breadcrumbs, ...breadcrumbs];
      }
      if (fingerprint.length) {
        data.fingerprint = [...data.fingerprint, ...fingerprint];
      }
      if (eventProcessors.length) {
        data.eventProcessors = [...data.eventProcessors, ...eventProcessors];
      }
      if (attachments.length) {
        data.attachments = [...data.attachments, ...attachments];
      }
      data.propagationContext = { ...data.propagationContext, ...propagationContext };
    }
    function mergeAndOverwriteScopeData(data, prop, mergeVal) {
      if (mergeVal && Object.keys(mergeVal).length) {
        data[prop] = { ...data[prop] };
        for (const key in mergeVal) {
          if (Object.prototype.hasOwnProperty.call(mergeVal, key)) {
            data[prop][key] = mergeVal[key];
          }
        }
      }
    }
    function applyDataToEvent(event, data) {
      const {
        extra,
        tags,
        user,
        contexts,
        level,
        // eslint-disable-next-line deprecation/deprecation
        transactionName
      } = data;
      const cleanedExtra = utils.dropUndefinedKeys(extra);
      if (cleanedExtra && Object.keys(cleanedExtra).length) {
        event.extra = { ...cleanedExtra, ...event.extra };
      }
      const cleanedTags = utils.dropUndefinedKeys(tags);
      if (cleanedTags && Object.keys(cleanedTags).length) {
        event.tags = { ...cleanedTags, ...event.tags };
      }
      const cleanedUser = utils.dropUndefinedKeys(user);
      if (cleanedUser && Object.keys(cleanedUser).length) {
        event.user = { ...cleanedUser, ...event.user };
      }
      const cleanedContexts = utils.dropUndefinedKeys(contexts);
      if (cleanedContexts && Object.keys(cleanedContexts).length) {
        event.contexts = { ...cleanedContexts, ...event.contexts };
      }
      if (level) {
        event.level = level;
      }
      if (transactionName) {
        event.transaction = transactionName;
      }
    }
    function applyBreadcrumbsToEvent(event, breadcrumbs) {
      const mergedBreadcrumbs = [...event.breadcrumbs || [], ...breadcrumbs];
      event.breadcrumbs = mergedBreadcrumbs.length ? mergedBreadcrumbs : void 0;
    }
    function applySdkMetadataToEvent(event, sdkProcessingMetadata) {
      event.sdkProcessingMetadata = {
        ...event.sdkProcessingMetadata,
        ...sdkProcessingMetadata
      };
    }
    function applySpanToEvent(event, span) {
      event.contexts = { trace: spanUtils.spanToTraceContext(span), ...event.contexts };
      const rootSpan = getRootSpan.getRootSpan(span);
      if (rootSpan) {
        event.sdkProcessingMetadata = {
          dynamicSamplingContext: dynamicSamplingContext.getDynamicSamplingContextFromSpan(span),
          ...event.sdkProcessingMetadata
        };
        const transactionName = spanUtils.spanToJSON(rootSpan).description;
        if (transactionName) {
          event.tags = { transaction: transactionName, ...event.tags };
        }
      }
    }
    function applyFingerprintToEvent(event, fingerprint) {
      event.fingerprint = event.fingerprint ? utils.arrayify(event.fingerprint) : [];
      if (fingerprint) {
        event.fingerprint = event.fingerprint.concat(fingerprint);
      }
      if (event.fingerprint && !event.fingerprint.length) {
        delete event.fingerprint;
      }
    }
    exports.applyScopeDataToEvent = applyScopeDataToEvent;
    exports.mergeAndOverwriteScopeData = mergeAndOverwriteScopeData;
    exports.mergeScopeData = mergeScopeData;
  }
});

// ../../../node_modules/.pnpm/@sentry+core@7.120.2/node_modules/@sentry/core/cjs/scope.js
var require_scope = __commonJS({
  "../../../node_modules/.pnpm/@sentry+core@7.120.2/node_modules/@sentry/core/cjs/scope.js"(exports) {
    init_define_ENV_DEFINED_IN_BUILD_STEP();
    Object.defineProperty(exports, "__esModule", { value: true });
    var utils = require_cjs();
    var eventProcessors = require_eventProcessors();
    var session = require_session();
    var applyScopeDataToEvent = require_applyScopeDataToEvent();
    var DEFAULT_MAX_BREADCRUMBS = 100;
    var globalScope;
    var Scope = class _Scope {
      /** Flag if notifying is happening. */
      /** Callback for client to receive scope changes. */
      /** Callback list that will be called after {@link applyToEvent}. */
      /** Array of breadcrumbs. */
      /** User */
      /** Tags */
      /** Extra */
      /** Contexts */
      /** Attachments */
      /** Propagation Context for distributed tracing */
      /**
       * A place to stash data which is needed at some point in the SDK's event processing pipeline but which shouldn't get
       * sent to Sentry
       */
      /** Fingerprint */
      /** Severity */
      // eslint-disable-next-line deprecation/deprecation
      /**
       * Transaction Name
       */
      /** Span */
      /** Session */
      /** Request Mode Session Status */
      /** The client on this scope */
      // NOTE: Any field which gets added here should get added not only to the constructor but also to the `clone` method.
      constructor() {
        this._notifyingListeners = false;
        this._scopeListeners = [];
        this._eventProcessors = [];
        this._breadcrumbs = [];
        this._attachments = [];
        this._user = {};
        this._tags = {};
        this._extra = {};
        this._contexts = {};
        this._sdkProcessingMetadata = {};
        this._propagationContext = generatePropagationContext();
      }
      /**
       * Inherit values from the parent scope.
       * @deprecated Use `scope.clone()` and `new Scope()` instead.
       */
      static clone(scope) {
        return scope ? scope.clone() : new _Scope();
      }
      /**
       * Clone this scope instance.
       */
      clone() {
        const newScope = new _Scope();
        newScope._breadcrumbs = [...this._breadcrumbs];
        newScope._tags = { ...this._tags };
        newScope._extra = { ...this._extra };
        newScope._contexts = { ...this._contexts };
        newScope._user = this._user;
        newScope._level = this._level;
        newScope._span = this._span;
        newScope._session = this._session;
        newScope._transactionName = this._transactionName;
        newScope._fingerprint = this._fingerprint;
        newScope._eventProcessors = [...this._eventProcessors];
        newScope._requestSession = this._requestSession;
        newScope._attachments = [...this._attachments];
        newScope._sdkProcessingMetadata = { ...this._sdkProcessingMetadata };
        newScope._propagationContext = { ...this._propagationContext };
        newScope._client = this._client;
        return newScope;
      }
      /** Update the client on the scope. */
      setClient(client) {
        this._client = client;
      }
      /**
       * Get the client assigned to this scope.
       *
       * It is generally recommended to use the global function `Sentry.getClient()` instead, unless you know what you are doing.
       */
      getClient() {
        return this._client;
      }
      /**
       * Add internal on change listener. Used for sub SDKs that need to store the scope.
       * @hidden
       */
      addScopeListener(callback) {
        this._scopeListeners.push(callback);
      }
      /**
       * @inheritDoc
       */
      addEventProcessor(callback) {
        this._eventProcessors.push(callback);
        return this;
      }
      /**
       * @inheritDoc
       */
      setUser(user) {
        this._user = user || {
          email: void 0,
          id: void 0,
          ip_address: void 0,
          segment: void 0,
          username: void 0
        };
        if (this._session) {
          session.updateSession(this._session, { user });
        }
        this._notifyScopeListeners();
        return this;
      }
      /**
       * @inheritDoc
       */
      getUser() {
        return this._user;
      }
      /**
       * @inheritDoc
       */
      getRequestSession() {
        return this._requestSession;
      }
      /**
       * @inheritDoc
       */
      setRequestSession(requestSession) {
        this._requestSession = requestSession;
        return this;
      }
      /**
       * @inheritDoc
       */
      setTags(tags) {
        this._tags = {
          ...this._tags,
          ...tags
        };
        this._notifyScopeListeners();
        return this;
      }
      /**
       * @inheritDoc
       */
      setTag(key, value) {
        this._tags = { ...this._tags, [key]: value };
        this._notifyScopeListeners();
        return this;
      }
      /**
       * @inheritDoc
       */
      setExtras(extras) {
        this._extra = {
          ...this._extra,
          ...extras
        };
        this._notifyScopeListeners();
        return this;
      }
      /**
       * @inheritDoc
       */
      setExtra(key, extra) {
        this._extra = { ...this._extra, [key]: extra };
        this._notifyScopeListeners();
        return this;
      }
      /**
       * @inheritDoc
       */
      setFingerprint(fingerprint) {
        this._fingerprint = fingerprint;
        this._notifyScopeListeners();
        return this;
      }
      /**
       * @inheritDoc
       */
      setLevel(level) {
        this._level = level;
        this._notifyScopeListeners();
        return this;
      }
      /**
       * Sets the transaction name on the scope for future events.
       */
      setTransactionName(name) {
        this._transactionName = name;
        this._notifyScopeListeners();
        return this;
      }
      /**
       * @inheritDoc
       */
      setContext(key, context2) {
        if (context2 === null) {
          delete this._contexts[key];
        } else {
          this._contexts[key] = context2;
        }
        this._notifyScopeListeners();
        return this;
      }
      /**
       * Sets the Span on the scope.
       * @param span Span
       * @deprecated Instead of setting a span on a scope, use `startSpan()`/`startSpanManual()` instead.
       */
      setSpan(span) {
        this._span = span;
        this._notifyScopeListeners();
        return this;
      }
      /**
       * Returns the `Span` if there is one.
       * @deprecated Use `getActiveSpan()` instead.
       */
      getSpan() {
        return this._span;
      }
      /**
       * Returns the `Transaction` attached to the scope (if there is one).
       * @deprecated You should not rely on the transaction, but just use `startSpan()` APIs instead.
       */
      getTransaction() {
        const span = this._span;
        return span && span.transaction;
      }
      /**
       * @inheritDoc
       */
      setSession(session2) {
        if (!session2) {
          delete this._session;
        } else {
          this._session = session2;
        }
        this._notifyScopeListeners();
        return this;
      }
      /**
       * @inheritDoc
       */
      getSession() {
        return this._session;
      }
      /**
       * @inheritDoc
       */
      update(captureContext) {
        if (!captureContext) {
          return this;
        }
        const scopeToMerge = typeof captureContext === "function" ? captureContext(this) : captureContext;
        if (scopeToMerge instanceof _Scope) {
          const scopeData = scopeToMerge.getScopeData();
          this._tags = { ...this._tags, ...scopeData.tags };
          this._extra = { ...this._extra, ...scopeData.extra };
          this._contexts = { ...this._contexts, ...scopeData.contexts };
          if (scopeData.user && Object.keys(scopeData.user).length) {
            this._user = scopeData.user;
          }
          if (scopeData.level) {
            this._level = scopeData.level;
          }
          if (scopeData.fingerprint.length) {
            this._fingerprint = scopeData.fingerprint;
          }
          if (scopeToMerge.getRequestSession()) {
            this._requestSession = scopeToMerge.getRequestSession();
          }
          if (scopeData.propagationContext) {
            this._propagationContext = scopeData.propagationContext;
          }
        } else if (utils.isPlainObject(scopeToMerge)) {
          const scopeContext = captureContext;
          this._tags = { ...this._tags, ...scopeContext.tags };
          this._extra = { ...this._extra, ...scopeContext.extra };
          this._contexts = { ...this._contexts, ...scopeContext.contexts };
          if (scopeContext.user) {
            this._user = scopeContext.user;
          }
          if (scopeContext.level) {
            this._level = scopeContext.level;
          }
          if (scopeContext.fingerprint) {
            this._fingerprint = scopeContext.fingerprint;
          }
          if (scopeContext.requestSession) {
            this._requestSession = scopeContext.requestSession;
          }
          if (scopeContext.propagationContext) {
            this._propagationContext = scopeContext.propagationContext;
          }
        }
        return this;
      }
      /**
       * @inheritDoc
       */
      clear() {
        this._breadcrumbs = [];
        this._tags = {};
        this._extra = {};
        this._user = {};
        this._contexts = {};
        this._level = void 0;
        this._transactionName = void 0;
        this._fingerprint = void 0;
        this._requestSession = void 0;
        this._span = void 0;
        this._session = void 0;
        this._notifyScopeListeners();
        this._attachments = [];
        this._propagationContext = generatePropagationContext();
        return this;
      }
      /**
       * @inheritDoc
       */
      addBreadcrumb(breadcrumb, maxBreadcrumbs) {
        const maxCrumbs = typeof maxBreadcrumbs === "number" ? maxBreadcrumbs : DEFAULT_MAX_BREADCRUMBS;
        if (maxCrumbs <= 0) {
          return this;
        }
        const mergedBreadcrumb = {
          timestamp: utils.dateTimestampInSeconds(),
          ...breadcrumb
        };
        const breadcrumbs = this._breadcrumbs;
        breadcrumbs.push(mergedBreadcrumb);
        this._breadcrumbs = breadcrumbs.length > maxCrumbs ? breadcrumbs.slice(-maxCrumbs) : breadcrumbs;
        this._notifyScopeListeners();
        return this;
      }
      /**
       * @inheritDoc
       */
      getLastBreadcrumb() {
        return this._breadcrumbs[this._breadcrumbs.length - 1];
      }
      /**
       * @inheritDoc
       */
      clearBreadcrumbs() {
        this._breadcrumbs = [];
        this._notifyScopeListeners();
        return this;
      }
      /**
       * @inheritDoc
       */
      addAttachment(attachment) {
        this._attachments.push(attachment);
        return this;
      }
      /**
       * @inheritDoc
       * @deprecated Use `getScopeData()` instead.
       */
      getAttachments() {
        const data = this.getScopeData();
        return data.attachments;
      }
      /**
       * @inheritDoc
       */
      clearAttachments() {
        this._attachments = [];
        return this;
      }
      /** @inheritDoc */
      getScopeData() {
        const {
          _breadcrumbs,
          _attachments,
          _contexts,
          _tags,
          _extra,
          _user,
          _level,
          _fingerprint,
          _eventProcessors,
          _propagationContext,
          _sdkProcessingMetadata,
          _transactionName,
          _span
        } = this;
        return {
          breadcrumbs: _breadcrumbs,
          attachments: _attachments,
          contexts: _contexts,
          tags: _tags,
          extra: _extra,
          user: _user,
          level: _level,
          fingerprint: _fingerprint || [],
          eventProcessors: _eventProcessors,
          propagationContext: _propagationContext,
          sdkProcessingMetadata: _sdkProcessingMetadata,
          transactionName: _transactionName,
          span: _span
        };
      }
      /**
       * Applies data from the scope to the event and runs all event processors on it.
       *
       * @param event Event
       * @param hint Object containing additional information about the original exception, for use by the event processors.
       * @hidden
       * @deprecated Use `applyScopeDataToEvent()` directly
       */
      applyToEvent(event, hint = {}, additionalEventProcessors = []) {
        applyScopeDataToEvent.applyScopeDataToEvent(event, this.getScopeData());
        const eventProcessors$1 = [
          ...additionalEventProcessors,
          // eslint-disable-next-line deprecation/deprecation
          ...eventProcessors.getGlobalEventProcessors(),
          ...this._eventProcessors
        ];
        return eventProcessors.notifyEventProcessors(eventProcessors$1, event, hint);
      }
      /**
       * Add data which will be accessible during event processing but won't get sent to Sentry
       */
      setSDKProcessingMetadata(newData) {
        this._sdkProcessingMetadata = { ...this._sdkProcessingMetadata, ...newData };
        return this;
      }
      /**
       * @inheritDoc
       */
      setPropagationContext(context2) {
        this._propagationContext = context2;
        return this;
      }
      /**
       * @inheritDoc
       */
      getPropagationContext() {
        return this._propagationContext;
      }
      /**
       * Capture an exception for this scope.
       *
       * @param exception The exception to capture.
       * @param hint Optinal additional data to attach to the Sentry event.
       * @returns the id of the captured Sentry event.
       */
      captureException(exception, hint) {
        const eventId = hint && hint.event_id ? hint.event_id : utils.uuid4();
        if (!this._client) {
          utils.logger.warn("No client configured on scope - will not capture exception!");
          return eventId;
        }
        const syntheticException = new Error("Sentry syntheticException");
        this._client.captureException(
          exception,
          {
            originalException: exception,
            syntheticException,
            ...hint,
            event_id: eventId
          },
          this
        );
        return eventId;
      }
      /**
       * Capture a message for this scope.
       *
       * @param message The message to capture.
       * @param level An optional severity level to report the message with.
       * @param hint Optional additional data to attach to the Sentry event.
       * @returns the id of the captured message.
       */
      captureMessage(message, level, hint) {
        const eventId = hint && hint.event_id ? hint.event_id : utils.uuid4();
        if (!this._client) {
          utils.logger.warn("No client configured on scope - will not capture message!");
          return eventId;
        }
        const syntheticException = new Error(message);
        this._client.captureMessage(
          message,
          level,
          {
            originalException: message,
            syntheticException,
            ...hint,
            event_id: eventId
          },
          this
        );
        return eventId;
      }
      /**
       * Captures a manually created event for this scope and sends it to Sentry.
       *
       * @param exception The event to capture.
       * @param hint Optional additional data to attach to the Sentry event.
       * @returns the id of the captured event.
       */
      captureEvent(event, hint) {
        const eventId = hint && hint.event_id ? hint.event_id : utils.uuid4();
        if (!this._client) {
          utils.logger.warn("No client configured on scope - will not capture event!");
          return eventId;
        }
        this._client.captureEvent(event, { ...hint, event_id: eventId }, this);
        return eventId;
      }
      /**
       * This will be called on every set call.
       */
      _notifyScopeListeners() {
        if (!this._notifyingListeners) {
          this._notifyingListeners = true;
          this._scopeListeners.forEach((callback) => {
            callback(this);
          });
          this._notifyingListeners = false;
        }
      }
    };
    function getGlobalScope() {
      if (!globalScope) {
        globalScope = new Scope();
      }
      return globalScope;
    }
    function setGlobalScope(scope) {
      globalScope = scope;
    }
    function generatePropagationContext() {
      return {
        traceId: utils.uuid4(),
        spanId: utils.uuid4().substring(16)
      };
    }
    exports.Scope = Scope;
    exports.getGlobalScope = getGlobalScope;
    exports.setGlobalScope = setGlobalScope;
  }
});

// ../../../node_modules/.pnpm/@sentry+core@7.120.2/node_modules/@sentry/core/cjs/version.js
var require_version = __commonJS({
  "../../../node_modules/.pnpm/@sentry+core@7.120.2/node_modules/@sentry/core/cjs/version.js"(exports) {
    init_define_ENV_DEFINED_IN_BUILD_STEP();
    Object.defineProperty(exports, "__esModule", { value: true });
    var SDK_VERSION = "7.120.2";
    exports.SDK_VERSION = SDK_VERSION;
  }
});

// ../../../node_modules/.pnpm/@sentry+core@7.120.2/node_modules/@sentry/core/cjs/hub.js
var require_hub = __commonJS({
  "../../../node_modules/.pnpm/@sentry+core@7.120.2/node_modules/@sentry/core/cjs/hub.js"(exports) {
    init_define_ENV_DEFINED_IN_BUILD_STEP();
    Object.defineProperty(exports, "__esModule", { value: true });
    var utils = require_cjs();
    var constants = require_constants();
    var debugBuild = require_debug_build2();
    var scope = require_scope();
    var session = require_session();
    var version2 = require_version();
    var API_VERSION = parseFloat(version2.SDK_VERSION);
    var DEFAULT_BREADCRUMBS = 100;
    var Hub = class {
      /** Is a {@link Layer}[] containing the client and scope */
      /** Contains the last event id of a captured event.  */
      /**
       * Creates a new instance of the hub, will push one {@link Layer} into the
       * internal stack on creation.
       *
       * @param client bound to the hub.
       * @param scope bound to the hub.
       * @param version number, higher number means higher priority.
       *
       * @deprecated Instantiation of Hub objects is deprecated and the constructor will be removed in version 8 of the SDK.
       *
       * If you are currently using the Hub for multi-client use like so:
       *
       * ```
       * // OLD
       * const hub = new Hub();
       * hub.bindClient(client);
       * makeMain(hub)
       * ```
       *
       * instead initialize the client as follows:
       *
       * ```
       * // NEW
       * Sentry.withIsolationScope(() => {
       *    Sentry.setCurrentClient(client);
       *    client.init();
       * });
       * ```
       *
       * If you are using the Hub to capture events like so:
       *
       * ```
       * // OLD
       * const client = new Client();
       * const hub = new Hub(client);
       * hub.captureException()
       * ```
       *
       * instead capture isolated events as follows:
       *
       * ```
       * // NEW
       * const client = new Client();
       * const scope = new Scope();
       * scope.setClient(client);
       * scope.captureException();
       * ```
       */
      constructor(client, scope$1, isolationScope, _version = API_VERSION) {
        this._version = _version;
        let assignedScope;
        if (!scope$1) {
          assignedScope = new scope.Scope();
          assignedScope.setClient(client);
        } else {
          assignedScope = scope$1;
        }
        let assignedIsolationScope;
        if (!isolationScope) {
          assignedIsolationScope = new scope.Scope();
          assignedIsolationScope.setClient(client);
        } else {
          assignedIsolationScope = isolationScope;
        }
        this._stack = [{ scope: assignedScope }];
        if (client) {
          this.bindClient(client);
        }
        this._isolationScope = assignedIsolationScope;
      }
      /**
       * Checks if this hub's version is older than the given version.
       *
       * @param version A version number to compare to.
       * @return True if the given version is newer; otherwise false.
       *
       * @deprecated This will be removed in v8.
       */
      isOlderThan(version3) {
        return this._version < version3;
      }
      /**
       * This binds the given client to the current scope.
       * @param client An SDK client (client) instance.
       *
       * @deprecated Use `initAndBind()` directly, or `setCurrentClient()` and/or `client.init()` instead.
       */
      bindClient(client) {
        const top = this.getStackTop();
        top.client = client;
        top.scope.setClient(client);
        if (client && client.setupIntegrations) {
          client.setupIntegrations();
        }
      }
      /**
       * @inheritDoc
       *
       * @deprecated Use `withScope` instead.
       */
      pushScope() {
        const scope2 = this.getScope().clone();
        this.getStack().push({
          // eslint-disable-next-line deprecation/deprecation
          client: this.getClient(),
          scope: scope2
        });
        return scope2;
      }
      /**
       * @inheritDoc
       *
       * @deprecated Use `withScope` instead.
       */
      popScope() {
        if (this.getStack().length <= 1)
          return false;
        return !!this.getStack().pop();
      }
      /**
       * @inheritDoc
       *
       * @deprecated Use `Sentry.withScope()` instead.
       */
      withScope(callback) {
        const scope2 = this.pushScope();
        let maybePromiseResult;
        try {
          maybePromiseResult = callback(scope2);
        } catch (e2) {
          this.popScope();
          throw e2;
        }
        if (utils.isThenable(maybePromiseResult)) {
          return maybePromiseResult.then(
            (res) => {
              this.popScope();
              return res;
            },
            (e2) => {
              this.popScope();
              throw e2;
            }
          );
        }
        this.popScope();
        return maybePromiseResult;
      }
      /**
       * @inheritDoc
       *
       * @deprecated Use `Sentry.getClient()` instead.
       */
      getClient() {
        return this.getStackTop().client;
      }
      /**
       * Returns the scope of the top stack.
       *
       * @deprecated Use `Sentry.getCurrentScope()` instead.
       */
      getScope() {
        return this.getStackTop().scope;
      }
      /**
       * @deprecated Use `Sentry.getIsolationScope()` instead.
       */
      getIsolationScope() {
        return this._isolationScope;
      }
      /**
       * Returns the scope stack for domains or the process.
       * @deprecated This will be removed in v8.
       */
      getStack() {
        return this._stack;
      }
      /**
       * Returns the topmost scope layer in the order domain > local > process.
       * @deprecated This will be removed in v8.
       */
      getStackTop() {
        return this._stack[this._stack.length - 1];
      }
      /**
       * @inheritDoc
       *
       * @deprecated Use `Sentry.captureException()` instead.
       */
      captureException(exception, hint) {
        const eventId = this._lastEventId = hint && hint.event_id ? hint.event_id : utils.uuid4();
        const syntheticException = new Error("Sentry syntheticException");
        this.getScope().captureException(exception, {
          originalException: exception,
          syntheticException,
          ...hint,
          event_id: eventId
        });
        return eventId;
      }
      /**
       * @inheritDoc
       *
       * @deprecated Use  `Sentry.captureMessage()` instead.
       */
      captureMessage(message, level, hint) {
        const eventId = this._lastEventId = hint && hint.event_id ? hint.event_id : utils.uuid4();
        const syntheticException = new Error(message);
        this.getScope().captureMessage(message, level, {
          originalException: message,
          syntheticException,
          ...hint,
          event_id: eventId
        });
        return eventId;
      }
      /**
       * @inheritDoc
       *
       * @deprecated Use `Sentry.captureEvent()` instead.
       */
      captureEvent(event, hint) {
        const eventId = hint && hint.event_id ? hint.event_id : utils.uuid4();
        if (!event.type) {
          this._lastEventId = eventId;
        }
        this.getScope().captureEvent(event, { ...hint, event_id: eventId });
        return eventId;
      }
      /**
       * @inheritDoc
       *
       * @deprecated This will be removed in v8.
       */
      lastEventId() {
        return this._lastEventId;
      }
      /**
       * @inheritDoc
       *
       * @deprecated Use `Sentry.addBreadcrumb()` instead.
       */
      addBreadcrumb(breadcrumb, hint) {
        const { scope: scope2, client } = this.getStackTop();
        if (!client)
          return;
        const { beforeBreadcrumb = null, maxBreadcrumbs = DEFAULT_BREADCRUMBS } = client.getOptions && client.getOptions() || {};
        if (maxBreadcrumbs <= 0)
          return;
        const timestamp = utils.dateTimestampInSeconds();
        const mergedBreadcrumb = { timestamp, ...breadcrumb };
        const finalBreadcrumb = beforeBreadcrumb ? utils.consoleSandbox(() => beforeBreadcrumb(mergedBreadcrumb, hint)) : mergedBreadcrumb;
        if (finalBreadcrumb === null)
          return;
        if (client.emit) {
          client.emit("beforeAddBreadcrumb", finalBreadcrumb, hint);
        }
        scope2.addBreadcrumb(finalBreadcrumb, maxBreadcrumbs);
      }
      /**
       * @inheritDoc
       * @deprecated Use `Sentry.setUser()` instead.
       */
      setUser(user) {
        this.getScope().setUser(user);
        this.getIsolationScope().setUser(user);
      }
      /**
       * @inheritDoc
       * @deprecated Use `Sentry.setTags()` instead.
       */
      setTags(tags) {
        this.getScope().setTags(tags);
        this.getIsolationScope().setTags(tags);
      }
      /**
       * @inheritDoc
       * @deprecated Use `Sentry.setExtras()` instead.
       */
      setExtras(extras) {
        this.getScope().setExtras(extras);
        this.getIsolationScope().setExtras(extras);
      }
      /**
       * @inheritDoc
       * @deprecated Use `Sentry.setTag()` instead.
       */
      setTag(key, value) {
        this.getScope().setTag(key, value);
        this.getIsolationScope().setTag(key, value);
      }
      /**
       * @inheritDoc
       * @deprecated Use `Sentry.setExtra()` instead.
       */
      setExtra(key, extra) {
        this.getScope().setExtra(key, extra);
        this.getIsolationScope().setExtra(key, extra);
      }
      /**
       * @inheritDoc
       * @deprecated Use `Sentry.setContext()` instead.
       */
      // eslint-disable-next-line @typescript-eslint/no-explicit-any
      setContext(name, context2) {
        this.getScope().setContext(name, context2);
        this.getIsolationScope().setContext(name, context2);
      }
      /**
       * @inheritDoc
       *
       * @deprecated Use `getScope()` directly.
       */
      configureScope(callback) {
        const { scope: scope2, client } = this.getStackTop();
        if (client) {
          callback(scope2);
        }
      }
      /**
       * @inheritDoc
       */
      // eslint-disable-next-line deprecation/deprecation
      run(callback) {
        const oldHub = makeMain(this);
        try {
          callback(this);
        } finally {
          makeMain(oldHub);
        }
      }
      /**
       * @inheritDoc
       * @deprecated Use `Sentry.getClient().getIntegrationByName()` instead.
       */
      getIntegration(integration) {
        const client = this.getClient();
        if (!client)
          return null;
        try {
          return client.getIntegration(integration);
        } catch (_oO) {
          debugBuild.DEBUG_BUILD && utils.logger.warn(`Cannot retrieve integration ${integration.id} from the current Hub`);
          return null;
        }
      }
      /**
       * Starts a new `Transaction` and returns it. This is the entry point to manual tracing instrumentation.
       *
       * A tree structure can be built by adding child spans to the transaction, and child spans to other spans. To start a
       * new child span within the transaction or any span, call the respective `.startChild()` method.
       *
       * Every child span must be finished before the transaction is finished, otherwise the unfinished spans are discarded.
       *
       * The transaction must be finished with a call to its `.end()` method, at which point the transaction with all its
       * finished child spans will be sent to Sentry.
       *
       * @param context Properties of the new `Transaction`.
       * @param customSamplingContext Information given to the transaction sampling function (along with context-dependent
       * default values). See {@link Options.tracesSampler}.
       *
       * @returns The transaction which was just started
       *
       * @deprecated Use `startSpan()`, `startSpanManual()` or `startInactiveSpan()` instead.
       */
      startTransaction(context2, customSamplingContext) {
        const result = this._callExtensionMethod("startTransaction", context2, customSamplingContext);
        if (debugBuild.DEBUG_BUILD && !result) {
          const client = this.getClient();
          if (!client) {
            utils.logger.warn(
              "Tracing extension 'startTransaction' is missing. You should 'init' the SDK before calling 'startTransaction'"
            );
          } else {
            utils.logger.warn(`Tracing extension 'startTransaction' has not been added. Call 'addTracingExtensions' before calling 'init':
Sentry.addTracingExtensions();
Sentry.init({...});
`);
          }
        }
        return result;
      }
      /**
       * @inheritDoc
       * @deprecated Use `spanToTraceHeader()` instead.
       */
      traceHeaders() {
        return this._callExtensionMethod("traceHeaders");
      }
      /**
       * @inheritDoc
       *
       * @deprecated Use top level `captureSession` instead.
       */
      captureSession(endSession = false) {
        if (endSession) {
          return this.endSession();
        }
        this._sendSessionUpdate();
      }
      /**
       * @inheritDoc
       * @deprecated Use top level `endSession` instead.
       */
      endSession() {
        const layer = this.getStackTop();
        const scope2 = layer.scope;
        const session$1 = scope2.getSession();
        if (session$1) {
          session.closeSession(session$1);
        }
        this._sendSessionUpdate();
        scope2.setSession();
      }
      /**
       * @inheritDoc
       * @deprecated Use top level `startSession` instead.
       */
      startSession(context2) {
        const { scope: scope2, client } = this.getStackTop();
        const { release, environment = constants.DEFAULT_ENVIRONMENT } = client && client.getOptions() || {};
        const { userAgent } = utils.GLOBAL_OBJ.navigator || {};
        const session$1 = session.makeSession({
          release,
          environment,
          user: scope2.getUser(),
          ...userAgent && { userAgent },
          ...context2
        });
        const currentSession = scope2.getSession && scope2.getSession();
        if (currentSession && currentSession.status === "ok") {
          session.updateSession(currentSession, { status: "exited" });
        }
        this.endSession();
        scope2.setSession(session$1);
        return session$1;
      }
      /**
       * Returns if default PII should be sent to Sentry and propagated in ourgoing requests
       * when Tracing is used.
       *
       * @deprecated Use top-level `getClient().getOptions().sendDefaultPii` instead. This function
       * only unnecessarily increased API surface but only wrapped accessing the option.
       */
      shouldSendDefaultPii() {
        const client = this.getClient();
        const options = client && client.getOptions();
        return Boolean(options && options.sendDefaultPii);
      }
      /**
       * Sends the current Session on the scope
       */
      _sendSessionUpdate() {
        const { scope: scope2, client } = this.getStackTop();
        const session2 = scope2.getSession();
        if (session2 && client && client.captureSession) {
          client.captureSession(session2);
        }
      }
      /**
       * Calls global extension method and binding current instance to the function call
       */
      // @ts-expect-error Function lacks ending return statement and return type does not include 'undefined'. ts(2366)
      // eslint-disable-next-line @typescript-eslint/no-explicit-any
      _callExtensionMethod(method, ...args) {
        const carrier = getMainCarrier();
        const sentry = carrier.__SENTRY__;
        if (sentry && sentry.extensions && typeof sentry.extensions[method] === "function") {
          return sentry.extensions[method].apply(this, args);
        }
        debugBuild.DEBUG_BUILD && utils.logger.warn(`Extension method ${method} couldn't be found, doing nothing.`);
      }
    };
    function getMainCarrier() {
      utils.GLOBAL_OBJ.__SENTRY__ = utils.GLOBAL_OBJ.__SENTRY__ || {
        extensions: {},
        hub: void 0
      };
      return utils.GLOBAL_OBJ;
    }
    function makeMain(hub) {
      const registry = getMainCarrier();
      const oldHub = getHubFromCarrier(registry);
      setHubOnCarrier(registry, hub);
      return oldHub;
    }
    function getCurrentHub() {
      const registry = getMainCarrier();
      if (registry.__SENTRY__ && registry.__SENTRY__.acs) {
        const hub = registry.__SENTRY__.acs.getCurrentHub();
        if (hub) {
          return hub;
        }
      }
      return getGlobalHub(registry);
    }
    function getIsolationScope() {
      return getCurrentHub().getIsolationScope();
    }
    function getGlobalHub(registry = getMainCarrier()) {
      if (!hasHubOnCarrier(registry) || // eslint-disable-next-line deprecation/deprecation
      getHubFromCarrier(registry).isOlderThan(API_VERSION)) {
        setHubOnCarrier(registry, new Hub());
      }
      return getHubFromCarrier(registry);
    }
    function ensureHubOnCarrier(carrier, parent = getGlobalHub()) {
      if (!hasHubOnCarrier(carrier) || // eslint-disable-next-line deprecation/deprecation
      getHubFromCarrier(carrier).isOlderThan(API_VERSION)) {
        const client = parent.getClient();
        const scope2 = parent.getScope();
        const isolationScope = parent.getIsolationScope();
        setHubOnCarrier(carrier, new Hub(client, scope2.clone(), isolationScope.clone()));
      }
    }
    function setAsyncContextStrategy(strategy) {
      const registry = getMainCarrier();
      registry.__SENTRY__ = registry.__SENTRY__ || {};
      registry.__SENTRY__.acs = strategy;
    }
    function runWithAsyncContext(callback, options = {}) {
      const registry = getMainCarrier();
      if (registry.__SENTRY__ && registry.__SENTRY__.acs) {
        return registry.__SENTRY__.acs.runWithAsyncContext(callback, options);
      }
      return callback();
    }
    function hasHubOnCarrier(carrier) {
      return !!(carrier && carrier.__SENTRY__ && carrier.__SENTRY__.hub);
    }
    function getHubFromCarrier(carrier) {
      return utils.getGlobalSingleton("hub", () => new Hub(), carrier);
    }
    function setHubOnCarrier(carrier, hub) {
      if (!carrier)
        return false;
      const __SENTRY__ = carrier.__SENTRY__ = carrier.__SENTRY__ || {};
      __SENTRY__.hub = hub;
      return true;
    }
    exports.API_VERSION = API_VERSION;
    exports.Hub = Hub;
    exports.ensureHubOnCarrier = ensureHubOnCarrier;
    exports.getCurrentHub = getCurrentHub;
    exports.getHubFromCarrier = getHubFromCarrier;
    exports.getIsolationScope = getIsolationScope;
    exports.getMainCarrier = getMainCarrier;
    exports.makeMain = makeMain;
    exports.runWithAsyncContext = runWithAsyncContext;
    exports.setAsyncContextStrategy = setAsyncContextStrategy;
    exports.setHubOnCarrier = setHubOnCarrier;
  }
});

// ../../../node_modules/.pnpm/@sentry+core@7.120.2/node_modules/@sentry/core/cjs/tracing/utils.js
var require_utils = __commonJS({
  "../../../node_modules/.pnpm/@sentry+core@7.120.2/node_modules/@sentry/core/cjs/tracing/utils.js"(exports) {
    init_define_ENV_DEFINED_IN_BUILD_STEP();
    Object.defineProperty(exports, "__esModule", { value: true });
    var utils = require_cjs();
    var hub = require_hub();
    function getActiveTransaction(maybeHub) {
      const hub$1 = maybeHub || hub.getCurrentHub();
      const scope = hub$1.getScope();
      return scope.getTransaction();
    }
    var extractTraceparentData = utils.extractTraceparentData;
    exports.stripUrlQueryAndFragment = utils.stripUrlQueryAndFragment;
    exports.extractTraceparentData = extractTraceparentData;
    exports.getActiveTransaction = getActiveTransaction;
  }
});

// ../../../node_modules/.pnpm/@sentry+core@7.120.2/node_modules/@sentry/core/cjs/tracing/errors.js
var require_errors = __commonJS({
  "../../../node_modules/.pnpm/@sentry+core@7.120.2/node_modules/@sentry/core/cjs/tracing/errors.js"(exports) {
    init_define_ENV_DEFINED_IN_BUILD_STEP();
    Object.defineProperty(exports, "__esModule", { value: true });
    var utils = require_cjs();
    var debugBuild = require_debug_build2();
    var utils$1 = require_utils();
    var errorsInstrumented = false;
    function registerErrorInstrumentation() {
      if (errorsInstrumented) {
        return;
      }
      errorsInstrumented = true;
      utils.addGlobalErrorInstrumentationHandler(errorCallback);
      utils.addGlobalUnhandledRejectionInstrumentationHandler(errorCallback);
    }
    function errorCallback() {
      const activeTransaction = utils$1.getActiveTransaction();
      if (activeTransaction) {
        const status = "internal_error";
        debugBuild.DEBUG_BUILD && utils.logger.log(`[Tracing] Transaction: ${status} -> Global error occured`);
        activeTransaction.setStatus(status);
      }
    }
    errorCallback.tag = "sentry_tracingErrorCallback";
    exports.registerErrorInstrumentation = registerErrorInstrumentation;
  }
});

// ../../../node_modules/.pnpm/@sentry+core@7.120.2/node_modules/@sentry/core/cjs/tracing/spanstatus.js
var require_spanstatus = __commonJS({
  "../../../node_modules/.pnpm/@sentry+core@7.120.2/node_modules/@sentry/core/cjs/tracing/spanstatus.js"(exports) {
    init_define_ENV_DEFINED_IN_BUILD_STEP();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.SpanStatus = void 0;
    (function(SpanStatus) {
      const Ok = "ok";
      SpanStatus["Ok"] = Ok;
      const DeadlineExceeded = "deadline_exceeded";
      SpanStatus["DeadlineExceeded"] = DeadlineExceeded;
      const Unauthenticated = "unauthenticated";
      SpanStatus["Unauthenticated"] = Unauthenticated;
      const PermissionDenied = "permission_denied";
      SpanStatus["PermissionDenied"] = PermissionDenied;
      const NotFound = "not_found";
      SpanStatus["NotFound"] = NotFound;
      const ResourceExhausted = "resource_exhausted";
      SpanStatus["ResourceExhausted"] = ResourceExhausted;
      const InvalidArgument = "invalid_argument";
      SpanStatus["InvalidArgument"] = InvalidArgument;
      const Unimplemented = "unimplemented";
      SpanStatus["Unimplemented"] = Unimplemented;
      const Unavailable = "unavailable";
      SpanStatus["Unavailable"] = Unavailable;
      const InternalError = "internal_error";
      SpanStatus["InternalError"] = InternalError;
      const UnknownError = "unknown_error";
      SpanStatus["UnknownError"] = UnknownError;
      const Cancelled = "cancelled";
      SpanStatus["Cancelled"] = Cancelled;
      const AlreadyExists = "already_exists";
      SpanStatus["AlreadyExists"] = AlreadyExists;
      const FailedPrecondition = "failed_precondition";
      SpanStatus["FailedPrecondition"] = FailedPrecondition;
      const Aborted = "aborted";
      SpanStatus["Aborted"] = Aborted;
      const OutOfRange = "out_of_range";
      SpanStatus["OutOfRange"] = OutOfRange;
      const DataLoss = "data_loss";
      SpanStatus["DataLoss"] = DataLoss;
    })(exports.SpanStatus || (exports.SpanStatus = {}));
    function getSpanStatusFromHttpCode(httpStatus) {
      if (httpStatus < 400 && httpStatus >= 100) {
        return "ok";
      }
      if (httpStatus >= 400 && httpStatus < 500) {
        switch (httpStatus) {
          case 401:
            return "unauthenticated";
          case 403:
            return "permission_denied";
          case 404:
            return "not_found";
          case 409:
            return "already_exists";
          case 413:
            return "failed_precondition";
          case 429:
            return "resource_exhausted";
          default:
            return "invalid_argument";
        }
      }
      if (httpStatus >= 500 && httpStatus < 600) {
        switch (httpStatus) {
          case 501:
            return "unimplemented";
          case 503:
            return "unavailable";
          case 504:
            return "deadline_exceeded";
          default:
            return "internal_error";
        }
      }
      return "unknown_error";
    }
    var spanStatusfromHttpCode = getSpanStatusFromHttpCode;
    function setHttpStatus(span, httpStatus) {
      span.setTag("http.status_code", String(httpStatus));
      span.setData("http.response.status_code", httpStatus);
      const spanStatus = getSpanStatusFromHttpCode(httpStatus);
      if (spanStatus !== "unknown_error") {
        span.setStatus(spanStatus);
      }
    }
    exports.getSpanStatusFromHttpCode = getSpanStatusFromHttpCode;
    exports.setHttpStatus = setHttpStatus;
    exports.spanStatusfromHttpCode = spanStatusfromHttpCode;
  }
});

// ../../../node_modules/.pnpm/@sentry+core@7.120.2/node_modules/@sentry/core/cjs/utils/handleCallbackErrors.js
var require_handleCallbackErrors = __commonJS({
  "../../../node_modules/.pnpm/@sentry+core@7.120.2/node_modules/@sentry/core/cjs/utils/handleCallbackErrors.js"(exports) {
    init_define_ENV_DEFINED_IN_BUILD_STEP();
    Object.defineProperty(exports, "__esModule", { value: true });
    var utils = require_cjs();
    function handleCallbackErrors(fn, onError, onFinally = () => {
    }) {
      let maybePromiseResult;
      try {
        maybePromiseResult = fn();
      } catch (e2) {
        onError(e2);
        onFinally();
        throw e2;
      }
      return maybeHandlePromiseRejection(maybePromiseResult, onError, onFinally);
    }
    function maybeHandlePromiseRejection(value, onError, onFinally) {
      if (utils.isThenable(value)) {
        return value.then(
          (res) => {
            onFinally();
            return res;
          },
          (e2) => {
            onError(e2);
            onFinally();
            throw e2;
          }
        );
      }
      onFinally();
      return value;
    }
    exports.handleCallbackErrors = handleCallbackErrors;
  }
});

// ../../../node_modules/.pnpm/@sentry+core@7.120.2/node_modules/@sentry/core/cjs/utils/hasTracingEnabled.js
var require_hasTracingEnabled = __commonJS({
  "../../../node_modules/.pnpm/@sentry+core@7.120.2/node_modules/@sentry/core/cjs/utils/hasTracingEnabled.js"(exports) {
    init_define_ENV_DEFINED_IN_BUILD_STEP();
    Object.defineProperty(exports, "__esModule", { value: true });
    var exports$1 = require_exports();
    function hasTracingEnabled(maybeOptions) {
      if (typeof __SENTRY_TRACING__ === "boolean" && !__SENTRY_TRACING__) {
        return false;
      }
      const client = exports$1.getClient();
      const options = maybeOptions || client && client.getOptions();
      return !!options && (options.enableTracing || "tracesSampleRate" in options || "tracesSampler" in options);
    }
    exports.hasTracingEnabled = hasTracingEnabled;
  }
});

// ../../../node_modules/.pnpm/@sentry+core@7.120.2/node_modules/@sentry/core/cjs/tracing/trace.js
var require_trace = __commonJS({
  "../../../node_modules/.pnpm/@sentry+core@7.120.2/node_modules/@sentry/core/cjs/tracing/trace.js"(exports) {
    init_define_ENV_DEFINED_IN_BUILD_STEP();
    Object.defineProperty(exports, "__esModule", { value: true });
    var utils = require_cjs();
    var debugBuild = require_debug_build2();
    var hub = require_hub();
    var spanUtils = require_spanUtils();
    require_errors();
    require_spanstatus();
    var dynamicSamplingContext = require_dynamicSamplingContext();
    var exports$1 = require_exports();
    var handleCallbackErrors = require_handleCallbackErrors();
    var hasTracingEnabled = require_hasTracingEnabled();
    function trace(context2, callback, onError = () => {
    }, afterFinish = () => {
    }) {
      const hub$1 = hub.getCurrentHub();
      const scope = exports$1.getCurrentScope();
      const parentSpan = scope.getSpan();
      const spanContext = normalizeContext(context2);
      const activeSpan = createChildSpanOrTransaction(hub$1, {
        parentSpan,
        spanContext,
        forceTransaction: false,
        scope
      });
      scope.setSpan(activeSpan);
      return handleCallbackErrors.handleCallbackErrors(
        () => callback(activeSpan),
        (error) => {
          activeSpan && activeSpan.setStatus("internal_error");
          onError(error, activeSpan);
        },
        () => {
          activeSpan && activeSpan.end();
          scope.setSpan(parentSpan);
          afterFinish();
        }
      );
    }
    function startSpan(context2, callback) {
      const spanContext = normalizeContext(context2);
      return hub.runWithAsyncContext(() => {
        return exports$1.withScope(context2.scope, (scope) => {
          const hub$1 = hub.getCurrentHub();
          const parentSpan = scope.getSpan();
          const shouldSkipSpan = context2.onlyIfParent && !parentSpan;
          const activeSpan = shouldSkipSpan ? void 0 : createChildSpanOrTransaction(hub$1, {
            parentSpan,
            spanContext,
            forceTransaction: context2.forceTransaction,
            scope
          });
          return handleCallbackErrors.handleCallbackErrors(
            () => callback(activeSpan),
            () => {
              if (activeSpan) {
                const { status } = spanUtils.spanToJSON(activeSpan);
                if (!status || status === "ok") {
                  activeSpan.setStatus("internal_error");
                }
              }
            },
            () => activeSpan && activeSpan.end()
          );
        });
      });
    }
    var startActiveSpan = startSpan;
    function startSpanManual(context2, callback) {
      const spanContext = normalizeContext(context2);
      return hub.runWithAsyncContext(() => {
        return exports$1.withScope(context2.scope, (scope) => {
          const hub$1 = hub.getCurrentHub();
          const parentSpan = scope.getSpan();
          const shouldSkipSpan = context2.onlyIfParent && !parentSpan;
          const activeSpan = shouldSkipSpan ? void 0 : createChildSpanOrTransaction(hub$1, {
            parentSpan,
            spanContext,
            forceTransaction: context2.forceTransaction,
            scope
          });
          function finishAndSetSpan() {
            activeSpan && activeSpan.end();
          }
          return handleCallbackErrors.handleCallbackErrors(
            () => callback(activeSpan, finishAndSetSpan),
            () => {
              if (activeSpan && activeSpan.isRecording()) {
                const { status } = spanUtils.spanToJSON(activeSpan);
                if (!status || status === "ok") {
                  activeSpan.setStatus("internal_error");
                }
              }
            }
          );
        });
      });
    }
    function startInactiveSpan(context2) {
      if (!hasTracingEnabled.hasTracingEnabled()) {
        return void 0;
      }
      const spanContext = normalizeContext(context2);
      const hub$1 = hub.getCurrentHub();
      const parentSpan = context2.scope ? (
        // eslint-disable-next-line deprecation/deprecation
        context2.scope.getSpan()
      ) : getActiveSpan();
      const shouldSkipSpan = context2.onlyIfParent && !parentSpan;
      if (shouldSkipSpan) {
        return void 0;
      }
      const scope = context2.scope || exports$1.getCurrentScope();
      const temporaryScope = scope.clone();
      return createChildSpanOrTransaction(hub$1, {
        parentSpan,
        spanContext,
        forceTransaction: context2.forceTransaction,
        scope: temporaryScope
      });
    }
    function getActiveSpan() {
      return exports$1.getCurrentScope().getSpan();
    }
    var continueTrace = ({
      sentryTrace,
      baggage
    }, callback) => {
      const currentScope = exports$1.getCurrentScope();
      const { traceparentData, dynamicSamplingContext: dynamicSamplingContext2, propagationContext } = utils.tracingContextFromHeaders(
        sentryTrace,
        baggage
      );
      currentScope.setPropagationContext(propagationContext);
      if (debugBuild.DEBUG_BUILD && traceparentData) {
        utils.logger.log(`[Tracing] Continuing trace ${traceparentData.traceId}.`);
      }
      const transactionContext = {
        ...traceparentData,
        metadata: utils.dropUndefinedKeys({
          dynamicSamplingContext: dynamicSamplingContext2
        })
      };
      if (!callback) {
        return transactionContext;
      }
      return hub.runWithAsyncContext(() => {
        return callback(transactionContext);
      });
    };
    function createChildSpanOrTransaction(hub$1, {
      parentSpan,
      spanContext,
      forceTransaction,
      scope
    }) {
      if (!hasTracingEnabled.hasTracingEnabled()) {
        return void 0;
      }
      const isolationScope = hub.getIsolationScope();
      let span;
      if (parentSpan && !forceTransaction) {
        span = parentSpan.startChild(spanContext);
      } else if (parentSpan) {
        const dsc = dynamicSamplingContext.getDynamicSamplingContextFromSpan(parentSpan);
        const { traceId, spanId: parentSpanId } = parentSpan.spanContext();
        const sampled = spanUtils.spanIsSampled(parentSpan);
        span = hub$1.startTransaction({
          traceId,
          parentSpanId,
          parentSampled: sampled,
          ...spanContext,
          metadata: {
            dynamicSamplingContext: dsc,
            // eslint-disable-next-line deprecation/deprecation
            ...spanContext.metadata
          }
        });
      } else {
        const { traceId, dsc, parentSpanId, sampled } = {
          ...isolationScope.getPropagationContext(),
          ...scope.getPropagationContext()
        };
        span = hub$1.startTransaction({
          traceId,
          parentSpanId,
          parentSampled: sampled,
          ...spanContext,
          metadata: {
            dynamicSamplingContext: dsc,
            // eslint-disable-next-line deprecation/deprecation
            ...spanContext.metadata
          }
        });
      }
      scope.setSpan(span);
      setCapturedScopesOnSpan(span, scope, isolationScope);
      return span;
    }
    function normalizeContext(context2) {
      if (context2.startTime) {
        const ctx = { ...context2 };
        ctx.startTimestamp = spanUtils.spanTimeInputToSeconds(context2.startTime);
        delete ctx.startTime;
        return ctx;
      }
      return context2;
    }
    var SCOPE_ON_START_SPAN_FIELD = "_sentryScope";
    var ISOLATION_SCOPE_ON_START_SPAN_FIELD = "_sentryIsolationScope";
    function setCapturedScopesOnSpan(span, scope, isolationScope) {
      if (span) {
        utils.addNonEnumerableProperty(span, ISOLATION_SCOPE_ON_START_SPAN_FIELD, isolationScope);
        utils.addNonEnumerableProperty(span, SCOPE_ON_START_SPAN_FIELD, scope);
      }
    }
    function getCapturedScopesOnSpan(span) {
      return {
        scope: span[SCOPE_ON_START_SPAN_FIELD],
        isolationScope: span[ISOLATION_SCOPE_ON_START_SPAN_FIELD]
      };
    }
    exports.continueTrace = continueTrace;
    exports.getActiveSpan = getActiveSpan;
    exports.getCapturedScopesOnSpan = getCapturedScopesOnSpan;
    exports.startActiveSpan = startActiveSpan;
    exports.startInactiveSpan = startInactiveSpan;
    exports.startSpan = startSpan;
    exports.startSpanManual = startSpanManual;
    exports.trace = trace;
  }
});

// ../../../node_modules/.pnpm/@sentry+core@7.120.2/node_modules/@sentry/core/cjs/metrics/metric-summary.js
var require_metric_summary = __commonJS({
  "../../../node_modules/.pnpm/@sentry+core@7.120.2/node_modules/@sentry/core/cjs/metrics/metric-summary.js"(exports) {
    init_define_ENV_DEFINED_IN_BUILD_STEP();
    Object.defineProperty(exports, "__esModule", { value: true });
    var utils = require_cjs();
    require_debug_build2();
    require_errors();
    require_spanstatus();
    var trace = require_trace();
    var SPAN_METRIC_SUMMARY;
    function getMetricStorageForSpan(span) {
      return SPAN_METRIC_SUMMARY ? SPAN_METRIC_SUMMARY.get(span) : void 0;
    }
    function getMetricSummaryJsonForSpan(span) {
      const storage = getMetricStorageForSpan(span);
      if (!storage) {
        return void 0;
      }
      const output = {};
      for (const [, [exportKey, summary]] of storage) {
        if (!output[exportKey]) {
          output[exportKey] = [];
        }
        output[exportKey].push(utils.dropUndefinedKeys(summary));
      }
      return output;
    }
    function updateMetricSummaryOnActiveSpan(metricType, sanitizedName, value, unit, tags, bucketKey) {
      const span = trace.getActiveSpan();
      if (span) {
        const storage = getMetricStorageForSpan(span) || /* @__PURE__ */ new Map();
        const exportKey = `${metricType}:${sanitizedName}@${unit}`;
        const bucketItem = storage.get(bucketKey);
        if (bucketItem) {
          const [, summary] = bucketItem;
          storage.set(bucketKey, [
            exportKey,
            {
              min: Math.min(summary.min, value),
              max: Math.max(summary.max, value),
              count: summary.count += 1,
              sum: summary.sum += value,
              tags: summary.tags
            }
          ]);
        } else {
          storage.set(bucketKey, [
            exportKey,
            {
              min: value,
              max: value,
              count: 1,
              sum: value,
              tags
            }
          ]);
        }
        if (!SPAN_METRIC_SUMMARY) {
          SPAN_METRIC_SUMMARY = /* @__PURE__ */ new WeakMap();
        }
        SPAN_METRIC_SUMMARY.set(span, storage);
      }
    }
    exports.getMetricSummaryJsonForSpan = getMetricSummaryJsonForSpan;
    exports.updateMetricSummaryOnActiveSpan = updateMetricSummaryOnActiveSpan;
  }
});

// ../../../node_modules/.pnpm/@sentry+core@7.120.2/node_modules/@sentry/core/cjs/semanticAttributes.js
var require_semanticAttributes = __commonJS({
  "../../../node_modules/.pnpm/@sentry+core@7.120.2/node_modules/@sentry/core/cjs/semanticAttributes.js"(exports) {
    init_define_ENV_DEFINED_IN_BUILD_STEP();
    Object.defineProperty(exports, "__esModule", { value: true });
    var SEMANTIC_ATTRIBUTE_SENTRY_SOURCE = "sentry.source";
    var SEMANTIC_ATTRIBUTE_SENTRY_SAMPLE_RATE = "sentry.sample_rate";
    var SEMANTIC_ATTRIBUTE_SENTRY_OP = "sentry.op";
    var SEMANTIC_ATTRIBUTE_SENTRY_ORIGIN = "sentry.origin";
    var SEMANTIC_ATTRIBUTE_PROFILE_ID = "profile_id";
    exports.SEMANTIC_ATTRIBUTE_PROFILE_ID = SEMANTIC_ATTRIBUTE_PROFILE_ID;
    exports.SEMANTIC_ATTRIBUTE_SENTRY_OP = SEMANTIC_ATTRIBUTE_SENTRY_OP;
    exports.SEMANTIC_ATTRIBUTE_SENTRY_ORIGIN = SEMANTIC_ATTRIBUTE_SENTRY_ORIGIN;
    exports.SEMANTIC_ATTRIBUTE_SENTRY_SAMPLE_RATE = SEMANTIC_ATTRIBUTE_SENTRY_SAMPLE_RATE;
    exports.SEMANTIC_ATTRIBUTE_SENTRY_SOURCE = SEMANTIC_ATTRIBUTE_SENTRY_SOURCE;
  }
});

// ../../../node_modules/.pnpm/@sentry+core@7.120.2/node_modules/@sentry/core/cjs/tracing/span.js
var require_span = __commonJS({
  "../../../node_modules/.pnpm/@sentry+core@7.120.2/node_modules/@sentry/core/cjs/tracing/span.js"(exports) {
    init_define_ENV_DEFINED_IN_BUILD_STEP();
    Object.defineProperty(exports, "__esModule", { value: true });
    var utils = require_cjs();
    var debugBuild = require_debug_build2();
    var metricSummary = require_metric_summary();
    var semanticAttributes = require_semanticAttributes();
    var getRootSpan = require_getRootSpan();
    var spanUtils = require_spanUtils();
    var spanstatus = require_spanstatus();
    var SpanRecorder = class {
      constructor(maxlen = 1e3) {
        this._maxlen = maxlen;
        this.spans = [];
      }
      /**
       * This is just so that we don't run out of memory while recording a lot
       * of spans. At some point we just stop and flush out the start of the
       * trace tree (i.e.the first n spans with the smallest
       * start_timestamp).
       */
      add(span) {
        if (this.spans.length > this._maxlen) {
          span.spanRecorder = void 0;
        } else {
          this.spans.push(span);
        }
      }
    };
    var Span = class _Span {
      /**
       * Tags for the span.
       * @deprecated Use `spanToJSON(span).atttributes` instead.
       */
      /**
       * Data for the span.
       * @deprecated Use `spanToJSON(span).atttributes` instead.
       */
      // eslint-disable-next-line @typescript-eslint/no-explicit-any
      /**
       * List of spans that were finalized
       *
       * @deprecated This property will no longer be public. Span recording will be handled internally.
       */
      /**
       * @inheritDoc
       * @deprecated Use top level `Sentry.getRootSpan()` instead
       */
      /**
       * The instrumenter that created this span.
       *
       * TODO (v8): This can probably be replaced by an `instanceOf` check of the span class.
       *            the instrumenter can only be sentry or otel so we can check the span instance
       *            to verify which one it is and remove this field entirely.
       *
       * @deprecated This field will be removed.
       */
      /** Epoch timestamp in seconds when the span started. */
      /** Epoch timestamp in seconds when the span ended. */
      /** Internal keeper of the status */
      /**
       * You should never call the constructor manually, always use `Sentry.startTransaction()`
       * or call `startChild()` on an existing span.
       * @internal
       * @hideconstructor
       * @hidden
       */
      constructor(spanContext = {}) {
        this._traceId = spanContext.traceId || utils.uuid4();
        this._spanId = spanContext.spanId || utils.uuid4().substring(16);
        this._startTime = spanContext.startTimestamp || utils.timestampInSeconds();
        this.tags = spanContext.tags ? { ...spanContext.tags } : {};
        this.data = spanContext.data ? { ...spanContext.data } : {};
        this.instrumenter = spanContext.instrumenter || "sentry";
        this._attributes = {};
        this.setAttributes({
          [semanticAttributes.SEMANTIC_ATTRIBUTE_SENTRY_ORIGIN]: spanContext.origin || "manual",
          [semanticAttributes.SEMANTIC_ATTRIBUTE_SENTRY_OP]: spanContext.op,
          ...spanContext.attributes
        });
        this._name = spanContext.name || spanContext.description;
        if (spanContext.parentSpanId) {
          this._parentSpanId = spanContext.parentSpanId;
        }
        if ("sampled" in spanContext) {
          this._sampled = spanContext.sampled;
        }
        if (spanContext.status) {
          this._status = spanContext.status;
        }
        if (spanContext.endTimestamp) {
          this._endTime = spanContext.endTimestamp;
        }
        if (spanContext.exclusiveTime !== void 0) {
          this._exclusiveTime = spanContext.exclusiveTime;
        }
        this._measurements = spanContext.measurements ? { ...spanContext.measurements } : {};
      }
      // This rule conflicts with another eslint rule :(
      /* eslint-disable @typescript-eslint/member-ordering */
      /**
       * An alias for `description` of the Span.
       * @deprecated Use `spanToJSON(span).description` instead.
       */
      get name() {
        return this._name || "";
      }
      /**
       * Update the name of the span.
       * @deprecated Use `spanToJSON(span).description` instead.
       */
      set name(name) {
        this.updateName(name);
      }
      /**
       * Get the description of the Span.
       * @deprecated Use `spanToJSON(span).description` instead.
       */
      get description() {
        return this._name;
      }
      /**
       * Get the description of the Span.
       * @deprecated Use `spanToJSON(span).description` instead.
       */
      set description(description) {
        this._name = description;
      }
      /**
       * The ID of the trace.
       * @deprecated Use `spanContext().traceId` instead.
       */
      get traceId() {
        return this._traceId;
      }
      /**
       * The ID of the trace.
       * @deprecated You cannot update the traceId of a span after span creation.
       */
      set traceId(traceId) {
        this._traceId = traceId;
      }
      /**
       * The ID of the span.
       * @deprecated Use `spanContext().spanId` instead.
       */
      get spanId() {
        return this._spanId;
      }
      /**
       * The ID of the span.
       * @deprecated You cannot update the spanId of a span after span creation.
       */
      set spanId(spanId) {
        this._spanId = spanId;
      }
      /**
       * @inheritDoc
       *
       * @deprecated Use `startSpan` functions instead.
       */
      set parentSpanId(string) {
        this._parentSpanId = string;
      }
      /**
       * @inheritDoc
       *
       * @deprecated Use `spanToJSON(span).parent_span_id` instead.
       */
      get parentSpanId() {
        return this._parentSpanId;
      }
      /**
       * Was this span chosen to be sent as part of the sample?
       * @deprecated Use `isRecording()` instead.
       */
      get sampled() {
        return this._sampled;
      }
      /**
       * Was this span chosen to be sent as part of the sample?
       * @deprecated You cannot update the sampling decision of a span after span creation.
       */
      set sampled(sampled) {
        this._sampled = sampled;
      }
      /**
       * Attributes for the span.
       * @deprecated Use `spanToJSON(span).atttributes` instead.
       */
      get attributes() {
        return this._attributes;
      }
      /**
       * Attributes for the span.
       * @deprecated Use `setAttributes()` instead.
       */
      set attributes(attributes) {
        this._attributes = attributes;
      }
      /**
       * Timestamp in seconds (epoch time) indicating when the span started.
       * @deprecated Use `spanToJSON()` instead.
       */
      get startTimestamp() {
        return this._startTime;
      }
      /**
       * Timestamp in seconds (epoch time) indicating when the span started.
       * @deprecated In v8, you will not be able to update the span start time after creation.
       */
      set startTimestamp(startTime) {
        this._startTime = startTime;
      }
      /**
       * Timestamp in seconds when the span ended.
       * @deprecated Use `spanToJSON()` instead.
       */
      get endTimestamp() {
        return this._endTime;
      }
      /**
       * Timestamp in seconds when the span ended.
       * @deprecated Set the end time via `span.end()` instead.
       */
      set endTimestamp(endTime) {
        this._endTime = endTime;
      }
      /**
       * The status of the span.
       *
       * @deprecated Use `spanToJSON().status` instead to get the status.
       */
      get status() {
        return this._status;
      }
      /**
       * The status of the span.
       *
       * @deprecated Use `.setStatus()` instead to set or update the status.
       */
      set status(status) {
        this._status = status;
      }
      /**
       * Operation of the span
       *
       * @deprecated Use `spanToJSON().op` to read the op instead.
       */
      get op() {
        return this._attributes[semanticAttributes.SEMANTIC_ATTRIBUTE_SENTRY_OP];
      }
      /**
       * Operation of the span
       *
       * @deprecated Use `startSpan()` functions to set or `span.setAttribute(SEMANTIC_ATTRIBUTE_SENTRY_OP, 'op')
       *             to update the span instead.
       */
      set op(op) {
        this.setAttribute(semanticAttributes.SEMANTIC_ATTRIBUTE_SENTRY_OP, op);
      }
      /**
       * The origin of the span, giving context about what created the span.
       *
       * @deprecated Use `spanToJSON().origin` to read the origin instead.
       */
      get origin() {
        return this._attributes[semanticAttributes.SEMANTIC_ATTRIBUTE_SENTRY_ORIGIN];
      }
      /**
       * The origin of the span, giving context about what created the span.
       *
       * @deprecated Use `startSpan()` functions to set the origin instead.
       */
      set origin(origin) {
        this.setAttribute(semanticAttributes.SEMANTIC_ATTRIBUTE_SENTRY_ORIGIN, origin);
      }
      /* eslint-enable @typescript-eslint/member-ordering */
      /** @inheritdoc */
      spanContext() {
        const { _spanId: spanId, _traceId: traceId, _sampled: sampled } = this;
        return {
          spanId,
          traceId,
          traceFlags: sampled ? spanUtils.TRACE_FLAG_SAMPLED : spanUtils.TRACE_FLAG_NONE
        };
      }
      /**
       * Creates a new `Span` while setting the current `Span.id` as `parentSpanId`.
       * Also the `sampled` decision will be inherited.
       *
       * @deprecated Use `startSpan()`, `startSpanManual()` or `startInactiveSpan()` instead.
       */
      startChild(spanContext) {
        const childSpan = new _Span({
          ...spanContext,
          parentSpanId: this._spanId,
          sampled: this._sampled,
          traceId: this._traceId
        });
        childSpan.spanRecorder = this.spanRecorder;
        if (childSpan.spanRecorder) {
          childSpan.spanRecorder.add(childSpan);
        }
        const rootSpan = getRootSpan.getRootSpan(this);
        childSpan.transaction = rootSpan;
        if (debugBuild.DEBUG_BUILD && rootSpan) {
          const opStr = spanContext && spanContext.op || "< unknown op >";
          const nameStr = spanUtils.spanToJSON(childSpan).description || "< unknown name >";
          const idStr = rootSpan.spanContext().spanId;
          const logMessage = `[Tracing] Starting '${opStr}' span on transaction '${nameStr}' (${idStr}).`;
          utils.logger.log(logMessage);
          this._logMessage = logMessage;
        }
        return childSpan;
      }
      /**
       * Sets the tag attribute on the current span.
       *
       * Can also be used to unset a tag, by passing `undefined`.
       *
       * @param key Tag key
       * @param value Tag value
       * @deprecated Use `setAttribute()` instead.
       */
      setTag(key, value) {
        this.tags = { ...this.tags, [key]: value };
        return this;
      }
      /**
       * Sets the data attribute on the current span
       * @param key Data key
       * @param value Data value
       * @deprecated Use `setAttribute()` instead.
       */
      // eslint-disable-next-line @typescript-eslint/no-explicit-any
      setData(key, value) {
        this.data = { ...this.data, [key]: value };
        return this;
      }
      /** @inheritdoc */
      setAttribute(key, value) {
        if (value === void 0) {
          delete this._attributes[key];
        } else {
          this._attributes[key] = value;
        }
      }
      /** @inheritdoc */
      setAttributes(attributes) {
        Object.keys(attributes).forEach((key) => this.setAttribute(key, attributes[key]));
      }
      /**
       * @inheritDoc
       */
      setStatus(value) {
        this._status = value;
        return this;
      }
      /**
       * @inheritDoc
       * @deprecated Use top-level `setHttpStatus()` instead.
       */
      setHttpStatus(httpStatus) {
        spanstatus.setHttpStatus(this, httpStatus);
        return this;
      }
      /**
       * @inheritdoc
       *
       * @deprecated Use `.updateName()` instead.
       */
      setName(name) {
        this.updateName(name);
      }
      /**
       * @inheritDoc
       */
      updateName(name) {
        this._name = name;
        return this;
      }
      /**
       * @inheritDoc
       *
       * @deprecated Use `spanToJSON(span).status === 'ok'` instead.
       */
      isSuccess() {
        return this._status === "ok";
      }
      /**
       * @inheritDoc
       *
       * @deprecated Use `.end()` instead.
       */
      finish(endTimestamp) {
        return this.end(endTimestamp);
      }
      /** @inheritdoc */
      end(endTimestamp) {
        if (this._endTime) {
          return;
        }
        const rootSpan = getRootSpan.getRootSpan(this);
        if (debugBuild.DEBUG_BUILD && // Don't call this for transactions
        rootSpan && rootSpan.spanContext().spanId !== this._spanId) {
          const logMessage = this._logMessage;
          if (logMessage) {
            utils.logger.log(logMessage.replace("Starting", "Finishing"));
          }
        }
        this._endTime = spanUtils.spanTimeInputToSeconds(endTimestamp);
      }
      /**
       * @inheritDoc
       *
       * @deprecated Use `spanToTraceHeader()` instead.
       */
      toTraceparent() {
        return spanUtils.spanToTraceHeader(this);
      }
      /**
       * @inheritDoc
       *
       * @deprecated Use `spanToJSON()` or access the fields directly instead.
       */
      toContext() {
        return utils.dropUndefinedKeys({
          data: this._getData(),
          description: this._name,
          endTimestamp: this._endTime,
          // eslint-disable-next-line deprecation/deprecation
          op: this.op,
          parentSpanId: this._parentSpanId,
          sampled: this._sampled,
          spanId: this._spanId,
          startTimestamp: this._startTime,
          status: this._status,
          // eslint-disable-next-line deprecation/deprecation
          tags: this.tags,
          traceId: this._traceId
        });
      }
      /**
       * @inheritDoc
       *
       * @deprecated Update the fields directly instead.
       */
      updateWithContext(spanContext) {
        this.data = spanContext.data || {};
        this._name = spanContext.name || spanContext.description;
        this._endTime = spanContext.endTimestamp;
        this.op = spanContext.op;
        this._parentSpanId = spanContext.parentSpanId;
        this._sampled = spanContext.sampled;
        this._spanId = spanContext.spanId || this._spanId;
        this._startTime = spanContext.startTimestamp || this._startTime;
        this._status = spanContext.status;
        this.tags = spanContext.tags || {};
        this._traceId = spanContext.traceId || this._traceId;
        return this;
      }
      /**
       * @inheritDoc
       *
       * @deprecated Use `spanToTraceContext()` util function instead.
       */
      getTraceContext() {
        return spanUtils.spanToTraceContext(this);
      }
      /**
       * Get JSON representation of this span.
       *
       * @hidden
       * @internal This method is purely for internal purposes and should not be used outside
       * of SDK code. If you need to get a JSON representation of a span,
       * use `spanToJSON(span)` instead.
       */
      getSpanJSON() {
        return utils.dropUndefinedKeys({
          data: this._getData(),
          description: this._name,
          op: this._attributes[semanticAttributes.SEMANTIC_ATTRIBUTE_SENTRY_OP],
          parent_span_id: this._parentSpanId,
          span_id: this._spanId,
          start_timestamp: this._startTime,
          status: this._status,
          // eslint-disable-next-line deprecation/deprecation
          tags: Object.keys(this.tags).length > 0 ? this.tags : void 0,
          timestamp: this._endTime,
          trace_id: this._traceId,
          origin: this._attributes[semanticAttributes.SEMANTIC_ATTRIBUTE_SENTRY_ORIGIN],
          _metrics_summary: metricSummary.getMetricSummaryJsonForSpan(this),
          profile_id: this._attributes[semanticAttributes.SEMANTIC_ATTRIBUTE_PROFILE_ID],
          exclusive_time: this._exclusiveTime,
          measurements: Object.keys(this._measurements).length > 0 ? this._measurements : void 0
        });
      }
      /** @inheritdoc */
      isRecording() {
        return !this._endTime && !!this._sampled;
      }
      /**
       * Convert the object to JSON.
       * @deprecated Use `spanToJSON(span)` instead.
       */
      toJSON() {
        return this.getSpanJSON();
      }
      /**
       * Get the merged data for this span.
       * For now, this combines `data` and `attributes` together,
       * until eventually we can ingest `attributes` directly.
       */
      _getData() {
        const { data, _attributes: attributes } = this;
        const hasData = Object.keys(data).length > 0;
        const hasAttributes = Object.keys(attributes).length > 0;
        if (!hasData && !hasAttributes) {
          return void 0;
        }
        if (hasData && hasAttributes) {
          return {
            ...data,
            ...attributes
          };
        }
        return hasData ? data : attributes;
      }
    };
    exports.Span = Span;
    exports.SpanRecorder = SpanRecorder;
  }
});

// ../../../node_modules/.pnpm/@sentry+core@7.120.2/node_modules/@sentry/core/cjs/tracing/transaction.js
var require_transaction = __commonJS({
  "../../../node_modules/.pnpm/@sentry+core@7.120.2/node_modules/@sentry/core/cjs/tracing/transaction.js"(exports) {
    init_define_ENV_DEFINED_IN_BUILD_STEP();
    Object.defineProperty(exports, "__esModule", { value: true });
    var utils = require_cjs();
    var debugBuild = require_debug_build2();
    var hub = require_hub();
    var metricSummary = require_metric_summary();
    var semanticAttributes = require_semanticAttributes();
    var spanUtils = require_spanUtils();
    var dynamicSamplingContext = require_dynamicSamplingContext();
    var span = require_span();
    var trace = require_trace();
    var Transaction2 = class extends span.Span {
      /**
       * The reference to the current hub.
       */
      // eslint-disable-next-line deprecation/deprecation
      // DO NOT yet remove this property, it is used in a hack for v7 backwards compatibility.
      /**
       * This constructor should never be called manually. Those instrumenting tracing should use
       * `Sentry.startTransaction()`, and internal methods should use `hub.startTransaction()`.
       * @internal
       * @hideconstructor
       * @hidden
       *
       * @deprecated Transactions will be removed in v8. Use spans instead.
       */
      // eslint-disable-next-line deprecation/deprecation
      constructor(transactionContext, hub$1) {
        super(transactionContext);
        this._contexts = {};
        this._hub = hub$1 || hub.getCurrentHub();
        this._name = transactionContext.name || "";
        this._metadata = {
          // eslint-disable-next-line deprecation/deprecation
          ...transactionContext.metadata
        };
        this._trimEnd = transactionContext.trimEnd;
        this.transaction = this;
        const incomingDynamicSamplingContext = this._metadata.dynamicSamplingContext;
        if (incomingDynamicSamplingContext) {
          this._frozenDynamicSamplingContext = { ...incomingDynamicSamplingContext };
        }
      }
      // This sadly conflicts with the getter/setter ordering :(
      /* eslint-disable @typescript-eslint/member-ordering */
      /**
       * Getter for `name` property.
       * @deprecated Use `spanToJSON(span).description` instead.
       */
      get name() {
        return this._name;
      }
      /**
       * Setter for `name` property, which also sets `source` as custom.
       * @deprecated Use `updateName()` and `setMetadata()` instead.
       */
      set name(newName) {
        this.setName(newName);
      }
      /**
       * Get the metadata for this transaction.
       * @deprecated Use `spanGetMetadata(transaction)` instead.
       */
      get metadata() {
        return {
          // Defaults
          // eslint-disable-next-line deprecation/deprecation
          source: "custom",
          spanMetadata: {},
          // Legacy metadata
          ...this._metadata,
          // From attributes
          ...this._attributes[semanticAttributes.SEMANTIC_ATTRIBUTE_SENTRY_SOURCE] && {
            source: this._attributes[semanticAttributes.SEMANTIC_ATTRIBUTE_SENTRY_SOURCE]
          },
          ...this._attributes[semanticAttributes.SEMANTIC_ATTRIBUTE_SENTRY_SAMPLE_RATE] && {
            sampleRate: this._attributes[semanticAttributes.SEMANTIC_ATTRIBUTE_SENTRY_SAMPLE_RATE]
          }
        };
      }
      /**
       * Update the metadata for this transaction.
       * @deprecated Use `spanGetMetadata(transaction)` instead.
       */
      set metadata(metadata) {
        this._metadata = metadata;
      }
      /* eslint-enable @typescript-eslint/member-ordering */
      /**
       * Setter for `name` property, which also sets `source` on the metadata.
       *
       * @deprecated Use `.updateName()` and `.setAttribute()` instead.
       */
      setName(name, source = "custom") {
        this._name = name;
        this.setAttribute(semanticAttributes.SEMANTIC_ATTRIBUTE_SENTRY_SOURCE, source);
      }
      /** @inheritdoc */
      updateName(name) {
        this._name = name;
        return this;
      }
      /**
       * Attaches SpanRecorder to the span itself
       * @param maxlen maximum number of spans that can be recorded
       */
      initSpanRecorder(maxlen = 1e3) {
        if (!this.spanRecorder) {
          this.spanRecorder = new span.SpanRecorder(maxlen);
        }
        this.spanRecorder.add(this);
      }
      /**
       * Set the context of a transaction event.
       * @deprecated Use either `.setAttribute()`, or set the context on the scope before creating the transaction.
       */
      setContext(key, context2) {
        if (context2 === null) {
          delete this._contexts[key];
        } else {
          this._contexts[key] = context2;
        }
      }
      /**
       * @inheritDoc
       *
       * @deprecated Use top-level `setMeasurement()` instead.
       */
      setMeasurement(name, value, unit = "") {
        this._measurements[name] = { value, unit };
      }
      /**
       * Store metadata on this transaction.
       * @deprecated Use attributes or store data on the scope instead.
       */
      setMetadata(newMetadata) {
        this._metadata = { ...this._metadata, ...newMetadata };
      }
      /**
       * @inheritDoc
       */
      end(endTimestamp) {
        const timestampInS = spanUtils.spanTimeInputToSeconds(endTimestamp);
        const transaction = this._finishTransaction(timestampInS);
        if (!transaction) {
          return void 0;
        }
        return this._hub.captureEvent(transaction);
      }
      /**
       * @inheritDoc
       */
      toContext() {
        const spanContext = super.toContext();
        return utils.dropUndefinedKeys({
          ...spanContext,
          name: this._name,
          trimEnd: this._trimEnd
        });
      }
      /**
       * @inheritDoc
       */
      updateWithContext(transactionContext) {
        super.updateWithContext(transactionContext);
        this._name = transactionContext.name || "";
        this._trimEnd = transactionContext.trimEnd;
        return this;
      }
      /**
       * @inheritdoc
       *
       * @experimental
       *
       * @deprecated Use top-level `getDynamicSamplingContextFromSpan` instead.
       */
      getDynamicSamplingContext() {
        return dynamicSamplingContext.getDynamicSamplingContextFromSpan(this);
      }
      /**
       * Override the current hub with a new one.
       * Used if you want another hub to finish the transaction.
       *
       * @internal
       */
      // eslint-disable-next-line deprecation/deprecation
      setHub(hub2) {
        this._hub = hub2;
      }
      /**
       * Get the profile id of the transaction.
       */
      getProfileId() {
        if (this._contexts !== void 0 && this._contexts["profile"] !== void 0) {
          return this._contexts["profile"].profile_id;
        }
        return void 0;
      }
      /**
       * Finish the transaction & prepare the event to send to Sentry.
       */
      _finishTransaction(endTimestamp) {
        if (this._endTime !== void 0) {
          return void 0;
        }
        if (!this._name) {
          debugBuild.DEBUG_BUILD && utils.logger.warn("Transaction has no name, falling back to `<unlabeled transaction>`.");
          this._name = "<unlabeled transaction>";
        }
        super.end(endTimestamp);
        const client = this._hub.getClient();
        if (client && client.emit) {
          client.emit("finishTransaction", this);
        }
        if (this._sampled !== true) {
          debugBuild.DEBUG_BUILD && utils.logger.log("[Tracing] Discarding transaction because its trace was not chosen to be sampled.");
          if (client) {
            client.recordDroppedEvent("sample_rate", "transaction");
          }
          return void 0;
        }
        const finishedSpans = this.spanRecorder ? (
          // eslint-disable-next-line deprecation/deprecation
          this.spanRecorder.spans.filter((span2) => span2 !== this && spanUtils.spanToJSON(span2).timestamp)
        ) : [];
        if (this._trimEnd && finishedSpans.length > 0) {
          const endTimes = finishedSpans.map((span2) => spanUtils.spanToJSON(span2).timestamp).filter(Boolean);
          this._endTime = endTimes.reduce((prev, current) => {
            return prev > current ? prev : current;
          });
        }
        const { scope: capturedSpanScope, isolationScope: capturedSpanIsolationScope } = trace.getCapturedScopesOnSpan(this);
        const { metadata } = this;
        const { source } = metadata;
        const transaction = {
          contexts: {
            ...this._contexts,
            // We don't want to override trace context
            trace: spanUtils.spanToTraceContext(this)
          },
          // TODO: Pass spans serialized via `spanToJSON()` here instead in v8.
          spans: finishedSpans,
          start_timestamp: this._startTime,
          // eslint-disable-next-line deprecation/deprecation
          tags: this.tags,
          timestamp: this._endTime,
          transaction: this._name,
          type: "transaction",
          sdkProcessingMetadata: {
            ...metadata,
            capturedSpanScope,
            capturedSpanIsolationScope,
            ...utils.dropUndefinedKeys({
              dynamicSamplingContext: dynamicSamplingContext.getDynamicSamplingContextFromSpan(this)
            })
          },
          _metrics_summary: metricSummary.getMetricSummaryJsonForSpan(this),
          ...source && {
            transaction_info: {
              source
            }
          }
        };
        const hasMeasurements = Object.keys(this._measurements).length > 0;
        if (hasMeasurements) {
          debugBuild.DEBUG_BUILD && utils.logger.log(
            "[Measurements] Adding measurements to transaction",
            JSON.stringify(this._measurements, void 0, 2)
          );
          transaction.measurements = this._measurements;
        }
        debugBuild.DEBUG_BUILD && utils.logger.log(`[Tracing] Finishing ${this.op} transaction: ${this._name}.`);
        return transaction;
      }
    };
    exports.Transaction = Transaction2;
  }
});

// ../../../node_modules/.pnpm/@sentry+core@7.120.2/node_modules/@sentry/core/cjs/tracing/idletransaction.js
var require_idletransaction = __commonJS({
  "../../../node_modules/.pnpm/@sentry+core@7.120.2/node_modules/@sentry/core/cjs/tracing/idletransaction.js"(exports) {
    init_define_ENV_DEFINED_IN_BUILD_STEP();
    Object.defineProperty(exports, "__esModule", { value: true });
    var utils = require_cjs();
    var debugBuild = require_debug_build2();
    var spanUtils = require_spanUtils();
    var span = require_span();
    var transaction = require_transaction();
    var TRACING_DEFAULTS = {
      idleTimeout: 1e3,
      finalTimeout: 3e4,
      heartbeatInterval: 5e3
    };
    var FINISH_REASON_TAG = "finishReason";
    var IDLE_TRANSACTION_FINISH_REASONS = [
      "heartbeatFailed",
      "idleTimeout",
      "documentHidden",
      "finalTimeout",
      "externalFinish",
      "cancelled"
    ];
    var IdleTransactionSpanRecorder = class extends span.SpanRecorder {
      constructor(_pushActivity, _popActivity, transactionSpanId, maxlen) {
        super(maxlen);
        this._pushActivity = _pushActivity;
        this._popActivity = _popActivity;
        this.transactionSpanId = transactionSpanId;
      }
      /**
       * @inheritDoc
       */
      add(span2) {
        if (span2.spanContext().spanId !== this.transactionSpanId) {
          const originalEnd = span2.end;
          span2.end = (...rest) => {
            this._popActivity(span2.spanContext().spanId);
            return originalEnd.apply(span2, rest);
          };
          if (spanUtils.spanToJSON(span2).timestamp === void 0) {
            this._pushActivity(span2.spanContext().spanId);
          }
        }
        super.add(span2);
      }
    };
    var IdleTransaction = class extends transaction.Transaction {
      // Activities store a list of active spans
      // Track state of activities in previous heartbeat
      // Amount of times heartbeat has counted. Will cause transaction to finish after 3 beats.
      // We should not use heartbeat if we finished a transaction
      // Idle timeout was canceled and we should finish the transaction with the last span end.
      /**
       * Timer that tracks Transaction idleTimeout
       */
      /**
       * @deprecated Transactions will be removed in v8. Use spans instead.
       */
      constructor(transactionContext, _idleHub, _idleTimeout = TRACING_DEFAULTS.idleTimeout, _finalTimeout = TRACING_DEFAULTS.finalTimeout, _heartbeatInterval = TRACING_DEFAULTS.heartbeatInterval, _onScope = false, delayAutoFinishUntilSignal = false) {
        super(transactionContext, _idleHub);
        this._idleHub = _idleHub;
        this._idleTimeout = _idleTimeout;
        this._finalTimeout = _finalTimeout;
        this._heartbeatInterval = _heartbeatInterval;
        this._onScope = _onScope;
        this.activities = {};
        this._heartbeatCounter = 0;
        this._finished = false;
        this._idleTimeoutCanceledPermanently = false;
        this._beforeFinishCallbacks = [];
        this._finishReason = IDLE_TRANSACTION_FINISH_REASONS[4];
        this._autoFinishAllowed = !delayAutoFinishUntilSignal;
        if (_onScope) {
          debugBuild.DEBUG_BUILD && utils.logger.log(`Setting idle transaction on scope. Span ID: ${this.spanContext().spanId}`);
          _idleHub.getScope().setSpan(this);
        }
        if (!delayAutoFinishUntilSignal) {
          this._restartIdleTimeout();
        }
        setTimeout(() => {
          if (!this._finished) {
            this.setStatus("deadline_exceeded");
            this._finishReason = IDLE_TRANSACTION_FINISH_REASONS[3];
            this.end();
          }
        }, this._finalTimeout);
      }
      /** {@inheritDoc} */
      end(endTimestamp) {
        const endTimestampInS = spanUtils.spanTimeInputToSeconds(endTimestamp);
        this._finished = true;
        this.activities = {};
        if (this.op === "ui.action.click") {
          this.setAttribute(FINISH_REASON_TAG, this._finishReason);
        }
        if (this.spanRecorder) {
          debugBuild.DEBUG_BUILD && // eslint-disable-next-line deprecation/deprecation
          utils.logger.log("[Tracing] finishing IdleTransaction", new Date(endTimestampInS * 1e3).toISOString(), this.op);
          for (const callback of this._beforeFinishCallbacks) {
            callback(this, endTimestampInS);
          }
          this.spanRecorder.spans = this.spanRecorder.spans.filter((span2) => {
            if (span2.spanContext().spanId === this.spanContext().spanId) {
              return true;
            }
            if (!spanUtils.spanToJSON(span2).timestamp) {
              span2.setStatus("cancelled");
              span2.end(endTimestampInS);
              debugBuild.DEBUG_BUILD && utils.logger.log("[Tracing] cancelling span since transaction ended early", JSON.stringify(span2, void 0, 2));
            }
            const { start_timestamp: startTime, timestamp: endTime } = spanUtils.spanToJSON(span2);
            const spanStartedBeforeTransactionFinish = startTime && startTime < endTimestampInS;
            const timeoutWithMarginOfError = (this._finalTimeout + this._idleTimeout) / 1e3;
            const spanEndedBeforeFinalTimeout = endTime && startTime && endTime - startTime < timeoutWithMarginOfError;
            if (debugBuild.DEBUG_BUILD) {
              const stringifiedSpan = JSON.stringify(span2, void 0, 2);
              if (!spanStartedBeforeTransactionFinish) {
                utils.logger.log("[Tracing] discarding Span since it happened after Transaction was finished", stringifiedSpan);
              } else if (!spanEndedBeforeFinalTimeout) {
                utils.logger.log("[Tracing] discarding Span since it finished after Transaction final timeout", stringifiedSpan);
              }
            }
            return spanStartedBeforeTransactionFinish && spanEndedBeforeFinalTimeout;
          });
          debugBuild.DEBUG_BUILD && utils.logger.log("[Tracing] flushing IdleTransaction");
        } else {
          debugBuild.DEBUG_BUILD && utils.logger.log("[Tracing] No active IdleTransaction");
        }
        if (this._onScope) {
          const scope = this._idleHub.getScope();
          if (scope.getTransaction() === this) {
            scope.setSpan(void 0);
          }
        }
        return super.end(endTimestamp);
      }
      /**
       * Register a callback function that gets executed before the transaction finishes.
       * Useful for cleanup or if you want to add any additional spans based on current context.
       *
       * This is exposed because users have no other way of running something before an idle transaction
       * finishes.
       */
      registerBeforeFinishCallback(callback) {
        this._beforeFinishCallbacks.push(callback);
      }
      /**
       * @inheritDoc
       */
      initSpanRecorder(maxlen) {
        if (!this.spanRecorder) {
          const pushActivity = (id) => {
            if (this._finished) {
              return;
            }
            this._pushActivity(id);
          };
          const popActivity = (id) => {
            if (this._finished) {
              return;
            }
            this._popActivity(id);
          };
          this.spanRecorder = new IdleTransactionSpanRecorder(pushActivity, popActivity, this.spanContext().spanId, maxlen);
          debugBuild.DEBUG_BUILD && utils.logger.log("Starting heartbeat");
          this._pingHeartbeat();
        }
        this.spanRecorder.add(this);
      }
      /**
       * Cancels the existing idle timeout, if there is one.
       * @param restartOnChildSpanChange Default is `true`.
       *                                 If set to false the transaction will end
       *                                 with the last child span.
       */
      cancelIdleTimeout(endTimestamp, {
        restartOnChildSpanChange
      } = {
        restartOnChildSpanChange: true
      }) {
        this._idleTimeoutCanceledPermanently = restartOnChildSpanChange === false;
        if (this._idleTimeoutID) {
          clearTimeout(this._idleTimeoutID);
          this._idleTimeoutID = void 0;
          if (Object.keys(this.activities).length === 0 && this._idleTimeoutCanceledPermanently) {
            this._finishReason = IDLE_TRANSACTION_FINISH_REASONS[5];
            this.end(endTimestamp);
          }
        }
      }
      /**
       * Temporary method used to externally set the transaction's `finishReason`
       *
       * ** WARNING**
       * This is for the purpose of experimentation only and will be removed in the near future, do not use!
       *
       * @internal
       *
       */
      setFinishReason(reason) {
        this._finishReason = reason;
      }
      /**
       * Permits the IdleTransaction to automatically end itself via the idle timeout and heartbeat mechanisms when the `delayAutoFinishUntilSignal` option was set to `true`.
       */
      sendAutoFinishSignal() {
        if (!this._autoFinishAllowed) {
          debugBuild.DEBUG_BUILD && utils.logger.log("[Tracing] Received finish signal for idle transaction.");
          this._restartIdleTimeout();
          this._autoFinishAllowed = true;
        }
      }
      /**
       * Restarts idle timeout, if there is no running idle timeout it will start one.
       */
      _restartIdleTimeout(endTimestamp) {
        this.cancelIdleTimeout();
        this._idleTimeoutID = setTimeout(() => {
          if (!this._finished && Object.keys(this.activities).length === 0) {
            this._finishReason = IDLE_TRANSACTION_FINISH_REASONS[1];
            this.end(endTimestamp);
          }
        }, this._idleTimeout);
      }
      /**
       * Start tracking a specific activity.
       * @param spanId The span id that represents the activity
       */
      _pushActivity(spanId) {
        this.cancelIdleTimeout(void 0, { restartOnChildSpanChange: !this._idleTimeoutCanceledPermanently });
        debugBuild.DEBUG_BUILD && utils.logger.log(`[Tracing] pushActivity: ${spanId}`);
        this.activities[spanId] = true;
        debugBuild.DEBUG_BUILD && utils.logger.log("[Tracing] new activities count", Object.keys(this.activities).length);
      }
      /**
       * Remove an activity from usage
       * @param spanId The span id that represents the activity
       */
      _popActivity(spanId) {
        if (this.activities[spanId]) {
          debugBuild.DEBUG_BUILD && utils.logger.log(`[Tracing] popActivity ${spanId}`);
          delete this.activities[spanId];
          debugBuild.DEBUG_BUILD && utils.logger.log("[Tracing] new activities count", Object.keys(this.activities).length);
        }
        if (Object.keys(this.activities).length === 0) {
          const endTimestamp = utils.timestampInSeconds();
          if (this._idleTimeoutCanceledPermanently) {
            if (this._autoFinishAllowed) {
              this._finishReason = IDLE_TRANSACTION_FINISH_REASONS[5];
              this.end(endTimestamp);
            }
          } else {
            this._restartIdleTimeout(endTimestamp + this._idleTimeout / 1e3);
          }
        }
      }
      /**
       * Checks when entries of this.activities are not changing for 3 beats.
       * If this occurs we finish the transaction.
       */
      _beat() {
        if (this._finished) {
          return;
        }
        const heartbeatString = Object.keys(this.activities).join("");
        if (heartbeatString === this._prevHeartbeatString) {
          this._heartbeatCounter++;
        } else {
          this._heartbeatCounter = 1;
        }
        this._prevHeartbeatString = heartbeatString;
        if (this._heartbeatCounter >= 3) {
          if (this._autoFinishAllowed) {
            debugBuild.DEBUG_BUILD && utils.logger.log("[Tracing] Transaction finished because of no change for 3 heart beats");
            this.setStatus("deadline_exceeded");
            this._finishReason = IDLE_TRANSACTION_FINISH_REASONS[0];
            this.end();
          }
        } else {
          this._pingHeartbeat();
        }
      }
      /**
       * Pings the heartbeat
       */
      _pingHeartbeat() {
        debugBuild.DEBUG_BUILD && utils.logger.log(`pinging Heartbeat -> current counter: ${this._heartbeatCounter}`);
        setTimeout(() => {
          this._beat();
        }, this._heartbeatInterval);
      }
    };
    exports.IdleTransaction = IdleTransaction;
    exports.IdleTransactionSpanRecorder = IdleTransactionSpanRecorder;
    exports.TRACING_DEFAULTS = TRACING_DEFAULTS;
  }
});

// ../../../node_modules/.pnpm/@sentry+core@7.120.2/node_modules/@sentry/core/cjs/tracing/sampling.js
var require_sampling = __commonJS({
  "../../../node_modules/.pnpm/@sentry+core@7.120.2/node_modules/@sentry/core/cjs/tracing/sampling.js"(exports) {
    init_define_ENV_DEFINED_IN_BUILD_STEP();
    Object.defineProperty(exports, "__esModule", { value: true });
    var utils = require_cjs();
    var debugBuild = require_debug_build2();
    var semanticAttributes = require_semanticAttributes();
    var hasTracingEnabled = require_hasTracingEnabled();
    var spanUtils = require_spanUtils();
    function sampleTransaction(transaction, options, samplingContext) {
      if (!hasTracingEnabled.hasTracingEnabled(options)) {
        transaction.sampled = false;
        return transaction;
      }
      if (transaction.sampled !== void 0) {
        transaction.setAttribute(semanticAttributes.SEMANTIC_ATTRIBUTE_SENTRY_SAMPLE_RATE, Number(transaction.sampled));
        return transaction;
      }
      let sampleRate;
      if (typeof options.tracesSampler === "function") {
        sampleRate = options.tracesSampler(samplingContext);
        transaction.setAttribute(semanticAttributes.SEMANTIC_ATTRIBUTE_SENTRY_SAMPLE_RATE, Number(sampleRate));
      } else if (samplingContext.parentSampled !== void 0) {
        sampleRate = samplingContext.parentSampled;
      } else if (typeof options.tracesSampleRate !== "undefined") {
        sampleRate = options.tracesSampleRate;
        transaction.setAttribute(semanticAttributes.SEMANTIC_ATTRIBUTE_SENTRY_SAMPLE_RATE, Number(sampleRate));
      } else {
        sampleRate = 1;
        transaction.setAttribute(semanticAttributes.SEMANTIC_ATTRIBUTE_SENTRY_SAMPLE_RATE, sampleRate);
      }
      if (!isValidSampleRate(sampleRate)) {
        debugBuild.DEBUG_BUILD && utils.logger.warn("[Tracing] Discarding transaction because of invalid sample rate.");
        transaction.sampled = false;
        return transaction;
      }
      if (!sampleRate) {
        debugBuild.DEBUG_BUILD && utils.logger.log(
          `[Tracing] Discarding transaction because ${typeof options.tracesSampler === "function" ? "tracesSampler returned 0 or false" : "a negative sampling decision was inherited or tracesSampleRate is set to 0"}`
        );
        transaction.sampled = false;
        return transaction;
      }
      transaction.sampled = Math.random() < sampleRate;
      if (!transaction.sampled) {
        debugBuild.DEBUG_BUILD && utils.logger.log(
          `[Tracing] Discarding transaction because it's not included in the random sample (sampling rate = ${Number(
            sampleRate
          )})`
        );
        return transaction;
      }
      debugBuild.DEBUG_BUILD && // eslint-disable-next-line deprecation/deprecation
      utils.logger.log(`[Tracing] starting ${transaction.op} transaction - ${spanUtils.spanToJSON(transaction).description}`);
      return transaction;
    }
    function isValidSampleRate(rate) {
      if (utils.isNaN(rate) || !(typeof rate === "number" || typeof rate === "boolean")) {
        debugBuild.DEBUG_BUILD && utils.logger.warn(
          `[Tracing] Given sample rate is invalid. Sample rate must be a boolean or a number between 0 and 1. Got ${JSON.stringify(
            rate
          )} of type ${JSON.stringify(typeof rate)}.`
        );
        return false;
      }
      if (rate < 0 || rate > 1) {
        debugBuild.DEBUG_BUILD && utils.logger.warn(`[Tracing] Given sample rate is invalid. Sample rate must be between 0 and 1. Got ${rate}.`);
        return false;
      }
      return true;
    }
    exports.isValidSampleRate = isValidSampleRate;
    exports.sampleTransaction = sampleTransaction;
  }
});

// ../../../node_modules/.pnpm/@sentry+core@7.120.2/node_modules/@sentry/core/cjs/tracing/hubextensions.js
var require_hubextensions = __commonJS({
  "../../../node_modules/.pnpm/@sentry+core@7.120.2/node_modules/@sentry/core/cjs/tracing/hubextensions.js"(exports) {
    init_define_ENV_DEFINED_IN_BUILD_STEP();
    Object.defineProperty(exports, "__esModule", { value: true });
    var utils = require_cjs();
    var debugBuild = require_debug_build2();
    var hub = require_hub();
    var spanUtils = require_spanUtils();
    var errors = require_errors();
    var idletransaction = require_idletransaction();
    var sampling = require_sampling();
    var transaction = require_transaction();
    function traceHeaders() {
      const scope = this.getScope();
      const span = scope.getSpan();
      return span ? {
        "sentry-trace": spanUtils.spanToTraceHeader(span)
      } : {};
    }
    function _startTransaction(transactionContext, customSamplingContext) {
      const client = this.getClient();
      const options = client && client.getOptions() || {};
      const configInstrumenter = options.instrumenter || "sentry";
      const transactionInstrumenter = transactionContext.instrumenter || "sentry";
      if (configInstrumenter !== transactionInstrumenter) {
        debugBuild.DEBUG_BUILD && utils.logger.error(
          `A transaction was started with instrumenter=\`${transactionInstrumenter}\`, but the SDK is configured with the \`${configInstrumenter}\` instrumenter.
The transaction will not be sampled. Please use the ${configInstrumenter} instrumentation to start transactions.`
        );
        transactionContext.sampled = false;
      }
      let transaction$1 = new transaction.Transaction(transactionContext, this);
      transaction$1 = sampling.sampleTransaction(transaction$1, options, {
        name: transactionContext.name,
        parentSampled: transactionContext.parentSampled,
        transactionContext,
        attributes: {
          // eslint-disable-next-line deprecation/deprecation
          ...transactionContext.data,
          ...transactionContext.attributes
        },
        ...customSamplingContext
      });
      if (transaction$1.isRecording()) {
        transaction$1.initSpanRecorder(options._experiments && options._experiments.maxSpans);
      }
      if (client && client.emit) {
        client.emit("startTransaction", transaction$1);
      }
      return transaction$1;
    }
    function startIdleTransaction(hub2, transactionContext, idleTimeout, finalTimeout, onScope, customSamplingContext, heartbeatInterval, delayAutoFinishUntilSignal = false) {
      const client = hub2.getClient();
      const options = client && client.getOptions() || {};
      let transaction2 = new idletransaction.IdleTransaction(
        transactionContext,
        hub2,
        idleTimeout,
        finalTimeout,
        heartbeatInterval,
        onScope,
        delayAutoFinishUntilSignal
      );
      transaction2 = sampling.sampleTransaction(transaction2, options, {
        name: transactionContext.name,
        parentSampled: transactionContext.parentSampled,
        transactionContext,
        attributes: {
          // eslint-disable-next-line deprecation/deprecation
          ...transactionContext.data,
          ...transactionContext.attributes
        },
        ...customSamplingContext
      });
      if (transaction2.isRecording()) {
        transaction2.initSpanRecorder(options._experiments && options._experiments.maxSpans);
      }
      if (client && client.emit) {
        client.emit("startTransaction", transaction2);
      }
      return transaction2;
    }
    function addTracingExtensions() {
      const carrier = hub.getMainCarrier();
      if (!carrier.__SENTRY__) {
        return;
      }
      carrier.__SENTRY__.extensions = carrier.__SENTRY__.extensions || {};
      if (!carrier.__SENTRY__.extensions.startTransaction) {
        carrier.__SENTRY__.extensions.startTransaction = _startTransaction;
      }
      if (!carrier.__SENTRY__.extensions.traceHeaders) {
        carrier.__SENTRY__.extensions.traceHeaders = traceHeaders;
      }
      errors.registerErrorInstrumentation();
    }
    exports.addTracingExtensions = addTracingExtensions;
    exports.startIdleTransaction = startIdleTransaction;
  }
});

// ../../../node_modules/.pnpm/@sentry+core@7.120.2/node_modules/@sentry/core/cjs/tracing/measurement.js
var require_measurement = __commonJS({
  "../../../node_modules/.pnpm/@sentry+core@7.120.2/node_modules/@sentry/core/cjs/tracing/measurement.js"(exports) {
    init_define_ENV_DEFINED_IN_BUILD_STEP();
    Object.defineProperty(exports, "__esModule", { value: true });
    var utils = require_utils();
    function setMeasurement(name, value, unit) {
      const transaction = utils.getActiveTransaction();
      if (transaction) {
        transaction.setMeasurement(name, value, unit);
      }
    }
    exports.setMeasurement = setMeasurement;
  }
});

// ../../../node_modules/.pnpm/@sentry+core@7.120.2/node_modules/@sentry/core/cjs/envelope.js
var require_envelope2 = __commonJS({
  "../../../node_modules/.pnpm/@sentry+core@7.120.2/node_modules/@sentry/core/cjs/envelope.js"(exports) {
    init_define_ENV_DEFINED_IN_BUILD_STEP();
    Object.defineProperty(exports, "__esModule", { value: true });
    var utils = require_cjs();
    function enhanceEventWithSdkInfo(event, sdkInfo) {
      if (!sdkInfo) {
        return event;
      }
      event.sdk = event.sdk || {};
      event.sdk.name = event.sdk.name || sdkInfo.name;
      event.sdk.version = event.sdk.version || sdkInfo.version;
      event.sdk.integrations = [...event.sdk.integrations || [], ...sdkInfo.integrations || []];
      event.sdk.packages = [...event.sdk.packages || [], ...sdkInfo.packages || []];
      return event;
    }
    function createSessionEnvelope(session, dsn, metadata, tunnel) {
      const sdkInfo = utils.getSdkMetadataForEnvelopeHeader(metadata);
      const envelopeHeaders = {
        sent_at: (/* @__PURE__ */ new Date()).toISOString(),
        ...sdkInfo && { sdk: sdkInfo },
        ...!!tunnel && dsn && { dsn: utils.dsnToString(dsn) }
      };
      const envelopeItem = "aggregates" in session ? [{ type: "sessions" }, session] : [{ type: "session" }, session.toJSON()];
      return utils.createEnvelope(envelopeHeaders, [envelopeItem]);
    }
    function createEventEnvelope(event, dsn, metadata, tunnel) {
      const sdkInfo = utils.getSdkMetadataForEnvelopeHeader(metadata);
      const eventType = event.type && event.type !== "replay_event" ? event.type : "event";
      enhanceEventWithSdkInfo(event, metadata && metadata.sdk);
      const envelopeHeaders = utils.createEventEnvelopeHeaders(event, sdkInfo, tunnel, dsn);
      delete event.sdkProcessingMetadata;
      const eventItem = [{ type: eventType }, event];
      return utils.createEnvelope(envelopeHeaders, [eventItem]);
    }
    exports.createEventEnvelope = createEventEnvelope;
    exports.createSessionEnvelope = createSessionEnvelope;
  }
});

// ../../../node_modules/.pnpm/@sentry+core@7.120.2/node_modules/@sentry/core/cjs/sessionflusher.js
var require_sessionflusher = __commonJS({
  "../../../node_modules/.pnpm/@sentry+core@7.120.2/node_modules/@sentry/core/cjs/sessionflusher.js"(exports) {
    init_define_ENV_DEFINED_IN_BUILD_STEP();
    Object.defineProperty(exports, "__esModule", { value: true });
    var utils = require_cjs();
    var exports$1 = require_exports();
    var SessionFlusher = class {
      // Cast to any so that it can use Node.js timeout
      // eslint-disable-next-line @typescript-eslint/no-explicit-any
      constructor(client, attrs) {
        this._client = client;
        this.flushTimeout = 60;
        this._pendingAggregates = {};
        this._isEnabled = true;
        this._intervalId = setInterval(() => this.flush(), this.flushTimeout * 1e3);
        if (this._intervalId.unref) {
          this._intervalId.unref();
        }
        this._sessionAttrs = attrs;
      }
      /** Checks if `pendingAggregates` has entries, and if it does flushes them by calling `sendSession` */
      flush() {
        const sessionAggregates = this.getSessionAggregates();
        if (sessionAggregates.aggregates.length === 0) {
          return;
        }
        this._pendingAggregates = {};
        this._client.sendSession(sessionAggregates);
      }
      /** Massages the entries in `pendingAggregates` and returns aggregated sessions */
      getSessionAggregates() {
        const aggregates = Object.keys(this._pendingAggregates).map((key) => {
          return this._pendingAggregates[parseInt(key)];
        });
        const sessionAggregates = {
          attrs: this._sessionAttrs,
          aggregates
        };
        return utils.dropUndefinedKeys(sessionAggregates);
      }
      /** JSDoc */
      close() {
        clearInterval(this._intervalId);
        this._isEnabled = false;
        this.flush();
      }
      /**
       * Wrapper function for _incrementSessionStatusCount that checks if the instance of SessionFlusher is enabled then
       * fetches the session status of the request from `Scope.getRequestSession().status` on the scope and passes them to
       * `_incrementSessionStatusCount` along with the start date
       */
      incrementSessionStatusCount() {
        if (!this._isEnabled) {
          return;
        }
        const scope = exports$1.getCurrentScope();
        const requestSession = scope.getRequestSession();
        if (requestSession && requestSession.status) {
          this._incrementSessionStatusCount(requestSession.status, /* @__PURE__ */ new Date());
          scope.setRequestSession(void 0);
        }
      }
      /**
       * Increments status bucket in pendingAggregates buffer (internal state) corresponding to status of
       * the session received
       */
      _incrementSessionStatusCount(status, date) {
        const sessionStartedTrunc = new Date(date).setSeconds(0, 0);
        this._pendingAggregates[sessionStartedTrunc] = this._pendingAggregates[sessionStartedTrunc] || {};
        const aggregationCounts = this._pendingAggregates[sessionStartedTrunc];
        if (!aggregationCounts.started) {
          aggregationCounts.started = new Date(sessionStartedTrunc).toISOString();
        }
        switch (status) {
          case "errored":
            aggregationCounts.errored = (aggregationCounts.errored || 0) + 1;
            return aggregationCounts.errored;
          case "ok":
            aggregationCounts.exited = (aggregationCounts.exited || 0) + 1;
            return aggregationCounts.exited;
          default:
            aggregationCounts.crashed = (aggregationCounts.crashed || 0) + 1;
            return aggregationCounts.crashed;
        }
      }
    };
    exports.SessionFlusher = SessionFlusher;
  }
});

// ../../../node_modules/.pnpm/@sentry+core@7.120.2/node_modules/@sentry/core/cjs/api.js
var require_api = __commonJS({
  "../../../node_modules/.pnpm/@sentry+core@7.120.2/node_modules/@sentry/core/cjs/api.js"(exports) {
    init_define_ENV_DEFINED_IN_BUILD_STEP();
    Object.defineProperty(exports, "__esModule", { value: true });
    var utils = require_cjs();
    var SENTRY_API_VERSION = "7";
    function getBaseApiEndpoint(dsn) {
      const protocol = dsn.protocol ? `${dsn.protocol}:` : "";
      const port = dsn.port ? `:${dsn.port}` : "";
      return `${protocol}//${dsn.host}${port}${dsn.path ? `/${dsn.path}` : ""}/api/`;
    }
    function _getIngestEndpoint(dsn) {
      return `${getBaseApiEndpoint(dsn)}${dsn.projectId}/envelope/`;
    }
    function _encodedAuth(dsn, sdkInfo) {
      return utils.urlEncode({
        // We send only the minimum set of required information. See
        // https://github.com/getsentry/sentry-javascript/issues/2572.
        sentry_key: dsn.publicKey,
        sentry_version: SENTRY_API_VERSION,
        ...sdkInfo && { sentry_client: `${sdkInfo.name}/${sdkInfo.version}` }
      });
    }
    function getEnvelopeEndpointWithUrlEncodedAuth(dsn, tunnelOrOptions = {}) {
      const tunnel = typeof tunnelOrOptions === "string" ? tunnelOrOptions : tunnelOrOptions.tunnel;
      const sdkInfo = typeof tunnelOrOptions === "string" || !tunnelOrOptions._metadata ? void 0 : tunnelOrOptions._metadata.sdk;
      return tunnel ? tunnel : `${_getIngestEndpoint(dsn)}?${_encodedAuth(dsn, sdkInfo)}`;
    }
    function getReportDialogEndpoint(dsnLike, dialogOptions) {
      const dsn = utils.makeDsn(dsnLike);
      if (!dsn) {
        return "";
      }
      const endpoint = `${getBaseApiEndpoint(dsn)}embed/error-page/`;
      let encodedOptions = `dsn=${utils.dsnToString(dsn)}`;
      for (const key in dialogOptions) {
        if (key === "dsn") {
          continue;
        }
        if (key === "onClose") {
          continue;
        }
        if (key === "user") {
          const user = dialogOptions.user;
          if (!user) {
            continue;
          }
          if (user.name) {
            encodedOptions += `&name=${encodeURIComponent(user.name)}`;
          }
          if (user.email) {
            encodedOptions += `&email=${encodeURIComponent(user.email)}`;
          }
        } else {
          encodedOptions += `&${encodeURIComponent(key)}=${encodeURIComponent(dialogOptions[key])}`;
        }
      }
      return `${endpoint}?${encodedOptions}`;
    }
    exports.getEnvelopeEndpointWithUrlEncodedAuth = getEnvelopeEndpointWithUrlEncodedAuth;
    exports.getReportDialogEndpoint = getReportDialogEndpoint;
  }
});

// ../../../node_modules/.pnpm/@sentry+core@7.120.2/node_modules/@sentry/core/cjs/integration.js
var require_integration = __commonJS({
  "../../../node_modules/.pnpm/@sentry+core@7.120.2/node_modules/@sentry/core/cjs/integration.js"(exports) {
    init_define_ENV_DEFINED_IN_BUILD_STEP();
    Object.defineProperty(exports, "__esModule", { value: true });
    var utils = require_cjs();
    var debugBuild = require_debug_build2();
    var eventProcessors = require_eventProcessors();
    var exports$1 = require_exports();
    var hub = require_hub();
    var installedIntegrations = [];
    function filterDuplicates(integrations) {
      const integrationsByName = {};
      integrations.forEach((currentInstance) => {
        const { name } = currentInstance;
        const existingInstance = integrationsByName[name];
        if (existingInstance && !existingInstance.isDefaultInstance && currentInstance.isDefaultInstance) {
          return;
        }
        integrationsByName[name] = currentInstance;
      });
      return Object.keys(integrationsByName).map((k2) => integrationsByName[k2]);
    }
    function getIntegrationsToSetup(options) {
      const defaultIntegrations = options.defaultIntegrations || [];
      const userIntegrations = options.integrations;
      defaultIntegrations.forEach((integration) => {
        integration.isDefaultInstance = true;
      });
      let integrations;
      if (Array.isArray(userIntegrations)) {
        integrations = [...defaultIntegrations, ...userIntegrations];
      } else if (typeof userIntegrations === "function") {
        integrations = utils.arrayify(userIntegrations(defaultIntegrations));
      } else {
        integrations = defaultIntegrations;
      }
      const finalIntegrations = filterDuplicates(integrations);
      const debugIndex = findIndex(finalIntegrations, (integration) => integration.name === "Debug");
      if (debugIndex !== -1) {
        const [debugInstance] = finalIntegrations.splice(debugIndex, 1);
        finalIntegrations.push(debugInstance);
      }
      return finalIntegrations;
    }
    function setupIntegrations(client, integrations) {
      const integrationIndex = {};
      integrations.forEach((integration) => {
        if (integration) {
          setupIntegration(client, integration, integrationIndex);
        }
      });
      return integrationIndex;
    }
    function afterSetupIntegrations(client, integrations) {
      for (const integration of integrations) {
        if (integration && integration.afterAllSetup) {
          integration.afterAllSetup(client);
        }
      }
    }
    function setupIntegration(client, integration, integrationIndex) {
      if (integrationIndex[integration.name]) {
        debugBuild.DEBUG_BUILD && utils.logger.log(`Integration skipped because it was already installed: ${integration.name}`);
        return;
      }
      integrationIndex[integration.name] = integration;
      if (installedIntegrations.indexOf(integration.name) === -1) {
        integration.setupOnce(eventProcessors.addGlobalEventProcessor, hub.getCurrentHub);
        installedIntegrations.push(integration.name);
      }
      if (integration.setup && typeof integration.setup === "function") {
        integration.setup(client);
      }
      if (client.on && typeof integration.preprocessEvent === "function") {
        const callback = integration.preprocessEvent.bind(integration);
        client.on("preprocessEvent", (event, hint) => callback(event, hint, client));
      }
      if (client.addEventProcessor && typeof integration.processEvent === "function") {
        const callback = integration.processEvent.bind(integration);
        const processor = Object.assign((event, hint) => callback(event, hint, client), {
          id: integration.name
        });
        client.addEventProcessor(processor);
      }
      debugBuild.DEBUG_BUILD && utils.logger.log(`Integration installed: ${integration.name}`);
    }
    function addIntegration(integration) {
      const client = exports$1.getClient();
      if (!client || !client.addIntegration) {
        debugBuild.DEBUG_BUILD && utils.logger.warn(`Cannot add integration "${integration.name}" because no SDK Client is available.`);
        return;
      }
      client.addIntegration(integration);
    }
    function findIndex(arr, callback) {
      for (let i2 = 0; i2 < arr.length; i2++) {
        if (callback(arr[i2]) === true) {
          return i2;
        }
      }
      return -1;
    }
    function convertIntegrationFnToClass(name, fn) {
      return Object.assign(
        function ConvertedIntegration(...args) {
          return fn(...args);
        },
        { id: name }
      );
    }
    function defineIntegration(fn) {
      return fn;
    }
    exports.addIntegration = addIntegration;
    exports.afterSetupIntegrations = afterSetupIntegrations;
    exports.convertIntegrationFnToClass = convertIntegrationFnToClass;
    exports.defineIntegration = defineIntegration;
    exports.getIntegrationsToSetup = getIntegrationsToSetup;
    exports.installedIntegrations = installedIntegrations;
    exports.setupIntegration = setupIntegration;
    exports.setupIntegrations = setupIntegrations;
  }
});

// ../../../node_modules/.pnpm/@sentry+core@7.120.2/node_modules/@sentry/core/cjs/metrics/utils.js
var require_utils2 = __commonJS({
  "../../../node_modules/.pnpm/@sentry+core@7.120.2/node_modules/@sentry/core/cjs/metrics/utils.js"(exports) {
    init_define_ENV_DEFINED_IN_BUILD_STEP();
    Object.defineProperty(exports, "__esModule", { value: true });
    var utils = require_cjs();
    function getBucketKey(metricType, name, unit, tags) {
      const stringifiedTags = Object.entries(utils.dropUndefinedKeys(tags)).sort((a3, b) => a3[0].localeCompare(b[0]));
      return `${metricType}${name}${unit}${stringifiedTags}`;
    }
    function simpleHash(s2) {
      let rv = 0;
      for (let i2 = 0; i2 < s2.length; i2++) {
        const c3 = s2.charCodeAt(i2);
        rv = (rv << 5) - rv + c3;
        rv &= rv;
      }
      return rv >>> 0;
    }
    function serializeMetricBuckets(metricBucketItems) {
      let out = "";
      for (const item of metricBucketItems) {
        const tagEntries = Object.entries(item.tags);
        const maybeTags = tagEntries.length > 0 ? `|#${tagEntries.map(([key, value]) => `${key}:${value}`).join(",")}` : "";
        out += `${item.name}@${item.unit}:${item.metric}|${item.metricType}${maybeTags}|T${item.timestamp}
`;
      }
      return out;
    }
    function sanitizeUnit(unit) {
      return unit.replace(/[^\w]+/gi, "_");
    }
    function sanitizeMetricKey(key) {
      return key.replace(/[^\w\-.]+/gi, "_");
    }
    function sanitizeTagKey(key) {
      return key.replace(/[^\w\-./]+/gi, "");
    }
    var tagValueReplacements = [
      ["\n", "\\n"],
      ["\r", "\\r"],
      ["	", "\\t"],
      ["\\", "\\\\"],
      ["|", "\\u{7c}"],
      [",", "\\u{2c}"]
    ];
    function getCharOrReplacement(input) {
      for (const [search, replacement] of tagValueReplacements) {
        if (input === search) {
          return replacement;
        }
      }
      return input;
    }
    function sanitizeTagValue(value) {
      return [...value].reduce((acc, char) => acc + getCharOrReplacement(char), "");
    }
    function sanitizeTags(unsanitizedTags) {
      const tags = {};
      for (const key in unsanitizedTags) {
        if (Object.prototype.hasOwnProperty.call(unsanitizedTags, key)) {
          const sanitizedKey = sanitizeTagKey(key);
          tags[sanitizedKey] = sanitizeTagValue(String(unsanitizedTags[key]));
        }
      }
      return tags;
    }
    exports.getBucketKey = getBucketKey;
    exports.sanitizeMetricKey = sanitizeMetricKey;
    exports.sanitizeTags = sanitizeTags;
    exports.sanitizeUnit = sanitizeUnit;
    exports.serializeMetricBuckets = serializeMetricBuckets;
    exports.simpleHash = simpleHash;
  }
});

// ../../../node_modules/.pnpm/@sentry+core@7.120.2/node_modules/@sentry/core/cjs/metrics/envelope.js
var require_envelope3 = __commonJS({
  "../../../node_modules/.pnpm/@sentry+core@7.120.2/node_modules/@sentry/core/cjs/metrics/envelope.js"(exports) {
    init_define_ENV_DEFINED_IN_BUILD_STEP();
    Object.defineProperty(exports, "__esModule", { value: true });
    var utils = require_cjs();
    var utils$1 = require_utils2();
    function createMetricEnvelope(metricBucketItems, dsn, metadata, tunnel) {
      const headers = {
        sent_at: (/* @__PURE__ */ new Date()).toISOString()
      };
      if (metadata && metadata.sdk) {
        headers.sdk = {
          name: metadata.sdk.name,
          version: metadata.sdk.version
        };
      }
      if (!!tunnel && dsn) {
        headers.dsn = utils.dsnToString(dsn);
      }
      const item = createMetricEnvelopeItem(metricBucketItems);
      return utils.createEnvelope(headers, [item]);
    }
    function createMetricEnvelopeItem(metricBucketItems) {
      const payload = utils$1.serializeMetricBuckets(metricBucketItems);
      const metricHeaders = {
        type: "statsd",
        length: payload.length
      };
      return [metricHeaders, payload];
    }
    exports.createMetricEnvelope = createMetricEnvelope;
  }
});

// ../../../node_modules/.pnpm/@sentry+core@7.120.2/node_modules/@sentry/core/cjs/baseclient.js
var require_baseclient = __commonJS({
  "../../../node_modules/.pnpm/@sentry+core@7.120.2/node_modules/@sentry/core/cjs/baseclient.js"(exports) {
    init_define_ENV_DEFINED_IN_BUILD_STEP();
    Object.defineProperty(exports, "__esModule", { value: true });
    var utils = require_cjs();
    var api = require_api();
    var debugBuild = require_debug_build2();
    var envelope = require_envelope2();
    var exports$1 = require_exports();
    var hub = require_hub();
    var integration = require_integration();
    var envelope$1 = require_envelope3();
    var session = require_session();
    var dynamicSamplingContext = require_dynamicSamplingContext();
    var prepareEvent = require_prepareEvent();
    var ALREADY_SEEN_ERROR = "Not capturing exception because it's already been captured.";
    var BaseClient = class {
      /**
       * A reference to a metrics aggregator
       *
       * @experimental Note this is alpha API. It may experience breaking changes in the future.
       */
      /** Options passed to the SDK. */
      /** The client Dsn, if specified in options. Without this Dsn, the SDK will be disabled. */
      /** Array of set up integrations. */
      /** Indicates whether this client's integrations have been set up. */
      /** Number of calls being processed */
      /** Holds flushable  */
      // eslint-disable-next-line @typescript-eslint/ban-types
      /**
       * Initializes this client instance.
       *
       * @param options Options for the client.
       */
      constructor(options) {
        this._options = options;
        this._integrations = {};
        this._integrationsInitialized = false;
        this._numProcessing = 0;
        this._outcomes = {};
        this._hooks = {};
        this._eventProcessors = [];
        if (options.dsn) {
          this._dsn = utils.makeDsn(options.dsn);
        } else {
          debugBuild.DEBUG_BUILD && utils.logger.warn("No DSN provided, client will not send events.");
        }
        if (this._dsn) {
          const url = api.getEnvelopeEndpointWithUrlEncodedAuth(this._dsn, options);
          this._transport = options.transport({
            tunnel: this._options.tunnel,
            recordDroppedEvent: this.recordDroppedEvent.bind(this),
            ...options.transportOptions,
            url
          });
        }
      }
      /**
       * @inheritDoc
       */
      // eslint-disable-next-line @typescript-eslint/no-explicit-any, @typescript-eslint/explicit-module-boundary-types
      captureException(exception, hint, scope) {
        if (utils.checkOrSetAlreadyCaught(exception)) {
          debugBuild.DEBUG_BUILD && utils.logger.log(ALREADY_SEEN_ERROR);
          return;
        }
        let eventId = hint && hint.event_id;
        this._process(
          this.eventFromException(exception, hint).then((event) => this._captureEvent(event, hint, scope)).then((result) => {
            eventId = result;
          })
        );
        return eventId;
      }
      /**
       * @inheritDoc
       */
      captureMessage(message, level, hint, scope) {
        let eventId = hint && hint.event_id;
        const eventMessage = utils.isParameterizedString(message) ? message : String(message);
        const promisedEvent = utils.isPrimitive(message) ? this.eventFromMessage(eventMessage, level, hint) : this.eventFromException(message, hint);
        this._process(
          promisedEvent.then((event) => this._captureEvent(event, hint, scope)).then((result) => {
            eventId = result;
          })
        );
        return eventId;
      }
      /**
       * @inheritDoc
       */
      captureEvent(event, hint, scope) {
        if (hint && hint.originalException && utils.checkOrSetAlreadyCaught(hint.originalException)) {
          debugBuild.DEBUG_BUILD && utils.logger.log(ALREADY_SEEN_ERROR);
          return;
        }
        let eventId = hint && hint.event_id;
        const sdkProcessingMetadata = event.sdkProcessingMetadata || {};
        const capturedSpanScope = sdkProcessingMetadata.capturedSpanScope;
        this._process(
          this._captureEvent(event, hint, capturedSpanScope || scope).then((result) => {
            eventId = result;
          })
        );
        return eventId;
      }
      /**
       * @inheritDoc
       */
      captureSession(session$1) {
        if (!(typeof session$1.release === "string")) {
          debugBuild.DEBUG_BUILD && utils.logger.warn("Discarded session because of missing or non-string release");
        } else {
          this.sendSession(session$1);
          session.updateSession(session$1, { init: false });
        }
      }
      /**
       * @inheritDoc
       */
      getDsn() {
        return this._dsn;
      }
      /**
       * @inheritDoc
       */
      getOptions() {
        return this._options;
      }
      /**
       * @see SdkMetadata in @sentry/types
       *
       * @return The metadata of the SDK
       */
      getSdkMetadata() {
        return this._options._metadata;
      }
      /**
       * @inheritDoc
       */
      getTransport() {
        return this._transport;
      }
      /**
       * @inheritDoc
       */
      flush(timeout) {
        const transport = this._transport;
        if (transport) {
          if (this.metricsAggregator) {
            this.metricsAggregator.flush();
          }
          return this._isClientDoneProcessing(timeout).then((clientFinished) => {
            return transport.flush(timeout).then((transportFlushed) => clientFinished && transportFlushed);
          });
        } else {
          return utils.resolvedSyncPromise(true);
        }
      }
      /**
       * @inheritDoc
       */
      close(timeout) {
        return this.flush(timeout).then((result) => {
          this.getOptions().enabled = false;
          if (this.metricsAggregator) {
            this.metricsAggregator.close();
          }
          return result;
        });
      }
      /** Get all installed event processors. */
      getEventProcessors() {
        return this._eventProcessors;
      }
      /** @inheritDoc */
      addEventProcessor(eventProcessor) {
        this._eventProcessors.push(eventProcessor);
      }
      /**
       * This is an internal function to setup all integrations that should run on the client.
       * @deprecated Use `client.init()` instead.
       */
      setupIntegrations(forceInitialize) {
        if (forceInitialize && !this._integrationsInitialized || this._isEnabled() && !this._integrationsInitialized) {
          this._setupIntegrations();
        }
      }
      /** @inheritdoc */
      init() {
        if (this._isEnabled()) {
          this._setupIntegrations();
        }
      }
      /**
       * Gets an installed integration by its `id`.
       *
       * @returns The installed integration or `undefined` if no integration with that `id` was installed.
       * @deprecated Use `getIntegrationByName()` instead.
       */
      getIntegrationById(integrationId) {
        return this.getIntegrationByName(integrationId);
      }
      /**
       * Gets an installed integration by its name.
       *
       * @returns The installed integration or `undefined` if no integration with that `name` was installed.
       */
      getIntegrationByName(integrationName) {
        return this._integrations[integrationName];
      }
      /**
       * Returns the client's instance of the given integration class, it any.
       * @deprecated Use `getIntegrationByName()` instead.
       */
      getIntegration(integration2) {
        try {
          return this._integrations[integration2.id] || null;
        } catch (_oO) {
          debugBuild.DEBUG_BUILD && utils.logger.warn(`Cannot retrieve integration ${integration2.id} from the current Client`);
          return null;
        }
      }
      /**
       * @inheritDoc
       */
      addIntegration(integration$1) {
        const isAlreadyInstalled = this._integrations[integration$1.name];
        integration.setupIntegration(this, integration$1, this._integrations);
        if (!isAlreadyInstalled) {
          integration.afterSetupIntegrations(this, [integration$1]);
        }
      }
      /**
       * @inheritDoc
       */
      sendEvent(event, hint = {}) {
        this.emit("beforeSendEvent", event, hint);
        let env2 = envelope.createEventEnvelope(event, this._dsn, this._options._metadata, this._options.tunnel);
        for (const attachment of hint.attachments || []) {
          env2 = utils.addItemToEnvelope(
            env2,
            utils.createAttachmentEnvelopeItem(
              attachment,
              this._options.transportOptions && this._options.transportOptions.textEncoder
            )
          );
        }
        const promise = this._sendEnvelope(env2);
        if (promise) {
          promise.then((sendResponse) => this.emit("afterSendEvent", event, sendResponse), null);
        }
      }
      /**
       * @inheritDoc
       */
      sendSession(session2) {
        const env2 = envelope.createSessionEnvelope(session2, this._dsn, this._options._metadata, this._options.tunnel);
        this._sendEnvelope(env2);
      }
      /**
       * @inheritDoc
       */
      recordDroppedEvent(reason, category, eventOrCount) {
        if (this._options.sendClientReports) {
          const count = typeof eventOrCount === "number" ? eventOrCount : 1;
          const key = `${reason}:${category}`;
          debugBuild.DEBUG_BUILD && utils.logger.log(`Recording outcome: "${key}"${count > 1 ? ` (${count} times)` : ""}`);
          this._outcomes[key] = (this._outcomes[key] || 0) + count;
        }
      }
      /**
       * @inheritDoc
       */
      captureAggregateMetrics(metricBucketItems) {
        debugBuild.DEBUG_BUILD && utils.logger.log(`Flushing aggregated metrics, number of metrics: ${metricBucketItems.length}`);
        const metricsEnvelope = envelope$1.createMetricEnvelope(
          metricBucketItems,
          this._dsn,
          this._options._metadata,
          this._options.tunnel
        );
        this._sendEnvelope(metricsEnvelope);
      }
      // Keep on() & emit() signatures in sync with types' client.ts interface
      /* eslint-disable @typescript-eslint/unified-signatures */
      /** @inheritdoc */
      /** @inheritdoc */
      on(hook, callback) {
        if (!this._hooks[hook]) {
          this._hooks[hook] = [];
        }
        this._hooks[hook].push(callback);
      }
      /** @inheritdoc */
      /** @inheritdoc */
      emit(hook, ...rest) {
        if (this._hooks[hook]) {
          this._hooks[hook].forEach((callback) => callback(...rest));
        }
      }
      /* eslint-enable @typescript-eslint/unified-signatures */
      /** Setup integrations for this client. */
      _setupIntegrations() {
        const { integrations } = this._options;
        this._integrations = integration.setupIntegrations(this, integrations);
        integration.afterSetupIntegrations(this, integrations);
        this._integrationsInitialized = true;
      }
      /** Updates existing session based on the provided event */
      _updateSessionFromEvent(session$1, event) {
        let crashed = false;
        let errored = false;
        const exceptions = event.exception && event.exception.values;
        if (exceptions) {
          errored = true;
          for (const ex of exceptions) {
            const mechanism = ex.mechanism;
            if (mechanism && mechanism.handled === false) {
              crashed = true;
              break;
            }
          }
        }
        const sessionNonTerminal = session$1.status === "ok";
        const shouldUpdateAndSend = sessionNonTerminal && session$1.errors === 0 || sessionNonTerminal && crashed;
        if (shouldUpdateAndSend) {
          session.updateSession(session$1, {
            ...crashed && { status: "crashed" },
            errors: session$1.errors || Number(errored || crashed)
          });
          this.captureSession(session$1);
        }
      }
      /**
       * Determine if the client is finished processing. Returns a promise because it will wait `timeout` ms before saying
       * "no" (resolving to `false`) in order to give the client a chance to potentially finish first.
       *
       * @param timeout The time, in ms, after which to resolve to `false` if the client is still busy. Passing `0` (or not
       * passing anything) will make the promise wait as long as it takes for processing to finish before resolving to
       * `true`.
       * @returns A promise which will resolve to `true` if processing is already done or finishes before the timeout, and
       * `false` otherwise
       */
      _isClientDoneProcessing(timeout) {
        return new utils.SyncPromise((resolve2) => {
          let ticked = 0;
          const tick = 1;
          const interval = setInterval(() => {
            if (this._numProcessing == 0) {
              clearInterval(interval);
              resolve2(true);
            } else {
              ticked += tick;
              if (timeout && ticked >= timeout) {
                clearInterval(interval);
                resolve2(false);
              }
            }
          }, tick);
        });
      }
      /** Determines whether this SDK is enabled and a transport is present. */
      _isEnabled() {
        return this.getOptions().enabled !== false && this._transport !== void 0;
      }
      /**
       * Adds common information to events.
       *
       * The information includes release and environment from `options`,
       * breadcrumbs and context (extra, tags and user) from the scope.
       *
       * Information that is already present in the event is never overwritten. For
       * nested objects, such as the context, keys are merged.
       *
       * @param event The original event.
       * @param hint May contain additional information about the original exception.
       * @param scope A scope containing event metadata.
       * @returns A new event with more information.
       */
      _prepareEvent(event, hint, scope, isolationScope = hub.getIsolationScope()) {
        const options = this.getOptions();
        const integrations = Object.keys(this._integrations);
        if (!hint.integrations && integrations.length > 0) {
          hint.integrations = integrations;
        }
        this.emit("preprocessEvent", event, hint);
        return prepareEvent.prepareEvent(options, event, hint, scope, this, isolationScope).then((evt) => {
          if (evt === null) {
            return evt;
          }
          const propagationContext = {
            ...isolationScope.getPropagationContext(),
            ...scope ? scope.getPropagationContext() : void 0
          };
          const trace = evt.contexts && evt.contexts.trace;
          if (!trace && propagationContext) {
            const { traceId: trace_id, spanId, parentSpanId, dsc } = propagationContext;
            evt.contexts = {
              trace: {
                trace_id,
                span_id: spanId,
                parent_span_id: parentSpanId
              },
              ...evt.contexts
            };
            const dynamicSamplingContext$1 = dsc ? dsc : dynamicSamplingContext.getDynamicSamplingContextFromClient(trace_id, this, scope);
            evt.sdkProcessingMetadata = {
              dynamicSamplingContext: dynamicSamplingContext$1,
              ...evt.sdkProcessingMetadata
            };
          }
          return evt;
        });
      }
      /**
       * Processes the event and logs an error in case of rejection
       * @param event
       * @param hint
       * @param scope
       */
      _captureEvent(event, hint = {}, scope) {
        return this._processEvent(event, hint, scope).then(
          (finalEvent) => {
            return finalEvent.event_id;
          },
          (reason) => {
            if (debugBuild.DEBUG_BUILD) {
              const sentryError = reason;
              if (sentryError.logLevel === "log") {
                utils.logger.log(sentryError.message);
              } else {
                utils.logger.warn(sentryError);
              }
            }
            return void 0;
          }
        );
      }
      /**
       * Processes an event (either error or message) and sends it to Sentry.
       *
       * This also adds breadcrumbs and context information to the event. However,
       * platform specific meta data (such as the User's IP address) must be added
       * by the SDK implementor.
       *
       *
       * @param event The event to send to Sentry.
       * @param hint May contain additional information about the original exception.
       * @param scope A scope containing event metadata.
       * @returns A SyncPromise that resolves with the event or rejects in case event was/will not be send.
       */
      _processEvent(event, hint, scope) {
        const options = this.getOptions();
        const { sampleRate } = options;
        const isTransaction = isTransactionEvent(event);
        const isError = isErrorEvent(event);
        const eventType = event.type || "error";
        const beforeSendLabel = `before send for type \`${eventType}\``;
        if (isError && typeof sampleRate === "number" && Math.random() > sampleRate) {
          this.recordDroppedEvent("sample_rate", "error", event);
          return utils.rejectedSyncPromise(
            new utils.SentryError(
              `Discarding event because it's not included in the random sample (sampling rate = ${sampleRate})`,
              "log"
            )
          );
        }
        const dataCategory = eventType === "replay_event" ? "replay" : eventType;
        const sdkProcessingMetadata = event.sdkProcessingMetadata || {};
        const capturedSpanIsolationScope = sdkProcessingMetadata.capturedSpanIsolationScope;
        return this._prepareEvent(event, hint, scope, capturedSpanIsolationScope).then((prepared) => {
          if (prepared === null) {
            this.recordDroppedEvent("event_processor", dataCategory, event);
            throw new utils.SentryError("An event processor returned `null`, will not send event.", "log");
          }
          const isInternalException = hint.data && hint.data.__sentry__ === true;
          if (isInternalException) {
            return prepared;
          }
          const result = processBeforeSend(options, prepared, hint);
          return _validateBeforeSendResult(result, beforeSendLabel);
        }).then((processedEvent) => {
          if (processedEvent === null) {
            this.recordDroppedEvent("before_send", dataCategory, event);
            if (isTransaction) {
              const spans = event.spans || [];
              const spanCount = 1 + spans.length;
              this.recordDroppedEvent("before_send", "span", spanCount);
            }
            throw new utils.SentryError(`${beforeSendLabel} returned \`null\`, will not send event.`, "log");
          }
          const session2 = scope && scope.getSession();
          if (!isTransaction && session2) {
            this._updateSessionFromEvent(session2, processedEvent);
          }
          if (isTransaction) {
            const spanCountBefore = processedEvent.sdkProcessingMetadata && processedEvent.sdkProcessingMetadata.spanCountBeforeProcessing || 0;
            const spanCountAfter = processedEvent.spans ? processedEvent.spans.length : 0;
            const droppedSpanCount = spanCountBefore - spanCountAfter;
            if (droppedSpanCount > 0) {
              this.recordDroppedEvent("before_send", "span", droppedSpanCount);
            }
          }
          const transactionInfo = processedEvent.transaction_info;
          if (isTransaction && transactionInfo && processedEvent.transaction !== event.transaction) {
            const source = "custom";
            processedEvent.transaction_info = {
              ...transactionInfo,
              source
            };
          }
          this.sendEvent(processedEvent, hint);
          return processedEvent;
        }).then(null, (reason) => {
          if (reason instanceof utils.SentryError) {
            throw reason;
          }
          this.captureException(reason, {
            data: {
              __sentry__: true
            },
            originalException: reason
          });
          throw new utils.SentryError(
            `Event processing pipeline threw an error, original event will not be sent. Details have been sent as a new event.
Reason: ${reason}`
          );
        });
      }
      /**
       * Occupies the client with processing and event
       */
      _process(promise) {
        this._numProcessing++;
        void promise.then(
          (value) => {
            this._numProcessing--;
            return value;
          },
          (reason) => {
            this._numProcessing--;
            return reason;
          }
        );
      }
      /**
       * @inheritdoc
       */
      _sendEnvelope(envelope2) {
        this.emit("beforeEnvelope", envelope2);
        if (this._isEnabled() && this._transport) {
          return this._transport.send(envelope2).then(null, (reason) => {
            debugBuild.DEBUG_BUILD && utils.logger.error("Error while sending event:", reason);
          });
        } else {
          debugBuild.DEBUG_BUILD && utils.logger.error("Transport disabled");
        }
      }
      /**
       * Clears outcomes on this client and returns them.
       */
      _clearOutcomes() {
        const outcomes = this._outcomes;
        this._outcomes = {};
        return Object.keys(outcomes).map((key) => {
          const [reason, category] = key.split(":");
          return {
            reason,
            category,
            quantity: outcomes[key]
          };
        });
      }
      /**
       * @inheritDoc
       */
      // eslint-disable-next-line @typescript-eslint/no-explicit-any, @typescript-eslint/explicit-module-boundary-types
    };
    function _validateBeforeSendResult(beforeSendResult, beforeSendLabel) {
      const invalidValueError = `${beforeSendLabel} must return \`null\` or a valid event.`;
      if (utils.isThenable(beforeSendResult)) {
        return beforeSendResult.then(
          (event) => {
            if (!utils.isPlainObject(event) && event !== null) {
              throw new utils.SentryError(invalidValueError);
            }
            return event;
          },
          (e2) => {
            throw new utils.SentryError(`${beforeSendLabel} rejected with ${e2}`);
          }
        );
      } else if (!utils.isPlainObject(beforeSendResult) && beforeSendResult !== null) {
        throw new utils.SentryError(invalidValueError);
      }
      return beforeSendResult;
    }
    function processBeforeSend(options, event, hint) {
      const { beforeSend, beforeSendTransaction } = options;
      if (isErrorEvent(event) && beforeSend) {
        return beforeSend(event, hint);
      }
      if (isTransactionEvent(event) && beforeSendTransaction) {
        if (event.spans) {
          const spanCountBefore = event.spans.length;
          event.sdkProcessingMetadata = {
            ...event.sdkProcessingMetadata,
            spanCountBeforeProcessing: spanCountBefore
          };
        }
        return beforeSendTransaction(event, hint);
      }
      return event;
    }
    function isErrorEvent(event) {
      return event.type === void 0;
    }
    function isTransactionEvent(event) {
      return event.type === "transaction";
    }
    function addEventProcessor(callback) {
      const client = exports$1.getClient();
      if (!client || !client.addEventProcessor) {
        return;
      }
      client.addEventProcessor(callback);
    }
    exports.BaseClient = BaseClient;
    exports.addEventProcessor = addEventProcessor;
  }
});

// ../../../node_modules/.pnpm/@sentry+core@7.120.2/node_modules/@sentry/core/cjs/checkin.js
var require_checkin = __commonJS({
  "../../../node_modules/.pnpm/@sentry+core@7.120.2/node_modules/@sentry/core/cjs/checkin.js"(exports) {
    init_define_ENV_DEFINED_IN_BUILD_STEP();
    Object.defineProperty(exports, "__esModule", { value: true });
    var utils = require_cjs();
    function createCheckInEnvelope(checkIn, dynamicSamplingContext, metadata, tunnel, dsn) {
      const headers = {
        sent_at: (/* @__PURE__ */ new Date()).toISOString()
      };
      if (metadata && metadata.sdk) {
        headers.sdk = {
          name: metadata.sdk.name,
          version: metadata.sdk.version
        };
      }
      if (!!tunnel && !!dsn) {
        headers.dsn = utils.dsnToString(dsn);
      }
      if (dynamicSamplingContext) {
        headers.trace = utils.dropUndefinedKeys(dynamicSamplingContext);
      }
      const item = createCheckInEnvelopeItem(checkIn);
      return utils.createEnvelope(headers, [item]);
    }
    function createCheckInEnvelopeItem(checkIn) {
      const checkInHeaders = {
        type: "check_in"
      };
      return [checkInHeaders, checkIn];
    }
    exports.createCheckInEnvelope = createCheckInEnvelope;
  }
});

// ../../../node_modules/.pnpm/@sentry+core@7.120.2/node_modules/@sentry/core/cjs/metrics/constants.js
var require_constants2 = __commonJS({
  "../../../node_modules/.pnpm/@sentry+core@7.120.2/node_modules/@sentry/core/cjs/metrics/constants.js"(exports) {
    init_define_ENV_DEFINED_IN_BUILD_STEP();
    Object.defineProperty(exports, "__esModule", { value: true });
    var COUNTER_METRIC_TYPE = "c";
    var GAUGE_METRIC_TYPE = "g";
    var SET_METRIC_TYPE = "s";
    var DISTRIBUTION_METRIC_TYPE = "d";
    var DEFAULT_BROWSER_FLUSH_INTERVAL = 5e3;
    var DEFAULT_FLUSH_INTERVAL = 1e4;
    var MAX_WEIGHT = 1e4;
    exports.COUNTER_METRIC_TYPE = COUNTER_METRIC_TYPE;
    exports.DEFAULT_BROWSER_FLUSH_INTERVAL = DEFAULT_BROWSER_FLUSH_INTERVAL;
    exports.DEFAULT_FLUSH_INTERVAL = DEFAULT_FLUSH_INTERVAL;
    exports.DISTRIBUTION_METRIC_TYPE = DISTRIBUTION_METRIC_TYPE;
    exports.GAUGE_METRIC_TYPE = GAUGE_METRIC_TYPE;
    exports.MAX_WEIGHT = MAX_WEIGHT;
    exports.SET_METRIC_TYPE = SET_METRIC_TYPE;
  }
});

// ../../../node_modules/.pnpm/@sentry+core@7.120.2/node_modules/@sentry/core/cjs/metrics/instance.js
var require_instance = __commonJS({
  "../../../node_modules/.pnpm/@sentry+core@7.120.2/node_modules/@sentry/core/cjs/metrics/instance.js"(exports) {
    init_define_ENV_DEFINED_IN_BUILD_STEP();
    Object.defineProperty(exports, "__esModule", { value: true });
    var constants = require_constants2();
    var utils = require_utils2();
    var CounterMetric = class {
      constructor(_value) {
        this._value = _value;
      }
      /** @inheritDoc */
      get weight() {
        return 1;
      }
      /** @inheritdoc */
      add(value) {
        this._value += value;
      }
      /** @inheritdoc */
      toString() {
        return `${this._value}`;
      }
    };
    var GaugeMetric = class {
      constructor(value) {
        this._last = value;
        this._min = value;
        this._max = value;
        this._sum = value;
        this._count = 1;
      }
      /** @inheritDoc */
      get weight() {
        return 5;
      }
      /** @inheritdoc */
      add(value) {
        this._last = value;
        if (value < this._min) {
          this._min = value;
        }
        if (value > this._max) {
          this._max = value;
        }
        this._sum += value;
        this._count++;
      }
      /** @inheritdoc */
      toString() {
        return `${this._last}:${this._min}:${this._max}:${this._sum}:${this._count}`;
      }
    };
    var DistributionMetric = class {
      constructor(first) {
        this._value = [first];
      }
      /** @inheritDoc */
      get weight() {
        return this._value.length;
      }
      /** @inheritdoc */
      add(value) {
        this._value.push(value);
      }
      /** @inheritdoc */
      toString() {
        return this._value.join(":");
      }
    };
    var SetMetric = class {
      constructor(first) {
        this.first = first;
        this._value = /* @__PURE__ */ new Set([first]);
      }
      /** @inheritDoc */
      get weight() {
        return this._value.size;
      }
      /** @inheritdoc */
      add(value) {
        this._value.add(value);
      }
      /** @inheritdoc */
      toString() {
        return Array.from(this._value).map((val) => typeof val === "string" ? utils.simpleHash(val) : val).join(":");
      }
    };
    var METRIC_MAP = {
      [constants.COUNTER_METRIC_TYPE]: CounterMetric,
      [constants.GAUGE_METRIC_TYPE]: GaugeMetric,
      [constants.DISTRIBUTION_METRIC_TYPE]: DistributionMetric,
      [constants.SET_METRIC_TYPE]: SetMetric
    };
    exports.CounterMetric = CounterMetric;
    exports.DistributionMetric = DistributionMetric;
    exports.GaugeMetric = GaugeMetric;
    exports.METRIC_MAP = METRIC_MAP;
    exports.SetMetric = SetMetric;
  }
});

// ../../../node_modules/.pnpm/@sentry+core@7.120.2/node_modules/@sentry/core/cjs/metrics/aggregator.js
var require_aggregator = __commonJS({
  "../../../node_modules/.pnpm/@sentry+core@7.120.2/node_modules/@sentry/core/cjs/metrics/aggregator.js"(exports) {
    init_define_ENV_DEFINED_IN_BUILD_STEP();
    Object.defineProperty(exports, "__esModule", { value: true });
    var utils$1 = require_cjs();
    var constants = require_constants2();
    var instance = require_instance();
    var metricSummary = require_metric_summary();
    var utils = require_utils2();
    var MetricsAggregator = class {
      // TODO(@anonrig): Use FinalizationRegistry to have a proper way of flushing the buckets
      // when the aggregator is garbage collected.
      // Ref: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/FinalizationRegistry
      // Different metrics have different weights. We use this to limit the number of metrics
      // that we store in memory.
      // Cast to any so that it can use Node.js timeout
      // eslint-disable-next-line @typescript-eslint/no-explicit-any
      // SDKs are required to shift the flush interval by random() * rollup_in_seconds.
      // That shift is determined once per startup to create jittering.
      // An SDK is required to perform force flushing ahead of scheduled time if the memory
      // pressure is too high. There is no rule for this other than that SDKs should be tracking
      // abstract aggregation complexity (eg: a counter only carries a single float, whereas a
      // distribution is a float per emission).
      //
      // Force flush is used on either shutdown, flush() or when we exceed the max weight.
      constructor(_client) {
        this._client = _client;
        this._buckets = /* @__PURE__ */ new Map();
        this._bucketsTotalWeight = 0;
        this._interval = setInterval(() => this._flush(), constants.DEFAULT_FLUSH_INTERVAL);
        if (this._interval.unref) {
          this._interval.unref();
        }
        this._flushShift = Math.floor(Math.random() * constants.DEFAULT_FLUSH_INTERVAL / 1e3);
        this._forceFlush = false;
      }
      /**
       * @inheritDoc
       */
      add(metricType, unsanitizedName, value, unsanitizedUnit = "none", unsanitizedTags = {}, maybeFloatTimestamp = utils$1.timestampInSeconds()) {
        const timestamp = Math.floor(maybeFloatTimestamp);
        const name = utils.sanitizeMetricKey(unsanitizedName);
        const tags = utils.sanitizeTags(unsanitizedTags);
        const unit = utils.sanitizeUnit(unsanitizedUnit);
        const bucketKey = utils.getBucketKey(metricType, name, unit, tags);
        let bucketItem = this._buckets.get(bucketKey);
        const previousWeight = bucketItem && metricType === constants.SET_METRIC_TYPE ? bucketItem.metric.weight : 0;
        if (bucketItem) {
          bucketItem.metric.add(value);
          if (bucketItem.timestamp < timestamp) {
            bucketItem.timestamp = timestamp;
          }
        } else {
          bucketItem = {
            // @ts-expect-error we don't need to narrow down the type of value here, saves bundle size.
            metric: new instance.METRIC_MAP[metricType](value),
            timestamp,
            metricType,
            name,
            unit,
            tags
          };
          this._buckets.set(bucketKey, bucketItem);
        }
        const val = typeof value === "string" ? bucketItem.metric.weight - previousWeight : value;
        metricSummary.updateMetricSummaryOnActiveSpan(metricType, name, val, unit, unsanitizedTags, bucketKey);
        this._bucketsTotalWeight += bucketItem.metric.weight;
        if (this._bucketsTotalWeight >= constants.MAX_WEIGHT) {
          this.flush();
        }
      }
      /**
       * Flushes the current metrics to the transport via the transport.
       */
      flush() {
        this._forceFlush = true;
        this._flush();
      }
      /**
       * Shuts down metrics aggregator and clears all metrics.
       */
      close() {
        this._forceFlush = true;
        clearInterval(this._interval);
        this._flush();
      }
      /**
       * Flushes the buckets according to the internal state of the aggregator.
       * If it is a force flush, which happens on shutdown, it will flush all buckets.
       * Otherwise, it will only flush buckets that are older than the flush interval,
       * and according to the flush shift.
       *
       * This function mutates `_forceFlush` and `_bucketsTotalWeight` properties.
       */
      _flush() {
        if (this._forceFlush) {
          this._forceFlush = false;
          this._bucketsTotalWeight = 0;
          this._captureMetrics(this._buckets);
          this._buckets.clear();
          return;
        }
        const cutoffSeconds = Math.floor(utils$1.timestampInSeconds()) - constants.DEFAULT_FLUSH_INTERVAL / 1e3 - this._flushShift;
        const flushedBuckets = /* @__PURE__ */ new Map();
        for (const [key, bucket] of this._buckets) {
          if (bucket.timestamp <= cutoffSeconds) {
            flushedBuckets.set(key, bucket);
            this._bucketsTotalWeight -= bucket.metric.weight;
          }
        }
        for (const [key] of flushedBuckets) {
          this._buckets.delete(key);
        }
        this._captureMetrics(flushedBuckets);
      }
      /**
       * Only captures a subset of the buckets passed to this function.
       * @param flushedBuckets
       */
      _captureMetrics(flushedBuckets) {
        if (flushedBuckets.size > 0 && this._client.captureAggregateMetrics) {
          const buckets = Array.from(flushedBuckets).map(([, bucketItem]) => bucketItem);
          this._client.captureAggregateMetrics(buckets);
        }
      }
    };
    exports.MetricsAggregator = MetricsAggregator;
  }
});

// ../../../node_modules/.pnpm/@sentry+core@7.120.2/node_modules/@sentry/core/cjs/server-runtime-client.js
var require_server_runtime_client = __commonJS({
  "../../../node_modules/.pnpm/@sentry+core@7.120.2/node_modules/@sentry/core/cjs/server-runtime-client.js"(exports) {
    init_define_ENV_DEFINED_IN_BUILD_STEP();
    Object.defineProperty(exports, "__esModule", { value: true });
    var utils = require_cjs();
    var baseclient = require_baseclient();
    var checkin = require_checkin();
    var debugBuild = require_debug_build2();
    var exports$1 = require_exports();
    var aggregator = require_aggregator();
    var sessionflusher = require_sessionflusher();
    var hubextensions = require_hubextensions();
    var spanUtils = require_spanUtils();
    var getRootSpan = require_getRootSpan();
    require_spanstatus();
    var dynamicSamplingContext = require_dynamicSamplingContext();
    var ServerRuntimeClient = class extends baseclient.BaseClient {
      /**
       * Creates a new Edge SDK instance.
       * @param options Configuration options for this SDK.
       */
      constructor(options) {
        hubextensions.addTracingExtensions();
        super(options);
        if (options._experiments && options._experiments["metricsAggregator"]) {
          this.metricsAggregator = new aggregator.MetricsAggregator(this);
        }
      }
      /**
       * @inheritDoc
       */
      eventFromException(exception, hint) {
        return utils.resolvedSyncPromise(utils.eventFromUnknownInput(exports$1.getClient(), this._options.stackParser, exception, hint));
      }
      /**
       * @inheritDoc
       */
      eventFromMessage(message, level = "info", hint) {
        return utils.resolvedSyncPromise(
          utils.eventFromMessage(this._options.stackParser, message, level, hint, this._options.attachStacktrace)
        );
      }
      /**
       * @inheritDoc
       */
      // eslint-disable-next-line @typescript-eslint/no-explicit-any, @typescript-eslint/explicit-module-boundary-types
      captureException(exception, hint, scope) {
        if (this._options.autoSessionTracking && this._sessionFlusher && scope) {
          const requestSession = scope.getRequestSession();
          if (requestSession && requestSession.status === "ok") {
            requestSession.status = "errored";
          }
        }
        return super.captureException(exception, hint, scope);
      }
      /**
       * @inheritDoc
       */
      captureEvent(event, hint, scope) {
        if (this._options.autoSessionTracking && this._sessionFlusher && scope) {
          const eventType = event.type || "exception";
          const isException = eventType === "exception" && event.exception && event.exception.values && event.exception.values.length > 0;
          if (isException) {
            const requestSession = scope.getRequestSession();
            if (requestSession && requestSession.status === "ok") {
              requestSession.status = "errored";
            }
          }
        }
        return super.captureEvent(event, hint, scope);
      }
      /**
       *
       * @inheritdoc
       */
      close(timeout) {
        if (this._sessionFlusher) {
          this._sessionFlusher.close();
        }
        return super.close(timeout);
      }
      /** Method that initialises an instance of SessionFlusher on Client */
      initSessionFlusher() {
        const { release, environment } = this._options;
        if (!release) {
          debugBuild.DEBUG_BUILD && utils.logger.warn("Cannot initialise an instance of SessionFlusher if no release is provided!");
        } else {
          this._sessionFlusher = new sessionflusher.SessionFlusher(this, {
            release,
            environment
          });
        }
      }
      /**
       * Create a cron monitor check in and send it to Sentry.
       *
       * @param checkIn An object that describes a check in.
       * @param upsertMonitorConfig An optional object that describes a monitor config. Use this if you want
       * to create a monitor automatically when sending a check in.
       */
      captureCheckIn(checkIn, monitorConfig, scope) {
        const id = "checkInId" in checkIn && checkIn.checkInId ? checkIn.checkInId : utils.uuid4();
        if (!this._isEnabled()) {
          debugBuild.DEBUG_BUILD && utils.logger.warn("SDK not enabled, will not capture checkin.");
          return id;
        }
        const options = this.getOptions();
        const { release, environment, tunnel } = options;
        const serializedCheckIn = {
          check_in_id: id,
          monitor_slug: checkIn.monitorSlug,
          status: checkIn.status,
          release,
          environment
        };
        if ("duration" in checkIn) {
          serializedCheckIn.duration = checkIn.duration;
        }
        if (monitorConfig) {
          serializedCheckIn.monitor_config = {
            schedule: monitorConfig.schedule,
            checkin_margin: monitorConfig.checkinMargin,
            max_runtime: monitorConfig.maxRuntime,
            timezone: monitorConfig.timezone
          };
        }
        const [dynamicSamplingContext2, traceContext] = this._getTraceInfoFromScope(scope);
        if (traceContext) {
          serializedCheckIn.contexts = {
            trace: traceContext
          };
        }
        const envelope = checkin.createCheckInEnvelope(
          serializedCheckIn,
          dynamicSamplingContext2,
          this.getSdkMetadata(),
          tunnel,
          this.getDsn()
        );
        debugBuild.DEBUG_BUILD && utils.logger.info("Sending checkin:", checkIn.monitorSlug, checkIn.status);
        this._sendEnvelope(envelope);
        return id;
      }
      /**
       * Method responsible for capturing/ending a request session by calling `incrementSessionStatusCount` to increment
       * appropriate session aggregates bucket
       */
      _captureRequestSession() {
        if (!this._sessionFlusher) {
          debugBuild.DEBUG_BUILD && utils.logger.warn("Discarded request mode session because autoSessionTracking option was disabled");
        } else {
          this._sessionFlusher.incrementSessionStatusCount();
        }
      }
      /**
       * @inheritDoc
       */
      _prepareEvent(event, hint, scope, isolationScope) {
        if (this._options.platform) {
          event.platform = event.platform || this._options.platform;
        }
        if (this._options.runtime) {
          event.contexts = {
            ...event.contexts,
            runtime: (event.contexts || {}).runtime || this._options.runtime
          };
        }
        if (this._options.serverName) {
          event.server_name = event.server_name || this._options.serverName;
        }
        return super._prepareEvent(event, hint, scope, isolationScope);
      }
      /** Extract trace information from scope */
      _getTraceInfoFromScope(scope) {
        if (!scope) {
          return [void 0, void 0];
        }
        const span = scope.getSpan();
        if (span) {
          const samplingContext = getRootSpan.getRootSpan(span) ? dynamicSamplingContext.getDynamicSamplingContextFromSpan(span) : void 0;
          return [samplingContext, spanUtils.spanToTraceContext(span)];
        }
        const { traceId, spanId, parentSpanId, dsc } = scope.getPropagationContext();
        const traceContext = {
          trace_id: traceId,
          span_id: spanId,
          parent_span_id: parentSpanId
        };
        if (dsc) {
          return [dsc, traceContext];
        }
        return [dynamicSamplingContext.getDynamicSamplingContextFromClient(traceId, this, scope), traceContext];
      }
    };
    exports.ServerRuntimeClient = ServerRuntimeClient;
  }
});

// ../../../node_modules/.pnpm/@sentry+core@7.120.2/node_modules/@sentry/core/cjs/sdk.js
var require_sdk = __commonJS({
  "../../../node_modules/.pnpm/@sentry+core@7.120.2/node_modules/@sentry/core/cjs/sdk.js"(exports) {
    init_define_ENV_DEFINED_IN_BUILD_STEP();
    Object.defineProperty(exports, "__esModule", { value: true });
    var utils = require_cjs();
    var debugBuild = require_debug_build2();
    var exports$1 = require_exports();
    var hub = require_hub();
    function initAndBind(clientClass, options) {
      if (options.debug === true) {
        if (debugBuild.DEBUG_BUILD) {
          utils.logger.enable();
        } else {
          utils.consoleSandbox(() => {
            console.warn("[Sentry] Cannot initialize SDK with `debug` option using a non-debug bundle.");
          });
        }
      }
      const scope = exports$1.getCurrentScope();
      scope.update(options.initialScope);
      const client = new clientClass(options);
      setCurrentClient(client);
      initializeClient(client);
    }
    function setCurrentClient(client) {
      const hub$1 = hub.getCurrentHub();
      const top = hub$1.getStackTop();
      top.client = client;
      top.scope.setClient(client);
    }
    function initializeClient(client) {
      if (client.init) {
        client.init();
      } else if (client.setupIntegrations) {
        client.setupIntegrations();
      }
    }
    exports.initAndBind = initAndBind;
    exports.setCurrentClient = setCurrentClient;
  }
});

// ../../../node_modules/.pnpm/@sentry+core@7.120.2/node_modules/@sentry/core/cjs/transports/base.js
var require_base = __commonJS({
  "../../../node_modules/.pnpm/@sentry+core@7.120.2/node_modules/@sentry/core/cjs/transports/base.js"(exports) {
    init_define_ENV_DEFINED_IN_BUILD_STEP();
    Object.defineProperty(exports, "__esModule", { value: true });
    var utils = require_cjs();
    var debugBuild = require_debug_build2();
    var DEFAULT_TRANSPORT_BUFFER_SIZE = 30;
    function createTransport(options, makeRequest, buffer = utils.makePromiseBuffer(
      options.bufferSize || DEFAULT_TRANSPORT_BUFFER_SIZE
    )) {
      let rateLimits = {};
      const flush = (timeout) => buffer.drain(timeout);
      function send(envelope) {
        const filteredEnvelopeItems = [];
        utils.forEachEnvelopeItem(envelope, (item, type) => {
          const dataCategory = utils.envelopeItemTypeToDataCategory(type);
          if (utils.isRateLimited(rateLimits, dataCategory)) {
            const event = getEventForEnvelopeItem(item, type);
            options.recordDroppedEvent("ratelimit_backoff", dataCategory, event);
          } else {
            filteredEnvelopeItems.push(item);
          }
        });
        if (filteredEnvelopeItems.length === 0) {
          return utils.resolvedSyncPromise();
        }
        const filteredEnvelope = utils.createEnvelope(envelope[0], filteredEnvelopeItems);
        const recordEnvelopeLoss = (reason) => {
          utils.forEachEnvelopeItem(filteredEnvelope, (item, type) => {
            const event = getEventForEnvelopeItem(item, type);
            options.recordDroppedEvent(reason, utils.envelopeItemTypeToDataCategory(type), event);
          });
        };
        const requestTask = () => makeRequest({ body: utils.serializeEnvelope(filteredEnvelope, options.textEncoder) }).then(
          (response) => {
            if (response.statusCode !== void 0 && (response.statusCode < 200 || response.statusCode >= 300)) {
              debugBuild.DEBUG_BUILD && utils.logger.warn(`Sentry responded with status code ${response.statusCode} to sent event.`);
            }
            rateLimits = utils.updateRateLimits(rateLimits, response);
            return response;
          },
          (error) => {
            recordEnvelopeLoss("network_error");
            throw error;
          }
        );
        return buffer.add(requestTask).then(
          (result) => result,
          (error) => {
            if (error instanceof utils.SentryError) {
              debugBuild.DEBUG_BUILD && utils.logger.error("Skipped sending event because buffer is full.");
              recordEnvelopeLoss("queue_overflow");
              return utils.resolvedSyncPromise();
            } else {
              throw error;
            }
          }
        );
      }
      send.__sentry__baseTransport__ = true;
      return {
        send,
        flush
      };
    }
    function getEventForEnvelopeItem(item, type) {
      if (type !== "event" && type !== "transaction") {
        return void 0;
      }
      return Array.isArray(item) ? item[1] : void 0;
    }
    exports.DEFAULT_TRANSPORT_BUFFER_SIZE = DEFAULT_TRANSPORT_BUFFER_SIZE;
    exports.createTransport = createTransport;
  }
});

// ../../../node_modules/.pnpm/@sentry+core@7.120.2/node_modules/@sentry/core/cjs/transports/offline.js
var require_offline = __commonJS({
  "../../../node_modules/.pnpm/@sentry+core@7.120.2/node_modules/@sentry/core/cjs/transports/offline.js"(exports) {
    init_define_ENV_DEFINED_IN_BUILD_STEP();
    Object.defineProperty(exports, "__esModule", { value: true });
    var utils = require_cjs();
    var debugBuild = require_debug_build2();
    var MIN_DELAY = 100;
    var START_DELAY = 5e3;
    var MAX_DELAY = 36e5;
    function log2(msg, error) {
      debugBuild.DEBUG_BUILD && utils.logger.info(`[Offline]: ${msg}`, error);
    }
    function makeOfflineTransport(createTransport) {
      return (options) => {
        const transport = createTransport(options);
        const store = options.createStore ? options.createStore(options) : void 0;
        let retryDelay = START_DELAY;
        let flushTimer;
        function shouldQueue(env2, error, retryDelay2) {
          if (utils.envelopeContainsItemType(env2, ["replay_event", "replay_recording", "client_report"])) {
            return false;
          }
          if (options.shouldStore) {
            return options.shouldStore(env2, error, retryDelay2);
          }
          return true;
        }
        function flushIn(delay) {
          if (!store) {
            return;
          }
          if (flushTimer) {
            clearTimeout(flushTimer);
          }
          flushTimer = setTimeout(async () => {
            flushTimer = void 0;
            const found = await store.pop();
            if (found) {
              log2("Attempting to send previously queued event");
              void send(found).catch((e2) => {
                log2("Failed to retry sending", e2);
              });
            }
          }, delay);
          if (typeof flushTimer !== "number" && flushTimer.unref) {
            flushTimer.unref();
          }
        }
        function flushWithBackOff() {
          if (flushTimer) {
            return;
          }
          flushIn(retryDelay);
          retryDelay = Math.min(retryDelay * 2, MAX_DELAY);
        }
        async function send(envelope) {
          try {
            const result = await transport.send(envelope);
            let delay = MIN_DELAY;
            if (result) {
              if (result.headers && result.headers["retry-after"]) {
                delay = utils.parseRetryAfterHeader(result.headers["retry-after"]);
              } else if ((result.statusCode || 0) >= 400) {
                return result;
              }
            }
            flushIn(delay);
            retryDelay = START_DELAY;
            return result;
          } catch (e2) {
            if (store && await shouldQueue(envelope, e2, retryDelay)) {
              await store.insert(envelope);
              flushWithBackOff();
              log2("Error sending. Event queued", e2);
              return {};
            } else {
              throw e2;
            }
          }
        }
        if (options.flushAtStartup) {
          flushWithBackOff();
        }
        return {
          send,
          flush: (t2) => transport.flush(t2)
        };
      };
    }
    exports.MIN_DELAY = MIN_DELAY;
    exports.START_DELAY = START_DELAY;
    exports.makeOfflineTransport = makeOfflineTransport;
  }
});

// ../../../node_modules/.pnpm/@sentry+core@7.120.2/node_modules/@sentry/core/cjs/transports/multiplexed.js
var require_multiplexed = __commonJS({
  "../../../node_modules/.pnpm/@sentry+core@7.120.2/node_modules/@sentry/core/cjs/transports/multiplexed.js"(exports) {
    init_define_ENV_DEFINED_IN_BUILD_STEP();
    Object.defineProperty(exports, "__esModule", { value: true });
    var utils = require_cjs();
    var api = require_api();
    function eventFromEnvelope(env2, types) {
      let event;
      utils.forEachEnvelopeItem(env2, (item, type) => {
        if (types.includes(type)) {
          event = Array.isArray(item) ? item[1] : void 0;
        }
        return !!event;
      });
      return event;
    }
    function makeOverrideReleaseTransport(createTransport, release) {
      return (options) => {
        const transport = createTransport(options);
        return {
          ...transport,
          send: async (envelope) => {
            const event = eventFromEnvelope(envelope, ["event", "transaction", "profile", "replay_event"]);
            if (event) {
              event.release = release;
            }
            return transport.send(envelope);
          }
        };
      };
    }
    function overrideDsn(envelope, dsn) {
      return utils.createEnvelope(
        dsn ? {
          ...envelope[0],
          dsn
        } : envelope[0],
        envelope[1]
      );
    }
    function makeMultiplexedTransport(createTransport, matcher) {
      return (options) => {
        const fallbackTransport = createTransport(options);
        const otherTransports = /* @__PURE__ */ new Map();
        function getTransport(dsn, release) {
          const key = release ? `${dsn}:${release}` : dsn;
          let transport = otherTransports.get(key);
          if (!transport) {
            const validatedDsn = utils.dsnFromString(dsn);
            if (!validatedDsn) {
              return void 0;
            }
            const url = api.getEnvelopeEndpointWithUrlEncodedAuth(validatedDsn, options.tunnel);
            transport = release ? makeOverrideReleaseTransport(createTransport, release)({ ...options, url }) : createTransport({ ...options, url });
            otherTransports.set(key, transport);
          }
          return [dsn, transport];
        }
        async function send(envelope) {
          function getEvent(types) {
            const eventTypes = types && types.length ? types : ["event"];
            return eventFromEnvelope(envelope, eventTypes);
          }
          const transports = matcher({ envelope, getEvent }).map((result) => {
            if (typeof result === "string") {
              return getTransport(result, void 0);
            } else {
              return getTransport(result.dsn, result.release);
            }
          }).filter((t2) => !!t2);
          if (transports.length === 0) {
            transports.push(["", fallbackTransport]);
          }
          const results = await Promise.all(
            transports.map(([dsn, transport]) => transport.send(overrideDsn(envelope, dsn)))
          );
          return results[0];
        }
        async function flush(timeout) {
          const promises = [await fallbackTransport.flush(timeout)];
          for (const [, transport] of otherTransports) {
            promises.push(await transport.flush(timeout));
          }
          return promises.every((r3) => r3);
        }
        return {
          send,
          flush
        };
      };
    }
    exports.eventFromEnvelope = eventFromEnvelope;
    exports.makeMultiplexedTransport = makeMultiplexedTransport;
  }
});

// ../../../node_modules/.pnpm/@sentry+core@7.120.2/node_modules/@sentry/core/cjs/span.js
var require_span2 = __commonJS({
  "../../../node_modules/.pnpm/@sentry+core@7.120.2/node_modules/@sentry/core/cjs/span.js"(exports) {
    init_define_ENV_DEFINED_IN_BUILD_STEP();
    Object.defineProperty(exports, "__esModule", { value: true });
    var utils = require_cjs();
    function createSpanEnvelope(spans, dsn) {
      const headers = {
        sent_at: (/* @__PURE__ */ new Date()).toISOString()
      };
      if (dsn) {
        headers.dsn = utils.dsnToString(dsn);
      }
      const items = spans.map(createSpanItem);
      return utils.createEnvelope(headers, items);
    }
    function createSpanItem(span) {
      const spanHeaders = {
        type: "span"
      };
      return [spanHeaders, span];
    }
    exports.createSpanEnvelope = createSpanEnvelope;
  }
});

// ../../../node_modules/.pnpm/@sentry+core@7.120.2/node_modules/@sentry/core/cjs/utils/isSentryRequestUrl.js
var require_isSentryRequestUrl = __commonJS({
  "../../../node_modules/.pnpm/@sentry+core@7.120.2/node_modules/@sentry/core/cjs/utils/isSentryRequestUrl.js"(exports) {
    init_define_ENV_DEFINED_IN_BUILD_STEP();
    Object.defineProperty(exports, "__esModule", { value: true });
    function isSentryRequestUrl(url, hubOrClient) {
      const client = hubOrClient && isHub(hubOrClient) ? (
        // eslint-disable-next-line deprecation/deprecation
        hubOrClient.getClient()
      ) : hubOrClient;
      const dsn = client && client.getDsn();
      const tunnel = client && client.getOptions().tunnel;
      return checkDsn(url, dsn) || checkTunnel(url, tunnel);
    }
    function checkTunnel(url, tunnel) {
      if (!tunnel) {
        return false;
      }
      return removeTrailingSlash(url) === removeTrailingSlash(tunnel);
    }
    function checkDsn(url, dsn) {
      return dsn ? url.includes(dsn.host) : false;
    }
    function removeTrailingSlash(str) {
      return str[str.length - 1] === "/" ? str.slice(0, -1) : str;
    }
    function isHub(hubOrClient) {
      return hubOrClient.getClient !== void 0;
    }
    exports.isSentryRequestUrl = isSentryRequestUrl;
  }
});

// ../../../node_modules/.pnpm/@sentry+core@7.120.2/node_modules/@sentry/core/cjs/utils/parameterize.js
var require_parameterize = __commonJS({
  "../../../node_modules/.pnpm/@sentry+core@7.120.2/node_modules/@sentry/core/cjs/utils/parameterize.js"(exports) {
    init_define_ENV_DEFINED_IN_BUILD_STEP();
    Object.defineProperty(exports, "__esModule", { value: true });
    function parameterize(strings, ...values) {
      const formatted = new String(String.raw(strings, ...values));
      formatted.__sentry_template_string__ = strings.join("\0").replace(/%/g, "%%").replace(/\0/g, "%s");
      formatted.__sentry_template_values__ = values;
      return formatted;
    }
    exports.parameterize = parameterize;
  }
});

// ../../../node_modules/.pnpm/@sentry+core@7.120.2/node_modules/@sentry/core/cjs/utils/sdkMetadata.js
var require_sdkMetadata = __commonJS({
  "../../../node_modules/.pnpm/@sentry+core@7.120.2/node_modules/@sentry/core/cjs/utils/sdkMetadata.js"(exports) {
    init_define_ENV_DEFINED_IN_BUILD_STEP();
    Object.defineProperty(exports, "__esModule", { value: true });
    var version2 = require_version();
    function applySdkMetadata(options, name, names = [name], source = "npm") {
      const metadata = options._metadata || {};
      if (!metadata.sdk) {
        metadata.sdk = {
          name: `sentry.javascript.${name}`,
          packages: names.map((name2) => ({
            name: `${source}:@sentry/${name2}`,
            version: version2.SDK_VERSION
          })),
          version: version2.SDK_VERSION
        };
      }
      options._metadata = metadata;
    }
    exports.applySdkMetadata = applySdkMetadata;
  }
});

// ../../../node_modules/.pnpm/@sentry+core@7.120.2/node_modules/@sentry/core/cjs/metadata.js
var require_metadata = __commonJS({
  "../../../node_modules/.pnpm/@sentry+core@7.120.2/node_modules/@sentry/core/cjs/metadata.js"(exports) {
    init_define_ENV_DEFINED_IN_BUILD_STEP();
    Object.defineProperty(exports, "__esModule", { value: true });
    var utils = require_cjs();
    var filenameMetadataMap = /* @__PURE__ */ new Map();
    var parsedStacks = /* @__PURE__ */ new Set();
    function ensureMetadataStacksAreParsed(parser) {
      if (!utils.GLOBAL_OBJ._sentryModuleMetadata) {
        return;
      }
      for (const stack of Object.keys(utils.GLOBAL_OBJ._sentryModuleMetadata)) {
        const metadata = utils.GLOBAL_OBJ._sentryModuleMetadata[stack];
        if (parsedStacks.has(stack)) {
          continue;
        }
        parsedStacks.add(stack);
        const frames = parser(stack);
        for (const frame of frames.reverse()) {
          if (frame.filename) {
            filenameMetadataMap.set(frame.filename, metadata);
            break;
          }
        }
      }
    }
    function getMetadataForUrl(parser, filename) {
      ensureMetadataStacksAreParsed(parser);
      return filenameMetadataMap.get(filename);
    }
    function addMetadataToStackFrames(parser, event) {
      try {
        event.exception.values.forEach((exception) => {
          if (!exception.stacktrace) {
            return;
          }
          for (const frame of exception.stacktrace.frames || []) {
            if (!frame.filename) {
              continue;
            }
            const metadata = getMetadataForUrl(parser, frame.filename);
            if (metadata) {
              frame.module_metadata = metadata;
            }
          }
        });
      } catch (_3) {
      }
    }
    function stripMetadataFromStackFrames(event) {
      try {
        event.exception.values.forEach((exception) => {
          if (!exception.stacktrace) {
            return;
          }
          for (const frame of exception.stacktrace.frames || []) {
            delete frame.module_metadata;
          }
        });
      } catch (_3) {
      }
    }
    exports.addMetadataToStackFrames = addMetadataToStackFrames;
    exports.getMetadataForUrl = getMetadataForUrl;
    exports.stripMetadataFromStackFrames = stripMetadataFromStackFrames;
  }
});

// ../../../node_modules/.pnpm/@sentry+core@7.120.2/node_modules/@sentry/core/cjs/integrations/metadata.js
var require_metadata2 = __commonJS({
  "../../../node_modules/.pnpm/@sentry+core@7.120.2/node_modules/@sentry/core/cjs/integrations/metadata.js"(exports) {
    init_define_ENV_DEFINED_IN_BUILD_STEP();
    Object.defineProperty(exports, "__esModule", { value: true });
    var utils = require_cjs();
    var integration = require_integration();
    var metadata = require_metadata();
    var INTEGRATION_NAME = "ModuleMetadata";
    var _moduleMetadataIntegration = () => {
      return {
        name: INTEGRATION_NAME,
        // TODO v8: Remove this
        setupOnce() {
        },
        // eslint-disable-line @typescript-eslint/no-empty-function
        setup(client) {
          if (typeof client.on !== "function") {
            return;
          }
          client.on("beforeEnvelope", (envelope) => {
            utils.forEachEnvelopeItem(envelope, (item, type) => {
              if (type === "event") {
                const event = Array.isArray(item) ? item[1] : void 0;
                if (event) {
                  metadata.stripMetadataFromStackFrames(event);
                  item[1] = event;
                }
              }
            });
          });
        },
        processEvent(event, _hint, client) {
          const stackParser = client.getOptions().stackParser;
          metadata.addMetadataToStackFrames(stackParser, event);
          return event;
        }
      };
    };
    var moduleMetadataIntegration = integration.defineIntegration(_moduleMetadataIntegration);
    var ModuleMetadata = integration.convertIntegrationFnToClass(
      INTEGRATION_NAME,
      moduleMetadataIntegration
    );
    exports.ModuleMetadata = ModuleMetadata;
    exports.moduleMetadataIntegration = moduleMetadataIntegration;
  }
});

// ../../../node_modules/.pnpm/@sentry+core@7.120.2/node_modules/@sentry/core/cjs/integrations/requestdata.js
var require_requestdata2 = __commonJS({
  "../../../node_modules/.pnpm/@sentry+core@7.120.2/node_modules/@sentry/core/cjs/integrations/requestdata.js"(exports) {
    init_define_ENV_DEFINED_IN_BUILD_STEP();
    Object.defineProperty(exports, "__esModule", { value: true });
    var utils = require_cjs();
    var integration = require_integration();
    var spanUtils = require_spanUtils();
    var DEFAULT_OPTIONS = {
      include: {
        cookies: true,
        data: true,
        headers: true,
        ip: false,
        query_string: true,
        url: true,
        user: {
          id: true,
          username: true,
          email: true
        }
      },
      transactionNamingScheme: "methodPath"
    };
    var INTEGRATION_NAME = "RequestData";
    var _requestDataIntegration = (options = {}) => {
      const _addRequestData = utils.addRequestDataToEvent;
      const _options = {
        ...DEFAULT_OPTIONS,
        ...options,
        include: {
          // @ts-expect-error It's mad because `method` isn't a known `include` key. (It's only here and not set by default in
          // `addRequestDataToEvent` for legacy reasons. TODO (v8): Change that.)
          method: true,
          ...DEFAULT_OPTIONS.include,
          ...options.include,
          user: options.include && typeof options.include.user === "boolean" ? options.include.user : {
            ...DEFAULT_OPTIONS.include.user,
            // Unclear why TS still thinks `options.include.user` could be a boolean at this point
            ...(options.include || {}).user
          }
        }
      };
      return {
        name: INTEGRATION_NAME,
        // TODO v8: Remove this
        setupOnce() {
        },
        // eslint-disable-line @typescript-eslint/no-empty-function
        processEvent(event, _hint, client) {
          const { transactionNamingScheme } = _options;
          const { sdkProcessingMetadata = {} } = event;
          const req = sdkProcessingMetadata.request;
          if (!req) {
            return event;
          }
          const addRequestDataOptions = sdkProcessingMetadata.requestDataOptionsFromExpressHandler || sdkProcessingMetadata.requestDataOptionsFromGCPWrapper || convertReqDataIntegrationOptsToAddReqDataOpts(_options);
          const processedEvent = _addRequestData(event, req, addRequestDataOptions);
          if (event.type === "transaction" || transactionNamingScheme === "handler") {
            return processedEvent;
          }
          const reqWithTransaction = req;
          const transaction = reqWithTransaction._sentryTransaction;
          if (transaction) {
            const name = spanUtils.spanToJSON(transaction).description || "";
            const shouldIncludeMethodInTransactionName = getSDKName(client) === "sentry.javascript.nextjs" ? name.startsWith("/api") : transactionNamingScheme !== "path";
            const [transactionValue] = utils.extractPathForTransaction(req, {
              path: true,
              method: shouldIncludeMethodInTransactionName,
              customRoute: name
            });
            processedEvent.transaction = transactionValue;
          }
          return processedEvent;
        }
      };
    };
    var requestDataIntegration = integration.defineIntegration(_requestDataIntegration);
    var RequestData = integration.convertIntegrationFnToClass(INTEGRATION_NAME, requestDataIntegration);
    function convertReqDataIntegrationOptsToAddReqDataOpts(integrationOptions) {
      const {
        transactionNamingScheme,
        include: { ip, user, ...requestOptions }
      } = integrationOptions;
      const requestIncludeKeys = [];
      for (const [key, value] of Object.entries(requestOptions)) {
        if (value) {
          requestIncludeKeys.push(key);
        }
      }
      let addReqDataUserOpt;
      if (user === void 0) {
        addReqDataUserOpt = true;
      } else if (typeof user === "boolean") {
        addReqDataUserOpt = user;
      } else {
        const userIncludeKeys = [];
        for (const [key, value] of Object.entries(user)) {
          if (value) {
            userIncludeKeys.push(key);
          }
        }
        addReqDataUserOpt = userIncludeKeys;
      }
      return {
        include: {
          ip,
          user: addReqDataUserOpt,
          request: requestIncludeKeys.length !== 0 ? requestIncludeKeys : void 0,
          transaction: transactionNamingScheme
        }
      };
    }
    function getSDKName(client) {
      try {
        return client.getOptions()._metadata.sdk.name;
      } catch (err) {
        return void 0;
      }
    }
    exports.RequestData = RequestData;
    exports.requestDataIntegration = requestDataIntegration;
  }
});

// ../../../node_modules/.pnpm/@sentry+core@7.120.2/node_modules/@sentry/core/cjs/integrations/inboundfilters.js
var require_inboundfilters = __commonJS({
  "../../../node_modules/.pnpm/@sentry+core@7.120.2/node_modules/@sentry/core/cjs/integrations/inboundfilters.js"(exports) {
    init_define_ENV_DEFINED_IN_BUILD_STEP();
    Object.defineProperty(exports, "__esModule", { value: true });
    var utils = require_cjs();
    var debugBuild = require_debug_build2();
    var integration = require_integration();
    var DEFAULT_IGNORE_ERRORS = [
      /^Script error\.?$/,
      /^Javascript error: Script error\.? on line 0$/,
      /^ResizeObserver loop completed with undelivered notifications.$/,
      /^Cannot redefine property: googletag$/
    ];
    var DEFAULT_IGNORE_TRANSACTIONS = [
      /^.*\/healthcheck$/,
      /^.*\/healthy$/,
      /^.*\/live$/,
      /^.*\/ready$/,
      /^.*\/heartbeat$/,
      /^.*\/health$/,
      /^.*\/healthz$/
    ];
    var INTEGRATION_NAME = "InboundFilters";
    var _inboundFiltersIntegration = (options = {}) => {
      return {
        name: INTEGRATION_NAME,
        // TODO v8: Remove this
        setupOnce() {
        },
        // eslint-disable-line @typescript-eslint/no-empty-function
        processEvent(event, _hint, client) {
          const clientOptions = client.getOptions();
          const mergedOptions = _mergeOptions(options, clientOptions);
          return _shouldDropEvent(event, mergedOptions) ? null : event;
        }
      };
    };
    var inboundFiltersIntegration = integration.defineIntegration(_inboundFiltersIntegration);
    var InboundFilters = integration.convertIntegrationFnToClass(
      INTEGRATION_NAME,
      inboundFiltersIntegration
    );
    function _mergeOptions(internalOptions = {}, clientOptions = {}) {
      return {
        allowUrls: [...internalOptions.allowUrls || [], ...clientOptions.allowUrls || []],
        denyUrls: [...internalOptions.denyUrls || [], ...clientOptions.denyUrls || []],
        ignoreErrors: [
          ...internalOptions.ignoreErrors || [],
          ...clientOptions.ignoreErrors || [],
          ...internalOptions.disableErrorDefaults ? [] : DEFAULT_IGNORE_ERRORS
        ],
        ignoreTransactions: [
          ...internalOptions.ignoreTransactions || [],
          ...clientOptions.ignoreTransactions || [],
          ...internalOptions.disableTransactionDefaults ? [] : DEFAULT_IGNORE_TRANSACTIONS
        ],
        ignoreInternal: internalOptions.ignoreInternal !== void 0 ? internalOptions.ignoreInternal : true
      };
    }
    function _shouldDropEvent(event, options) {
      if (options.ignoreInternal && _isSentryError(event)) {
        debugBuild.DEBUG_BUILD && utils.logger.warn(`Event dropped due to being internal Sentry Error.
Event: ${utils.getEventDescription(event)}`);
        return true;
      }
      if (_isIgnoredError(event, options.ignoreErrors)) {
        debugBuild.DEBUG_BUILD && utils.logger.warn(
          `Event dropped due to being matched by \`ignoreErrors\` option.
Event: ${utils.getEventDescription(event)}`
        );
        return true;
      }
      if (_isIgnoredTransaction(event, options.ignoreTransactions)) {
        debugBuild.DEBUG_BUILD && utils.logger.warn(
          `Event dropped due to being matched by \`ignoreTransactions\` option.
Event: ${utils.getEventDescription(event)}`
        );
        return true;
      }
      if (_isDeniedUrl(event, options.denyUrls)) {
        debugBuild.DEBUG_BUILD && utils.logger.warn(
          `Event dropped due to being matched by \`denyUrls\` option.
Event: ${utils.getEventDescription(
            event
          )}.
Url: ${_getEventFilterUrl(event)}`
        );
        return true;
      }
      if (!_isAllowedUrl(event, options.allowUrls)) {
        debugBuild.DEBUG_BUILD && utils.logger.warn(
          `Event dropped due to not being matched by \`allowUrls\` option.
Event: ${utils.getEventDescription(
            event
          )}.
Url: ${_getEventFilterUrl(event)}`
        );
        return true;
      }
      return false;
    }
    function _isIgnoredError(event, ignoreErrors) {
      if (event.type || !ignoreErrors || !ignoreErrors.length) {
        return false;
      }
      return _getPossibleEventMessages(event).some((message) => utils.stringMatchesSomePattern(message, ignoreErrors));
    }
    function _isIgnoredTransaction(event, ignoreTransactions) {
      if (event.type !== "transaction" || !ignoreTransactions || !ignoreTransactions.length) {
        return false;
      }
      const name = event.transaction;
      return name ? utils.stringMatchesSomePattern(name, ignoreTransactions) : false;
    }
    function _isDeniedUrl(event, denyUrls) {
      if (!denyUrls || !denyUrls.length) {
        return false;
      }
      const url = _getEventFilterUrl(event);
      return !url ? false : utils.stringMatchesSomePattern(url, denyUrls);
    }
    function _isAllowedUrl(event, allowUrls) {
      if (!allowUrls || !allowUrls.length) {
        return true;
      }
      const url = _getEventFilterUrl(event);
      return !url ? true : utils.stringMatchesSomePattern(url, allowUrls);
    }
    function _getPossibleEventMessages(event) {
      const possibleMessages = [];
      if (event.message) {
        possibleMessages.push(event.message);
      }
      let lastException;
      try {
        lastException = event.exception.values[event.exception.values.length - 1];
      } catch (e2) {
      }
      if (lastException) {
        if (lastException.value) {
          possibleMessages.push(lastException.value);
          if (lastException.type) {
            possibleMessages.push(`${lastException.type}: ${lastException.value}`);
          }
        }
      }
      if (debugBuild.DEBUG_BUILD && possibleMessages.length === 0) {
        utils.logger.error(`Could not extract message for event ${utils.getEventDescription(event)}`);
      }
      return possibleMessages;
    }
    function _isSentryError(event) {
      try {
        return event.exception.values[0].type === "SentryError";
      } catch (e2) {
      }
      return false;
    }
    function _getLastValidUrl(frames = []) {
      for (let i2 = frames.length - 1; i2 >= 0; i2--) {
        const frame = frames[i2];
        if (frame && frame.filename !== "<anonymous>" && frame.filename !== "[native code]") {
          return frame.filename || null;
        }
      }
      return null;
    }
    function _getEventFilterUrl(event) {
      try {
        let frames;
        try {
          frames = event.exception.values[0].stacktrace.frames;
        } catch (e2) {
        }
        return frames ? _getLastValidUrl(frames) : null;
      } catch (oO) {
        debugBuild.DEBUG_BUILD && utils.logger.error(`Cannot extract url for event ${utils.getEventDescription(event)}`);
        return null;
      }
    }
    exports.InboundFilters = InboundFilters;
    exports.inboundFiltersIntegration = inboundFiltersIntegration;
  }
});

// ../../../node_modules/.pnpm/@sentry+core@7.120.2/node_modules/@sentry/core/cjs/integrations/functiontostring.js
var require_functiontostring = __commonJS({
  "../../../node_modules/.pnpm/@sentry+core@7.120.2/node_modules/@sentry/core/cjs/integrations/functiontostring.js"(exports) {
    init_define_ENV_DEFINED_IN_BUILD_STEP();
    Object.defineProperty(exports, "__esModule", { value: true });
    var utils = require_cjs();
    var exports$1 = require_exports();
    var integration = require_integration();
    var originalFunctionToString;
    var INTEGRATION_NAME = "FunctionToString";
    var SETUP_CLIENTS = /* @__PURE__ */ new WeakMap();
    var _functionToStringIntegration = () => {
      return {
        name: INTEGRATION_NAME,
        setupOnce() {
          originalFunctionToString = Function.prototype.toString;
          try {
            Function.prototype.toString = function(...args) {
              const originalFunction = utils.getOriginalFunction(this);
              const context2 = SETUP_CLIENTS.has(exports$1.getClient()) && originalFunction !== void 0 ? originalFunction : this;
              return originalFunctionToString.apply(context2, args);
            };
          } catch (e2) {
          }
        },
        setup(client) {
          SETUP_CLIENTS.set(client, true);
        }
      };
    };
    var functionToStringIntegration = integration.defineIntegration(_functionToStringIntegration);
    var FunctionToString = integration.convertIntegrationFnToClass(
      INTEGRATION_NAME,
      functionToStringIntegration
    );
    exports.FunctionToString = FunctionToString;
    exports.functionToStringIntegration = functionToStringIntegration;
  }
});

// ../../../node_modules/.pnpm/@sentry+core@7.120.2/node_modules/@sentry/core/cjs/integrations/linkederrors.js
var require_linkederrors = __commonJS({
  "../../../node_modules/.pnpm/@sentry+core@7.120.2/node_modules/@sentry/core/cjs/integrations/linkederrors.js"(exports) {
    init_define_ENV_DEFINED_IN_BUILD_STEP();
    Object.defineProperty(exports, "__esModule", { value: true });
    var utils = require_cjs();
    var integration = require_integration();
    var DEFAULT_KEY = "cause";
    var DEFAULT_LIMIT = 5;
    var INTEGRATION_NAME = "LinkedErrors";
    var _linkedErrorsIntegration = (options = {}) => {
      const limit = options.limit || DEFAULT_LIMIT;
      const key = options.key || DEFAULT_KEY;
      return {
        name: INTEGRATION_NAME,
        // TODO v8: Remove this
        setupOnce() {
        },
        // eslint-disable-line @typescript-eslint/no-empty-function
        preprocessEvent(event, hint, client) {
          const options2 = client.getOptions();
          utils.applyAggregateErrorsToEvent(
            utils.exceptionFromError,
            options2.stackParser,
            options2.maxValueLength,
            key,
            limit,
            event,
            hint
          );
        }
      };
    };
    var linkedErrorsIntegration = integration.defineIntegration(_linkedErrorsIntegration);
    var LinkedErrors = integration.convertIntegrationFnToClass(INTEGRATION_NAME, linkedErrorsIntegration);
    exports.LinkedErrors = LinkedErrors;
    exports.linkedErrorsIntegration = linkedErrorsIntegration;
  }
});

// ../../../node_modules/.pnpm/@sentry+core@7.120.2/node_modules/@sentry/core/cjs/integrations/index.js
var require_integrations = __commonJS({
  "../../../node_modules/.pnpm/@sentry+core@7.120.2/node_modules/@sentry/core/cjs/integrations/index.js"(exports) {
    init_define_ENV_DEFINED_IN_BUILD_STEP();
    Object.defineProperty(exports, "__esModule", { value: true });
    var functiontostring = require_functiontostring();
    var inboundfilters = require_inboundfilters();
    var linkederrors = require_linkederrors();
    exports.FunctionToString = functiontostring.FunctionToString;
    exports.InboundFilters = inboundfilters.InboundFilters;
    exports.LinkedErrors = linkederrors.LinkedErrors;
  }
});

// ../../../node_modules/.pnpm/@sentry+core@7.120.2/node_modules/@sentry/core/cjs/metrics/browser-aggregator.js
var require_browser_aggregator = __commonJS({
  "../../../node_modules/.pnpm/@sentry+core@7.120.2/node_modules/@sentry/core/cjs/metrics/browser-aggregator.js"(exports) {
    init_define_ENV_DEFINED_IN_BUILD_STEP();
    Object.defineProperty(exports, "__esModule", { value: true });
    var utils$1 = require_cjs();
    var constants = require_constants2();
    var instance = require_instance();
    var metricSummary = require_metric_summary();
    var utils = require_utils2();
    var BrowserMetricsAggregator = class {
      // TODO(@anonrig): Use FinalizationRegistry to have a proper way of flushing the buckets
      // when the aggregator is garbage collected.
      // Ref: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/FinalizationRegistry
      constructor(_client) {
        this._client = _client;
        this._buckets = /* @__PURE__ */ new Map();
        this._interval = setInterval(() => this.flush(), constants.DEFAULT_BROWSER_FLUSH_INTERVAL);
      }
      /**
       * @inheritDoc
       */
      add(metricType, unsanitizedName, value, unsanitizedUnit = "none", unsanitizedTags = {}, maybeFloatTimestamp = utils$1.timestampInSeconds()) {
        const timestamp = Math.floor(maybeFloatTimestamp);
        const name = utils.sanitizeMetricKey(unsanitizedName);
        const tags = utils.sanitizeTags(unsanitizedTags);
        const unit = utils.sanitizeUnit(unsanitizedUnit);
        const bucketKey = utils.getBucketKey(metricType, name, unit, tags);
        let bucketItem = this._buckets.get(bucketKey);
        const previousWeight = bucketItem && metricType === constants.SET_METRIC_TYPE ? bucketItem.metric.weight : 0;
        if (bucketItem) {
          bucketItem.metric.add(value);
          if (bucketItem.timestamp < timestamp) {
            bucketItem.timestamp = timestamp;
          }
        } else {
          bucketItem = {
            // @ts-expect-error we don't need to narrow down the type of value here, saves bundle size.
            metric: new instance.METRIC_MAP[metricType](value),
            timestamp,
            metricType,
            name,
            unit,
            tags
          };
          this._buckets.set(bucketKey, bucketItem);
        }
        const val = typeof value === "string" ? bucketItem.metric.weight - previousWeight : value;
        metricSummary.updateMetricSummaryOnActiveSpan(metricType, name, val, unit, unsanitizedTags, bucketKey);
      }
      /**
       * @inheritDoc
       */
      flush() {
        if (this._buckets.size === 0) {
          return;
        }
        if (this._client.captureAggregateMetrics) {
          const metricBuckets = Array.from(this._buckets).map(([, bucketItem]) => bucketItem);
          this._client.captureAggregateMetrics(metricBuckets);
        }
        this._buckets.clear();
      }
      /**
       * @inheritDoc
       */
      close() {
        clearInterval(this._interval);
        this.flush();
      }
    };
    exports.BrowserMetricsAggregator = BrowserMetricsAggregator;
  }
});

// ../../../node_modules/.pnpm/@sentry+core@7.120.2/node_modules/@sentry/core/cjs/metrics/integration.js
var require_integration2 = __commonJS({
  "../../../node_modules/.pnpm/@sentry+core@7.120.2/node_modules/@sentry/core/cjs/metrics/integration.js"(exports) {
    init_define_ENV_DEFINED_IN_BUILD_STEP();
    Object.defineProperty(exports, "__esModule", { value: true });
    var integration = require_integration();
    var browserAggregator = require_browser_aggregator();
    var INTEGRATION_NAME = "MetricsAggregator";
    var _metricsAggregatorIntegration = () => {
      return {
        name: INTEGRATION_NAME,
        // TODO v8: Remove this
        setupOnce() {
        },
        // eslint-disable-line @typescript-eslint/no-empty-function
        setup(client) {
          client.metricsAggregator = new browserAggregator.BrowserMetricsAggregator(client);
        }
      };
    };
    var metricsAggregatorIntegration = integration.defineIntegration(_metricsAggregatorIntegration);
    var MetricsAggregator = integration.convertIntegrationFnToClass(
      INTEGRATION_NAME,
      metricsAggregatorIntegration
    );
    exports.MetricsAggregator = MetricsAggregator;
    exports.metricsAggregatorIntegration = metricsAggregatorIntegration;
  }
});

// ../../../node_modules/.pnpm/@sentry+core@7.120.2/node_modules/@sentry/core/cjs/metrics/exports.js
var require_exports2 = __commonJS({
  "../../../node_modules/.pnpm/@sentry+core@7.120.2/node_modules/@sentry/core/cjs/metrics/exports.js"(exports) {
    init_define_ENV_DEFINED_IN_BUILD_STEP();
    Object.defineProperty(exports, "__esModule", { value: true });
    var utils = require_cjs();
    var debugBuild = require_debug_build2();
    var exports$1 = require_exports();
    var spanUtils = require_spanUtils();
    var constants = require_constants2();
    var integration = require_integration2();
    function addToMetricsAggregator(metricType, name, value, data = {}) {
      const client = exports$1.getClient();
      const scope = exports$1.getCurrentScope();
      if (client) {
        if (!client.metricsAggregator) {
          debugBuild.DEBUG_BUILD && utils.logger.warn("No metrics aggregator enabled. Please add the MetricsAggregator integration to use metrics APIs");
          return;
        }
        const { unit, tags, timestamp } = data;
        const { release, environment } = client.getOptions();
        const transaction = scope.getTransaction();
        const metricTags = {};
        if (release) {
          metricTags.release = release;
        }
        if (environment) {
          metricTags.environment = environment;
        }
        if (transaction) {
          metricTags.transaction = spanUtils.spanToJSON(transaction).description || "";
        }
        debugBuild.DEBUG_BUILD && utils.logger.log(`Adding value of ${value} to ${metricType} metric ${name}`);
        client.metricsAggregator.add(metricType, name, value, unit, { ...metricTags, ...tags }, timestamp);
      }
    }
    function increment(name, value = 1, data) {
      addToMetricsAggregator(constants.COUNTER_METRIC_TYPE, name, value, data);
    }
    function distribution(name, value, data) {
      addToMetricsAggregator(constants.DISTRIBUTION_METRIC_TYPE, name, value, data);
    }
    function set(name, value, data) {
      addToMetricsAggregator(constants.SET_METRIC_TYPE, name, value, data);
    }
    function gauge(name, value, data) {
      addToMetricsAggregator(constants.GAUGE_METRIC_TYPE, name, value, data);
    }
    var metrics = {
      increment,
      distribution,
      set,
      gauge,
      /** @deprecated Use `metrics.metricsAggregratorIntegration()` instead. */
      // eslint-disable-next-line deprecation/deprecation
      MetricsAggregator: integration.MetricsAggregator,
      metricsAggregatorIntegration: integration.metricsAggregatorIntegration
    };
    exports.distribution = distribution;
    exports.gauge = gauge;
    exports.increment = increment;
    exports.metrics = metrics;
    exports.set = set;
  }
});

// ../../../node_modules/.pnpm/@sentry+core@7.120.2/node_modules/@sentry/core/cjs/index.js
var require_cjs2 = __commonJS({
  "../../../node_modules/.pnpm/@sentry+core@7.120.2/node_modules/@sentry/core/cjs/index.js"(exports) {
    init_define_ENV_DEFINED_IN_BUILD_STEP();
    Object.defineProperty(exports, "__esModule", { value: true });
    var hubextensions = require_hubextensions();
    var idletransaction = require_idletransaction();
    var span$1 = require_span();
    var transaction = require_transaction();
    var utils = require_utils();
    var spanstatus = require_spanstatus();
    var trace = require_trace();
    var dynamicSamplingContext = require_dynamicSamplingContext();
    var measurement = require_measurement();
    var sampling = require_sampling();
    var semanticAttributes = require_semanticAttributes();
    var envelope = require_envelope2();
    var exports$1 = require_exports();
    var hub = require_hub();
    var session = require_session();
    var sessionflusher = require_sessionflusher();
    var scope = require_scope();
    var eventProcessors = require_eventProcessors();
    var api = require_api();
    var baseclient = require_baseclient();
    var serverRuntimeClient = require_server_runtime_client();
    var sdk = require_sdk();
    var base = require_base();
    var offline = require_offline();
    var multiplexed = require_multiplexed();
    var version2 = require_version();
    var integration = require_integration();
    var applyScopeDataToEvent = require_applyScopeDataToEvent();
    var prepareEvent = require_prepareEvent();
    var checkin = require_checkin();
    var span = require_span2();
    var hasTracingEnabled = require_hasTracingEnabled();
    var isSentryRequestUrl = require_isSentryRequestUrl();
    var handleCallbackErrors = require_handleCallbackErrors();
    var parameterize = require_parameterize();
    var spanUtils = require_spanUtils();
    var getRootSpan = require_getRootSpan();
    var sdkMetadata = require_sdkMetadata();
    var constants = require_constants();
    var metadata = require_metadata2();
    var requestdata = require_requestdata2();
    var inboundfilters = require_inboundfilters();
    var functiontostring = require_functiontostring();
    var linkederrors = require_linkederrors();
    var index = require_integrations();
    var exports$2 = require_exports2();
    var Integrations = index;
    exports.addTracingExtensions = hubextensions.addTracingExtensions;
    exports.startIdleTransaction = hubextensions.startIdleTransaction;
    exports.IdleTransaction = idletransaction.IdleTransaction;
    exports.TRACING_DEFAULTS = idletransaction.TRACING_DEFAULTS;
    exports.Span = span$1.Span;
    exports.Transaction = transaction.Transaction;
    exports.extractTraceparentData = utils.extractTraceparentData;
    exports.getActiveTransaction = utils.getActiveTransaction;
    Object.defineProperty(exports, "SpanStatus", {
      enumerable: true,
      get: () => spanstatus.SpanStatus
    });
    exports.getSpanStatusFromHttpCode = spanstatus.getSpanStatusFromHttpCode;
    exports.setHttpStatus = spanstatus.setHttpStatus;
    exports.spanStatusfromHttpCode = spanstatus.spanStatusfromHttpCode;
    exports.continueTrace = trace.continueTrace;
    exports.getActiveSpan = trace.getActiveSpan;
    exports.startActiveSpan = trace.startActiveSpan;
    exports.startInactiveSpan = trace.startInactiveSpan;
    exports.startSpan = trace.startSpan;
    exports.startSpanManual = trace.startSpanManual;
    exports.trace = trace.trace;
    exports.getDynamicSamplingContextFromClient = dynamicSamplingContext.getDynamicSamplingContextFromClient;
    exports.getDynamicSamplingContextFromSpan = dynamicSamplingContext.getDynamicSamplingContextFromSpan;
    exports.setMeasurement = measurement.setMeasurement;
    exports.isValidSampleRate = sampling.isValidSampleRate;
    exports.SEMANTIC_ATTRIBUTE_PROFILE_ID = semanticAttributes.SEMANTIC_ATTRIBUTE_PROFILE_ID;
    exports.SEMANTIC_ATTRIBUTE_SENTRY_OP = semanticAttributes.SEMANTIC_ATTRIBUTE_SENTRY_OP;
    exports.SEMANTIC_ATTRIBUTE_SENTRY_ORIGIN = semanticAttributes.SEMANTIC_ATTRIBUTE_SENTRY_ORIGIN;
    exports.SEMANTIC_ATTRIBUTE_SENTRY_SAMPLE_RATE = semanticAttributes.SEMANTIC_ATTRIBUTE_SENTRY_SAMPLE_RATE;
    exports.SEMANTIC_ATTRIBUTE_SENTRY_SOURCE = semanticAttributes.SEMANTIC_ATTRIBUTE_SENTRY_SOURCE;
    exports.createEventEnvelope = envelope.createEventEnvelope;
    exports.createSessionEnvelope = envelope.createSessionEnvelope;
    exports.addBreadcrumb = exports$1.addBreadcrumb;
    exports.captureCheckIn = exports$1.captureCheckIn;
    exports.captureEvent = exports$1.captureEvent;
    exports.captureException = exports$1.captureException;
    exports.captureMessage = exports$1.captureMessage;
    exports.captureSession = exports$1.captureSession;
    exports.close = exports$1.close;
    exports.configureScope = exports$1.configureScope;
    exports.endSession = exports$1.endSession;
    exports.flush = exports$1.flush;
    exports.getClient = exports$1.getClient;
    exports.getCurrentScope = exports$1.getCurrentScope;
    exports.isInitialized = exports$1.isInitialized;
    exports.lastEventId = exports$1.lastEventId;
    exports.setContext = exports$1.setContext;
    exports.setExtra = exports$1.setExtra;
    exports.setExtras = exports$1.setExtras;
    exports.setTag = exports$1.setTag;
    exports.setTags = exports$1.setTags;
    exports.setUser = exports$1.setUser;
    exports.startSession = exports$1.startSession;
    exports.startTransaction = exports$1.startTransaction;
    exports.withActiveSpan = exports$1.withActiveSpan;
    exports.withIsolationScope = exports$1.withIsolationScope;
    exports.withMonitor = exports$1.withMonitor;
    exports.withScope = exports$1.withScope;
    exports.Hub = hub.Hub;
    exports.ensureHubOnCarrier = hub.ensureHubOnCarrier;
    exports.getCurrentHub = hub.getCurrentHub;
    exports.getHubFromCarrier = hub.getHubFromCarrier;
    exports.getIsolationScope = hub.getIsolationScope;
    exports.getMainCarrier = hub.getMainCarrier;
    exports.makeMain = hub.makeMain;
    exports.runWithAsyncContext = hub.runWithAsyncContext;
    exports.setAsyncContextStrategy = hub.setAsyncContextStrategy;
    exports.setHubOnCarrier = hub.setHubOnCarrier;
    exports.closeSession = session.closeSession;
    exports.makeSession = session.makeSession;
    exports.updateSession = session.updateSession;
    exports.SessionFlusher = sessionflusher.SessionFlusher;
    exports.Scope = scope.Scope;
    exports.getGlobalScope = scope.getGlobalScope;
    exports.setGlobalScope = scope.setGlobalScope;
    exports.addGlobalEventProcessor = eventProcessors.addGlobalEventProcessor;
    exports.notifyEventProcessors = eventProcessors.notifyEventProcessors;
    exports.getEnvelopeEndpointWithUrlEncodedAuth = api.getEnvelopeEndpointWithUrlEncodedAuth;
    exports.getReportDialogEndpoint = api.getReportDialogEndpoint;
    exports.BaseClient = baseclient.BaseClient;
    exports.addEventProcessor = baseclient.addEventProcessor;
    exports.ServerRuntimeClient = serverRuntimeClient.ServerRuntimeClient;
    exports.initAndBind = sdk.initAndBind;
    exports.setCurrentClient = sdk.setCurrentClient;
    exports.createTransport = base.createTransport;
    exports.makeOfflineTransport = offline.makeOfflineTransport;
    exports.makeMultiplexedTransport = multiplexed.makeMultiplexedTransport;
    exports.SDK_VERSION = version2.SDK_VERSION;
    exports.addIntegration = integration.addIntegration;
    exports.convertIntegrationFnToClass = integration.convertIntegrationFnToClass;
    exports.defineIntegration = integration.defineIntegration;
    exports.getIntegrationsToSetup = integration.getIntegrationsToSetup;
    exports.applyScopeDataToEvent = applyScopeDataToEvent.applyScopeDataToEvent;
    exports.mergeScopeData = applyScopeDataToEvent.mergeScopeData;
    exports.prepareEvent = prepareEvent.prepareEvent;
    exports.createCheckInEnvelope = checkin.createCheckInEnvelope;
    exports.createSpanEnvelope = span.createSpanEnvelope;
    exports.hasTracingEnabled = hasTracingEnabled.hasTracingEnabled;
    exports.isSentryRequestUrl = isSentryRequestUrl.isSentryRequestUrl;
    exports.handleCallbackErrors = handleCallbackErrors.handleCallbackErrors;
    exports.parameterize = parameterize.parameterize;
    exports.spanIsSampled = spanUtils.spanIsSampled;
    exports.spanToJSON = spanUtils.spanToJSON;
    exports.spanToTraceContext = spanUtils.spanToTraceContext;
    exports.spanToTraceHeader = spanUtils.spanToTraceHeader;
    exports.getRootSpan = getRootSpan.getRootSpan;
    exports.applySdkMetadata = sdkMetadata.applySdkMetadata;
    exports.DEFAULT_ENVIRONMENT = constants.DEFAULT_ENVIRONMENT;
    exports.ModuleMetadata = metadata.ModuleMetadata;
    exports.moduleMetadataIntegration = metadata.moduleMetadataIntegration;
    exports.RequestData = requestdata.RequestData;
    exports.requestDataIntegration = requestdata.requestDataIntegration;
    exports.InboundFilters = inboundfilters.InboundFilters;
    exports.inboundFiltersIntegration = inboundfilters.inboundFiltersIntegration;
    exports.FunctionToString = functiontostring.FunctionToString;
    exports.functionToStringIntegration = functiontostring.functionToStringIntegration;
    exports.LinkedErrors = linkederrors.LinkedErrors;
    exports.linkedErrorsIntegration = linkederrors.linkedErrorsIntegration;
    exports.metrics = exports$2.metrics;
    exports.Integrations = Integrations;
  }
});

// ../../../node_modules/.pnpm/@sentry-internal+tracing@7.120.2/node_modules/@sentry-internal/tracing/cjs/common/debug-build.js
var require_debug_build3 = __commonJS({
  "../../../node_modules/.pnpm/@sentry-internal+tracing@7.120.2/node_modules/@sentry-internal/tracing/cjs/common/debug-build.js"(exports) {
    init_define_ENV_DEFINED_IN_BUILD_STEP();
    Object.defineProperty(exports, "__esModule", { value: true });
    var DEBUG_BUILD = typeof __SENTRY_DEBUG__ === "undefined" || __SENTRY_DEBUG__;
    exports.DEBUG_BUILD = DEBUG_BUILD;
  }
});

// ../../../node_modules/.pnpm/@sentry-internal+tracing@7.120.2/node_modules/@sentry-internal/tracing/cjs/node/integrations/utils/node-utils.js
var require_node_utils = __commonJS({
  "../../../node_modules/.pnpm/@sentry-internal+tracing@7.120.2/node_modules/@sentry-internal/tracing/cjs/node/integrations/utils/node-utils.js"(exports) {
    init_define_ENV_DEFINED_IN_BUILD_STEP();
    var {
      _optionalChain
    } = require_cjs();
    Object.defineProperty(exports, "__esModule", { value: true });
    function shouldDisableAutoInstrumentation(getCurrentHub) {
      const clientOptions = _optionalChain([getCurrentHub, "call", (_3) => _3(), "access", (_22) => _22.getClient, "call", (_3) => _3(), "optionalAccess", (_4) => _4.getOptions, "call", (_5) => _5()]);
      const instrumenter = _optionalChain([clientOptions, "optionalAccess", (_6) => _6.instrumenter]) || "sentry";
      return instrumenter !== "sentry";
    }
    exports.shouldDisableAutoInstrumentation = shouldDisableAutoInstrumentation;
  }
});

// ../../../node_modules/.pnpm/@sentry-internal+tracing@7.120.2/node_modules/@sentry-internal/tracing/cjs/node/integrations/express.js
var require_express = __commonJS({
  "../../../node_modules/.pnpm/@sentry-internal+tracing@7.120.2/node_modules/@sentry-internal/tracing/cjs/node/integrations/express.js"(exports) {
    init_define_ENV_DEFINED_IN_BUILD_STEP();
    var {
      _optionalChain
    } = require_cjs();
    Object.defineProperty(exports, "__esModule", { value: true });
    var core = require_cjs2();
    var utils = require_cjs();
    var debugBuild = require_debug_build3();
    var nodeUtils = require_node_utils();
    var Express = class _Express {
      /**
       * @inheritDoc
       */
      static __initStatic() {
        this.id = "Express";
      }
      /**
       * @inheritDoc
       */
      /**
       * Express App instance
       */
      /**
       * @inheritDoc
       */
      constructor(options = {}) {
        this.name = _Express.id;
        this._router = options.router || options.app;
        this._methods = (Array.isArray(options.methods) ? options.methods : []).concat("use");
      }
      /**
       * @inheritDoc
       */
      // eslint-disable-next-line deprecation/deprecation
      setupOnce(_3, getCurrentHub) {
        if (!this._router) {
          debugBuild.DEBUG_BUILD && utils.logger.error("ExpressIntegration is missing an Express instance");
          return;
        }
        if (nodeUtils.shouldDisableAutoInstrumentation(getCurrentHub)) {
          debugBuild.DEBUG_BUILD && utils.logger.log("Express Integration is skipped because of instrumenter configuration.");
          return;
        }
        instrumentMiddlewares(this._router, this._methods);
        instrumentRouter(this._router);
      }
    };
    Express.__initStatic();
    function wrap(fn, method) {
      const arity = fn.length;
      switch (arity) {
        case 2: {
          return function(req, res) {
            const transaction = res.__sentry_transaction;
            if (transaction) {
              const span = transaction.startChild({
                description: fn.name,
                op: `middleware.express.${method}`,
                origin: "auto.middleware.express"
              });
              res.once("finish", () => {
                span.end();
              });
            }
            return fn.call(this, req, res);
          };
        }
        case 3: {
          return function(req, res, next) {
            const transaction = res.__sentry_transaction;
            const span = _optionalChain([transaction, "optionalAccess", (_22) => _22.startChild, "call", (_3) => _3({
              description: fn.name,
              op: `middleware.express.${method}`,
              origin: "auto.middleware.express"
            })]);
            fn.call(this, req, res, function(...args) {
              _optionalChain([span, "optionalAccess", (_4) => _4.end, "call", (_5) => _5()]);
              next.call(this, ...args);
            });
          };
        }
        case 4: {
          return function(err, req, res, next) {
            const transaction = res.__sentry_transaction;
            const span = _optionalChain([transaction, "optionalAccess", (_6) => _6.startChild, "call", (_7) => _7({
              description: fn.name,
              op: `middleware.express.${method}`,
              origin: "auto.middleware.express"
            })]);
            fn.call(this, err, req, res, function(...args) {
              _optionalChain([span, "optionalAccess", (_8) => _8.end, "call", (_9) => _9()]);
              next.call(this, ...args);
            });
          };
        }
        default: {
          throw new Error(`Express middleware takes 2-4 arguments. Got: ${arity}`);
        }
      }
    }
    function wrapMiddlewareArgs(args, method) {
      return args.map((arg) => {
        if (typeof arg === "function") {
          return wrap(arg, method);
        }
        if (Array.isArray(arg)) {
          return arg.map((a3) => {
            if (typeof a3 === "function") {
              return wrap(a3, method);
            }
            return a3;
          });
        }
        return arg;
      });
    }
    function patchMiddleware(router, method) {
      const originalCallback = router[method];
      router[method] = function(...args) {
        return originalCallback.call(this, ...wrapMiddlewareArgs(args, method));
      };
      return router;
    }
    function instrumentMiddlewares(router, methods = []) {
      methods.forEach((method) => patchMiddleware(router, method));
    }
    function instrumentRouter(appOrRouter) {
      const isApp = "settings" in appOrRouter;
      if (isApp && appOrRouter._router === void 0 && appOrRouter.lazyrouter) {
        appOrRouter.lazyrouter();
      }
      const router = isApp ? appOrRouter._router : appOrRouter;
      if (!router) {
        debugBuild.DEBUG_BUILD && utils.logger.debug("Cannot instrument router for URL Parameterization (did not find a valid router).");
        debugBuild.DEBUG_BUILD && utils.logger.debug("Routing instrumentation is currently only supported in Express 4.");
        return;
      }
      const routerProto = Object.getPrototypeOf(router);
      const originalProcessParams = routerProto.process_params;
      routerProto.process_params = function process_params(layer, called, req, res, done) {
        if (!req._reconstructedRoute) {
          req._reconstructedRoute = "";
        }
        const { layerRoutePath, isRegex, isArray, numExtraSegments } = getLayerRoutePathInfo(layer);
        if (layerRoutePath || isRegex || isArray) {
          req._hasParameters = true;
        }
        let partialRoute;
        if (layerRoutePath) {
          partialRoute = layerRoutePath;
        } else {
          partialRoute = preventDuplicateSegments(req.originalUrl, req._reconstructedRoute, layer.path) || "";
        }
        const finalPartialRoute = partialRoute.split("/").filter((segment) => segment.length > 0 && (isRegex || isArray || !segment.includes("*"))).join("/");
        if (finalPartialRoute && finalPartialRoute.length > 0) {
          req._reconstructedRoute += `/${finalPartialRoute}${isRegex ? "/" : ""}`;
        }
        const urlLength = utils.getNumberOfUrlSegments(utils.stripUrlQueryAndFragment(req.originalUrl || "")) + numExtraSegments;
        const routeLength = utils.getNumberOfUrlSegments(req._reconstructedRoute);
        if (urlLength === routeLength) {
          if (!req._hasParameters) {
            if (req._reconstructedRoute !== req.originalUrl) {
              req._reconstructedRoute = req.originalUrl ? utils.stripUrlQueryAndFragment(req.originalUrl) : req.originalUrl;
            }
          }
          const transaction = res.__sentry_transaction;
          const attributes = transaction && core.spanToJSON(transaction).data || {};
          if (transaction && attributes[core.SEMANTIC_ATTRIBUTE_SENTRY_SOURCE] !== "custom") {
            const finalRoute = req._reconstructedRoute || "/";
            const [name, source] = utils.extractPathForTransaction(req, { path: true, method: true, customRoute: finalRoute });
            transaction.updateName(name);
            transaction.setAttribute(core.SEMANTIC_ATTRIBUTE_SENTRY_SOURCE, source);
          }
        }
        return originalProcessParams.call(this, layer, called, req, res, done);
      };
    }
    var extractOriginalRoute = (path2, regexp, keys) => {
      if (!path2 || !regexp || !keys || Object.keys(keys).length === 0 || _optionalChain([keys, "access", (_10) => _10[0], "optionalAccess", (_11) => _11.offset]) === void 0 || _optionalChain([keys, "access", (_12) => _12[0], "optionalAccess", (_13) => _13.offset]) === null) {
        return void 0;
      }
      const orderedKeys = keys.sort((a3, b) => a3.offset - b.offset);
      const pathRegex = new RegExp(regexp, `${regexp.flags}d`);
      const execResult = pathRegex.exec(path2);
      if (!execResult || !execResult.indices) {
        return void 0;
      }
      const [, ...paramIndices] = execResult.indices;
      if (paramIndices.length !== orderedKeys.length) {
        return void 0;
      }
      let resultPath = path2;
      let indexShift = 0;
      paramIndices.forEach((item, index) => {
        if (item) {
          const [startOffset, endOffset] = item;
          const substr1 = resultPath.substring(0, startOffset - indexShift);
          const replacement = `:${orderedKeys[index].name}`;
          const substr2 = resultPath.substring(endOffset - indexShift);
          resultPath = substr1 + replacement + substr2;
          indexShift = indexShift + (endOffset - startOffset - replacement.length);
        }
      });
      return resultPath;
    };
    function getLayerRoutePathInfo(layer) {
      let lrp = _optionalChain([layer, "access", (_14) => _14.route, "optionalAccess", (_15) => _15.path]);
      const isRegex = utils.isRegExp(lrp);
      const isArray = Array.isArray(lrp);
      if (!lrp) {
        const [major] = utils.GLOBAL_OBJ.process.versions.node.split(".").map(Number);
        if (major >= 16) {
          lrp = extractOriginalRoute(layer.path, layer.regexp, layer.keys);
        }
      }
      if (!lrp) {
        return { isRegex, isArray, numExtraSegments: 0 };
      }
      const numExtraSegments = isArray ? Math.max(getNumberOfArrayUrlSegments(lrp) - utils.getNumberOfUrlSegments(layer.path || ""), 0) : 0;
      const layerRoutePath = getLayerRoutePathString(isArray, lrp);
      return { layerRoutePath, isRegex, isArray, numExtraSegments };
    }
    function getNumberOfArrayUrlSegments(routesArray) {
      return routesArray.reduce((accNumSegments, currentRoute) => {
        return accNumSegments + utils.getNumberOfUrlSegments(currentRoute.toString());
      }, 0);
    }
    function getLayerRoutePathString(isArray, lrp) {
      if (isArray) {
        return lrp.map((r3) => r3.toString()).join(",");
      }
      return lrp && lrp.toString();
    }
    function preventDuplicateSegments(originalUrl, reconstructedRoute, layerPath) {
      const normalizeURL = utils.stripUrlQueryAndFragment(originalUrl || "");
      const originalUrlSplit = _optionalChain([normalizeURL, "optionalAccess", (_16) => _16.split, "call", (_17) => _17("/"), "access", (_18) => _18.filter, "call", (_19) => _19((v3) => !!v3)]);
      let tempCounter = 0;
      const currentOffset = _optionalChain([reconstructedRoute, "optionalAccess", (_20) => _20.split, "call", (_21) => _21("/"), "access", (_22) => _22.filter, "call", (_23) => _23((v3) => !!v3), "access", (_24) => _24.length]) || 0;
      const result = _optionalChain([
        layerPath,
        "optionalAccess",
        (_25) => _25.split,
        "call",
        (_26) => _26("/"),
        "access",
        (_27) => _27.filter,
        "call",
        (_28) => _28((segment) => {
          if (_optionalChain([originalUrlSplit, "optionalAccess", (_29) => _29[currentOffset + tempCounter]]) === segment) {
            tempCounter += 1;
            return true;
          }
          return false;
        }),
        "access",
        (_30) => _30.join,
        "call",
        (_31) => _31("/")
      ]);
      return result;
    }
    exports.Express = Express;
    exports.extractOriginalRoute = extractOriginalRoute;
    exports.preventDuplicateSegments = preventDuplicateSegments;
  }
});

// ../../../node_modules/.pnpm/@sentry-internal+tracing@7.120.2/node_modules/@sentry-internal/tracing/cjs/node/integrations/postgres.js
var require_postgres = __commonJS({
  "../../../node_modules/.pnpm/@sentry-internal+tracing@7.120.2/node_modules/@sentry-internal/tracing/cjs/node/integrations/postgres.js"(exports) {
    init_define_ENV_DEFINED_IN_BUILD_STEP();
    var {
      _optionalChain
    } = require_cjs();
    Object.defineProperty(exports, "__esModule", { value: true });
    var utils = require_cjs();
    var debugBuild = require_debug_build3();
    var nodeUtils = require_node_utils();
    var Postgres = class _Postgres {
      /**
       * @inheritDoc
       */
      static __initStatic() {
        this.id = "Postgres";
      }
      /**
       * @inheritDoc
       */
      constructor(options = {}) {
        this.name = _Postgres.id;
        this._usePgNative = !!options.usePgNative;
        this._module = options.module;
      }
      /** @inheritdoc */
      loadDependency() {
        return this._module = this._module || utils.loadModule("pg");
      }
      /**
       * @inheritDoc
       */
      // eslint-disable-next-line deprecation/deprecation
      setupOnce(_3, getCurrentHub) {
        if (nodeUtils.shouldDisableAutoInstrumentation(getCurrentHub)) {
          debugBuild.DEBUG_BUILD && utils.logger.log("Postgres Integration is skipped because of instrumenter configuration.");
          return;
        }
        const pkg = this.loadDependency();
        if (!pkg) {
          debugBuild.DEBUG_BUILD && utils.logger.error("Postgres Integration was unable to require `pg` package.");
          return;
        }
        const Client = this._usePgNative ? _optionalChain([pkg, "access", (_22) => _22.native, "optionalAccess", (_32) => _32.Client]) : pkg.Client;
        if (!Client) {
          debugBuild.DEBUG_BUILD && utils.logger.error("Postgres Integration was unable to access 'pg-native' bindings.");
          return;
        }
        utils.fill(Client.prototype, "query", function(orig) {
          return function(config, values, callback) {
            const scope = getCurrentHub().getScope();
            const parentSpan = scope.getSpan();
            const data = {
              "db.system": "postgresql"
            };
            try {
              if (this.database) {
                data["db.name"] = this.database;
              }
              if (this.host) {
                data["server.address"] = this.host;
              }
              if (this.port) {
                data["server.port"] = this.port;
              }
              if (this.user) {
                data["db.user"] = this.user;
              }
            } catch (e2) {
            }
            const span = _optionalChain([parentSpan, "optionalAccess", (_4) => _4.startChild, "call", (_5) => _5({
              description: typeof config === "string" ? config : config.text,
              op: "db",
              origin: "auto.db.postgres",
              data
            })]);
            if (typeof callback === "function") {
              return orig.call(this, config, values, function(err, result) {
                _optionalChain([span, "optionalAccess", (_6) => _6.end, "call", (_7) => _7()]);
                callback(err, result);
              });
            }
            if (typeof values === "function") {
              return orig.call(this, config, function(err, result) {
                _optionalChain([span, "optionalAccess", (_8) => _8.end, "call", (_9) => _9()]);
                values(err, result);
              });
            }
            const rv = typeof values !== "undefined" ? orig.call(this, config, values) : orig.call(this, config);
            if (utils.isThenable(rv)) {
              return rv.then((res) => {
                _optionalChain([span, "optionalAccess", (_10) => _10.end, "call", (_11) => _11()]);
                return res;
              });
            }
            _optionalChain([span, "optionalAccess", (_12) => _12.end, "call", (_13) => _13()]);
            return rv;
          };
        });
      }
    };
    Postgres.__initStatic();
    exports.Postgres = Postgres;
  }
});

// ../../../node_modules/.pnpm/@sentry-internal+tracing@7.120.2/node_modules/@sentry-internal/tracing/cjs/node/integrations/mysql.js
var require_mysql = __commonJS({
  "../../../node_modules/.pnpm/@sentry-internal+tracing@7.120.2/node_modules/@sentry-internal/tracing/cjs/node/integrations/mysql.js"(exports) {
    init_define_ENV_DEFINED_IN_BUILD_STEP();
    var {
      _optionalChain
    } = require_cjs();
    Object.defineProperty(exports, "__esModule", { value: true });
    var utils = require_cjs();
    var debugBuild = require_debug_build3();
    var nodeUtils = require_node_utils();
    var Mysql = class _Mysql {
      /**
       * @inheritDoc
       */
      static __initStatic() {
        this.id = "Mysql";
      }
      /**
       * @inheritDoc
       */
      constructor() {
        this.name = _Mysql.id;
      }
      /** @inheritdoc */
      loadDependency() {
        return this._module = this._module || utils.loadModule("mysql/lib/Connection.js");
      }
      /**
       * @inheritDoc
       */
      // eslint-disable-next-line deprecation/deprecation
      setupOnce(_3, getCurrentHub) {
        if (nodeUtils.shouldDisableAutoInstrumentation(getCurrentHub)) {
          debugBuild.DEBUG_BUILD && utils.logger.log("Mysql Integration is skipped because of instrumenter configuration.");
          return;
        }
        const pkg = this.loadDependency();
        if (!pkg) {
          debugBuild.DEBUG_BUILD && utils.logger.error("Mysql Integration was unable to require `mysql` package.");
          return;
        }
        let mySqlConfig = void 0;
        try {
          pkg.prototype.connect = new Proxy(pkg.prototype.connect, {
            apply(wrappingTarget, thisArg, args) {
              if (!mySqlConfig) {
                mySqlConfig = thisArg.config;
              }
              return wrappingTarget.apply(thisArg, args);
            }
          });
        } catch (e2) {
          debugBuild.DEBUG_BUILD && utils.logger.error("Mysql Integration was unable to instrument `mysql` config.");
        }
        function spanDataFromConfig() {
          if (!mySqlConfig) {
            return {};
          }
          return {
            "server.address": mySqlConfig.host,
            "server.port": mySqlConfig.port,
            "db.user": mySqlConfig.user
          };
        }
        function finishSpan(span) {
          if (!span) {
            return;
          }
          const data = spanDataFromConfig();
          Object.keys(data).forEach((key) => {
            span.setAttribute(key, data[key]);
          });
          span.end();
        }
        utils.fill(pkg, "createQuery", function(orig) {
          return function(options, values, callback) {
            const scope = getCurrentHub().getScope();
            const parentSpan = scope.getSpan();
            const span = _optionalChain([parentSpan, "optionalAccess", (_22) => _22.startChild, "call", (_32) => _32({
              description: typeof options === "string" ? options : options.sql,
              op: "db",
              origin: "auto.db.mysql",
              data: {
                "db.system": "mysql"
              }
            })]);
            if (typeof callback === "function") {
              return orig.call(this, options, values, function(err, result, fields) {
                finishSpan(span);
                callback(err, result, fields);
              });
            }
            if (typeof values === "function") {
              return orig.call(this, options, function(err, result, fields) {
                finishSpan(span);
                values(err, result, fields);
              });
            }
            const query = orig.call(this, options, values);
            query.on("end", () => {
              finishSpan(span);
            });
            return query;
          };
        });
      }
    };
    Mysql.__initStatic();
    exports.Mysql = Mysql;
  }
});

// ../../../node_modules/.pnpm/@sentry-internal+tracing@7.120.2/node_modules/@sentry-internal/tracing/cjs/node/integrations/mongo.js
var require_mongo = __commonJS({
  "../../../node_modules/.pnpm/@sentry-internal+tracing@7.120.2/node_modules/@sentry-internal/tracing/cjs/node/integrations/mongo.js"(exports) {
    init_define_ENV_DEFINED_IN_BUILD_STEP();
    var {
      _optionalChain
    } = require_cjs();
    Object.defineProperty(exports, "__esModule", { value: true });
    var utils = require_cjs();
    var debugBuild = require_debug_build3();
    var nodeUtils = require_node_utils();
    var OPERATIONS = [
      "aggregate",
      // aggregate(pipeline, options, callback)
      "bulkWrite",
      // bulkWrite(operations, options, callback)
      "countDocuments",
      // countDocuments(query, options, callback)
      "createIndex",
      // createIndex(fieldOrSpec, options, callback)
      "createIndexes",
      // createIndexes(indexSpecs, options, callback)
      "deleteMany",
      // deleteMany(filter, options, callback)
      "deleteOne",
      // deleteOne(filter, options, callback)
      "distinct",
      // distinct(key, query, options, callback)
      "drop",
      // drop(options, callback)
      "dropIndex",
      // dropIndex(indexName, options, callback)
      "dropIndexes",
      // dropIndexes(options, callback)
      "estimatedDocumentCount",
      // estimatedDocumentCount(options, callback)
      "find",
      // find(query, options, callback)
      "findOne",
      // findOne(query, options, callback)
      "findOneAndDelete",
      // findOneAndDelete(filter, options, callback)
      "findOneAndReplace",
      // findOneAndReplace(filter, replacement, options, callback)
      "findOneAndUpdate",
      // findOneAndUpdate(filter, update, options, callback)
      "indexes",
      // indexes(options, callback)
      "indexExists",
      // indexExists(indexes, options, callback)
      "indexInformation",
      // indexInformation(options, callback)
      "initializeOrderedBulkOp",
      // initializeOrderedBulkOp(options, callback)
      "insertMany",
      // insertMany(docs, options, callback)
      "insertOne",
      // insertOne(doc, options, callback)
      "isCapped",
      // isCapped(options, callback)
      "mapReduce",
      // mapReduce(map, reduce, options, callback)
      "options",
      // options(options, callback)
      "parallelCollectionScan",
      // parallelCollectionScan(options, callback)
      "rename",
      // rename(newName, options, callback)
      "replaceOne",
      // replaceOne(filter, doc, options, callback)
      "stats",
      // stats(options, callback)
      "updateMany",
      // updateMany(filter, update, options, callback)
      "updateOne"
      // updateOne(filter, update, options, callback)
    ];
    var OPERATION_SIGNATURES = {
      // aggregate intentionally not included because `pipeline` arguments are too complex to serialize well
      // see https://github.com/getsentry/sentry-javascript/pull/3102
      bulkWrite: ["operations"],
      countDocuments: ["query"],
      createIndex: ["fieldOrSpec"],
      createIndexes: ["indexSpecs"],
      deleteMany: ["filter"],
      deleteOne: ["filter"],
      distinct: ["key", "query"],
      dropIndex: ["indexName"],
      find: ["query"],
      findOne: ["query"],
      findOneAndDelete: ["filter"],
      findOneAndReplace: ["filter", "replacement"],
      findOneAndUpdate: ["filter", "update"],
      indexExists: ["indexes"],
      insertMany: ["docs"],
      insertOne: ["doc"],
      mapReduce: ["map", "reduce"],
      rename: ["newName"],
      replaceOne: ["filter", "doc"],
      updateMany: ["filter", "update"],
      updateOne: ["filter", "update"]
    };
    function isCursor(maybeCursor) {
      return maybeCursor && typeof maybeCursor === "object" && maybeCursor.once && typeof maybeCursor.once === "function";
    }
    var Mongo = class _Mongo {
      /**
       * @inheritDoc
       */
      static __initStatic() {
        this.id = "Mongo";
      }
      /**
       * @inheritDoc
       */
      /**
       * @inheritDoc
       */
      constructor(options = {}) {
        this.name = _Mongo.id;
        this._operations = Array.isArray(options.operations) ? options.operations : OPERATIONS;
        this._describeOperations = "describeOperations" in options ? options.describeOperations : true;
        this._useMongoose = !!options.useMongoose;
      }
      /** @inheritdoc */
      loadDependency() {
        const moduleName = this._useMongoose ? "mongoose" : "mongodb";
        return this._module = this._module || utils.loadModule(moduleName);
      }
      /**
       * @inheritDoc
       */
      // eslint-disable-next-line deprecation/deprecation
      setupOnce(_3, getCurrentHub) {
        if (nodeUtils.shouldDisableAutoInstrumentation(getCurrentHub)) {
          debugBuild.DEBUG_BUILD && utils.logger.log("Mongo Integration is skipped because of instrumenter configuration.");
          return;
        }
        const pkg = this.loadDependency();
        if (!pkg) {
          const moduleName = this._useMongoose ? "mongoose" : "mongodb";
          debugBuild.DEBUG_BUILD && utils.logger.error(`Mongo Integration was unable to require \`${moduleName}\` package.`);
          return;
        }
        this._instrumentOperations(pkg.Collection, this._operations, getCurrentHub);
      }
      /**
       * Patches original collection methods
       */
      // eslint-disable-next-line deprecation/deprecation
      _instrumentOperations(collection, operations, getCurrentHub) {
        operations.forEach((operation) => this._patchOperation(collection, operation, getCurrentHub));
      }
      /**
       * Patches original collection to utilize our tracing functionality
       */
      // eslint-disable-next-line deprecation/deprecation
      _patchOperation(collection, operation, getCurrentHub) {
        if (!(operation in collection.prototype))
          return;
        const getSpanContext = this._getSpanContextFromOperationArguments.bind(this);
        utils.fill(collection.prototype, operation, function(orig) {
          return function(...args) {
            const lastArg = args[args.length - 1];
            const hub = getCurrentHub();
            const scope = hub.getScope();
            const client = hub.getClient();
            const parentSpan = scope.getSpan();
            const sendDefaultPii = _optionalChain([client, "optionalAccess", (_22) => _22.getOptions, "call", (_3) => _3(), "access", (_4) => _4.sendDefaultPii]);
            if (typeof lastArg !== "function" || operation === "mapReduce" && args.length === 2) {
              const span2 = _optionalChain([parentSpan, "optionalAccess", (_5) => _5.startChild, "call", (_6) => _6(getSpanContext(this, operation, args, sendDefaultPii))]);
              const maybePromiseOrCursor = orig.call(this, ...args);
              if (utils.isThenable(maybePromiseOrCursor)) {
                return maybePromiseOrCursor.then((res) => {
                  _optionalChain([span2, "optionalAccess", (_7) => _7.end, "call", (_8) => _8()]);
                  return res;
                });
              } else if (isCursor(maybePromiseOrCursor)) {
                const cursor = maybePromiseOrCursor;
                try {
                  cursor.once("close", () => {
                    _optionalChain([span2, "optionalAccess", (_9) => _9.end, "call", (_10) => _10()]);
                  });
                } catch (e2) {
                  _optionalChain([span2, "optionalAccess", (_11) => _11.end, "call", (_12) => _12()]);
                }
                return cursor;
              } else {
                _optionalChain([span2, "optionalAccess", (_13) => _13.end, "call", (_14) => _14()]);
                return maybePromiseOrCursor;
              }
            }
            const span = _optionalChain([parentSpan, "optionalAccess", (_15) => _15.startChild, "call", (_16) => _16(getSpanContext(this, operation, args.slice(0, -1)))]);
            return orig.call(this, ...args.slice(0, -1), function(err, result) {
              _optionalChain([span, "optionalAccess", (_17) => _17.end, "call", (_18) => _18()]);
              lastArg(err, result);
            });
          };
        });
      }
      /**
       * Form a SpanContext based on the user input to a given operation.
       */
      _getSpanContextFromOperationArguments(collection, operation, args, sendDefaultPii = false) {
        const data = {
          "db.system": "mongodb",
          "db.name": collection.dbName,
          "db.operation": operation,
          "db.mongodb.collection": collection.collectionName
        };
        const spanContext = {
          op: "db",
          // TODO v8: Use `${collection.collectionName}.${operation}`
          origin: "auto.db.mongo",
          description: operation,
          data
        };
        const signature = OPERATION_SIGNATURES[operation];
        const shouldDescribe = Array.isArray(this._describeOperations) ? this._describeOperations.includes(operation) : this._describeOperations;
        if (!signature || !shouldDescribe || !sendDefaultPii) {
          return spanContext;
        }
        try {
          if (operation === "mapReduce") {
            const [map3, reduce] = args;
            data[signature[0]] = typeof map3 === "string" ? map3 : map3.name || "<anonymous>";
            data[signature[1]] = typeof reduce === "string" ? reduce : reduce.name || "<anonymous>";
          } else {
            for (let i2 = 0; i2 < signature.length; i2++) {
              data[`db.mongodb.${signature[i2]}`] = JSON.stringify(args[i2]);
            }
          }
        } catch (_oO) {
        }
        return spanContext;
      }
    };
    Mongo.__initStatic();
    exports.Mongo = Mongo;
  }
});

// ../../../node_modules/.pnpm/@sentry-internal+tracing@7.120.2/node_modules/@sentry-internal/tracing/cjs/node/integrations/prisma.js
var require_prisma = __commonJS({
  "../../../node_modules/.pnpm/@sentry-internal+tracing@7.120.2/node_modules/@sentry-internal/tracing/cjs/node/integrations/prisma.js"(exports) {
    init_define_ENV_DEFINED_IN_BUILD_STEP();
    Object.defineProperty(exports, "__esModule", { value: true });
    var core = require_cjs2();
    var utils = require_cjs();
    var debugBuild = require_debug_build3();
    var nodeUtils = require_node_utils();
    function isValidPrismaClient(possibleClient) {
      return !!possibleClient && !!possibleClient["$use"];
    }
    var Prisma = class _Prisma {
      /**
       * @inheritDoc
       */
      static __initStatic() {
        this.id = "Prisma";
      }
      /**
       * @inheritDoc
       */
      /**
       * @inheritDoc
       */
      constructor(options = {}) {
        this.name = _Prisma.id;
        if (isValidPrismaClient(options.client) && !options.client._sentryInstrumented) {
          utils.addNonEnumerableProperty(options.client, "_sentryInstrumented", true);
          const clientData = {};
          try {
            const engineConfig = options.client._engineConfig;
            if (engineConfig) {
              const { activeProvider, clientVersion } = engineConfig;
              if (activeProvider) {
                clientData["db.system"] = activeProvider;
              }
              if (clientVersion) {
                clientData["db.prisma.version"] = clientVersion;
              }
            }
          } catch (e2) {
          }
          options.client.$use((params, next) => {
            if (nodeUtils.shouldDisableAutoInstrumentation(core.getCurrentHub)) {
              return next(params);
            }
            const action = params.action;
            const model = params.model;
            return core.startSpan(
              {
                name: model ? `${model} ${action}` : action,
                onlyIfParent: true,
                op: "db.prisma",
                attributes: {
                  [core.SEMANTIC_ATTRIBUTE_SENTRY_ORIGIN]: "auto.db.prisma"
                },
                data: { ...clientData, "db.operation": action }
              },
              () => next(params)
            );
          });
        } else {
          debugBuild.DEBUG_BUILD && utils.logger.warn("Unsupported Prisma client provided to PrismaIntegration. Provided client:", options.client);
        }
      }
      /**
       * @inheritDoc
       */
      setupOnce() {
      }
    };
    Prisma.__initStatic();
    exports.Prisma = Prisma;
  }
});

// ../../../node_modules/.pnpm/@sentry-internal+tracing@7.120.2/node_modules/@sentry-internal/tracing/cjs/node/integrations/graphql.js
var require_graphql = __commonJS({
  "../../../node_modules/.pnpm/@sentry-internal+tracing@7.120.2/node_modules/@sentry-internal/tracing/cjs/node/integrations/graphql.js"(exports) {
    init_define_ENV_DEFINED_IN_BUILD_STEP();
    var {
      _optionalChain
    } = require_cjs();
    Object.defineProperty(exports, "__esModule", { value: true });
    var utils = require_cjs();
    var debugBuild = require_debug_build3();
    var nodeUtils = require_node_utils();
    var GraphQL = class _GraphQL {
      /**
       * @inheritDoc
       */
      static __initStatic() {
        this.id = "GraphQL";
      }
      /**
       * @inheritDoc
       */
      constructor() {
        this.name = _GraphQL.id;
      }
      /** @inheritdoc */
      loadDependency() {
        return this._module = this._module || utils.loadModule("graphql/execution/execute.js");
      }
      /**
       * @inheritDoc
       */
      // eslint-disable-next-line deprecation/deprecation
      setupOnce(_3, getCurrentHub) {
        if (nodeUtils.shouldDisableAutoInstrumentation(getCurrentHub)) {
          debugBuild.DEBUG_BUILD && utils.logger.log("GraphQL Integration is skipped because of instrumenter configuration.");
          return;
        }
        const pkg = this.loadDependency();
        if (!pkg) {
          debugBuild.DEBUG_BUILD && utils.logger.error("GraphQL Integration was unable to require graphql/execution package.");
          return;
        }
        utils.fill(pkg, "execute", function(orig) {
          return function(...args) {
            const scope = getCurrentHub().getScope();
            const parentSpan = scope.getSpan();
            const span = _optionalChain([parentSpan, "optionalAccess", (_22) => _22.startChild, "call", (_32) => _32({
              description: "execute",
              op: "graphql.execute",
              origin: "auto.graphql.graphql"
            })]);
            _optionalChain([scope, "optionalAccess", (_4) => _4.setSpan, "call", (_5) => _5(span)]);
            const rv = orig.call(this, ...args);
            if (utils.isThenable(rv)) {
              return rv.then((res) => {
                _optionalChain([span, "optionalAccess", (_6) => _6.end, "call", (_7) => _7()]);
                _optionalChain([scope, "optionalAccess", (_8) => _8.setSpan, "call", (_9) => _9(parentSpan)]);
                return res;
              });
            }
            _optionalChain([span, "optionalAccess", (_10) => _10.end, "call", (_11) => _11()]);
            _optionalChain([scope, "optionalAccess", (_12) => _12.setSpan, "call", (_13) => _13(parentSpan)]);
            return rv;
          };
        });
      }
    };
    GraphQL.__initStatic();
    exports.GraphQL = GraphQL;
  }
});

// ../../../node_modules/.pnpm/@sentry-internal+tracing@7.120.2/node_modules/@sentry-internal/tracing/cjs/node/integrations/apollo.js
var require_apollo = __commonJS({
  "../../../node_modules/.pnpm/@sentry-internal+tracing@7.120.2/node_modules/@sentry-internal/tracing/cjs/node/integrations/apollo.js"(exports) {
    init_define_ENV_DEFINED_IN_BUILD_STEP();
    var {
      _optionalChain
    } = require_cjs();
    Object.defineProperty(exports, "__esModule", { value: true });
    var utils = require_cjs();
    var debugBuild = require_debug_build3();
    var nodeUtils = require_node_utils();
    var Apollo = class _Apollo {
      /**
       * @inheritDoc
       */
      static __initStatic() {
        this.id = "Apollo";
      }
      /**
       * @inheritDoc
       */
      /**
       * @inheritDoc
       */
      constructor(options = {
        useNestjs: false
      }) {
        this.name = _Apollo.id;
        this._useNest = !!options.useNestjs;
      }
      /** @inheritdoc */
      loadDependency() {
        if (this._useNest) {
          this._module = this._module || utils.loadModule("@nestjs/graphql");
        } else {
          this._module = this._module || utils.loadModule("apollo-server-core");
        }
        return this._module;
      }
      /**
       * @inheritDoc
       */
      // eslint-disable-next-line deprecation/deprecation
      setupOnce(_3, getCurrentHub) {
        if (nodeUtils.shouldDisableAutoInstrumentation(getCurrentHub)) {
          debugBuild.DEBUG_BUILD && utils.logger.log("Apollo Integration is skipped because of instrumenter configuration.");
          return;
        }
        if (this._useNest) {
          const pkg = this.loadDependency();
          if (!pkg) {
            debugBuild.DEBUG_BUILD && utils.logger.error("Apollo-NestJS Integration was unable to require @nestjs/graphql package.");
            return;
          }
          utils.fill(
            pkg.GraphQLFactory.prototype,
            "mergeWithSchema",
            function(orig) {
              return function(...args) {
                utils.fill(this.resolversExplorerService, "explore", function(orig2) {
                  return function() {
                    const resolvers = utils.arrayify(orig2.call(this));
                    const instrumentedResolvers = instrumentResolvers(resolvers, getCurrentHub);
                    return instrumentedResolvers;
                  };
                });
                return orig.call(this, ...args);
              };
            }
          );
        } else {
          const pkg = this.loadDependency();
          if (!pkg) {
            debugBuild.DEBUG_BUILD && utils.logger.error("Apollo Integration was unable to require apollo-server-core package.");
            return;
          }
          utils.fill(pkg.ApolloServerBase.prototype, "constructSchema", function(orig) {
            return function() {
              if (!this.config.resolvers) {
                if (debugBuild.DEBUG_BUILD) {
                  if (this.config.schema) {
                    utils.logger.warn(
                      "Apollo integration is not able to trace `ApolloServer` instances constructed via `schema` property.If you are using NestJS with Apollo, please use `Sentry.Integrations.Apollo({ useNestjs: true })` instead."
                    );
                    utils.logger.warn();
                  } else if (this.config.modules) {
                    utils.logger.warn(
                      "Apollo integration is not able to trace `ApolloServer` instances constructed via `modules` property."
                    );
                  }
                  utils.logger.error("Skipping tracing as no resolvers found on the `ApolloServer` instance.");
                }
                return orig.call(this);
              }
              const resolvers = utils.arrayify(this.config.resolvers);
              this.config.resolvers = instrumentResolvers(resolvers, getCurrentHub);
              return orig.call(this);
            };
          });
        }
      }
    };
    Apollo.__initStatic();
    function instrumentResolvers(resolvers, getCurrentHub) {
      return resolvers.map((model) => {
        Object.keys(model).forEach((resolverGroupName) => {
          Object.keys(model[resolverGroupName]).forEach((resolverName) => {
            if (typeof model[resolverGroupName][resolverName] !== "function") {
              return;
            }
            wrapResolver(model, resolverGroupName, resolverName, getCurrentHub);
          });
        });
        return model;
      });
    }
    function wrapResolver(model, resolverGroupName, resolverName, getCurrentHub) {
      utils.fill(model[resolverGroupName], resolverName, function(orig) {
        return function(...args) {
          const scope = getCurrentHub().getScope();
          const parentSpan = scope.getSpan();
          const span = _optionalChain([parentSpan, "optionalAccess", (_22) => _22.startChild, "call", (_3) => _3({
            description: `${resolverGroupName}.${resolverName}`,
            op: "graphql.resolve",
            origin: "auto.graphql.apollo"
          })]);
          const rv = orig.call(this, ...args);
          if (utils.isThenable(rv)) {
            return rv.then((res) => {
              _optionalChain([span, "optionalAccess", (_4) => _4.end, "call", (_5) => _5()]);
              return res;
            });
          }
          _optionalChain([span, "optionalAccess", (_6) => _6.end, "call", (_7) => _7()]);
          return rv;
        };
      });
    }
    exports.Apollo = Apollo;
  }
});

// ../../../node_modules/.pnpm/@sentry-internal+tracing@7.120.2/node_modules/@sentry-internal/tracing/cjs/node/integrations/lazy.js
var require_lazy = __commonJS({
  "../../../node_modules/.pnpm/@sentry-internal+tracing@7.120.2/node_modules/@sentry-internal/tracing/cjs/node/integrations/lazy.js"(exports, module) {
    init_define_ENV_DEFINED_IN_BUILD_STEP();
    Object.defineProperty(exports, "__esModule", { value: true });
    var utils = require_cjs();
    var lazyLoadedNodePerformanceMonitoringIntegrations = [
      () => {
        const integration = utils.dynamicRequire(module, "./apollo");
        return new integration.Apollo();
      },
      () => {
        const integration = utils.dynamicRequire(module, "./apollo");
        return new integration.Apollo({ useNestjs: true });
      },
      () => {
        const integration = utils.dynamicRequire(module, "./graphql");
        return new integration.GraphQL();
      },
      () => {
        const integration = utils.dynamicRequire(module, "./mongo");
        return new integration.Mongo();
      },
      () => {
        const integration = utils.dynamicRequire(module, "./mongo");
        return new integration.Mongo({ mongoose: true });
      },
      () => {
        const integration = utils.dynamicRequire(module, "./mysql");
        return new integration.Mysql();
      },
      () => {
        const integration = utils.dynamicRequire(module, "./postgres");
        return new integration.Postgres();
      }
    ];
    exports.lazyLoadedNodePerformanceMonitoringIntegrations = lazyLoadedNodePerformanceMonitoringIntegrations;
  }
});

// ../../../node_modules/.pnpm/@sentry-internal+tracing@7.120.2/node_modules/@sentry-internal/tracing/cjs/browser/types.js
var require_types = __commonJS({
  "../../../node_modules/.pnpm/@sentry-internal+tracing@7.120.2/node_modules/@sentry-internal/tracing/cjs/browser/types.js"(exports) {
    init_define_ENV_DEFINED_IN_BUILD_STEP();
    Object.defineProperty(exports, "__esModule", { value: true });
    var utils = require_cjs();
    var WINDOW = utils.GLOBAL_OBJ;
    exports.WINDOW = WINDOW;
  }
});

// ../../../node_modules/.pnpm/@sentry-internal+tracing@7.120.2/node_modules/@sentry-internal/tracing/cjs/browser/backgroundtab.js
var require_backgroundtab = __commonJS({
  "../../../node_modules/.pnpm/@sentry-internal+tracing@7.120.2/node_modules/@sentry-internal/tracing/cjs/browser/backgroundtab.js"(exports) {
    init_define_ENV_DEFINED_IN_BUILD_STEP();
    Object.defineProperty(exports, "__esModule", { value: true });
    var core = require_cjs2();
    var utils = require_cjs();
    var debugBuild = require_debug_build3();
    var types = require_types();
    function registerBackgroundTabDetection() {
      if (types.WINDOW.document) {
        types.WINDOW.document.addEventListener("visibilitychange", () => {
          const activeTransaction = core.getActiveTransaction();
          if (types.WINDOW.document.hidden && activeTransaction) {
            const statusType = "cancelled";
            const { op, status } = core.spanToJSON(activeTransaction);
            debugBuild.DEBUG_BUILD && utils.logger.log(`[Tracing] Transaction: ${statusType} -> since tab moved to the background, op: ${op}`);
            if (!status) {
              activeTransaction.setStatus(statusType);
            }
            activeTransaction.setTag("visibilitychange", "document.hidden");
            activeTransaction.end();
          }
        });
      } else {
        debugBuild.DEBUG_BUILD && utils.logger.warn("[Tracing] Could not set up background tab detection due to lack of global document");
      }
    }
    exports.registerBackgroundTabDetection = registerBackgroundTabDetection;
  }
});

// ../../../node_modules/.pnpm/@sentry-internal+tracing@7.120.2/node_modules/@sentry-internal/tracing/cjs/browser/web-vitals/lib/bindReporter.js
var require_bindReporter = __commonJS({
  "../../../node_modules/.pnpm/@sentry-internal+tracing@7.120.2/node_modules/@sentry-internal/tracing/cjs/browser/web-vitals/lib/bindReporter.js"(exports) {
    init_define_ENV_DEFINED_IN_BUILD_STEP();
    Object.defineProperty(exports, "__esModule", { value: true });
    var bindReporter = (callback, metric, reportAllChanges) => {
      let prevValue;
      let delta;
      return (forceReport) => {
        if (metric.value >= 0) {
          if (forceReport || reportAllChanges) {
            delta = metric.value - (prevValue || 0);
            if (delta || prevValue === void 0) {
              prevValue = metric.value;
              metric.delta = delta;
              callback(metric);
            }
          }
        }
      };
    };
    exports.bindReporter = bindReporter;
  }
});

// ../../../node_modules/.pnpm/@sentry-internal+tracing@7.120.2/node_modules/@sentry-internal/tracing/cjs/browser/web-vitals/lib/generateUniqueID.js
var require_generateUniqueID = __commonJS({
  "../../../node_modules/.pnpm/@sentry-internal+tracing@7.120.2/node_modules/@sentry-internal/tracing/cjs/browser/web-vitals/lib/generateUniqueID.js"(exports) {
    init_define_ENV_DEFINED_IN_BUILD_STEP();
    Object.defineProperty(exports, "__esModule", { value: true });
    var generateUniqueID = () => {
      return `v3-${Date.now()}-${Math.floor(Math.random() * (9e12 - 1)) + 1e12}`;
    };
    exports.generateUniqueID = generateUniqueID;
  }
});

// ../../../node_modules/.pnpm/@sentry-internal+tracing@7.120.2/node_modules/@sentry-internal/tracing/cjs/browser/web-vitals/lib/getNavigationEntry.js
var require_getNavigationEntry = __commonJS({
  "../../../node_modules/.pnpm/@sentry-internal+tracing@7.120.2/node_modules/@sentry-internal/tracing/cjs/browser/web-vitals/lib/getNavigationEntry.js"(exports) {
    init_define_ENV_DEFINED_IN_BUILD_STEP();
    Object.defineProperty(exports, "__esModule", { value: true });
    var types = require_types();
    var getNavigationEntryFromPerformanceTiming = () => {
      const timing = types.WINDOW.performance.timing;
      const type = types.WINDOW.performance.navigation.type;
      const navigationEntry = {
        entryType: "navigation",
        startTime: 0,
        type: type == 2 ? "back_forward" : type === 1 ? "reload" : "navigate"
      };
      for (const key in timing) {
        if (key !== "navigationStart" && key !== "toJSON") {
          navigationEntry[key] = Math.max(timing[key] - timing.navigationStart, 0);
        }
      }
      return navigationEntry;
    };
    var getNavigationEntry = () => {
      if (types.WINDOW.__WEB_VITALS_POLYFILL__) {
        return types.WINDOW.performance && (performance.getEntriesByType && performance.getEntriesByType("navigation")[0] || getNavigationEntryFromPerformanceTiming());
      } else {
        return types.WINDOW.performance && performance.getEntriesByType && performance.getEntriesByType("navigation")[0];
      }
    };
    exports.getNavigationEntry = getNavigationEntry;
  }
});

// ../../../node_modules/.pnpm/@sentry-internal+tracing@7.120.2/node_modules/@sentry-internal/tracing/cjs/browser/web-vitals/lib/getActivationStart.js
var require_getActivationStart = __commonJS({
  "../../../node_modules/.pnpm/@sentry-internal+tracing@7.120.2/node_modules/@sentry-internal/tracing/cjs/browser/web-vitals/lib/getActivationStart.js"(exports) {
    init_define_ENV_DEFINED_IN_BUILD_STEP();
    Object.defineProperty(exports, "__esModule", { value: true });
    var getNavigationEntry = require_getNavigationEntry();
    var getActivationStart = () => {
      const navEntry = getNavigationEntry.getNavigationEntry();
      return navEntry && navEntry.activationStart || 0;
    };
    exports.getActivationStart = getActivationStart;
  }
});

// ../../../node_modules/.pnpm/@sentry-internal+tracing@7.120.2/node_modules/@sentry-internal/tracing/cjs/browser/web-vitals/lib/initMetric.js
var require_initMetric = __commonJS({
  "../../../node_modules/.pnpm/@sentry-internal+tracing@7.120.2/node_modules/@sentry-internal/tracing/cjs/browser/web-vitals/lib/initMetric.js"(exports) {
    init_define_ENV_DEFINED_IN_BUILD_STEP();
    Object.defineProperty(exports, "__esModule", { value: true });
    var types = require_types();
    var generateUniqueID = require_generateUniqueID();
    var getActivationStart = require_getActivationStart();
    var getNavigationEntry = require_getNavigationEntry();
    var initMetric = (name, value) => {
      const navEntry = getNavigationEntry.getNavigationEntry();
      let navigationType = "navigate";
      if (navEntry) {
        if (types.WINDOW.document && types.WINDOW.document.prerendering || getActivationStart.getActivationStart() > 0) {
          navigationType = "prerender";
        } else {
          navigationType = navEntry.type.replace(/_/g, "-");
        }
      }
      return {
        name,
        value: typeof value === "undefined" ? -1 : value,
        rating: "good",
        // Will be updated if the value changes.
        delta: 0,
        entries: [],
        id: generateUniqueID.generateUniqueID(),
        navigationType
      };
    };
    exports.initMetric = initMetric;
  }
});

// ../../../node_modules/.pnpm/@sentry-internal+tracing@7.120.2/node_modules/@sentry-internal/tracing/cjs/browser/web-vitals/lib/observe.js
var require_observe = __commonJS({
  "../../../node_modules/.pnpm/@sentry-internal+tracing@7.120.2/node_modules/@sentry-internal/tracing/cjs/browser/web-vitals/lib/observe.js"(exports) {
    init_define_ENV_DEFINED_IN_BUILD_STEP();
    Object.defineProperty(exports, "__esModule", { value: true });
    var observe = (type, callback, opts) => {
      try {
        if (PerformanceObserver.supportedEntryTypes.includes(type)) {
          const po = new PerformanceObserver((list) => {
            callback(list.getEntries());
          });
          po.observe(
            Object.assign(
              {
                type,
                buffered: true
              },
              opts || {}
            )
          );
          return po;
        }
      } catch (e2) {
      }
      return;
    };
    exports.observe = observe;
  }
});

// ../../../node_modules/.pnpm/@sentry-internal+tracing@7.120.2/node_modules/@sentry-internal/tracing/cjs/browser/web-vitals/lib/onHidden.js
var require_onHidden = __commonJS({
  "../../../node_modules/.pnpm/@sentry-internal+tracing@7.120.2/node_modules/@sentry-internal/tracing/cjs/browser/web-vitals/lib/onHidden.js"(exports) {
    init_define_ENV_DEFINED_IN_BUILD_STEP();
    Object.defineProperty(exports, "__esModule", { value: true });
    var types = require_types();
    var onHidden = (cb, once) => {
      const onHiddenOrPageHide = (event) => {
        if (event.type === "pagehide" || types.WINDOW.document.visibilityState === "hidden") {
          cb(event);
          if (once) {
            removeEventListener("visibilitychange", onHiddenOrPageHide, true);
            removeEventListener("pagehide", onHiddenOrPageHide, true);
          }
        }
      };
      if (types.WINDOW.document) {
        addEventListener("visibilitychange", onHiddenOrPageHide, true);
        addEventListener("pagehide", onHiddenOrPageHide, true);
      }
    };
    exports.onHidden = onHidden;
  }
});

// ../../../node_modules/.pnpm/@sentry-internal+tracing@7.120.2/node_modules/@sentry-internal/tracing/cjs/browser/web-vitals/getCLS.js
var require_getCLS = __commonJS({
  "../../../node_modules/.pnpm/@sentry-internal+tracing@7.120.2/node_modules/@sentry-internal/tracing/cjs/browser/web-vitals/getCLS.js"(exports) {
    init_define_ENV_DEFINED_IN_BUILD_STEP();
    Object.defineProperty(exports, "__esModule", { value: true });
    var bindReporter = require_bindReporter();
    var initMetric = require_initMetric();
    var observe = require_observe();
    var onHidden = require_onHidden();
    var onCLS = (onReport, options = {}) => {
      const metric = initMetric.initMetric("CLS", 0);
      let report;
      let sessionValue = 0;
      let sessionEntries = [];
      const handleEntries = (entries) => {
        entries.forEach((entry) => {
          if (!entry.hadRecentInput) {
            const firstSessionEntry = sessionEntries[0];
            const lastSessionEntry = sessionEntries[sessionEntries.length - 1];
            if (sessionValue && sessionEntries.length !== 0 && entry.startTime - lastSessionEntry.startTime < 1e3 && entry.startTime - firstSessionEntry.startTime < 5e3) {
              sessionValue += entry.value;
              sessionEntries.push(entry);
            } else {
              sessionValue = entry.value;
              sessionEntries = [entry];
            }
            if (sessionValue > metric.value) {
              metric.value = sessionValue;
              metric.entries = sessionEntries;
              if (report) {
                report();
              }
            }
          }
        });
      };
      const po = observe.observe("layout-shift", handleEntries);
      if (po) {
        report = bindReporter.bindReporter(onReport, metric, options.reportAllChanges);
        const stopListening = () => {
          handleEntries(po.takeRecords());
          report(true);
        };
        onHidden.onHidden(stopListening);
        return stopListening;
      }
      return;
    };
    exports.onCLS = onCLS;
  }
});

// ../../../node_modules/.pnpm/@sentry-internal+tracing@7.120.2/node_modules/@sentry-internal/tracing/cjs/browser/web-vitals/lib/getVisibilityWatcher.js
var require_getVisibilityWatcher = __commonJS({
  "../../../node_modules/.pnpm/@sentry-internal+tracing@7.120.2/node_modules/@sentry-internal/tracing/cjs/browser/web-vitals/lib/getVisibilityWatcher.js"(exports) {
    init_define_ENV_DEFINED_IN_BUILD_STEP();
    Object.defineProperty(exports, "__esModule", { value: true });
    var types = require_types();
    var onHidden = require_onHidden();
    var firstHiddenTime = -1;
    var initHiddenTime = () => {
      if (types.WINDOW.document && types.WINDOW.document.visibilityState) {
        firstHiddenTime = types.WINDOW.document.visibilityState === "hidden" && !types.WINDOW.document.prerendering ? 0 : Infinity;
      }
    };
    var trackChanges = () => {
      onHidden.onHidden(({ timeStamp }) => {
        firstHiddenTime = timeStamp;
      }, true);
    };
    var getVisibilityWatcher = () => {
      if (firstHiddenTime < 0) {
        initHiddenTime();
        trackChanges();
      }
      return {
        get firstHiddenTime() {
          return firstHiddenTime;
        }
      };
    };
    exports.getVisibilityWatcher = getVisibilityWatcher;
  }
});

// ../../../node_modules/.pnpm/@sentry-internal+tracing@7.120.2/node_modules/@sentry-internal/tracing/cjs/browser/web-vitals/getFID.js
var require_getFID = __commonJS({
  "../../../node_modules/.pnpm/@sentry-internal+tracing@7.120.2/node_modules/@sentry-internal/tracing/cjs/browser/web-vitals/getFID.js"(exports) {
    init_define_ENV_DEFINED_IN_BUILD_STEP();
    Object.defineProperty(exports, "__esModule", { value: true });
    var bindReporter = require_bindReporter();
    var getVisibilityWatcher = require_getVisibilityWatcher();
    var initMetric = require_initMetric();
    var observe = require_observe();
    var onHidden = require_onHidden();
    var onFID = (onReport) => {
      const visibilityWatcher = getVisibilityWatcher.getVisibilityWatcher();
      const metric = initMetric.initMetric("FID");
      let report;
      const handleEntry = (entry) => {
        if (entry.startTime < visibilityWatcher.firstHiddenTime) {
          metric.value = entry.processingStart - entry.startTime;
          metric.entries.push(entry);
          report(true);
        }
      };
      const handleEntries = (entries) => {
        entries.forEach(handleEntry);
      };
      const po = observe.observe("first-input", handleEntries);
      report = bindReporter.bindReporter(onReport, metric);
      if (po) {
        onHidden.onHidden(() => {
          handleEntries(po.takeRecords());
          po.disconnect();
        }, true);
      }
    };
    exports.onFID = onFID;
  }
});

// ../../../node_modules/.pnpm/@sentry-internal+tracing@7.120.2/node_modules/@sentry-internal/tracing/cjs/browser/web-vitals/lib/polyfills/interactionCountPolyfill.js
var require_interactionCountPolyfill = __commonJS({
  "../../../node_modules/.pnpm/@sentry-internal+tracing@7.120.2/node_modules/@sentry-internal/tracing/cjs/browser/web-vitals/lib/polyfills/interactionCountPolyfill.js"(exports) {
    init_define_ENV_DEFINED_IN_BUILD_STEP();
    Object.defineProperty(exports, "__esModule", { value: true });
    var observe = require_observe();
    var interactionCountEstimate = 0;
    var minKnownInteractionId = Infinity;
    var maxKnownInteractionId = 0;
    var updateEstimate = (entries) => {
      entries.forEach((e2) => {
        if (e2.interactionId) {
          minKnownInteractionId = Math.min(minKnownInteractionId, e2.interactionId);
          maxKnownInteractionId = Math.max(maxKnownInteractionId, e2.interactionId);
          interactionCountEstimate = maxKnownInteractionId ? (maxKnownInteractionId - minKnownInteractionId) / 7 + 1 : 0;
        }
      });
    };
    var po;
    var getInteractionCount = () => {
      return po ? interactionCountEstimate : performance.interactionCount || 0;
    };
    var initInteractionCountPolyfill = () => {
      if ("interactionCount" in performance || po)
        return;
      po = observe.observe("event", updateEstimate, {
        type: "event",
        buffered: true,
        durationThreshold: 0
      });
    };
    exports.getInteractionCount = getInteractionCount;
    exports.initInteractionCountPolyfill = initInteractionCountPolyfill;
  }
});

// ../../../node_modules/.pnpm/@sentry-internal+tracing@7.120.2/node_modules/@sentry-internal/tracing/cjs/browser/web-vitals/getINP.js
var require_getINP = __commonJS({
  "../../../node_modules/.pnpm/@sentry-internal+tracing@7.120.2/node_modules/@sentry-internal/tracing/cjs/browser/web-vitals/getINP.js"(exports) {
    init_define_ENV_DEFINED_IN_BUILD_STEP();
    Object.defineProperty(exports, "__esModule", { value: true });
    var bindReporter = require_bindReporter();
    var initMetric = require_initMetric();
    var observe = require_observe();
    var onHidden = require_onHidden();
    var interactionCountPolyfill = require_interactionCountPolyfill();
    var getInteractionCountForNavigation = () => {
      return interactionCountPolyfill.getInteractionCount();
    };
    var MAX_INTERACTIONS_TO_CONSIDER = 10;
    var longestInteractionList = [];
    var longestInteractionMap = {};
    var processEntry = (entry) => {
      const minLongestInteraction = longestInteractionList[longestInteractionList.length - 1];
      const existingInteraction = longestInteractionMap[entry.interactionId];
      if (existingInteraction || longestInteractionList.length < MAX_INTERACTIONS_TO_CONSIDER || entry.duration > minLongestInteraction.latency) {
        if (existingInteraction) {
          existingInteraction.entries.push(entry);
          existingInteraction.latency = Math.max(existingInteraction.latency, entry.duration);
        } else {
          const interaction = {
            // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
            id: entry.interactionId,
            latency: entry.duration,
            entries: [entry]
          };
          longestInteractionMap[interaction.id] = interaction;
          longestInteractionList.push(interaction);
        }
        longestInteractionList.sort((a3, b) => b.latency - a3.latency);
        longestInteractionList.splice(MAX_INTERACTIONS_TO_CONSIDER).forEach((i2) => {
          delete longestInteractionMap[i2.id];
        });
      }
    };
    var estimateP98LongestInteraction = () => {
      const candidateInteractionIndex = Math.min(
        longestInteractionList.length - 1,
        Math.floor(getInteractionCountForNavigation() / 50)
      );
      return longestInteractionList[candidateInteractionIndex];
    };
    var onINP = (onReport, opts) => {
      opts = opts || {};
      interactionCountPolyfill.initInteractionCountPolyfill();
      const metric = initMetric.initMetric("INP");
      let report;
      const handleEntries = (entries) => {
        entries.forEach((entry) => {
          if (entry.interactionId) {
            processEntry(entry);
          }
          if (entry.entryType === "first-input") {
            const noMatchingEntry = !longestInteractionList.some((interaction) => {
              return interaction.entries.some((prevEntry) => {
                return entry.duration === prevEntry.duration && entry.startTime === prevEntry.startTime;
              });
            });
            if (noMatchingEntry) {
              processEntry(entry);
            }
          }
        });
        const inp = estimateP98LongestInteraction();
        if (inp && inp.latency !== metric.value) {
          metric.value = inp.latency;
          metric.entries = inp.entries;
          report();
        }
      };
      const po = observe.observe("event", handleEntries, {
        // Event Timing entries have their durations rounded to the nearest 8ms,
        // so a duration of 40ms would be any event that spans 2.5 or more frames
        // at 60Hz. This threshold is chosen to strike a balance between usefulness
        // and performance. Running this callback for any interaction that spans
        // just one or two frames is likely not worth the insight that could be
        // gained.
        durationThreshold: opts.durationThreshold || 40
      });
      report = bindReporter.bindReporter(onReport, metric, opts.reportAllChanges);
      if (po) {
        po.observe({ type: "first-input", buffered: true });
        onHidden.onHidden(() => {
          handleEntries(po.takeRecords());
          if (metric.value < 0 && getInteractionCountForNavigation() > 0) {
            metric.value = 0;
            metric.entries = [];
          }
          report(true);
        });
      }
    };
    exports.onINP = onINP;
  }
});

// ../../../node_modules/.pnpm/@sentry-internal+tracing@7.120.2/node_modules/@sentry-internal/tracing/cjs/browser/web-vitals/getLCP.js
var require_getLCP = __commonJS({
  "../../../node_modules/.pnpm/@sentry-internal+tracing@7.120.2/node_modules/@sentry-internal/tracing/cjs/browser/web-vitals/getLCP.js"(exports) {
    init_define_ENV_DEFINED_IN_BUILD_STEP();
    Object.defineProperty(exports, "__esModule", { value: true });
    var types = require_types();
    var bindReporter = require_bindReporter();
    var getActivationStart = require_getActivationStart();
    var getVisibilityWatcher = require_getVisibilityWatcher();
    var initMetric = require_initMetric();
    var observe = require_observe();
    var onHidden = require_onHidden();
    var reportedMetricIDs = {};
    var onLCP = (onReport) => {
      const visibilityWatcher = getVisibilityWatcher.getVisibilityWatcher();
      const metric = initMetric.initMetric("LCP");
      let report;
      const handleEntries = (entries) => {
        const lastEntry = entries[entries.length - 1];
        if (lastEntry) {
          const value = Math.max(lastEntry.startTime - getActivationStart.getActivationStart(), 0);
          if (value < visibilityWatcher.firstHiddenTime) {
            metric.value = value;
            metric.entries = [lastEntry];
            report();
          }
        }
      };
      const po = observe.observe("largest-contentful-paint", handleEntries);
      if (po) {
        report = bindReporter.bindReporter(onReport, metric);
        const stopListening = () => {
          if (!reportedMetricIDs[metric.id]) {
            handleEntries(po.takeRecords());
            po.disconnect();
            reportedMetricIDs[metric.id] = true;
            report(true);
          }
        };
        ["keydown", "click"].forEach((type) => {
          if (types.WINDOW.document) {
            addEventListener(type, stopListening, { once: true, capture: true });
          }
        });
        onHidden.onHidden(stopListening, true);
        return stopListening;
      }
      return;
    };
    exports.onLCP = onLCP;
  }
});

// ../../../node_modules/.pnpm/@sentry-internal+tracing@7.120.2/node_modules/@sentry-internal/tracing/cjs/browser/web-vitals/onTTFB.js
var require_onTTFB = __commonJS({
  "../../../node_modules/.pnpm/@sentry-internal+tracing@7.120.2/node_modules/@sentry-internal/tracing/cjs/browser/web-vitals/onTTFB.js"(exports) {
    init_define_ENV_DEFINED_IN_BUILD_STEP();
    Object.defineProperty(exports, "__esModule", { value: true });
    var types = require_types();
    var bindReporter = require_bindReporter();
    var getActivationStart = require_getActivationStart();
    var getNavigationEntry = require_getNavigationEntry();
    var initMetric = require_initMetric();
    var whenReady = (callback) => {
      if (!types.WINDOW.document) {
        return;
      }
      if (types.WINDOW.document.prerendering) {
        addEventListener("prerenderingchange", () => whenReady(callback), true);
      } else if (types.WINDOW.document.readyState !== "complete") {
        addEventListener("load", () => whenReady(callback), true);
      } else {
        setTimeout(callback, 0);
      }
    };
    var onTTFB = (onReport, opts) => {
      opts = opts || {};
      const metric = initMetric.initMetric("TTFB");
      const report = bindReporter.bindReporter(onReport, metric, opts.reportAllChanges);
      whenReady(() => {
        const navEntry = getNavigationEntry.getNavigationEntry();
        if (navEntry) {
          metric.value = Math.max(navEntry.responseStart - getActivationStart.getActivationStart(), 0);
          if (metric.value < 0 || metric.value > performance.now())
            return;
          metric.entries = [navEntry];
          report(true);
        }
      });
    };
    exports.onTTFB = onTTFB;
  }
});

// ../../../node_modules/.pnpm/@sentry-internal+tracing@7.120.2/node_modules/@sentry-internal/tracing/cjs/browser/instrument.js
var require_instrument2 = __commonJS({
  "../../../node_modules/.pnpm/@sentry-internal+tracing@7.120.2/node_modules/@sentry-internal/tracing/cjs/browser/instrument.js"(exports) {
    init_define_ENV_DEFINED_IN_BUILD_STEP();
    Object.defineProperty(exports, "__esModule", { value: true });
    var utils = require_cjs();
    var debugBuild = require_debug_build3();
    var getCLS = require_getCLS();
    var getFID = require_getFID();
    var getINP = require_getINP();
    var getLCP = require_getLCP();
    var observe = require_observe();
    var onTTFB = require_onTTFB();
    var handlers = {};
    var instrumented = {};
    var _previousCls;
    var _previousFid;
    var _previousLcp;
    var _previousTtfb;
    var _previousInp;
    function addClsInstrumentationHandler(callback, stopOnCallback = false) {
      return addMetricObserver("cls", callback, instrumentCls, _previousCls, stopOnCallback);
    }
    function addLcpInstrumentationHandler(callback, stopOnCallback = false) {
      return addMetricObserver("lcp", callback, instrumentLcp, _previousLcp, stopOnCallback);
    }
    function addTtfbInstrumentationHandler(callback) {
      return addMetricObserver("ttfb", callback, instrumentTtfb, _previousTtfb);
    }
    function addFidInstrumentationHandler(callback) {
      return addMetricObserver("fid", callback, instrumentFid, _previousFid);
    }
    function addInpInstrumentationHandler(callback) {
      return addMetricObserver("inp", callback, instrumentInp, _previousInp);
    }
    function addPerformanceInstrumentationHandler(type, callback) {
      addHandler(type, callback);
      if (!instrumented[type]) {
        instrumentPerformanceObserver(type);
        instrumented[type] = true;
      }
      return getCleanupCallback(type, callback);
    }
    function triggerHandlers(type, data) {
      const typeHandlers = handlers[type];
      if (!typeHandlers || !typeHandlers.length) {
        return;
      }
      for (const handler of typeHandlers) {
        try {
          handler(data);
        } catch (e2) {
          debugBuild.DEBUG_BUILD && utils.logger.error(
            `Error while triggering instrumentation handler.
Type: ${type}
Name: ${utils.getFunctionName(handler)}
Error:`,
            e2
          );
        }
      }
    }
    function instrumentCls() {
      return getCLS.onCLS(
        (metric) => {
          triggerHandlers("cls", {
            metric
          });
          _previousCls = metric;
        },
        { reportAllChanges: true }
      );
    }
    function instrumentFid() {
      return getFID.onFID((metric) => {
        triggerHandlers("fid", {
          metric
        });
        _previousFid = metric;
      });
    }
    function instrumentLcp() {
      return getLCP.onLCP((metric) => {
        triggerHandlers("lcp", {
          metric
        });
        _previousLcp = metric;
      });
    }
    function instrumentTtfb() {
      return onTTFB.onTTFB((metric) => {
        triggerHandlers("ttfb", {
          metric
        });
        _previousTtfb = metric;
      });
    }
    function instrumentInp() {
      return getINP.onINP((metric) => {
        triggerHandlers("inp", {
          metric
        });
        _previousInp = metric;
      });
    }
    function addMetricObserver(type, callback, instrumentFn, previousValue, stopOnCallback = false) {
      addHandler(type, callback);
      let stopListening;
      if (!instrumented[type]) {
        stopListening = instrumentFn();
        instrumented[type] = true;
      }
      if (previousValue) {
        callback({ metric: previousValue });
      }
      return getCleanupCallback(type, callback, stopOnCallback ? stopListening : void 0);
    }
    function instrumentPerformanceObserver(type) {
      const options = {};
      if (type === "event") {
        options.durationThreshold = 0;
      }
      observe.observe(
        type,
        (entries) => {
          triggerHandlers(type, { entries });
        },
        options
      );
    }
    function addHandler(type, handler) {
      handlers[type] = handlers[type] || [];
      handlers[type].push(handler);
    }
    function getCleanupCallback(type, callback, stopListening) {
      return () => {
        if (stopListening) {
          stopListening();
        }
        const typeHandlers = handlers[type];
        if (!typeHandlers) {
          return;
        }
        const index = typeHandlers.indexOf(callback);
        if (index !== -1) {
          typeHandlers.splice(index, 1);
        }
      };
    }
    exports.addClsInstrumentationHandler = addClsInstrumentationHandler;
    exports.addFidInstrumentationHandler = addFidInstrumentationHandler;
    exports.addInpInstrumentationHandler = addInpInstrumentationHandler;
    exports.addLcpInstrumentationHandler = addLcpInstrumentationHandler;
    exports.addPerformanceInstrumentationHandler = addPerformanceInstrumentationHandler;
    exports.addTtfbInstrumentationHandler = addTtfbInstrumentationHandler;
  }
});

// ../../../node_modules/.pnpm/@sentry-internal+tracing@7.120.2/node_modules/@sentry-internal/tracing/cjs/browser/metrics/utils.js
var require_utils3 = __commonJS({
  "../../../node_modules/.pnpm/@sentry-internal+tracing@7.120.2/node_modules/@sentry-internal/tracing/cjs/browser/metrics/utils.js"(exports) {
    init_define_ENV_DEFINED_IN_BUILD_STEP();
    Object.defineProperty(exports, "__esModule", { value: true });
    function isMeasurementValue(value) {
      return typeof value === "number" && isFinite(value);
    }
    function _startChild(transaction, { startTimestamp, ...ctx }) {
      if (startTimestamp && transaction.startTimestamp > startTimestamp) {
        transaction.startTimestamp = startTimestamp;
      }
      return transaction.startChild({
        startTimestamp,
        ...ctx
      });
    }
    exports._startChild = _startChild;
    exports.isMeasurementValue = isMeasurementValue;
  }
});

// ../../../node_modules/.pnpm/@sentry-internal+tracing@7.120.2/node_modules/@sentry-internal/tracing/cjs/browser/metrics/index.js
var require_metrics = __commonJS({
  "../../../node_modules/.pnpm/@sentry-internal+tracing@7.120.2/node_modules/@sentry-internal/tracing/cjs/browser/metrics/index.js"(exports) {
    init_define_ENV_DEFINED_IN_BUILD_STEP();
    Object.defineProperty(exports, "__esModule", { value: true });
    var core = require_cjs2();
    var utils = require_cjs();
    var debugBuild = require_debug_build3();
    var instrument = require_instrument2();
    var types = require_types();
    var getVisibilityWatcher = require_getVisibilityWatcher();
    var utils$1 = require_utils3();
    var getNavigationEntry = require_getNavigationEntry();
    var MAX_INT_AS_BYTES = 2147483647;
    function msToSec(time) {
      return time / 1e3;
    }
    function getBrowserPerformanceAPI() {
      return types.WINDOW && types.WINDOW.addEventListener && types.WINDOW.performance;
    }
    var _performanceCursor = 0;
    var _measurements = {};
    var _lcpEntry;
    var _clsEntry;
    function startTrackingWebVitals() {
      const performance2 = getBrowserPerformanceAPI();
      if (performance2 && utils.browserPerformanceTimeOrigin) {
        if (performance2.mark) {
          types.WINDOW.performance.mark("sentry-tracing-init");
        }
        const fidCallback = _trackFID();
        const clsCallback = _trackCLS();
        const lcpCallback = _trackLCP();
        const ttfbCallback = _trackTtfb();
        return () => {
          fidCallback();
          clsCallback();
          lcpCallback();
          ttfbCallback();
        };
      }
      return () => void 0;
    }
    function startTrackingLongTasks() {
      instrument.addPerformanceInstrumentationHandler("longtask", ({ entries }) => {
        for (const entry of entries) {
          const transaction = core.getActiveTransaction();
          if (!transaction) {
            return;
          }
          const startTime = msToSec(utils.browserPerformanceTimeOrigin + entry.startTime);
          const duration = msToSec(entry.duration);
          transaction.startChild({
            description: "Main UI thread blocked",
            op: "ui.long-task",
            origin: "auto.ui.browser.metrics",
            startTimestamp: startTime,
            endTimestamp: startTime + duration
          });
        }
      });
    }
    function startTrackingInteractions() {
      instrument.addPerformanceInstrumentationHandler("event", ({ entries }) => {
        for (const entry of entries) {
          const transaction = core.getActiveTransaction();
          if (!transaction) {
            return;
          }
          if (entry.name === "click") {
            const startTime = msToSec(utils.browserPerformanceTimeOrigin + entry.startTime);
            const duration = msToSec(entry.duration);
            const span = {
              description: utils.htmlTreeAsString(entry.target),
              op: `ui.interaction.${entry.name}`,
              origin: "auto.ui.browser.metrics",
              startTimestamp: startTime,
              endTimestamp: startTime + duration
            };
            const componentName = utils.getComponentName(entry.target);
            if (componentName) {
              span.attributes = { "ui.component_name": componentName };
            }
            transaction.startChild(span);
          }
        }
      });
    }
    function startTrackingINP(interactionIdtoRouteNameMapping, interactionsSampleRate) {
      const performance2 = getBrowserPerformanceAPI();
      if (performance2 && utils.browserPerformanceTimeOrigin) {
        const inpCallback = _trackINP(interactionIdtoRouteNameMapping, interactionsSampleRate);
        return () => {
          inpCallback();
        };
      }
      return () => void 0;
    }
    function _trackCLS() {
      return instrument.addClsInstrumentationHandler(({ metric }) => {
        const entry = metric.entries[metric.entries.length - 1];
        if (!entry) {
          return;
        }
        debugBuild.DEBUG_BUILD && utils.logger.log("[Measurements] Adding CLS");
        _measurements["cls"] = { value: metric.value, unit: "" };
        _clsEntry = entry;
      }, true);
    }
    function _trackLCP() {
      return instrument.addLcpInstrumentationHandler(({ metric }) => {
        const entry = metric.entries[metric.entries.length - 1];
        if (!entry) {
          return;
        }
        debugBuild.DEBUG_BUILD && utils.logger.log("[Measurements] Adding LCP");
        _measurements["lcp"] = { value: metric.value, unit: "millisecond" };
        _lcpEntry = entry;
      }, true);
    }
    function _trackFID() {
      return instrument.addFidInstrumentationHandler(({ metric }) => {
        const entry = metric.entries[metric.entries.length - 1];
        if (!entry) {
          return;
        }
        const timeOrigin = msToSec(utils.browserPerformanceTimeOrigin);
        const startTime = msToSec(entry.startTime);
        debugBuild.DEBUG_BUILD && utils.logger.log("[Measurements] Adding FID");
        _measurements["fid"] = { value: metric.value, unit: "millisecond" };
        _measurements["mark.fid"] = { value: timeOrigin + startTime, unit: "second" };
      });
    }
    function _trackTtfb() {
      return instrument.addTtfbInstrumentationHandler(({ metric }) => {
        const entry = metric.entries[metric.entries.length - 1];
        if (!entry) {
          return;
        }
        debugBuild.DEBUG_BUILD && utils.logger.log("[Measurements] Adding TTFB");
        _measurements["ttfb"] = { value: metric.value, unit: "millisecond" };
      });
    }
    var INP_ENTRY_MAP = {
      click: "click",
      pointerdown: "click",
      pointerup: "click",
      mousedown: "click",
      mouseup: "click",
      touchstart: "click",
      touchend: "click",
      mouseover: "hover",
      mouseout: "hover",
      mouseenter: "hover",
      mouseleave: "hover",
      pointerover: "hover",
      pointerout: "hover",
      pointerenter: "hover",
      pointerleave: "hover",
      dragstart: "drag",
      dragend: "drag",
      drag: "drag",
      dragenter: "drag",
      dragleave: "drag",
      dragover: "drag",
      drop: "drag",
      keydown: "press",
      keyup: "press",
      keypress: "press",
      input: "press"
    };
    function _trackINP(interactionIdToRouteNameMapping, interactionsSampleRate) {
      return instrument.addInpInstrumentationHandler(({ metric }) => {
        if (metric.value === void 0) {
          return;
        }
        const entry = metric.entries.find(
          (entry2) => entry2.duration === metric.value && INP_ENTRY_MAP[entry2.name] !== void 0
        );
        const client = core.getClient();
        if (!entry || !client) {
          return;
        }
        const interactionType = INP_ENTRY_MAP[entry.name];
        const options = client.getOptions();
        const startTime = msToSec(utils.browserPerformanceTimeOrigin + entry.startTime);
        const duration = msToSec(metric.value);
        const interaction = entry.interactionId !== void 0 ? interactionIdToRouteNameMapping[entry.interactionId] : void 0;
        if (interaction === void 0) {
          return;
        }
        const { routeName, parentContext, activeTransaction, user, replayId } = interaction;
        const userDisplay = user !== void 0 ? user.email || user.id || user.ip_address : void 0;
        const profileId = activeTransaction !== void 0 ? activeTransaction.getProfileId() : void 0;
        const span = new core.Span({
          startTimestamp: startTime,
          endTimestamp: startTime + duration,
          op: `ui.interaction.${interactionType}`,
          name: utils.htmlTreeAsString(entry.target),
          attributes: {
            release: options.release,
            environment: options.environment,
            transaction: routeName,
            ...userDisplay !== void 0 && userDisplay !== "" ? { user: userDisplay } : {},
            ...profileId !== void 0 ? { profile_id: profileId } : {},
            ...replayId !== void 0 ? { replay_id: replayId } : {}
          },
          exclusiveTime: metric.value,
          measurements: {
            inp: { value: metric.value, unit: "millisecond" }
          }
        });
        const sampleRate = getSampleRate(parentContext, options, interactionsSampleRate);
        if (!sampleRate) {
          return;
        }
        if (Math.random() < sampleRate) {
          const envelope = span ? core.createSpanEnvelope([span], client.getDsn()) : void 0;
          const transport = client && client.getTransport();
          if (transport && envelope) {
            transport.send(envelope).then(null, (reason) => {
              debugBuild.DEBUG_BUILD && utils.logger.error("Error while sending interaction:", reason);
            });
          }
          return;
        }
      });
    }
    function addPerformanceEntries(transaction) {
      const performance2 = getBrowserPerformanceAPI();
      if (!performance2 || !types.WINDOW.performance.getEntries || !utils.browserPerformanceTimeOrigin) {
        return;
      }
      debugBuild.DEBUG_BUILD && utils.logger.log("[Tracing] Adding & adjusting spans using Performance API");
      const timeOrigin = msToSec(utils.browserPerformanceTimeOrigin);
      const performanceEntries = performance2.getEntries();
      const { op, start_timestamp: transactionStartTime } = core.spanToJSON(transaction);
      performanceEntries.slice(_performanceCursor).forEach((entry) => {
        const startTime = msToSec(entry.startTime);
        const duration = msToSec(entry.duration);
        if (transaction.op === "navigation" && transactionStartTime && timeOrigin + startTime < transactionStartTime) {
          return;
        }
        switch (entry.entryType) {
          case "navigation": {
            _addNavigationSpans(transaction, entry, timeOrigin);
            break;
          }
          case "mark":
          case "paint":
          case "measure": {
            _addMeasureSpans(transaction, entry, startTime, duration, timeOrigin);
            const firstHidden = getVisibilityWatcher.getVisibilityWatcher();
            const shouldRecord = entry.startTime < firstHidden.firstHiddenTime;
            if (entry.name === "first-paint" && shouldRecord) {
              debugBuild.DEBUG_BUILD && utils.logger.log("[Measurements] Adding FP");
              _measurements["fp"] = { value: entry.startTime, unit: "millisecond" };
            }
            if (entry.name === "first-contentful-paint" && shouldRecord) {
              debugBuild.DEBUG_BUILD && utils.logger.log("[Measurements] Adding FCP");
              _measurements["fcp"] = { value: entry.startTime, unit: "millisecond" };
            }
            break;
          }
          case "resource": {
            _addResourceSpans(transaction, entry, entry.name, startTime, duration, timeOrigin);
            break;
          }
        }
      });
      _performanceCursor = Math.max(performanceEntries.length - 1, 0);
      _trackNavigator(transaction);
      if (op === "pageload") {
        _addTtfbRequestTimeToMeasurements(_measurements);
        ["fcp", "fp", "lcp"].forEach((name) => {
          if (!_measurements[name] || !transactionStartTime || timeOrigin >= transactionStartTime) {
            return;
          }
          const oldValue = _measurements[name].value;
          const measurementTimestamp = timeOrigin + msToSec(oldValue);
          const normalizedValue = Math.abs((measurementTimestamp - transactionStartTime) * 1e3);
          const delta = normalizedValue - oldValue;
          debugBuild.DEBUG_BUILD && utils.logger.log(`[Measurements] Normalized ${name} from ${oldValue} to ${normalizedValue} (${delta})`);
          _measurements[name].value = normalizedValue;
        });
        const fidMark = _measurements["mark.fid"];
        if (fidMark && _measurements["fid"]) {
          utils$1._startChild(transaction, {
            description: "first input delay",
            endTimestamp: fidMark.value + msToSec(_measurements["fid"].value),
            op: "ui.action",
            origin: "auto.ui.browser.metrics",
            startTimestamp: fidMark.value
          });
          delete _measurements["mark.fid"];
        }
        if (!("fcp" in _measurements)) {
          delete _measurements.cls;
        }
        Object.keys(_measurements).forEach((measurementName) => {
          core.setMeasurement(measurementName, _measurements[measurementName].value, _measurements[measurementName].unit);
        });
        _tagMetricInfo(transaction);
      }
      _lcpEntry = void 0;
      _clsEntry = void 0;
      _measurements = {};
    }
    function _addMeasureSpans(transaction, entry, startTime, duration, timeOrigin) {
      const measureStartTimestamp = timeOrigin + startTime;
      const measureEndTimestamp = measureStartTimestamp + duration;
      utils$1._startChild(transaction, {
        description: entry.name,
        endTimestamp: measureEndTimestamp,
        op: entry.entryType,
        origin: "auto.resource.browser.metrics",
        startTimestamp: measureStartTimestamp
      });
      return measureStartTimestamp;
    }
    function _addNavigationSpans(transaction, entry, timeOrigin) {
      ["unloadEvent", "redirect", "domContentLoadedEvent", "loadEvent", "connect"].forEach((event) => {
        _addPerformanceNavigationTiming(transaction, entry, event, timeOrigin);
      });
      _addPerformanceNavigationTiming(transaction, entry, "secureConnection", timeOrigin, "TLS/SSL", "connectEnd");
      _addPerformanceNavigationTiming(transaction, entry, "fetch", timeOrigin, "cache", "domainLookupStart");
      _addPerformanceNavigationTiming(transaction, entry, "domainLookup", timeOrigin, "DNS");
      _addRequest(transaction, entry, timeOrigin);
    }
    function _addPerformanceNavigationTiming(transaction, entry, event, timeOrigin, description, eventEnd) {
      const end = eventEnd ? entry[eventEnd] : entry[`${event}End`];
      const start = entry[`${event}Start`];
      if (!start || !end) {
        return;
      }
      utils$1._startChild(transaction, {
        op: "browser",
        origin: "auto.browser.browser.metrics",
        description: description || event,
        startTimestamp: timeOrigin + msToSec(start),
        endTimestamp: timeOrigin + msToSec(end)
      });
    }
    function _addRequest(transaction, entry, timeOrigin) {
      if (entry.responseEnd) {
        utils$1._startChild(transaction, {
          op: "browser",
          origin: "auto.browser.browser.metrics",
          description: "request",
          startTimestamp: timeOrigin + msToSec(entry.requestStart),
          endTimestamp: timeOrigin + msToSec(entry.responseEnd)
        });
        utils$1._startChild(transaction, {
          op: "browser",
          origin: "auto.browser.browser.metrics",
          description: "response",
          startTimestamp: timeOrigin + msToSec(entry.responseStart),
          endTimestamp: timeOrigin + msToSec(entry.responseEnd)
        });
      }
    }
    function _addResourceSpans(transaction, entry, resourceUrl, startTime, duration, timeOrigin) {
      if (entry.initiatorType === "xmlhttprequest" || entry.initiatorType === "fetch") {
        return;
      }
      const parsedUrl = utils.parseUrl(resourceUrl);
      const data = {};
      setResourceEntrySizeData(data, entry, "transferSize", "http.response_transfer_size");
      setResourceEntrySizeData(data, entry, "encodedBodySize", "http.response_content_length");
      setResourceEntrySizeData(data, entry, "decodedBodySize", "http.decoded_response_content_length");
      if ("renderBlockingStatus" in entry) {
        data["resource.render_blocking_status"] = entry.renderBlockingStatus;
      }
      if (parsedUrl.protocol) {
        data["url.scheme"] = parsedUrl.protocol.split(":").pop();
      }
      if (parsedUrl.host) {
        data["server.address"] = parsedUrl.host;
      }
      data["url.same_origin"] = resourceUrl.includes(types.WINDOW.location.origin);
      const startTimestamp = timeOrigin + startTime;
      const endTimestamp = startTimestamp + duration;
      utils$1._startChild(transaction, {
        description: resourceUrl.replace(types.WINDOW.location.origin, ""),
        endTimestamp,
        op: entry.initiatorType ? `resource.${entry.initiatorType}` : "resource.other",
        origin: "auto.resource.browser.metrics",
        startTimestamp,
        data
      });
    }
    function _trackNavigator(transaction) {
      const navigator2 = types.WINDOW.navigator;
      if (!navigator2) {
        return;
      }
      const connection = navigator2.connection;
      if (connection) {
        if (connection.effectiveType) {
          transaction.setTag("effectiveConnectionType", connection.effectiveType);
        }
        if (connection.type) {
          transaction.setTag("connectionType", connection.type);
        }
        if (utils$1.isMeasurementValue(connection.rtt)) {
          _measurements["connection.rtt"] = { value: connection.rtt, unit: "millisecond" };
        }
      }
      if (utils$1.isMeasurementValue(navigator2.deviceMemory)) {
        transaction.setTag("deviceMemory", `${navigator2.deviceMemory} GB`);
      }
      if (utils$1.isMeasurementValue(navigator2.hardwareConcurrency)) {
        transaction.setTag("hardwareConcurrency", String(navigator2.hardwareConcurrency));
      }
    }
    function _tagMetricInfo(transaction) {
      if (_lcpEntry) {
        debugBuild.DEBUG_BUILD && utils.logger.log("[Measurements] Adding LCP Data");
        if (_lcpEntry.element) {
          transaction.setTag("lcp.element", utils.htmlTreeAsString(_lcpEntry.element));
        }
        if (_lcpEntry.id) {
          transaction.setTag("lcp.id", _lcpEntry.id);
        }
        if (_lcpEntry.url) {
          transaction.setTag("lcp.url", _lcpEntry.url.trim().slice(0, 200));
        }
        transaction.setTag("lcp.size", _lcpEntry.size);
      }
      if (_clsEntry && _clsEntry.sources) {
        debugBuild.DEBUG_BUILD && utils.logger.log("[Measurements] Adding CLS Data");
        _clsEntry.sources.forEach(
          (source, index) => (
            // TODO: Can we rewrite this to an attribute?
            // eslint-disable-next-line deprecation/deprecation
            transaction.setTag(`cls.source.${index + 1}`, utils.htmlTreeAsString(source.node))
          )
        );
      }
    }
    function setResourceEntrySizeData(data, entry, key, dataKey) {
      const entryVal = entry[key];
      if (entryVal != null && entryVal < MAX_INT_AS_BYTES) {
        data[dataKey] = entryVal;
      }
    }
    function _addTtfbRequestTimeToMeasurements(_measurements2) {
      const navEntry = getNavigationEntry.getNavigationEntry();
      if (!navEntry) {
        return;
      }
      const { responseStart, requestStart } = navEntry;
      if (requestStart <= responseStart) {
        debugBuild.DEBUG_BUILD && utils.logger.log("[Measurements] Adding TTFB Request Time");
        _measurements2["ttfb.requestTime"] = {
          value: responseStart - requestStart,
          unit: "millisecond"
        };
      }
    }
    function getSampleRate(transactionContext, options, interactionsSampleRate) {
      if (!core.hasTracingEnabled(options)) {
        return false;
      }
      let sampleRate;
      if (transactionContext !== void 0 && typeof options.tracesSampler === "function") {
        sampleRate = options.tracesSampler({
          transactionContext,
          name: transactionContext.name,
          parentSampled: transactionContext.parentSampled,
          attributes: {
            // eslint-disable-next-line deprecation/deprecation
            ...transactionContext.data,
            ...transactionContext.attributes
          },
          location: types.WINDOW.location
        });
      } else if (transactionContext !== void 0 && transactionContext.sampled !== void 0) {
        sampleRate = transactionContext.sampled;
      } else if (typeof options.tracesSampleRate !== "undefined") {
        sampleRate = options.tracesSampleRate;
      } else {
        sampleRate = 1;
      }
      if (!core.isValidSampleRate(sampleRate)) {
        debugBuild.DEBUG_BUILD && utils.logger.warn("[Tracing] Discarding interaction span because of invalid sample rate.");
        return false;
      }
      if (sampleRate === true) {
        return interactionsSampleRate;
      } else if (sampleRate === false) {
        return 0;
      }
      return sampleRate * interactionsSampleRate;
    }
    exports._addMeasureSpans = _addMeasureSpans;
    exports._addResourceSpans = _addResourceSpans;
    exports.addPerformanceEntries = addPerformanceEntries;
    exports.startTrackingINP = startTrackingINP;
    exports.startTrackingInteractions = startTrackingInteractions;
    exports.startTrackingLongTasks = startTrackingLongTasks;
    exports.startTrackingWebVitals = startTrackingWebVitals;
  }
});

// ../../../node_modules/.pnpm/@sentry-internal+tracing@7.120.2/node_modules/@sentry-internal/tracing/cjs/common/fetch.js
var require_fetch2 = __commonJS({
  "../../../node_modules/.pnpm/@sentry-internal+tracing@7.120.2/node_modules/@sentry-internal/tracing/cjs/common/fetch.js"(exports) {
    init_define_ENV_DEFINED_IN_BUILD_STEP();
    Object.defineProperty(exports, "__esModule", { value: true });
    var core = require_cjs2();
    var utils = require_cjs();
    function instrumentFetchRequest(handlerData, shouldCreateSpan, shouldAttachHeaders, spans, spanOrigin = "auto.http.browser") {
      if (!core.hasTracingEnabled() || !handlerData.fetchData) {
        return void 0;
      }
      const shouldCreateSpanResult = shouldCreateSpan(handlerData.fetchData.url);
      if (handlerData.endTimestamp && shouldCreateSpanResult) {
        const spanId = handlerData.fetchData.__span;
        if (!spanId)
          return;
        const span2 = spans[spanId];
        if (span2) {
          endSpan(span2, handlerData);
          delete spans[spanId];
        }
        return void 0;
      }
      const scope = core.getCurrentScope();
      const client = core.getClient();
      const { method, url } = handlerData.fetchData;
      const fullUrl = getFullURL(url);
      const host = fullUrl ? utils.parseUrl(fullUrl).host : void 0;
      const span = shouldCreateSpanResult ? core.startInactiveSpan({
        name: `${method} ${url}`,
        onlyIfParent: true,
        attributes: {
          url,
          type: "fetch",
          "http.method": method,
          "http.url": fullUrl,
          "server.address": host,
          [core.SEMANTIC_ATTRIBUTE_SENTRY_ORIGIN]: spanOrigin
        },
        op: "http.client"
      }) : void 0;
      if (span) {
        handlerData.fetchData.__span = span.spanContext().spanId;
        spans[span.spanContext().spanId] = span;
      }
      if (shouldAttachHeaders(handlerData.fetchData.url) && client) {
        const request = handlerData.args[0];
        handlerData.args[1] = handlerData.args[1] || {};
        const options = handlerData.args[1];
        options.headers = addTracingHeadersToFetchRequest(request, client, scope, options, span);
      }
      return span;
    }
    function addTracingHeadersToFetchRequest(request, client, scope, options, requestSpan) {
      const span = requestSpan || scope.getSpan();
      const isolationScope = core.getIsolationScope();
      const { traceId, spanId, sampled, dsc } = {
        ...isolationScope.getPropagationContext(),
        ...scope.getPropagationContext()
      };
      const sentryTraceHeader = span ? core.spanToTraceHeader(span) : utils.generateSentryTraceHeader(traceId, spanId, sampled);
      const sentryBaggageHeader = utils.dynamicSamplingContextToSentryBaggageHeader(
        dsc || (span ? core.getDynamicSamplingContextFromSpan(span) : core.getDynamicSamplingContextFromClient(traceId, client, scope))
      );
      const headers = options.headers || (typeof Request !== "undefined" && utils.isInstanceOf(request, Request) ? request.headers : void 0);
      if (!headers) {
        return { "sentry-trace": sentryTraceHeader, baggage: sentryBaggageHeader };
      } else if (typeof Headers !== "undefined" && utils.isInstanceOf(headers, Headers)) {
        const newHeaders = new Headers(headers);
        newHeaders.append("sentry-trace", sentryTraceHeader);
        if (sentryBaggageHeader) {
          newHeaders.append(utils.BAGGAGE_HEADER_NAME, sentryBaggageHeader);
        }
        return newHeaders;
      } else if (Array.isArray(headers)) {
        const newHeaders = [...headers, ["sentry-trace", sentryTraceHeader]];
        if (sentryBaggageHeader) {
          newHeaders.push([utils.BAGGAGE_HEADER_NAME, sentryBaggageHeader]);
        }
        return newHeaders;
      } else {
        const existingBaggageHeader = "baggage" in headers ? headers.baggage : void 0;
        const newBaggageHeaders = [];
        if (Array.isArray(existingBaggageHeader)) {
          newBaggageHeaders.push(...existingBaggageHeader);
        } else if (existingBaggageHeader) {
          newBaggageHeaders.push(existingBaggageHeader);
        }
        if (sentryBaggageHeader) {
          newBaggageHeaders.push(sentryBaggageHeader);
        }
        return {
          ...headers,
          "sentry-trace": sentryTraceHeader,
          baggage: newBaggageHeaders.length > 0 ? newBaggageHeaders.join(",") : void 0
        };
      }
    }
    function getFullURL(url) {
      try {
        const parsed = new URL(url);
        return parsed.href;
      } catch (e2) {
        return void 0;
      }
    }
    function endSpan(span, handlerData) {
      if (handlerData.response) {
        core.setHttpStatus(span, handlerData.response.status);
        const contentLength = handlerData.response && handlerData.response.headers && handlerData.response.headers.get("content-length");
        if (contentLength) {
          const contentLengthNum = parseInt(contentLength);
          if (contentLengthNum > 0) {
            span.setAttribute("http.response_content_length", contentLengthNum);
          }
        }
      } else if (handlerData.error) {
        span.setStatus("internal_error");
      }
      span.end();
    }
    exports.addTracingHeadersToFetchRequest = addTracingHeadersToFetchRequest;
    exports.instrumentFetchRequest = instrumentFetchRequest;
  }
});

// ../../../node_modules/.pnpm/@sentry-internal+tracing@7.120.2/node_modules/@sentry-internal/tracing/cjs/browser/request.js
var require_request = __commonJS({
  "../../../node_modules/.pnpm/@sentry-internal+tracing@7.120.2/node_modules/@sentry-internal/tracing/cjs/browser/request.js"(exports) {
    init_define_ENV_DEFINED_IN_BUILD_STEP();
    Object.defineProperty(exports, "__esModule", { value: true });
    var core = require_cjs2();
    var utils = require_cjs();
    var fetch2 = require_fetch2();
    var instrument = require_instrument2();
    var types = require_types();
    var DEFAULT_TRACE_PROPAGATION_TARGETS = ["localhost", /^\/(?!\/)/];
    var defaultRequestInstrumentationOptions = {
      traceFetch: true,
      traceXHR: true,
      enableHTTPTimings: true,
      // TODO (v8): Remove this property
      tracingOrigins: DEFAULT_TRACE_PROPAGATION_TARGETS,
      tracePropagationTargets: DEFAULT_TRACE_PROPAGATION_TARGETS
    };
    function instrumentOutgoingRequests(_options) {
      const {
        traceFetch,
        traceXHR,
        // eslint-disable-next-line deprecation/deprecation
        tracePropagationTargets,
        // eslint-disable-next-line deprecation/deprecation
        tracingOrigins,
        shouldCreateSpanForRequest,
        enableHTTPTimings
      } = {
        traceFetch: defaultRequestInstrumentationOptions.traceFetch,
        traceXHR: defaultRequestInstrumentationOptions.traceXHR,
        ..._options
      };
      const shouldCreateSpan = typeof shouldCreateSpanForRequest === "function" ? shouldCreateSpanForRequest : (_3) => true;
      const shouldAttachHeadersWithTargets = (url) => shouldAttachHeaders(url, tracePropagationTargets || tracingOrigins);
      const spans = {};
      if (traceFetch) {
        utils.addFetchInstrumentationHandler((handlerData) => {
          const createdSpan = fetch2.instrumentFetchRequest(handlerData, shouldCreateSpan, shouldAttachHeadersWithTargets, spans);
          if (createdSpan) {
            const fullUrl = getFullURL(handlerData.fetchData.url);
            const host = fullUrl ? utils.parseUrl(fullUrl).host : void 0;
            createdSpan.setAttributes({
              "http.url": fullUrl,
              "server.address": host
            });
          }
          if (enableHTTPTimings && createdSpan) {
            addHTTPTimings(createdSpan);
          }
        });
      }
      if (traceXHR) {
        utils.addXhrInstrumentationHandler((handlerData) => {
          const createdSpan = xhrCallback(handlerData, shouldCreateSpan, shouldAttachHeadersWithTargets, spans);
          if (enableHTTPTimings && createdSpan) {
            addHTTPTimings(createdSpan);
          }
        });
      }
    }
    function isPerformanceResourceTiming(entry) {
      return entry.entryType === "resource" && "initiatorType" in entry && typeof entry.nextHopProtocol === "string" && (entry.initiatorType === "fetch" || entry.initiatorType === "xmlhttprequest");
    }
    function addHTTPTimings(span) {
      const { url } = core.spanToJSON(span).data || {};
      if (!url || typeof url !== "string") {
        return;
      }
      const cleanup = instrument.addPerformanceInstrumentationHandler("resource", ({ entries }) => {
        entries.forEach((entry) => {
          if (isPerformanceResourceTiming(entry) && entry.name.endsWith(url)) {
            const spanData = resourceTimingEntryToSpanData(entry);
            spanData.forEach((data) => span.setAttribute(...data));
            setTimeout(cleanup);
          }
        });
      });
    }
    function extractNetworkProtocol(nextHopProtocol) {
      let name = "unknown";
      let version2 = "unknown";
      let _name = "";
      for (const char of nextHopProtocol) {
        if (char === "/") {
          [name, version2] = nextHopProtocol.split("/");
          break;
        }
        if (!isNaN(Number(char))) {
          name = _name === "h" ? "http" : _name;
          version2 = nextHopProtocol.split(_name)[1];
          break;
        }
        _name += char;
      }
      if (_name === nextHopProtocol) {
        name = _name;
      }
      return { name, version: version2 };
    }
    function getAbsoluteTime(time = 0) {
      return ((utils.browserPerformanceTimeOrigin || performance.timeOrigin) + time) / 1e3;
    }
    function resourceTimingEntryToSpanData(resourceTiming) {
      const { name, version: version2 } = extractNetworkProtocol(resourceTiming.nextHopProtocol);
      const timingSpanData = [];
      timingSpanData.push(["network.protocol.version", version2], ["network.protocol.name", name]);
      if (!utils.browserPerformanceTimeOrigin) {
        return timingSpanData;
      }
      return [
        ...timingSpanData,
        ["http.request.redirect_start", getAbsoluteTime(resourceTiming.redirectStart)],
        ["http.request.fetch_start", getAbsoluteTime(resourceTiming.fetchStart)],
        ["http.request.domain_lookup_start", getAbsoluteTime(resourceTiming.domainLookupStart)],
        ["http.request.domain_lookup_end", getAbsoluteTime(resourceTiming.domainLookupEnd)],
        ["http.request.connect_start", getAbsoluteTime(resourceTiming.connectStart)],
        ["http.request.secure_connection_start", getAbsoluteTime(resourceTiming.secureConnectionStart)],
        ["http.request.connection_end", getAbsoluteTime(resourceTiming.connectEnd)],
        ["http.request.request_start", getAbsoluteTime(resourceTiming.requestStart)],
        ["http.request.response_start", getAbsoluteTime(resourceTiming.responseStart)],
        ["http.request.response_end", getAbsoluteTime(resourceTiming.responseEnd)]
      ];
    }
    function shouldAttachHeaders(url, tracePropagationTargets) {
      return utils.stringMatchesSomePattern(url, tracePropagationTargets || DEFAULT_TRACE_PROPAGATION_TARGETS);
    }
    function xhrCallback(handlerData, shouldCreateSpan, shouldAttachHeaders2, spans) {
      const xhr = handlerData.xhr;
      const sentryXhrData = xhr && xhr[utils.SENTRY_XHR_DATA_KEY];
      if (!core.hasTracingEnabled() || !xhr || xhr.__sentry_own_request__ || !sentryXhrData) {
        return void 0;
      }
      const shouldCreateSpanResult = shouldCreateSpan(sentryXhrData.url);
      if (handlerData.endTimestamp && shouldCreateSpanResult) {
        const spanId = xhr.__sentry_xhr_span_id__;
        if (!spanId)
          return;
        const span2 = spans[spanId];
        if (span2 && sentryXhrData.status_code !== void 0) {
          core.setHttpStatus(span2, sentryXhrData.status_code);
          span2.end();
          delete spans[spanId];
        }
        return void 0;
      }
      const scope = core.getCurrentScope();
      const isolationScope = core.getIsolationScope();
      const fullUrl = getFullURL(sentryXhrData.url);
      const host = fullUrl ? utils.parseUrl(fullUrl).host : void 0;
      const span = shouldCreateSpanResult ? core.startInactiveSpan({
        name: `${sentryXhrData.method} ${sentryXhrData.url}`,
        onlyIfParent: true,
        attributes: {
          type: "xhr",
          "http.method": sentryXhrData.method,
          "http.url": fullUrl,
          url: sentryXhrData.url,
          "server.address": host,
          [core.SEMANTIC_ATTRIBUTE_SENTRY_ORIGIN]: "auto.http.browser"
        },
        op: "http.client"
      }) : void 0;
      if (span) {
        xhr.__sentry_xhr_span_id__ = span.spanContext().spanId;
        spans[xhr.__sentry_xhr_span_id__] = span;
      }
      const client = core.getClient();
      if (xhr.setRequestHeader && shouldAttachHeaders2(sentryXhrData.url) && client) {
        const { traceId, spanId, sampled, dsc } = {
          ...isolationScope.getPropagationContext(),
          ...scope.getPropagationContext()
        };
        const sentryTraceHeader = span ? core.spanToTraceHeader(span) : utils.generateSentryTraceHeader(traceId, spanId, sampled);
        const sentryBaggageHeader = utils.dynamicSamplingContextToSentryBaggageHeader(
          dsc || (span ? core.getDynamicSamplingContextFromSpan(span) : core.getDynamicSamplingContextFromClient(traceId, client, scope))
        );
        setHeaderOnXhr(xhr, sentryTraceHeader, sentryBaggageHeader);
      }
      return span;
    }
    function setHeaderOnXhr(xhr, sentryTraceHeader, sentryBaggageHeader) {
      try {
        xhr.setRequestHeader("sentry-trace", sentryTraceHeader);
        if (sentryBaggageHeader) {
          xhr.setRequestHeader(utils.BAGGAGE_HEADER_NAME, sentryBaggageHeader);
        }
      } catch (_3) {
      }
    }
    function getFullURL(url) {
      try {
        const parsed = new URL(url, types.WINDOW.location.origin);
        return parsed.href;
      } catch (e2) {
        return void 0;
      }
    }
    exports.DEFAULT_TRACE_PROPAGATION_TARGETS = DEFAULT_TRACE_PROPAGATION_TARGETS;
    exports.defaultRequestInstrumentationOptions = defaultRequestInstrumentationOptions;
    exports.extractNetworkProtocol = extractNetworkProtocol;
    exports.instrumentOutgoingRequests = instrumentOutgoingRequests;
    exports.shouldAttachHeaders = shouldAttachHeaders;
    exports.xhrCallback = xhrCallback;
  }
});

// ../../../node_modules/.pnpm/@sentry-internal+tracing@7.120.2/node_modules/@sentry-internal/tracing/cjs/browser/router.js
var require_router = __commonJS({
  "../../../node_modules/.pnpm/@sentry-internal+tracing@7.120.2/node_modules/@sentry-internal/tracing/cjs/browser/router.js"(exports) {
    init_define_ENV_DEFINED_IN_BUILD_STEP();
    Object.defineProperty(exports, "__esModule", { value: true });
    var utils = require_cjs();
    var debugBuild = require_debug_build3();
    var types = require_types();
    function instrumentRoutingWithDefaults(customStartTransaction, startTransactionOnPageLoad = true, startTransactionOnLocationChange = true) {
      if (!types.WINDOW || !types.WINDOW.location) {
        debugBuild.DEBUG_BUILD && utils.logger.warn("Could not initialize routing instrumentation due to invalid location");
        return;
      }
      let startingUrl = types.WINDOW.location.href;
      let activeTransaction;
      if (startTransactionOnPageLoad) {
        activeTransaction = customStartTransaction({
          name: types.WINDOW.location.pathname,
          // pageload should always start at timeOrigin (and needs to be in s, not ms)
          startTimestamp: utils.browserPerformanceTimeOrigin ? utils.browserPerformanceTimeOrigin / 1e3 : void 0,
          op: "pageload",
          origin: "auto.pageload.browser",
          metadata: { source: "url" }
        });
      }
      if (startTransactionOnLocationChange) {
        utils.addHistoryInstrumentationHandler(({ to, from }) => {
          if (from === void 0 && startingUrl && startingUrl.indexOf(to) !== -1) {
            startingUrl = void 0;
            return;
          }
          if (from !== to) {
            startingUrl = void 0;
            if (activeTransaction) {
              debugBuild.DEBUG_BUILD && utils.logger.log(`[Tracing] Finishing current transaction with op: ${activeTransaction.op}`);
              activeTransaction.end();
            }
            activeTransaction = customStartTransaction({
              name: types.WINDOW.location.pathname,
              op: "navigation",
              origin: "auto.navigation.browser",
              metadata: { source: "url" }
            });
          }
        });
      }
    }
    exports.instrumentRoutingWithDefaults = instrumentRoutingWithDefaults;
  }
});

// ../../../node_modules/.pnpm/@sentry-internal+tracing@7.120.2/node_modules/@sentry-internal/tracing/cjs/browser/browsertracing.js
var require_browsertracing = __commonJS({
  "../../../node_modules/.pnpm/@sentry-internal+tracing@7.120.2/node_modules/@sentry-internal/tracing/cjs/browser/browsertracing.js"(exports) {
    init_define_ENV_DEFINED_IN_BUILD_STEP();
    Object.defineProperty(exports, "__esModule", { value: true });
    var core = require_cjs2();
    var utils = require_cjs();
    var debugBuild = require_debug_build3();
    var backgroundtab = require_backgroundtab();
    var instrument = require_instrument2();
    var index = require_metrics();
    var request = require_request();
    var router = require_router();
    var types = require_types();
    var BROWSER_TRACING_INTEGRATION_ID = "BrowserTracing";
    var DEFAULT_BROWSER_TRACING_OPTIONS = {
      ...core.TRACING_DEFAULTS,
      markBackgroundTransactions: true,
      routingInstrumentation: router.instrumentRoutingWithDefaults,
      startTransactionOnLocationChange: true,
      startTransactionOnPageLoad: true,
      enableLongTask: true,
      enableInp: false,
      interactionsSampleRate: 1,
      _experiments: {},
      ...request.defaultRequestInstrumentationOptions
    };
    var MAX_INTERACTIONS = 10;
    var BrowserTracing = class {
      // This class currently doesn't have a static `id` field like the other integration classes, because it prevented
      // @sentry/tracing from being treeshaken. Tree shakers do not like static fields, because they behave like side effects.
      // TODO: Come up with a better plan, than using static fields on integration classes, and use that plan on all
      // integrations.
      /** Browser Tracing integration options */
      /**
       * @inheritDoc
       */
      // eslint-disable-next-line deprecation/deprecation
      constructor(_options) {
        this.name = BROWSER_TRACING_INTEGRATION_ID;
        this._hasSetTracePropagationTargets = false;
        core.addTracingExtensions();
        if (debugBuild.DEBUG_BUILD) {
          this._hasSetTracePropagationTargets = !!(_options && // eslint-disable-next-line deprecation/deprecation
          (_options.tracePropagationTargets || _options.tracingOrigins));
        }
        this.options = {
          ...DEFAULT_BROWSER_TRACING_OPTIONS,
          ..._options
        };
        if (this.options._experiments.enableLongTask !== void 0) {
          this.options.enableLongTask = this.options._experiments.enableLongTask;
        }
        if (_options && !_options.tracePropagationTargets && _options.tracingOrigins) {
          this.options.tracePropagationTargets = _options.tracingOrigins;
        }
        this._collectWebVitals = index.startTrackingWebVitals();
        this._interactionIdToRouteNameMapping = {};
        if (this.options.enableInp) {
          index.startTrackingINP(this._interactionIdToRouteNameMapping, this.options.interactionsSampleRate);
        }
        if (this.options.enableLongTask) {
          index.startTrackingLongTasks();
        }
        if (this.options._experiments.enableInteractions) {
          index.startTrackingInteractions();
        }
        this._latestRoute = {
          name: void 0,
          context: void 0
        };
      }
      /**
       * @inheritDoc
       */
      // eslint-disable-next-line deprecation/deprecation
      setupOnce(_3, getCurrentHub) {
        this._getCurrentHub = getCurrentHub;
        const hub = getCurrentHub();
        const client = hub.getClient();
        const clientOptions = client && client.getOptions();
        const {
          routingInstrumentation: instrumentRouting,
          startTransactionOnLocationChange,
          startTransactionOnPageLoad,
          markBackgroundTransactions,
          traceFetch,
          traceXHR,
          shouldCreateSpanForRequest,
          enableHTTPTimings,
          _experiments
        } = this.options;
        const clientOptionsTracePropagationTargets = clientOptions && clientOptions.tracePropagationTargets;
        const tracePropagationTargets = clientOptionsTracePropagationTargets || this.options.tracePropagationTargets;
        if (debugBuild.DEBUG_BUILD && this._hasSetTracePropagationTargets && clientOptionsTracePropagationTargets) {
          utils.logger.warn(
            "[Tracing] The `tracePropagationTargets` option was set in the BrowserTracing integration and top level `Sentry.init`. The top level `Sentry.init` value is being used."
          );
        }
        instrumentRouting(
          (context2) => {
            const transaction = this._createRouteTransaction(context2);
            this.options._experiments.onStartRouteTransaction && this.options._experiments.onStartRouteTransaction(transaction, context2, getCurrentHub);
            return transaction;
          },
          startTransactionOnPageLoad,
          startTransactionOnLocationChange
        );
        if (markBackgroundTransactions) {
          backgroundtab.registerBackgroundTabDetection();
        }
        if (_experiments.enableInteractions) {
          this._registerInteractionListener();
        }
        if (this.options.enableInp) {
          this._registerInpInteractionListener();
        }
        request.instrumentOutgoingRequests({
          traceFetch,
          traceXHR,
          tracePropagationTargets,
          shouldCreateSpanForRequest,
          enableHTTPTimings
        });
      }
      /** Create routing idle transaction. */
      _createRouteTransaction(context2) {
        if (!this._getCurrentHub) {
          debugBuild.DEBUG_BUILD && utils.logger.warn(`[Tracing] Did not create ${context2.op} transaction because _getCurrentHub is invalid.`);
          return void 0;
        }
        const hub = this._getCurrentHub();
        const { beforeNavigate, idleTimeout, finalTimeout, heartbeatInterval } = this.options;
        const isPageloadTransaction = context2.op === "pageload";
        let expandedContext;
        if (isPageloadTransaction) {
          const sentryTrace = isPageloadTransaction ? getMetaContent("sentry-trace") : "";
          const baggage = isPageloadTransaction ? getMetaContent("baggage") : void 0;
          const { traceId, dsc, parentSpanId, sampled } = utils.propagationContextFromHeaders(sentryTrace, baggage);
          expandedContext = {
            traceId,
            parentSpanId,
            parentSampled: sampled,
            ...context2,
            metadata: {
              // eslint-disable-next-line deprecation/deprecation
              ...context2.metadata,
              dynamicSamplingContext: dsc
            },
            trimEnd: true
          };
        } else {
          expandedContext = {
            trimEnd: true,
            ...context2
          };
        }
        const modifiedContext = typeof beforeNavigate === "function" ? beforeNavigate(expandedContext) : expandedContext;
        const finalContext = modifiedContext === void 0 ? { ...expandedContext, sampled: false } : modifiedContext;
        finalContext.metadata = finalContext.name !== expandedContext.name ? (
          // eslint-disable-next-line deprecation/deprecation
          { ...finalContext.metadata, source: "custom" }
        ) : (
          // eslint-disable-next-line deprecation/deprecation
          finalContext.metadata
        );
        this._latestRoute.name = finalContext.name;
        this._latestRoute.context = finalContext;
        if (finalContext.sampled === false) {
          debugBuild.DEBUG_BUILD && utils.logger.log(`[Tracing] Will not send ${finalContext.op} transaction because of beforeNavigate.`);
        }
        debugBuild.DEBUG_BUILD && utils.logger.log(`[Tracing] Starting ${finalContext.op} transaction on scope`);
        const { location } = types.WINDOW;
        const idleTransaction = core.startIdleTransaction(
          hub,
          finalContext,
          idleTimeout,
          finalTimeout,
          true,
          { location },
          // for use in the tracesSampler
          heartbeatInterval,
          isPageloadTransaction
          // should wait for finish signal if it's a pageload transaction
        );
        if (isPageloadTransaction) {
          if (types.WINDOW.document) {
            types.WINDOW.document.addEventListener("readystatechange", () => {
              if (["interactive", "complete"].includes(types.WINDOW.document.readyState)) {
                idleTransaction.sendAutoFinishSignal();
              }
            });
            if (["interactive", "complete"].includes(types.WINDOW.document.readyState)) {
              idleTransaction.sendAutoFinishSignal();
            }
          }
        }
        idleTransaction.registerBeforeFinishCallback((transaction) => {
          this._collectWebVitals();
          index.addPerformanceEntries(transaction);
        });
        return idleTransaction;
      }
      /** Start listener for interaction transactions */
      _registerInteractionListener() {
        let inflightInteractionTransaction;
        const registerInteractionTransaction = () => {
          const { idleTimeout, finalTimeout, heartbeatInterval } = this.options;
          const op = "ui.action.click";
          const currentTransaction = core.getActiveTransaction();
          if (currentTransaction && currentTransaction.op && ["navigation", "pageload"].includes(currentTransaction.op)) {
            debugBuild.DEBUG_BUILD && utils.logger.warn(
              `[Tracing] Did not create ${op} transaction because a pageload or navigation transaction is in progress.`
            );
            return void 0;
          }
          if (inflightInteractionTransaction) {
            inflightInteractionTransaction.setFinishReason("interactionInterrupted");
            inflightInteractionTransaction.end();
            inflightInteractionTransaction = void 0;
          }
          if (!this._getCurrentHub) {
            debugBuild.DEBUG_BUILD && utils.logger.warn(`[Tracing] Did not create ${op} transaction because _getCurrentHub is invalid.`);
            return void 0;
          }
          if (!this._latestRoute.name) {
            debugBuild.DEBUG_BUILD && utils.logger.warn(`[Tracing] Did not create ${op} transaction because _latestRouteName is missing.`);
            return void 0;
          }
          const hub = this._getCurrentHub();
          const { location } = types.WINDOW;
          const context2 = {
            name: this._latestRoute.name,
            op,
            trimEnd: true,
            data: {
              [core.SEMANTIC_ATTRIBUTE_SENTRY_SOURCE]: this._latestRoute.context ? getSource(this._latestRoute.context) : "url"
            }
          };
          inflightInteractionTransaction = core.startIdleTransaction(
            hub,
            context2,
            idleTimeout,
            finalTimeout,
            true,
            { location },
            // for use in the tracesSampler
            heartbeatInterval
          );
        };
        ["click"].forEach((type) => {
          if (types.WINDOW.document) {
            addEventListener(type, registerInteractionTransaction, { once: false, capture: true });
          }
        });
      }
      /** Creates a listener on interaction entries, and maps interactionIds to the origin path of the interaction */
      _registerInpInteractionListener() {
        const handleEntries = ({ entries }) => {
          const client = core.getClient();
          const replay = client !== void 0 && client.getIntegrationByName !== void 0 ? client.getIntegrationByName("Replay") : void 0;
          const replayId = replay !== void 0 ? replay.getReplayId() : void 0;
          const activeTransaction = core.getActiveTransaction();
          const currentScope = core.getCurrentScope();
          const user = currentScope !== void 0 ? currentScope.getUser() : void 0;
          entries.forEach((entry) => {
            if (isPerformanceEventTiming(entry)) {
              const interactionId = entry.interactionId;
              if (interactionId === void 0) {
                return;
              }
              const existingInteraction = this._interactionIdToRouteNameMapping[interactionId];
              const duration = entry.duration;
              const startTime = entry.startTime;
              const keys = Object.keys(this._interactionIdToRouteNameMapping);
              const minInteractionId = keys.length > 0 ? keys.reduce((a3, b) => {
                return this._interactionIdToRouteNameMapping[a3].duration < this._interactionIdToRouteNameMapping[b].duration ? a3 : b;
              }) : void 0;
              if (entry.entryType === "first-input") {
                const matchingEntry = keys.map((key) => this._interactionIdToRouteNameMapping[key]).some((interaction) => {
                  return interaction.duration === duration && interaction.startTime === startTime;
                });
                if (matchingEntry) {
                  return;
                }
              }
              if (!interactionId) {
                return;
              }
              if (existingInteraction) {
                existingInteraction.duration = Math.max(existingInteraction.duration, duration);
              } else if (keys.length < MAX_INTERACTIONS || minInteractionId === void 0 || duration > this._interactionIdToRouteNameMapping[minInteractionId].duration) {
                const routeName = this._latestRoute.name;
                const parentContext = this._latestRoute.context;
                if (routeName && parentContext) {
                  if (minInteractionId && Object.keys(this._interactionIdToRouteNameMapping).length >= MAX_INTERACTIONS) {
                    delete this._interactionIdToRouteNameMapping[minInteractionId];
                  }
                  this._interactionIdToRouteNameMapping[interactionId] = {
                    routeName,
                    duration,
                    parentContext,
                    user,
                    activeTransaction,
                    replayId,
                    startTime
                  };
                }
              }
            }
          });
        };
        instrument.addPerformanceInstrumentationHandler("event", handleEntries);
        instrument.addPerformanceInstrumentationHandler("first-input", handleEntries);
      }
    };
    function getMetaContent(metaName) {
      const metaTag = utils.getDomElement(`meta[name=${metaName}]`);
      return metaTag ? metaTag.getAttribute("content") : void 0;
    }
    function getSource(context2) {
      const sourceFromAttributes = context2.attributes && context2.attributes[core.SEMANTIC_ATTRIBUTE_SENTRY_SOURCE];
      const sourceFromData = context2.data && context2.data[core.SEMANTIC_ATTRIBUTE_SENTRY_SOURCE];
      const sourceFromMetadata = context2.metadata && context2.metadata.source;
      return sourceFromAttributes || sourceFromData || sourceFromMetadata;
    }
    function isPerformanceEventTiming(entry) {
      return "duration" in entry;
    }
    exports.BROWSER_TRACING_INTEGRATION_ID = BROWSER_TRACING_INTEGRATION_ID;
    exports.BrowserTracing = BrowserTracing;
    exports.getMetaContent = getMetaContent;
  }
});

// ../../../node_modules/.pnpm/@sentry-internal+tracing@7.120.2/node_modules/@sentry-internal/tracing/cjs/browser/browserTracingIntegration.js
var require_browserTracingIntegration = __commonJS({
  "../../../node_modules/.pnpm/@sentry-internal+tracing@7.120.2/node_modules/@sentry-internal/tracing/cjs/browser/browserTracingIntegration.js"(exports) {
    init_define_ENV_DEFINED_IN_BUILD_STEP();
    Object.defineProperty(exports, "__esModule", { value: true });
    var core = require_cjs2();
    var utils = require_cjs();
    var debugBuild = require_debug_build3();
    var backgroundtab = require_backgroundtab();
    var instrument = require_instrument2();
    var index = require_metrics();
    var request = require_request();
    var types = require_types();
    var BROWSER_TRACING_INTEGRATION_ID = "BrowserTracing";
    var DEFAULT_BROWSER_TRACING_OPTIONS = {
      ...core.TRACING_DEFAULTS,
      instrumentNavigation: true,
      instrumentPageLoad: true,
      markBackgroundSpan: true,
      enableLongTask: true,
      enableInp: false,
      interactionsSampleRate: 1,
      _experiments: {},
      ...request.defaultRequestInstrumentationOptions
    };
    var browserTracingIntegration = (_options = {}) => {
      const _hasSetTracePropagationTargets = debugBuild.DEBUG_BUILD ? !!// eslint-disable-next-line deprecation/deprecation
      (_options.tracePropagationTargets || _options.tracingOrigins) : false;
      core.addTracingExtensions();
      if (!_options.tracePropagationTargets && _options.tracingOrigins) {
        _options.tracePropagationTargets = _options.tracingOrigins;
      }
      const options = {
        ...DEFAULT_BROWSER_TRACING_OPTIONS,
        ..._options
      };
      const _collectWebVitals = index.startTrackingWebVitals();
      const interactionIdToRouteNameMapping = {};
      if (options.enableInp) {
        index.startTrackingINP(interactionIdToRouteNameMapping, options.interactionsSampleRate);
      }
      if (options.enableLongTask) {
        index.startTrackingLongTasks();
      }
      if (options._experiments.enableInteractions) {
        index.startTrackingInteractions();
      }
      const latestRoute = {
        name: void 0,
        context: void 0
      };
      function _createRouteTransaction(context2) {
        const hub = core.getCurrentHub();
        const { beforeStartSpan, idleTimeout, finalTimeout, heartbeatInterval } = options;
        const isPageloadTransaction = context2.op === "pageload";
        let expandedContext;
        if (isPageloadTransaction) {
          const sentryTrace = isPageloadTransaction ? getMetaContent("sentry-trace") : "";
          const baggage = isPageloadTransaction ? getMetaContent("baggage") : void 0;
          const { traceId, dsc, parentSpanId, sampled } = utils.propagationContextFromHeaders(sentryTrace, baggage);
          expandedContext = {
            traceId,
            parentSpanId,
            parentSampled: sampled,
            ...context2,
            metadata: {
              // eslint-disable-next-line deprecation/deprecation
              ...context2.metadata,
              dynamicSamplingContext: dsc
            },
            trimEnd: true
          };
        } else {
          expandedContext = {
            trimEnd: true,
            ...context2
          };
        }
        const finalContext = beforeStartSpan ? beforeStartSpan(expandedContext) : expandedContext;
        finalContext.metadata = finalContext.name !== expandedContext.name ? (
          // eslint-disable-next-line deprecation/deprecation
          { ...finalContext.metadata, source: "custom" }
        ) : (
          // eslint-disable-next-line deprecation/deprecation
          finalContext.metadata
        );
        latestRoute.name = finalContext.name;
        latestRoute.context = finalContext;
        if (finalContext.sampled === false) {
          debugBuild.DEBUG_BUILD && utils.logger.log(`[Tracing] Will not send ${finalContext.op} transaction because of beforeNavigate.`);
        }
        debugBuild.DEBUG_BUILD && utils.logger.log(`[Tracing] Starting ${finalContext.op} transaction on scope`);
        const { location } = types.WINDOW;
        const idleTransaction = core.startIdleTransaction(
          hub,
          finalContext,
          idleTimeout,
          finalTimeout,
          true,
          { location },
          // for use in the tracesSampler
          heartbeatInterval,
          isPageloadTransaction
          // should wait for finish signal if it's a pageload transaction
        );
        if (isPageloadTransaction && types.WINDOW.document) {
          types.WINDOW.document.addEventListener("readystatechange", () => {
            if (["interactive", "complete"].includes(types.WINDOW.document.readyState)) {
              idleTransaction.sendAutoFinishSignal();
            }
          });
          if (["interactive", "complete"].includes(types.WINDOW.document.readyState)) {
            idleTransaction.sendAutoFinishSignal();
          }
        }
        idleTransaction.registerBeforeFinishCallback((transaction) => {
          _collectWebVitals();
          index.addPerformanceEntries(transaction);
        });
        return idleTransaction;
      }
      return {
        name: BROWSER_TRACING_INTEGRATION_ID,
        // eslint-disable-next-line @typescript-eslint/no-empty-function
        setupOnce: () => {
        },
        afterAllSetup(client) {
          const clientOptions = client.getOptions();
          const { markBackgroundSpan, traceFetch, traceXHR, shouldCreateSpanForRequest, enableHTTPTimings, _experiments } = options;
          const clientOptionsTracePropagationTargets = clientOptions && clientOptions.tracePropagationTargets;
          const tracePropagationTargets = clientOptionsTracePropagationTargets || options.tracePropagationTargets;
          if (debugBuild.DEBUG_BUILD && _hasSetTracePropagationTargets && clientOptionsTracePropagationTargets) {
            utils.logger.warn(
              "[Tracing] The `tracePropagationTargets` option was set in the BrowserTracing integration and top level `Sentry.init`. The top level `Sentry.init` value is being used."
            );
          }
          let activeSpan;
          let startingUrl = types.WINDOW.location && types.WINDOW.location.href;
          if (client.on) {
            client.on("startNavigationSpan", (context2) => {
              if (activeSpan) {
                debugBuild.DEBUG_BUILD && utils.logger.log(`[Tracing] Finishing current transaction with op: ${core.spanToJSON(activeSpan).op}`);
                activeSpan.end();
              }
              activeSpan = _createRouteTransaction({
                op: "navigation",
                ...context2
              });
            });
            client.on("startPageLoadSpan", (context2) => {
              if (activeSpan) {
                debugBuild.DEBUG_BUILD && utils.logger.log(`[Tracing] Finishing current transaction with op: ${core.spanToJSON(activeSpan).op}`);
                activeSpan.end();
              }
              activeSpan = _createRouteTransaction({
                op: "pageload",
                ...context2
              });
            });
          }
          if (options.instrumentPageLoad && client.emit && types.WINDOW.location) {
            const context2 = {
              name: types.WINDOW.location.pathname,
              // pageload should always start at timeOrigin (and needs to be in s, not ms)
              startTimestamp: utils.browserPerformanceTimeOrigin ? utils.browserPerformanceTimeOrigin / 1e3 : void 0,
              origin: "auto.pageload.browser",
              attributes: {
                [core.SEMANTIC_ATTRIBUTE_SENTRY_SOURCE]: "url"
              }
            };
            startBrowserTracingPageLoadSpan(client, context2);
          }
          if (options.instrumentNavigation && client.emit && types.WINDOW.location) {
            utils.addHistoryInstrumentationHandler(({ to, from }) => {
              if (from === void 0 && startingUrl && startingUrl.indexOf(to) !== -1) {
                startingUrl = void 0;
                return;
              }
              if (from !== to) {
                startingUrl = void 0;
                const context2 = {
                  name: types.WINDOW.location.pathname,
                  origin: "auto.navigation.browser",
                  attributes: {
                    [core.SEMANTIC_ATTRIBUTE_SENTRY_SOURCE]: "url"
                  }
                };
                startBrowserTracingNavigationSpan(client, context2);
              }
            });
          }
          if (markBackgroundSpan) {
            backgroundtab.registerBackgroundTabDetection();
          }
          if (_experiments.enableInteractions) {
            registerInteractionListener(options, latestRoute);
          }
          if (options.enableInp) {
            registerInpInteractionListener(interactionIdToRouteNameMapping, latestRoute);
          }
          request.instrumentOutgoingRequests({
            traceFetch,
            traceXHR,
            tracePropagationTargets,
            shouldCreateSpanForRequest,
            enableHTTPTimings
          });
        },
        // TODO v8: Remove this again
        // This is private API that we use to fix converted BrowserTracing integrations in Next.js & SvelteKit
        options
      };
    };
    function startBrowserTracingPageLoadSpan(client, spanOptions) {
      if (!client.emit) {
        return;
      }
      client.emit("startPageLoadSpan", spanOptions);
      const span = core.getActiveSpan();
      const op = span && core.spanToJSON(span).op;
      return op === "pageload" ? span : void 0;
    }
    function startBrowserTracingNavigationSpan(client, spanOptions) {
      if (!client.emit) {
        return;
      }
      client.emit("startNavigationSpan", spanOptions);
      const span = core.getActiveSpan();
      const op = span && core.spanToJSON(span).op;
      return op === "navigation" ? span : void 0;
    }
    function getMetaContent(metaName) {
      const metaTag = utils.getDomElement(`meta[name=${metaName}]`);
      return metaTag ? metaTag.getAttribute("content") : void 0;
    }
    function registerInteractionListener(options, latestRoute) {
      let inflightInteractionTransaction;
      const registerInteractionTransaction = () => {
        const { idleTimeout, finalTimeout, heartbeatInterval } = options;
        const op = "ui.action.click";
        const currentTransaction = core.getActiveTransaction();
        if (currentTransaction && currentTransaction.op && ["navigation", "pageload"].includes(currentTransaction.op)) {
          debugBuild.DEBUG_BUILD && utils.logger.warn(
            `[Tracing] Did not create ${op} transaction because a pageload or navigation transaction is in progress.`
          );
          return void 0;
        }
        if (inflightInteractionTransaction) {
          inflightInteractionTransaction.setFinishReason("interactionInterrupted");
          inflightInteractionTransaction.end();
          inflightInteractionTransaction = void 0;
        }
        if (!latestRoute.name) {
          debugBuild.DEBUG_BUILD && utils.logger.warn(`[Tracing] Did not create ${op} transaction because _latestRouteName is missing.`);
          return void 0;
        }
        const { location } = types.WINDOW;
        const context2 = {
          name: latestRoute.name,
          op,
          trimEnd: true,
          data: {
            [core.SEMANTIC_ATTRIBUTE_SENTRY_SOURCE]: latestRoute.context ? getSource(latestRoute.context) : "url"
          }
        };
        inflightInteractionTransaction = core.startIdleTransaction(
          // eslint-disable-next-line deprecation/deprecation
          core.getCurrentHub(),
          context2,
          idleTimeout,
          finalTimeout,
          true,
          { location },
          // for use in the tracesSampler
          heartbeatInterval
        );
      };
      ["click"].forEach((type) => {
        if (types.WINDOW.document) {
          addEventListener(type, registerInteractionTransaction, { once: false, capture: true });
        }
      });
    }
    function isPerformanceEventTiming(entry) {
      return "duration" in entry;
    }
    var MAX_INTERACTIONS = 10;
    function registerInpInteractionListener(interactionIdToRouteNameMapping, latestRoute) {
      const handleEntries = ({ entries }) => {
        const client = core.getClient();
        const replay = client !== void 0 && client.getIntegrationByName !== void 0 ? client.getIntegrationByName("Replay") : void 0;
        const replayId = replay !== void 0 ? replay.getReplayId() : void 0;
        const activeTransaction = core.getActiveTransaction();
        const currentScope = core.getCurrentScope();
        const user = currentScope !== void 0 ? currentScope.getUser() : void 0;
        entries.forEach((entry) => {
          if (isPerformanceEventTiming(entry)) {
            const interactionId = entry.interactionId;
            if (interactionId === void 0) {
              return;
            }
            const existingInteraction = interactionIdToRouteNameMapping[interactionId];
            const duration = entry.duration;
            const startTime = entry.startTime;
            const keys = Object.keys(interactionIdToRouteNameMapping);
            const minInteractionId = keys.length > 0 ? keys.reduce((a3, b) => {
              return interactionIdToRouteNameMapping[a3].duration < interactionIdToRouteNameMapping[b].duration ? a3 : b;
            }) : void 0;
            if (entry.entryType === "first-input") {
              const matchingEntry = keys.map((key) => interactionIdToRouteNameMapping[key]).some((interaction) => {
                return interaction.duration === duration && interaction.startTime === startTime;
              });
              if (matchingEntry) {
                return;
              }
            }
            if (!interactionId) {
              return;
            }
            if (existingInteraction) {
              existingInteraction.duration = Math.max(existingInteraction.duration, duration);
            } else if (keys.length < MAX_INTERACTIONS || minInteractionId === void 0 || duration > interactionIdToRouteNameMapping[minInteractionId].duration) {
              const routeName = latestRoute.name;
              const parentContext = latestRoute.context;
              if (routeName && parentContext) {
                if (minInteractionId && Object.keys(interactionIdToRouteNameMapping).length >= MAX_INTERACTIONS) {
                  delete interactionIdToRouteNameMapping[minInteractionId];
                }
                interactionIdToRouteNameMapping[interactionId] = {
                  routeName,
                  duration,
                  parentContext,
                  user,
                  activeTransaction,
                  replayId,
                  startTime
                };
              }
            }
          }
        });
      };
      instrument.addPerformanceInstrumentationHandler("event", handleEntries);
      instrument.addPerformanceInstrumentationHandler("first-input", handleEntries);
    }
    function getSource(context2) {
      const sourceFromAttributes = context2.attributes && context2.attributes[core.SEMANTIC_ATTRIBUTE_SENTRY_SOURCE];
      const sourceFromData = context2.data && context2.data[core.SEMANTIC_ATTRIBUTE_SENTRY_SOURCE];
      const sourceFromMetadata = context2.metadata && context2.metadata.source;
      return sourceFromAttributes || sourceFromData || sourceFromMetadata;
    }
    exports.BROWSER_TRACING_INTEGRATION_ID = BROWSER_TRACING_INTEGRATION_ID;
    exports.browserTracingIntegration = browserTracingIntegration;
    exports.getMetaContent = getMetaContent;
    exports.startBrowserTracingNavigationSpan = startBrowserTracingNavigationSpan;
    exports.startBrowserTracingPageLoadSpan = startBrowserTracingPageLoadSpan;
  }
});

// ../../../node_modules/.pnpm/@sentry-internal+tracing@7.120.2/node_modules/@sentry-internal/tracing/cjs/extensions.js
var require_extensions = __commonJS({
  "../../../node_modules/.pnpm/@sentry-internal+tracing@7.120.2/node_modules/@sentry-internal/tracing/cjs/extensions.js"(exports, module) {
    init_define_ENV_DEFINED_IN_BUILD_STEP();
    Object.defineProperty(exports, "__esModule", { value: true });
    var core = require_cjs2();
    var utils = require_cjs();
    function _autoloadDatabaseIntegrations() {
      const carrier = core.getMainCarrier();
      if (!carrier.__SENTRY__) {
        return;
      }
      const packageToIntegrationMapping = {
        mongodb() {
          const integration = utils.dynamicRequire(module, "./node/integrations/mongo");
          return new integration.Mongo();
        },
        mongoose() {
          const integration = utils.dynamicRequire(module, "./node/integrations/mongo");
          return new integration.Mongo();
        },
        mysql() {
          const integration = utils.dynamicRequire(module, "./node/integrations/mysql");
          return new integration.Mysql();
        },
        pg() {
          const integration = utils.dynamicRequire(module, "./node/integrations/postgres");
          return new integration.Postgres();
        }
      };
      const mappedPackages = Object.keys(packageToIntegrationMapping).filter((moduleName) => !!utils.loadModule(moduleName)).map((pkg) => {
        try {
          return packageToIntegrationMapping[pkg]();
        } catch (e2) {
          return void 0;
        }
      }).filter((p3) => p3);
      if (mappedPackages.length > 0) {
        carrier.__SENTRY__.integrations = [...carrier.__SENTRY__.integrations || [], ...mappedPackages];
      }
    }
    function addExtensionMethods() {
      core.addTracingExtensions();
      if (utils.isNodeEnv()) {
        _autoloadDatabaseIntegrations();
      }
    }
    exports.addExtensionMethods = addExtensionMethods;
  }
});

// ../../../node_modules/.pnpm/@sentry-internal+tracing@7.120.2/node_modules/@sentry-internal/tracing/cjs/index.js
var require_cjs3 = __commonJS({
  "../../../node_modules/.pnpm/@sentry-internal+tracing@7.120.2/node_modules/@sentry-internal/tracing/cjs/index.js"(exports) {
    init_define_ENV_DEFINED_IN_BUILD_STEP();
    Object.defineProperty(exports, "__esModule", { value: true });
    var core = require_cjs2();
    var utils = require_cjs();
    var express = require_express();
    var postgres = require_postgres();
    var mysql = require_mysql();
    var mongo = require_mongo();
    var prisma = require_prisma();
    var graphql = require_graphql();
    var apollo = require_apollo();
    var lazy = require_lazy();
    var browsertracing = require_browsertracing();
    var browserTracingIntegration = require_browserTracingIntegration();
    var request = require_request();
    var instrument = require_instrument2();
    var fetch2 = require_fetch2();
    var extensions = require_extensions();
    exports.IdleTransaction = core.IdleTransaction;
    exports.Span = core.Span;
    exports.SpanStatus = core.SpanStatus;
    exports.Transaction = core.Transaction;
    exports.extractTraceparentData = core.extractTraceparentData;
    exports.getActiveTransaction = core.getActiveTransaction;
    exports.hasTracingEnabled = core.hasTracingEnabled;
    exports.spanStatusfromHttpCode = core.spanStatusfromHttpCode;
    exports.startIdleTransaction = core.startIdleTransaction;
    exports.TRACEPARENT_REGEXP = utils.TRACEPARENT_REGEXP;
    exports.stripUrlQueryAndFragment = utils.stripUrlQueryAndFragment;
    exports.Express = express.Express;
    exports.Postgres = postgres.Postgres;
    exports.Mysql = mysql.Mysql;
    exports.Mongo = mongo.Mongo;
    exports.Prisma = prisma.Prisma;
    exports.GraphQL = graphql.GraphQL;
    exports.Apollo = apollo.Apollo;
    exports.lazyLoadedNodePerformanceMonitoringIntegrations = lazy.lazyLoadedNodePerformanceMonitoringIntegrations;
    exports.BROWSER_TRACING_INTEGRATION_ID = browsertracing.BROWSER_TRACING_INTEGRATION_ID;
    exports.BrowserTracing = browsertracing.BrowserTracing;
    exports.browserTracingIntegration = browserTracingIntegration.browserTracingIntegration;
    exports.startBrowserTracingNavigationSpan = browserTracingIntegration.startBrowserTracingNavigationSpan;
    exports.startBrowserTracingPageLoadSpan = browserTracingIntegration.startBrowserTracingPageLoadSpan;
    exports.defaultRequestInstrumentationOptions = request.defaultRequestInstrumentationOptions;
    exports.instrumentOutgoingRequests = request.instrumentOutgoingRequests;
    exports.addClsInstrumentationHandler = instrument.addClsInstrumentationHandler;
    exports.addFidInstrumentationHandler = instrument.addFidInstrumentationHandler;
    exports.addLcpInstrumentationHandler = instrument.addLcpInstrumentationHandler;
    exports.addPerformanceInstrumentationHandler = instrument.addPerformanceInstrumentationHandler;
    exports.addTracingHeadersToFetchRequest = fetch2.addTracingHeadersToFetchRequest;
    exports.instrumentFetchRequest = fetch2.instrumentFetchRequest;
    exports.addExtensionMethods = extensions.addExtensionMethods;
  }
});

// ../../../node_modules/.pnpm/@sentry+node@7.120.2/node_modules/@sentry/node/cjs/tracing/index.js
var require_tracing2 = __commonJS({
  "../../../node_modules/.pnpm/@sentry+node@7.120.2/node_modules/@sentry/node/cjs/tracing/index.js"(exports) {
    init_define_ENV_DEFINED_IN_BUILD_STEP();
    Object.defineProperty(exports, "__esModule", { value: true });
    var tracing = require_cjs3();
    var utils = require_cjs();
    function autoDiscoverNodePerformanceMonitoringIntegrations() {
      const loadedIntegrations = tracing.lazyLoadedNodePerformanceMonitoringIntegrations.map((tryLoad) => {
        try {
          return tryLoad();
        } catch (_3) {
          return void 0;
        }
      }).filter((integration) => !!integration);
      if (loadedIntegrations.length === 0) {
        utils.logger.warn("Performance monitoring integrations could not be automatically loaded.");
      }
      return loadedIntegrations.filter((integration) => !!integration.loadDependency());
    }
    exports.autoDiscoverNodePerformanceMonitoringIntegrations = autoDiscoverNodePerformanceMonitoringIntegrations;
  }
});

// ../../../node_modules/.pnpm/@sentry+node@7.120.2/node_modules/@sentry/node/cjs/client.js
var require_client2 = __commonJS({
  "../../../node_modules/.pnpm/@sentry+node@7.120.2/node_modules/@sentry/node/cjs/client.js"(exports) {
    init_define_ENV_DEFINED_IN_BUILD_STEP();
    Object.defineProperty(exports, "__esModule", { value: true });
    var os = __require("os");
    var util = __require("util");
    var core = require_cjs2();
    var NodeClient = class extends core.ServerRuntimeClient {
      /**
       * Creates a new Node SDK instance.
       * @param options Configuration options for this SDK.
       */
      constructor(options) {
        core.applySdkMetadata(options, "node");
        options.transportOptions = {
          textEncoder: new util.TextEncoder(),
          ...options.transportOptions
        };
        const clientOptions = {
          ...options,
          platform: "node",
          runtime: { name: "node", version: global.process.version },
          serverName: options.serverName || global.process.env.SENTRY_NAME || os.hostname()
        };
        super(clientOptions);
      }
    };
    exports.NodeClient = NodeClient;
  }
});

// ../../../node_modules/.pnpm/@sentry+node@7.120.2/node_modules/@sentry/node/cjs/proxy/base.js
var require_base2 = __commonJS({
  "../../../node_modules/.pnpm/@sentry+node@7.120.2/node_modules/@sentry/node/cjs/proxy/base.js"(exports) {
    init_define_ENV_DEFINED_IN_BUILD_STEP();
    var {
      _nullishCoalesce
    } = require_cjs();
    Object.defineProperty(exports, "__esModule", { value: true });
    var http = __require("http");
    __require("https");
    var INTERNAL = Symbol("AgentBaseInternalState");
    var Agent = class extends http.Agent {
      // Set by `http.Agent` - missing from `@types/node`
      constructor(opts) {
        super(opts);
        this[INTERNAL] = {};
      }
      /**
       * Determine whether this is an `http` or `https` request.
       */
      isSecureEndpoint(options) {
        if (options) {
          if (typeof options.secureEndpoint === "boolean") {
            return options.secureEndpoint;
          }
          if (typeof options.protocol === "string") {
            return options.protocol === "https:";
          }
        }
        const { stack } = new Error();
        if (typeof stack !== "string")
          return false;
        return stack.split("\n").some((l2) => l2.indexOf("(https.js:") !== -1 || l2.indexOf("node:https:") !== -1);
      }
      createSocket(req, options, cb) {
        const connectOpts = {
          ...options,
          secureEndpoint: this.isSecureEndpoint(options)
        };
        Promise.resolve().then(() => this.connect(req, connectOpts)).then((socket) => {
          if (socket instanceof http.Agent) {
            return socket.addRequest(req, connectOpts);
          }
          this[INTERNAL].currentSocket = socket;
          super.createSocket(req, options, cb);
        }, cb);
      }
      createConnection() {
        const socket = this[INTERNAL].currentSocket;
        this[INTERNAL].currentSocket = void 0;
        if (!socket) {
          throw new Error("No socket was returned in the `connect()` function");
        }
        return socket;
      }
      get defaultPort() {
        return _nullishCoalesce(this[INTERNAL].defaultPort, () => this.protocol === "https:" ? 443 : 80);
      }
      set defaultPort(v3) {
        if (this[INTERNAL]) {
          this[INTERNAL].defaultPort = v3;
        }
      }
      get protocol() {
        return _nullishCoalesce(this[INTERNAL].protocol, () => this.isSecureEndpoint() ? "https:" : "http:");
      }
      set protocol(v3) {
        if (this[INTERNAL]) {
          this[INTERNAL].protocol = v3;
        }
      }
    };
    exports.Agent = Agent;
  }
});

// ../../../node_modules/.pnpm/@sentry+node@7.120.2/node_modules/@sentry/node/cjs/proxy/parse-proxy-response.js
var require_parse_proxy_response = __commonJS({
  "../../../node_modules/.pnpm/@sentry+node@7.120.2/node_modules/@sentry/node/cjs/proxy/parse-proxy-response.js"(exports) {
    init_define_ENV_DEFINED_IN_BUILD_STEP();
    Object.defineProperty(exports, "__esModule", { value: true });
    var utils = require_cjs();
    function debug(...args) {
      utils.logger.log("[https-proxy-agent:parse-proxy-response]", ...args);
    }
    function parseProxyResponse(socket) {
      return new Promise((resolve2, reject) => {
        let buffersLength = 0;
        const buffers = [];
        function read() {
          const b = socket.read();
          if (b)
            ondata(b);
          else
            socket.once("readable", read);
        }
        function cleanup() {
          socket.removeListener("end", onend);
          socket.removeListener("error", onerror);
          socket.removeListener("readable", read);
        }
        function onend() {
          cleanup();
          debug("onend");
          reject(new Error("Proxy connection ended before receiving CONNECT response"));
        }
        function onerror(err) {
          cleanup();
          debug("onerror %o", err);
          reject(err);
        }
        function ondata(b) {
          buffers.push(b);
          buffersLength += b.length;
          const buffered = Buffer.concat(buffers, buffersLength);
          const endOfHeaders = buffered.indexOf("\r\n\r\n");
          if (endOfHeaders === -1) {
            debug("have not received end of HTTP headers yet...");
            read();
            return;
          }
          const headerParts = buffered.slice(0, endOfHeaders).toString("ascii").split("\r\n");
          const firstLine = headerParts.shift();
          if (!firstLine) {
            socket.destroy();
            return reject(new Error("No header received from proxy CONNECT response"));
          }
          const firstLineParts = firstLine.split(" ");
          const statusCode = +firstLineParts[1];
          const statusText = firstLineParts.slice(2).join(" ");
          const headers = {};
          for (const header of headerParts) {
            if (!header)
              continue;
            const firstColon = header.indexOf(":");
            if (firstColon === -1) {
              socket.destroy();
              return reject(new Error(`Invalid header from proxy CONNECT response: "${header}"`));
            }
            const key = header.slice(0, firstColon).toLowerCase();
            const value = header.slice(firstColon + 1).trimStart();
            const current = headers[key];
            if (typeof current === "string") {
              headers[key] = [current, value];
            } else if (Array.isArray(current)) {
              current.push(value);
            } else {
              headers[key] = value;
            }
          }
          debug("got proxy server response: %o %o", firstLine, headers);
          cleanup();
          resolve2({
            connect: {
              statusCode,
              statusText,
              headers
            },
            buffered
          });
        }
        socket.on("error", onerror);
        socket.on("end", onend);
        read();
      });
    }
    exports.parseProxyResponse = parseProxyResponse;
  }
});

// ../../../node_modules/.pnpm/@sentry+node@7.120.2/node_modules/@sentry/node/cjs/proxy/index.js
var require_proxy = __commonJS({
  "../../../node_modules/.pnpm/@sentry+node@7.120.2/node_modules/@sentry/node/cjs/proxy/index.js"(exports) {
    init_define_ENV_DEFINED_IN_BUILD_STEP();
    var {
      _nullishCoalesce,
      _optionalChain
    } = require_cjs();
    Object.defineProperty(exports, "__esModule", { value: true });
    var net = __require("net");
    var tls = __require("tls");
    var url = __require("url");
    var utils = require_cjs();
    var base = require_base2();
    var parseProxyResponse = require_parse_proxy_response();
    function debug(...args) {
      utils.logger.log("[https-proxy-agent]", ...args);
    }
    var HttpsProxyAgent = class extends base.Agent {
      static __initStatic() {
        this.protocols = ["http", "https"];
      }
      constructor(proxy, opts) {
        super(opts);
        this.options = {};
        this.proxy = typeof proxy === "string" ? new url.URL(proxy) : proxy;
        this.proxyHeaders = _nullishCoalesce(_optionalChain([opts, "optionalAccess", (_22) => _22.headers]), () => ({}));
        debug("Creating new HttpsProxyAgent instance: %o", this.proxy.href);
        const host = (this.proxy.hostname || this.proxy.host).replace(/^\[|\]$/g, "");
        const port = this.proxy.port ? parseInt(this.proxy.port, 10) : this.proxy.protocol === "https:" ? 443 : 80;
        this.connectOpts = {
          // Attempt to negotiate http/1.1 for proxy servers that support http/2
          ALPNProtocols: ["http/1.1"],
          ...opts ? omit(opts, "headers") : null,
          host,
          port
        };
      }
      /**
       * Called when the node-core HTTP client library is creating a
       * new HTTP request.
       */
      async connect(req, opts) {
        const { proxy } = this;
        if (!opts.host) {
          throw new TypeError('No "host" provided');
        }
        let socket;
        if (proxy.protocol === "https:") {
          debug("Creating `tls.Socket`: %o", this.connectOpts);
          const servername = this.connectOpts.servername || this.connectOpts.host;
          socket = tls.connect({
            ...this.connectOpts,
            servername: servername && net.isIP(servername) ? void 0 : servername
          });
        } else {
          debug("Creating `net.Socket`: %o", this.connectOpts);
          socket = net.connect(this.connectOpts);
        }
        const headers = typeof this.proxyHeaders === "function" ? this.proxyHeaders() : { ...this.proxyHeaders };
        const host = net.isIPv6(opts.host) ? `[${opts.host}]` : opts.host;
        let payload = `CONNECT ${host}:${opts.port} HTTP/1.1\r
`;
        if (proxy.username || proxy.password) {
          const auth = `${decodeURIComponent(proxy.username)}:${decodeURIComponent(proxy.password)}`;
          headers["Proxy-Authorization"] = `Basic ${Buffer.from(auth).toString("base64")}`;
        }
        headers.Host = `${host}:${opts.port}`;
        if (!headers["Proxy-Connection"]) {
          headers["Proxy-Connection"] = this.keepAlive ? "Keep-Alive" : "close";
        }
        for (const name of Object.keys(headers)) {
          payload += `${name}: ${headers[name]}\r
`;
        }
        const proxyResponsePromise = parseProxyResponse.parseProxyResponse(socket);
        socket.write(`${payload}\r
`);
        const { connect, buffered } = await proxyResponsePromise;
        req.emit("proxyConnect", connect);
        this.emit("proxyConnect", connect, req);
        if (connect.statusCode === 200) {
          req.once("socket", resume);
          if (opts.secureEndpoint) {
            debug("Upgrading socket connection to TLS");
            const servername = opts.servername || opts.host;
            return tls.connect({
              ...omit(opts, "host", "path", "port"),
              socket,
              servername: net.isIP(servername) ? void 0 : servername
            });
          }
          return socket;
        }
        socket.destroy();
        const fakeSocket = new net.Socket({ writable: false });
        fakeSocket.readable = true;
        req.once("socket", (s2) => {
          debug("Replaying proxy buffer for failed request");
          s2.push(buffered);
          s2.push(null);
        });
        return fakeSocket;
      }
    };
    HttpsProxyAgent.__initStatic();
    function resume(socket) {
      socket.resume();
    }
    function omit(obj, ...keys) {
      const ret = {};
      let key;
      for (key in obj) {
        if (!keys.includes(key)) {
          ret[key] = obj[key];
        }
      }
      return ret;
    }
    exports.HttpsProxyAgent = HttpsProxyAgent;
  }
});

// ../../../node_modules/.pnpm/@sentry+node@7.120.2/node_modules/@sentry/node/cjs/transports/http.js
var require_http = __commonJS({
  "../../../node_modules/.pnpm/@sentry+node@7.120.2/node_modules/@sentry/node/cjs/transports/http.js"(exports) {
    init_define_ENV_DEFINED_IN_BUILD_STEP();
    var {
      _nullishCoalesce
    } = require_cjs();
    Object.defineProperty(exports, "__esModule", { value: true });
    var http = __require("http");
    var https = __require("https");
    var stream = __require("stream");
    var url = __require("url");
    var zlib = __require("zlib");
    var core = require_cjs2();
    var utils = require_cjs();
    var index = require_proxy();
    var GZIP_THRESHOLD = 1024 * 32;
    function streamFromBody(body) {
      return new stream.Readable({
        read() {
          this.push(body);
          this.push(null);
        }
      });
    }
    function makeNodeTransport(options) {
      let urlSegments;
      try {
        urlSegments = new url.URL(options.url);
      } catch (e2) {
        utils.consoleSandbox(() => {
          console.warn(
            "[@sentry/node]: Invalid dsn or tunnel option, will not send any events. The tunnel option must be a full URL when used."
          );
        });
        return core.createTransport(options, () => Promise.resolve({}));
      }
      const isHttps = urlSegments.protocol === "https:";
      const proxy = applyNoProxyOption(
        urlSegments,
        options.proxy || (isHttps ? process.env.https_proxy : void 0) || process.env.http_proxy
      );
      const nativeHttpModule = isHttps ? https : http;
      const keepAlive = options.keepAlive === void 0 ? false : options.keepAlive;
      const agent = proxy ? new index.HttpsProxyAgent(proxy) : new nativeHttpModule.Agent({ keepAlive, maxSockets: 30, timeout: 2e3 });
      const requestExecutor = createRequestExecutor(options, _nullishCoalesce(options.httpModule, () => nativeHttpModule), agent);
      return core.createTransport(options, requestExecutor);
    }
    function applyNoProxyOption(transportUrlSegments, proxy) {
      const { no_proxy } = process.env;
      const urlIsExemptFromProxy = no_proxy && no_proxy.split(",").some(
        (exemption) => transportUrlSegments.host.endsWith(exemption) || transportUrlSegments.hostname.endsWith(exemption)
      );
      if (urlIsExemptFromProxy) {
        return void 0;
      } else {
        return proxy;
      }
    }
    function createRequestExecutor(options, httpModule, agent) {
      const { hostname, pathname, port, protocol, search } = new url.URL(options.url);
      return function makeRequest(request) {
        return new Promise((resolve2, reject) => {
          let body = streamFromBody(request.body);
          const headers = { ...options.headers };
          if (request.body.length > GZIP_THRESHOLD) {
            headers["content-encoding"] = "gzip";
            body = body.pipe(zlib.createGzip());
          }
          const req = httpModule.request(
            {
              method: "POST",
              agent,
              headers,
              hostname,
              path: `${pathname}${search}`,
              port,
              protocol,
              ca: options.caCerts
            },
            (res) => {
              res.on("data", () => {
              });
              res.on("end", () => {
              });
              res.setEncoding("utf8");
              const retryAfterHeader = _nullishCoalesce(res.headers["retry-after"], () => null);
              const rateLimitsHeader = _nullishCoalesce(res.headers["x-sentry-rate-limits"], () => null);
              resolve2({
                statusCode: res.statusCode,
                headers: {
                  "retry-after": retryAfterHeader,
                  "x-sentry-rate-limits": Array.isArray(rateLimitsHeader) ? rateLimitsHeader[0] : rateLimitsHeader
                }
              });
            }
          );
          req.on("error", reject);
          body.pipe(req);
        });
      };
    }
    exports.makeNodeTransport = makeNodeTransport;
  }
});

// ../../../node_modules/.pnpm/@sentry+node@7.120.2/node_modules/@sentry/node/cjs/nodeVersion.js
var require_nodeVersion = __commonJS({
  "../../../node_modules/.pnpm/@sentry+node@7.120.2/node_modules/@sentry/node/cjs/nodeVersion.js"(exports) {
    init_define_ENV_DEFINED_IN_BUILD_STEP();
    Object.defineProperty(exports, "__esModule", { value: true });
    var utils = require_cjs();
    var NODE_VERSION = utils.parseSemver(process.versions.node);
    exports.NODE_VERSION = NODE_VERSION;
  }
});

// ../../../node_modules/.pnpm/@sentry+node@7.120.2/node_modules/@sentry/node/cjs/async/domain.js
var require_domain = __commonJS({
  "../../../node_modules/.pnpm/@sentry+node@7.120.2/node_modules/@sentry/node/cjs/async/domain.js"(exports) {
    init_define_ENV_DEFINED_IN_BUILD_STEP();
    var {
      _optionalChain
    } = require_cjs();
    Object.defineProperty(exports, "__esModule", { value: true });
    var domain = __require("domain");
    var core = require_cjs2();
    function getActiveDomain() {
      return domain.active;
    }
    function getCurrentHub() {
      const activeDomain = getActiveDomain();
      if (!activeDomain) {
        return void 0;
      }
      core.ensureHubOnCarrier(activeDomain);
      return core.getHubFromCarrier(activeDomain);
    }
    function createNewHub(parent) {
      const carrier = {};
      core.ensureHubOnCarrier(carrier, parent);
      return core.getHubFromCarrier(carrier);
    }
    function runWithAsyncContext(callback, options) {
      const activeDomain = getActiveDomain();
      if (activeDomain && _optionalChain([options, "optionalAccess", (_3) => _3.reuseExisting])) {
        return callback();
      }
      const local = domain.create();
      const parentHub = activeDomain ? core.getHubFromCarrier(activeDomain) : void 0;
      const newHub = createNewHub(parentHub);
      core.setHubOnCarrier(local, newHub);
      return local.bind(() => {
        return callback();
      })();
    }
    function setDomainAsyncContextStrategy() {
      core.setAsyncContextStrategy({ getCurrentHub, runWithAsyncContext });
    }
    exports.setDomainAsyncContextStrategy = setDomainAsyncContextStrategy;
  }
});

// ../../../node_modules/.pnpm/@sentry+node@7.120.2/node_modules/@sentry/node/cjs/async/hooks.js
var require_hooks = __commonJS({
  "../../../node_modules/.pnpm/@sentry+node@7.120.2/node_modules/@sentry/node/cjs/async/hooks.js"(exports) {
    init_define_ENV_DEFINED_IN_BUILD_STEP();
    var {
      _optionalChain
    } = require_cjs();
    Object.defineProperty(exports, "__esModule", { value: true });
    var core = require_cjs2();
    var async_hooks = __require("async_hooks");
    var asyncStorage;
    function setHooksAsyncContextStrategy() {
      if (!asyncStorage) {
        asyncStorage = new async_hooks.AsyncLocalStorage();
      }
      function getCurrentHub() {
        return asyncStorage.getStore();
      }
      function createNewHub(parent) {
        const carrier = {};
        core.ensureHubOnCarrier(carrier, parent);
        return core.getHubFromCarrier(carrier);
      }
      function runWithAsyncContext(callback, options) {
        const existingHub = getCurrentHub();
        if (existingHub && _optionalChain([options, "optionalAccess", (_3) => _3.reuseExisting])) {
          return callback();
        }
        const newHub = createNewHub(existingHub);
        return asyncStorage.run(newHub, () => {
          return callback();
        });
      }
      core.setAsyncContextStrategy({ getCurrentHub, runWithAsyncContext });
    }
    exports.setHooksAsyncContextStrategy = setHooksAsyncContextStrategy;
  }
});

// ../../../node_modules/.pnpm/@sentry+node@7.120.2/node_modules/@sentry/node/cjs/async/index.js
var require_async = __commonJS({
  "../../../node_modules/.pnpm/@sentry+node@7.120.2/node_modules/@sentry/node/cjs/async/index.js"(exports) {
    init_define_ENV_DEFINED_IN_BUILD_STEP();
    Object.defineProperty(exports, "__esModule", { value: true });
    var nodeVersion = require_nodeVersion();
    var domain = require_domain();
    var hooks = require_hooks();
    function setNodeAsyncContextStrategy() {
      if (nodeVersion.NODE_VERSION.major >= 14) {
        hooks.setHooksAsyncContextStrategy();
      } else {
        domain.setDomainAsyncContextStrategy();
      }
    }
    exports.setNodeAsyncContextStrategy = setNodeAsyncContextStrategy;
  }
});

// ../../../node_modules/.pnpm/@sentry+node@7.120.2/node_modules/@sentry/node/cjs/integrations/console.js
var require_console2 = __commonJS({
  "../../../node_modules/.pnpm/@sentry+node@7.120.2/node_modules/@sentry/node/cjs/integrations/console.js"(exports) {
    init_define_ENV_DEFINED_IN_BUILD_STEP();
    Object.defineProperty(exports, "__esModule", { value: true });
    var util = __require("util");
    var core = require_cjs2();
    var utils = require_cjs();
    var INTEGRATION_NAME = "Console";
    var _consoleIntegration = () => {
      return {
        name: INTEGRATION_NAME,
        // TODO v8: Remove this
        setupOnce() {
        },
        // eslint-disable-line @typescript-eslint/no-empty-function
        setup(client) {
          utils.addConsoleInstrumentationHandler(({ args, level }) => {
            if (core.getClient() !== client) {
              return;
            }
            core.addBreadcrumb(
              {
                category: "console",
                level: utils.severityLevelFromString(level),
                message: util.format.apply(void 0, args)
              },
              {
                input: [...args],
                level
              }
            );
          });
        }
      };
    };
    var consoleIntegration = core.defineIntegration(_consoleIntegration);
    var Console = core.convertIntegrationFnToClass(INTEGRATION_NAME, consoleIntegration);
    exports.Console = Console;
    exports.consoleIntegration = consoleIntegration;
  }
});

// ../../../node_modules/.pnpm/@sentry+node@7.120.2/node_modules/@sentry/node/cjs/integrations/context.js
var require_context = __commonJS({
  "../../../node_modules/.pnpm/@sentry+node@7.120.2/node_modules/@sentry/node/cjs/integrations/context.js"(exports) {
    init_define_ENV_DEFINED_IN_BUILD_STEP();
    var {
      _optionalChain
    } = require_cjs();
    Object.defineProperty(exports, "__esModule", { value: true });
    var child_process = __require("child_process");
    var fs3 = __require("fs");
    var os = __require("os");
    var path2 = __require("path");
    var util = __require("util");
    var core = require_cjs2();
    var readFileAsync = util.promisify(fs3.readFile);
    var readDirAsync = util.promisify(fs3.readdir);
    var INTEGRATION_NAME = "Context";
    var _nodeContextIntegration = (options = {}) => {
      let cachedContext;
      const _options = {
        app: true,
        os: true,
        device: true,
        culture: true,
        cloudResource: true,
        ...options
      };
      async function addContext(event) {
        if (cachedContext === void 0) {
          cachedContext = _getContexts();
        }
        const updatedContext = _updateContext(await cachedContext);
        event.contexts = {
          ...event.contexts,
          app: { ...updatedContext.app, ..._optionalChain([event, "access", (_3) => _3.contexts, "optionalAccess", (_22) => _22.app]) },
          os: { ...updatedContext.os, ..._optionalChain([event, "access", (_3) => _3.contexts, "optionalAccess", (_4) => _4.os]) },
          device: { ...updatedContext.device, ..._optionalChain([event, "access", (_5) => _5.contexts, "optionalAccess", (_6) => _6.device]) },
          culture: { ...updatedContext.culture, ..._optionalChain([event, "access", (_7) => _7.contexts, "optionalAccess", (_8) => _8.culture]) },
          cloud_resource: { ...updatedContext.cloud_resource, ..._optionalChain([event, "access", (_9) => _9.contexts, "optionalAccess", (_10) => _10.cloud_resource]) }
        };
        return event;
      }
      async function _getContexts() {
        const contexts = {};
        if (_options.os) {
          contexts.os = await getOsContext();
        }
        if (_options.app) {
          contexts.app = getAppContext();
        }
        if (_options.device) {
          contexts.device = getDeviceContext(_options.device);
        }
        if (_options.culture) {
          const culture = getCultureContext();
          if (culture) {
            contexts.culture = culture;
          }
        }
        if (_options.cloudResource) {
          contexts.cloud_resource = getCloudResourceContext();
        }
        return contexts;
      }
      return {
        name: INTEGRATION_NAME,
        // TODO v8: Remove this
        setupOnce() {
        },
        // eslint-disable-line @typescript-eslint/no-empty-function
        processEvent(event) {
          return addContext(event);
        }
      };
    };
    var nodeContextIntegration = core.defineIntegration(_nodeContextIntegration);
    var Context = core.convertIntegrationFnToClass(INTEGRATION_NAME, nodeContextIntegration);
    function _updateContext(contexts) {
      if (_optionalChain([contexts, "optionalAccess", (_11) => _11.app, "optionalAccess", (_12) => _12.app_memory])) {
        contexts.app.app_memory = process.memoryUsage().rss;
      }
      if (_optionalChain([contexts, "optionalAccess", (_13) => _13.device, "optionalAccess", (_14) => _14.free_memory])) {
        contexts.device.free_memory = os.freemem();
      }
      return contexts;
    }
    async function getOsContext() {
      const platformId = os.platform();
      switch (platformId) {
        case "darwin":
          return getDarwinInfo();
        case "linux":
          return getLinuxInfo();
        default:
          return {
            name: PLATFORM_NAMES[platformId] || platformId,
            version: os.release()
          };
      }
    }
    function getCultureContext() {
      try {
        if (typeof process.versions.icu !== "string") {
          return;
        }
        const january = /* @__PURE__ */ new Date(9e8);
        const spanish = new Intl.DateTimeFormat("es", { month: "long" });
        if (spanish.format(january) === "enero") {
          const options = Intl.DateTimeFormat().resolvedOptions();
          return {
            locale: options.locale,
            timezone: options.timeZone
          };
        }
      } catch (err) {
      }
      return;
    }
    function getAppContext() {
      const app_memory = process.memoryUsage().rss;
      const app_start_time = new Date(Date.now() - process.uptime() * 1e3).toISOString();
      return { app_start_time, app_memory };
    }
    function getDeviceContext(deviceOpt) {
      const device = {};
      let uptime;
      try {
        uptime = os.uptime && os.uptime();
      } catch (e2) {
      }
      if (typeof uptime === "number") {
        device.boot_time = new Date(Date.now() - uptime * 1e3).toISOString();
      }
      device.arch = os.arch();
      if (deviceOpt === true || deviceOpt.memory) {
        device.memory_size = os.totalmem();
        device.free_memory = os.freemem();
      }
      if (deviceOpt === true || deviceOpt.cpu) {
        const cpuInfo = os.cpus();
        if (cpuInfo && cpuInfo.length) {
          const firstCpu = cpuInfo[0];
          device.processor_count = cpuInfo.length;
          device.cpu_description = firstCpu.model;
          device.processor_frequency = firstCpu.speed;
        }
      }
      return device;
    }
    var PLATFORM_NAMES = {
      aix: "IBM AIX",
      freebsd: "FreeBSD",
      openbsd: "OpenBSD",
      sunos: "SunOS",
      win32: "Windows"
    };
    var LINUX_DISTROS = [
      { name: "fedora-release", distros: ["Fedora"] },
      { name: "redhat-release", distros: ["Red Hat Linux", "Centos"] },
      { name: "redhat_version", distros: ["Red Hat Linux"] },
      { name: "SuSE-release", distros: ["SUSE Linux"] },
      { name: "lsb-release", distros: ["Ubuntu Linux", "Arch Linux"] },
      { name: "debian_version", distros: ["Debian"] },
      { name: "debian_release", distros: ["Debian"] },
      { name: "arch-release", distros: ["Arch Linux"] },
      { name: "gentoo-release", distros: ["Gentoo Linux"] },
      { name: "novell-release", distros: ["SUSE Linux"] },
      { name: "alpine-release", distros: ["Alpine Linux"] }
    ];
    var LINUX_VERSIONS = {
      alpine: (content) => content,
      arch: (content) => matchFirst(/distrib_release=(.*)/, content),
      centos: (content) => matchFirst(/release ([^ ]+)/, content),
      debian: (content) => content,
      fedora: (content) => matchFirst(/release (..)/, content),
      mint: (content) => matchFirst(/distrib_release=(.*)/, content),
      red: (content) => matchFirst(/release ([^ ]+)/, content),
      suse: (content) => matchFirst(/VERSION = (.*)\n/, content),
      ubuntu: (content) => matchFirst(/distrib_release=(.*)/, content)
    };
    function matchFirst(regex2, text) {
      const match = regex2.exec(text);
      return match ? match[1] : void 0;
    }
    async function getDarwinInfo() {
      const darwinInfo = {
        kernel_version: os.release(),
        name: "Mac OS X",
        version: `10.${Number(os.release().split(".")[0]) - 4}`
      };
      try {
        const output = await new Promise((resolve2, reject) => {
          child_process.execFile("/usr/bin/sw_vers", (error, stdout2) => {
            if (error) {
              reject(error);
              return;
            }
            resolve2(stdout2);
          });
        });
        darwinInfo.name = matchFirst(/^ProductName:\s+(.*)$/m, output);
        darwinInfo.version = matchFirst(/^ProductVersion:\s+(.*)$/m, output);
        darwinInfo.build = matchFirst(/^BuildVersion:\s+(.*)$/m, output);
      } catch (e2) {
      }
      return darwinInfo;
    }
    function getLinuxDistroId(name) {
      return name.split(" ")[0].toLowerCase();
    }
    async function getLinuxInfo() {
      const linuxInfo = {
        kernel_version: os.release(),
        name: "Linux"
      };
      try {
        const etcFiles = await readDirAsync("/etc");
        const distroFile = LINUX_DISTROS.find((file) => etcFiles.includes(file.name));
        if (!distroFile) {
          return linuxInfo;
        }
        const distroPath = path2.join("/etc", distroFile.name);
        const contents = (await readFileAsync(distroPath, { encoding: "utf-8" })).toLowerCase();
        const { distros } = distroFile;
        linuxInfo.name = distros.find((d2) => contents.indexOf(getLinuxDistroId(d2)) >= 0) || distros[0];
        const id = getLinuxDistroId(linuxInfo.name);
        linuxInfo.version = LINUX_VERSIONS[id](contents);
      } catch (e2) {
      }
      return linuxInfo;
    }
    function getCloudResourceContext() {
      if (process.env.VERCEL) {
        return {
          "cloud.provider": "vercel",
          "cloud.region": process.env.VERCEL_REGION
        };
      } else if (process.env.AWS_REGION) {
        return {
          "cloud.provider": "aws",
          "cloud.region": process.env.AWS_REGION,
          "cloud.platform": process.env.AWS_EXECUTION_ENV
        };
      } else if (process.env.GCP_PROJECT) {
        return {
          "cloud.provider": "gcp"
        };
      } else if (process.env.ALIYUN_REGION_ID) {
        return {
          "cloud.provider": "alibaba_cloud",
          "cloud.region": process.env.ALIYUN_REGION_ID
        };
      } else if (process.env.WEBSITE_SITE_NAME && process.env.REGION_NAME) {
        return {
          "cloud.provider": "azure",
          "cloud.region": process.env.REGION_NAME
        };
      } else if (process.env.IBM_CLOUD_REGION) {
        return {
          "cloud.provider": "ibm_cloud",
          "cloud.region": process.env.IBM_CLOUD_REGION
        };
      } else if (process.env.TENCENTCLOUD_REGION) {
        return {
          "cloud.provider": "tencent_cloud",
          "cloud.region": process.env.TENCENTCLOUD_REGION,
          "cloud.account.id": process.env.TENCENTCLOUD_APPID,
          "cloud.availability_zone": process.env.TENCENTCLOUD_ZONE
        };
      } else if (process.env.NETLIFY) {
        return {
          "cloud.provider": "netlify"
        };
      } else if (process.env.FLY_REGION) {
        return {
          "cloud.provider": "fly.io",
          "cloud.region": process.env.FLY_REGION
        };
      } else if (process.env.DYNO) {
        return {
          "cloud.provider": "heroku"
        };
      } else {
        return void 0;
      }
    }
    exports.Context = Context;
    exports.getDeviceContext = getDeviceContext;
    exports.nodeContextIntegration = nodeContextIntegration;
    exports.readDirAsync = readDirAsync;
    exports.readFileAsync = readFileAsync;
  }
});

// ../../../node_modules/.pnpm/@sentry+node@7.120.2/node_modules/@sentry/node/cjs/integrations/contextlines.js
var require_contextlines = __commonJS({
  "../../../node_modules/.pnpm/@sentry+node@7.120.2/node_modules/@sentry/node/cjs/integrations/contextlines.js"(exports) {
    init_define_ENV_DEFINED_IN_BUILD_STEP();
    var {
      _optionalChain
    } = require_cjs();
    Object.defineProperty(exports, "__esModule", { value: true });
    var fs3 = __require("fs");
    var core = require_cjs2();
    var utils = require_cjs();
    var FILE_CONTENT_CACHE = new utils.LRUMap(100);
    var DEFAULT_LINES_OF_CONTEXT = 7;
    var INTEGRATION_NAME = "ContextLines";
    function readTextFileAsync(path2) {
      return new Promise((resolve2, reject) => {
        fs3.readFile(path2, "utf8", (err, data) => {
          if (err)
            reject(err);
          else
            resolve2(data);
        });
      });
    }
    var _contextLinesIntegration = (options = {}) => {
      const contextLines = options.frameContextLines !== void 0 ? options.frameContextLines : DEFAULT_LINES_OF_CONTEXT;
      return {
        name: INTEGRATION_NAME,
        // TODO v8: Remove this
        setupOnce() {
        },
        // eslint-disable-line @typescript-eslint/no-empty-function
        processEvent(event) {
          return addSourceContext(event, contextLines);
        }
      };
    };
    var contextLinesIntegration = core.defineIntegration(_contextLinesIntegration);
    var ContextLines = core.convertIntegrationFnToClass(INTEGRATION_NAME, contextLinesIntegration);
    async function addSourceContext(event, contextLines) {
      const enqueuedReadSourceFileTasks = {};
      const readSourceFileTasks = [];
      if (contextLines > 0 && _optionalChain([event, "access", (_22) => _22.exception, "optionalAccess", (_3) => _3.values])) {
        for (const exception of event.exception.values) {
          if (!_optionalChain([exception, "access", (_4) => _4.stacktrace, "optionalAccess", (_5) => _5.frames])) {
            continue;
          }
          for (let i2 = exception.stacktrace.frames.length - 1; i2 >= 0; i2--) {
            const frame = exception.stacktrace.frames[i2];
            if (frame.filename && !enqueuedReadSourceFileTasks[frame.filename] && !FILE_CONTENT_CACHE.get(frame.filename)) {
              readSourceFileTasks.push(_readSourceFile(frame.filename));
              enqueuedReadSourceFileTasks[frame.filename] = 1;
            }
          }
        }
      }
      if (readSourceFileTasks.length > 0) {
        await Promise.all(readSourceFileTasks);
      }
      if (contextLines > 0 && _optionalChain([event, "access", (_6) => _6.exception, "optionalAccess", (_7) => _7.values])) {
        for (const exception of event.exception.values) {
          if (exception.stacktrace && exception.stacktrace.frames) {
            await addSourceContextToFrames(exception.stacktrace.frames, contextLines);
          }
        }
      }
      return event;
    }
    function addSourceContextToFrames(frames, contextLines) {
      for (const frame of frames) {
        if (frame.filename && frame.context_line === void 0) {
          const sourceFileLines = FILE_CONTENT_CACHE.get(frame.filename);
          if (sourceFileLines) {
            try {
              utils.addContextToFrame(sourceFileLines, frame, contextLines);
            } catch (e2) {
            }
          }
        }
      }
    }
    async function _readSourceFile(filename) {
      const cachedFile = FILE_CONTENT_CACHE.get(filename);
      if (cachedFile === null) {
        return null;
      }
      if (cachedFile !== void 0) {
        return cachedFile;
      }
      let content = null;
      try {
        const rawFileContents = await readTextFileAsync(filename);
        content = rawFileContents.split("\n");
      } catch (_3) {
      }
      FILE_CONTENT_CACHE.set(filename, content);
      return content;
    }
    exports.ContextLines = ContextLines;
    exports.contextLinesIntegration = contextLinesIntegration;
  }
});

// ../../../node_modules/.pnpm/@sentry+node@7.120.2/node_modules/@sentry/node/cjs/debug-build.js
var require_debug_build4 = __commonJS({
  "../../../node_modules/.pnpm/@sentry+node@7.120.2/node_modules/@sentry/node/cjs/debug-build.js"(exports) {
    init_define_ENV_DEFINED_IN_BUILD_STEP();
    Object.defineProperty(exports, "__esModule", { value: true });
    var DEBUG_BUILD = typeof __SENTRY_DEBUG__ === "undefined" || __SENTRY_DEBUG__;
    exports.DEBUG_BUILD = DEBUG_BUILD;
  }
});

// ../../../node_modules/.pnpm/@sentry+node@7.120.2/node_modules/@sentry/node/cjs/integrations/utils/http.js
var require_http2 = __commonJS({
  "../../../node_modules/.pnpm/@sentry+node@7.120.2/node_modules/@sentry/node/cjs/integrations/utils/http.js"(exports) {
    init_define_ENV_DEFINED_IN_BUILD_STEP();
    var {
      _optionalChain
    } = require_cjs();
    Object.defineProperty(exports, "__esModule", { value: true });
    var url = __require("url");
    var nodeVersion = require_nodeVersion();
    function extractRawUrl(requestOptions) {
      const { protocol, hostname, port } = parseRequestOptions(requestOptions);
      const path2 = requestOptions.path ? requestOptions.path : "/";
      return `${protocol}//${hostname}${port}${path2}`;
    }
    function extractUrl(requestOptions) {
      const { protocol, hostname, port } = parseRequestOptions(requestOptions);
      const path2 = requestOptions.pathname || "/";
      const authority = requestOptions.auth ? redactAuthority(requestOptions.auth) : "";
      return `${protocol}//${authority}${hostname}${port}${path2}`;
    }
    function redactAuthority(auth) {
      const [user, password] = auth.split(":");
      return `${user ? "[Filtered]" : ""}:${password ? "[Filtered]" : ""}@`;
    }
    function cleanSpanDescription(description, requestOptions, request) {
      if (!description) {
        return description;
      }
      let [method, requestUrl] = description.split(" ");
      if (requestOptions.host && !requestOptions.protocol) {
        requestOptions.protocol = _optionalChain([request, "optionalAccess", (_3) => _3.agent, "optionalAccess", (_22) => _22.protocol]);
        requestUrl = extractUrl(requestOptions);
      }
      if (_optionalChain([requestUrl, "optionalAccess", (_3) => _3.startsWith, "call", (_4) => _4("///")])) {
        requestUrl = requestUrl.slice(2);
      }
      return `${method} ${requestUrl}`;
    }
    function urlToOptions(url2) {
      const options = {
        protocol: url2.protocol,
        hostname: typeof url2.hostname === "string" && url2.hostname.startsWith("[") ? url2.hostname.slice(1, -1) : url2.hostname,
        hash: url2.hash,
        search: url2.search,
        pathname: url2.pathname,
        path: `${url2.pathname || ""}${url2.search || ""}`,
        href: url2.href
      };
      if (url2.port !== "") {
        options.port = Number(url2.port);
      }
      if (url2.username || url2.password) {
        options.auth = `${url2.username}:${url2.password}`;
      }
      return options;
    }
    function normalizeRequestArgs(httpModule, requestArgs) {
      let callback, requestOptions;
      if (typeof requestArgs[requestArgs.length - 1] === "function") {
        callback = requestArgs.pop();
      }
      if (typeof requestArgs[0] === "string") {
        requestOptions = urlToOptions(new url.URL(requestArgs[0]));
      } else if (requestArgs[0] instanceof url.URL) {
        requestOptions = urlToOptions(requestArgs[0]);
      } else {
        requestOptions = requestArgs[0];
        try {
          const parsed = new url.URL(
            requestOptions.path || "",
            `${requestOptions.protocol || "http:"}//${requestOptions.hostname}`
          );
          requestOptions = {
            pathname: parsed.pathname,
            search: parsed.search,
            hash: parsed.hash,
            ...requestOptions
          };
        } catch (e2) {
        }
      }
      if (requestArgs.length === 2) {
        requestOptions = { ...requestOptions, ...requestArgs[1] };
      }
      if (requestOptions.protocol === void 0) {
        if (nodeVersion.NODE_VERSION.major > 8) {
          requestOptions.protocol = _optionalChain([_optionalChain([httpModule, "optionalAccess", (_5) => _5.globalAgent]), "optionalAccess", (_6) => _6.protocol]) || _optionalChain([requestOptions.agent, "optionalAccess", (_7) => _7.protocol]) || _optionalChain([requestOptions._defaultAgent, "optionalAccess", (_8) => _8.protocol]);
        } else {
          requestOptions.protocol = _optionalChain([requestOptions.agent, "optionalAccess", (_9) => _9.protocol]) || _optionalChain([requestOptions._defaultAgent, "optionalAccess", (_10) => _10.protocol]) || _optionalChain([_optionalChain([httpModule, "optionalAccess", (_11) => _11.globalAgent]), "optionalAccess", (_12) => _12.protocol]);
        }
      }
      if (callback) {
        return [requestOptions, callback];
      } else {
        return [requestOptions];
      }
    }
    function parseRequestOptions(requestOptions) {
      const protocol = requestOptions.protocol || "";
      const hostname = requestOptions.hostname || requestOptions.host || "";
      const port = !requestOptions.port || requestOptions.port === 80 || requestOptions.port === 443 || /^(.*):(\d+)$/.test(hostname) ? "" : `:${requestOptions.port}`;
      return { protocol, hostname, port };
    }
    exports.cleanSpanDescription = cleanSpanDescription;
    exports.extractRawUrl = extractRawUrl;
    exports.extractUrl = extractUrl;
    exports.normalizeRequestArgs = normalizeRequestArgs;
    exports.urlToOptions = urlToOptions;
  }
});

// ../../../node_modules/.pnpm/@sentry+node@7.120.2/node_modules/@sentry/node/cjs/integrations/http.js
var require_http3 = __commonJS({
  "../../../node_modules/.pnpm/@sentry+node@7.120.2/node_modules/@sentry/node/cjs/integrations/http.js"(exports) {
    init_define_ENV_DEFINED_IN_BUILD_STEP();
    var {
      _optionalChain
    } = require_cjs();
    Object.defineProperty(exports, "__esModule", { value: true });
    var core = require_cjs2();
    var utils = require_cjs();
    var debugBuild = require_debug_build4();
    var nodeVersion = require_nodeVersion();
    var http = require_http2();
    var _httpIntegration = (options = {}) => {
      const { breadcrumbs, tracing, shouldCreateSpanForRequest } = options;
      const convertedOptions = {
        breadcrumbs,
        tracing: tracing === false ? false : utils.dropUndefinedKeys({
          // If tracing is forced to `true`, we don't want to set `enableIfHasTracingEnabled`
          enableIfHasTracingEnabled: tracing === true ? void 0 : true,
          shouldCreateSpanForRequest
        })
      };
      return new Http(convertedOptions);
    };
    var httpIntegration = core.defineIntegration(_httpIntegration);
    var Http = class _Http {
      /**
       * @inheritDoc
       */
      static __initStatic() {
        this.id = "Http";
      }
      /**
       * @inheritDoc
       */
      // eslint-disable-next-line deprecation/deprecation
      __init() {
        this.name = _Http.id;
      }
      /**
       * @inheritDoc
       */
      constructor(options = {}) {
        _Http.prototype.__init.call(this);
        this._breadcrumbs = typeof options.breadcrumbs === "undefined" ? true : options.breadcrumbs;
        this._tracing = !options.tracing ? void 0 : options.tracing === true ? {} : options.tracing;
      }
      /**
       * @inheritDoc
       */
      setupOnce(_addGlobalEventProcessor, setupOnceGetCurrentHub) {
        const clientOptions = _optionalChain([setupOnceGetCurrentHub, "call", (_3) => _3(), "access", (_22) => _22.getClient, "call", (_3) => _3(), "optionalAccess", (_4) => _4.getOptions, "call", (_5) => _5()]);
        const shouldCreateSpans = _shouldCreateSpans(this._tracing, clientOptions);
        if (!this._breadcrumbs && !shouldCreateSpans) {
          return;
        }
        if (clientOptions && clientOptions.instrumenter !== "sentry") {
          debugBuild.DEBUG_BUILD && utils.logger.log("HTTP Integration is skipped because of instrumenter configuration.");
          return;
        }
        const shouldCreateSpanForRequest = _getShouldCreateSpanForRequest(shouldCreateSpans, this._tracing, clientOptions);
        const tracePropagationTargets = _optionalChain([clientOptions, "optionalAccess", (_6) => _6.tracePropagationTargets]) || _optionalChain([this, "access", (_7) => _7._tracing, "optionalAccess", (_8) => _8.tracePropagationTargets]);
        const httpModule = __require("http");
        const wrappedHttpHandlerMaker = _createWrappedRequestMethodFactory(
          httpModule,
          this._breadcrumbs,
          shouldCreateSpanForRequest,
          tracePropagationTargets
        );
        utils.fill(httpModule, "get", wrappedHttpHandlerMaker);
        utils.fill(httpModule, "request", wrappedHttpHandlerMaker);
        if (nodeVersion.NODE_VERSION.major > 8) {
          const httpsModule = __require("https");
          const wrappedHttpsHandlerMaker = _createWrappedRequestMethodFactory(
            httpsModule,
            this._breadcrumbs,
            shouldCreateSpanForRequest,
            tracePropagationTargets
          );
          utils.fill(httpsModule, "get", wrappedHttpsHandlerMaker);
          utils.fill(httpsModule, "request", wrappedHttpsHandlerMaker);
        }
      }
    };
    Http.__initStatic();
    function _createWrappedRequestMethodFactory(httpModule, breadcrumbsEnabled, shouldCreateSpanForRequest, tracePropagationTargets) {
      const createSpanUrlMap = new utils.LRUMap(100);
      const headersUrlMap = new utils.LRUMap(100);
      const shouldCreateSpan = (url) => {
        if (shouldCreateSpanForRequest === void 0) {
          return true;
        }
        const cachedDecision = createSpanUrlMap.get(url);
        if (cachedDecision !== void 0) {
          return cachedDecision;
        }
        const decision = shouldCreateSpanForRequest(url);
        createSpanUrlMap.set(url, decision);
        return decision;
      };
      const shouldAttachTraceData = (url) => {
        if (tracePropagationTargets === void 0) {
          return true;
        }
        const cachedDecision = headersUrlMap.get(url);
        if (cachedDecision !== void 0) {
          return cachedDecision;
        }
        const decision = utils.stringMatchesSomePattern(url, tracePropagationTargets);
        headersUrlMap.set(url, decision);
        return decision;
      };
      function addRequestBreadcrumb(event, requestSpanData, req, res) {
        if (!core.getCurrentHub().getIntegration(Http)) {
          return;
        }
        core.addBreadcrumb(
          {
            category: "http",
            data: {
              status_code: res && res.statusCode,
              ...requestSpanData
            },
            type: "http"
          },
          {
            event,
            request: req,
            response: res
          }
        );
      }
      return function wrappedRequestMethodFactory(originalRequestMethod) {
        return function wrappedMethod(...args) {
          const requestArgs = http.normalizeRequestArgs(httpModule, args);
          const requestOptions = requestArgs[0];
          const rawRequestUrl = http.extractRawUrl(requestOptions);
          const requestUrl = http.extractUrl(requestOptions);
          const client = core.getClient();
          if (core.isSentryRequestUrl(requestUrl, client)) {
            return originalRequestMethod.apply(httpModule, requestArgs);
          }
          const scope = core.getCurrentScope();
          const isolationScope = core.getIsolationScope();
          const parentSpan = core.getActiveSpan();
          const data = getRequestSpanData(requestUrl, requestOptions);
          const requestSpan = shouldCreateSpan(rawRequestUrl) ? (
            // eslint-disable-next-line deprecation/deprecation
            _optionalChain([parentSpan, "optionalAccess", (_9) => _9.startChild, "call", (_10) => _10({
              op: "http.client",
              origin: "auto.http.node.http",
              description: `${data["http.method"]} ${data.url}`,
              data
            })])
          ) : void 0;
          if (client && shouldAttachTraceData(rawRequestUrl)) {
            const { traceId, spanId, sampled, dsc } = {
              ...isolationScope.getPropagationContext(),
              ...scope.getPropagationContext()
            };
            const sentryTraceHeader = requestSpan ? core.spanToTraceHeader(requestSpan) : utils.generateSentryTraceHeader(traceId, spanId, sampled);
            const sentryBaggageHeader = utils.dynamicSamplingContextToSentryBaggageHeader(
              dsc || (requestSpan ? core.getDynamicSamplingContextFromSpan(requestSpan) : core.getDynamicSamplingContextFromClient(traceId, client, scope))
            );
            addHeadersToRequestOptions(requestOptions, requestUrl, sentryTraceHeader, sentryBaggageHeader);
          } else {
            debugBuild.DEBUG_BUILD && utils.logger.log(
              `[Tracing] Not adding sentry-trace header to outgoing request (${requestUrl}) due to mismatching tracePropagationTargets option.`
            );
          }
          return originalRequestMethod.apply(httpModule, requestArgs).once("response", function(res) {
            const req = this;
            if (breadcrumbsEnabled) {
              addRequestBreadcrumb("response", data, req, res);
            }
            if (requestSpan) {
              if (res.statusCode) {
                core.setHttpStatus(requestSpan, res.statusCode);
              }
              requestSpan.updateName(
                http.cleanSpanDescription(core.spanToJSON(requestSpan).description || "", requestOptions, req) || ""
              );
              requestSpan.end();
            }
          }).once("error", function() {
            const req = this;
            if (breadcrumbsEnabled) {
              addRequestBreadcrumb("error", data, req);
            }
            if (requestSpan) {
              core.setHttpStatus(requestSpan, 500);
              requestSpan.updateName(
                http.cleanSpanDescription(core.spanToJSON(requestSpan).description || "", requestOptions, req) || ""
              );
              requestSpan.end();
            }
          });
        };
      };
    }
    function addHeadersToRequestOptions(requestOptions, requestUrl, sentryTraceHeader, sentryBaggageHeader) {
      const headers = requestOptions.headers || {};
      if (headers["sentry-trace"]) {
        return;
      }
      debugBuild.DEBUG_BUILD && utils.logger.log(`[Tracing] Adding sentry-trace header ${sentryTraceHeader} to outgoing request to "${requestUrl}": `);
      requestOptions.headers = {
        ...requestOptions.headers,
        "sentry-trace": sentryTraceHeader,
        // Setting a header to `undefined` will crash in node so we only set the baggage header when it's defined
        ...sentryBaggageHeader && sentryBaggageHeader.length > 0 && { baggage: normalizeBaggageHeader(requestOptions, sentryBaggageHeader) }
      };
    }
    function getRequestSpanData(requestUrl, requestOptions) {
      const method = requestOptions.method || "GET";
      const data = {
        url: requestUrl,
        "http.method": method
      };
      if (requestOptions.hash) {
        data["http.fragment"] = requestOptions.hash.substring(1);
      }
      if (requestOptions.search) {
        data["http.query"] = requestOptions.search.substring(1);
      }
      return data;
    }
    function normalizeBaggageHeader(requestOptions, sentryBaggageHeader) {
      if (!requestOptions.headers || !requestOptions.headers.baggage) {
        return sentryBaggageHeader;
      } else if (!sentryBaggageHeader) {
        return requestOptions.headers.baggage;
      } else if (Array.isArray(requestOptions.headers.baggage)) {
        return [...requestOptions.headers.baggage, sentryBaggageHeader];
      }
      return [requestOptions.headers.baggage, sentryBaggageHeader];
    }
    function _shouldCreateSpans(tracingOptions, clientOptions) {
      return tracingOptions === void 0 ? false : tracingOptions.enableIfHasTracingEnabled ? core.hasTracingEnabled(clientOptions) : true;
    }
    function _getShouldCreateSpanForRequest(shouldCreateSpans, tracingOptions, clientOptions) {
      const handler = shouldCreateSpans ? (
        // eslint-disable-next-line deprecation/deprecation
        _optionalChain([tracingOptions, "optionalAccess", (_11) => _11.shouldCreateSpanForRequest]) || _optionalChain([clientOptions, "optionalAccess", (_12) => _12.shouldCreateSpanForRequest])
      ) : () => false;
      return handler;
    }
    exports.Http = Http;
    exports._getShouldCreateSpanForRequest = _getShouldCreateSpanForRequest;
    exports._shouldCreateSpans = _shouldCreateSpans;
    exports.httpIntegration = httpIntegration;
  }
});

// ../../../node_modules/.pnpm/@sentry+node@7.120.2/node_modules/@sentry/node/cjs/integrations/local-variables/common.js
var require_common = __commonJS({
  "../../../node_modules/.pnpm/@sentry+node@7.120.2/node_modules/@sentry/node/cjs/integrations/local-variables/common.js"(exports) {
    init_define_ENV_DEFINED_IN_BUILD_STEP();
    Object.defineProperty(exports, "__esModule", { value: true });
    function createRateLimiter(maxPerSecond, enable, disable) {
      let count = 0;
      let retrySeconds = 5;
      let disabledTimeout = 0;
      setInterval(() => {
        if (disabledTimeout === 0) {
          if (count > maxPerSecond) {
            retrySeconds *= 2;
            disable(retrySeconds);
            if (retrySeconds > 86400) {
              retrySeconds = 86400;
            }
            disabledTimeout = retrySeconds;
          }
        } else {
          disabledTimeout -= 1;
          if (disabledTimeout === 0) {
            enable();
          }
        }
        count = 0;
      }, 1e3).unref();
      return () => {
        count += 1;
      };
    }
    function isAnonymous(name) {
      return name !== void 0 && (name.length === 0 || name === "?" || name === "<anonymous>");
    }
    function functionNamesMatch(a3, b) {
      return a3 === b || isAnonymous(a3) && isAnonymous(b);
    }
    function hashFrames(frames) {
      if (frames === void 0) {
        return;
      }
      return frames.slice(-10).reduce((acc, frame) => `${acc},${frame.function},${frame.lineno},${frame.colno}`, "");
    }
    function hashFromStack(stackParser, stack) {
      if (stack === void 0) {
        return void 0;
      }
      return hashFrames(stackParser(stack, 1));
    }
    exports.createRateLimiter = createRateLimiter;
    exports.functionNamesMatch = functionNamesMatch;
    exports.hashFrames = hashFrames;
    exports.hashFromStack = hashFromStack;
    exports.isAnonymous = isAnonymous;
  }
});

// ../../../node_modules/.pnpm/@sentry+node@7.120.2/node_modules/@sentry/node/cjs/integrations/local-variables/local-variables-sync.js
var require_local_variables_sync = __commonJS({
  "../../../node_modules/.pnpm/@sentry+node@7.120.2/node_modules/@sentry/node/cjs/integrations/local-variables/local-variables-sync.js"(exports) {
    init_define_ENV_DEFINED_IN_BUILD_STEP();
    var {
      _optionalChain
    } = require_cjs();
    Object.defineProperty(exports, "__esModule", { value: true });
    var core = require_cjs2();
    var utils = require_cjs();
    var nodeVersion = require_nodeVersion();
    var common = require_common();
    function createCallbackList(complete) {
      let callbacks = [];
      let completedCalled = false;
      function checkedComplete(result) {
        callbacks = [];
        if (completedCalled) {
          return;
        }
        completedCalled = true;
        complete(result);
      }
      callbacks.push(checkedComplete);
      function add(fn) {
        callbacks.push(fn);
      }
      function next(result) {
        const popped = callbacks.pop() || checkedComplete;
        try {
          popped(result);
        } catch (_3) {
          checkedComplete(result);
        }
      }
      return { add, next };
    }
    var AsyncSession = class {
      /** Throws if inspector API is not available */
      constructor() {
        const { Session } = __require("inspector");
        this._session = new Session();
      }
      /** @inheritdoc */
      configureAndConnect(onPause, captureAll) {
        this._session.connect();
        this._session.on("Debugger.paused", (event) => {
          onPause(event, () => {
            this._session.post("Debugger.resume");
          });
        });
        this._session.post("Debugger.enable");
        this._session.post("Debugger.setPauseOnExceptions", { state: captureAll ? "all" : "uncaught" });
      }
      setPauseOnExceptions(captureAll) {
        this._session.post("Debugger.setPauseOnExceptions", { state: captureAll ? "all" : "uncaught" });
      }
      /** @inheritdoc */
      getLocalVariables(objectId, complete) {
        this._getProperties(objectId, (props) => {
          const { add, next } = createCallbackList(complete);
          for (const prop of props) {
            if (_optionalChain([prop, "optionalAccess", (_22) => _22.value, "optionalAccess", (_3) => _3.objectId]) && _optionalChain([prop, "optionalAccess", (_4) => _4.value, "access", (_5) => _5.className]) === "Array") {
              const id = prop.value.objectId;
              add((vars) => this._unrollArray(id, prop.name, vars, next));
            } else if (_optionalChain([prop, "optionalAccess", (_6) => _6.value, "optionalAccess", (_7) => _7.objectId]) && _optionalChain([prop, "optionalAccess", (_8) => _8.value, "optionalAccess", (_9) => _9.className]) === "Object") {
              const id = prop.value.objectId;
              add((vars) => this._unrollObject(id, prop.name, vars, next));
            } else if (_optionalChain([prop, "optionalAccess", (_10) => _10.value, "optionalAccess", (_11) => _11.value]) != null || _optionalChain([prop, "optionalAccess", (_12) => _12.value, "optionalAccess", (_13) => _13.description]) != null) {
              add((vars) => this._unrollOther(prop, vars, next));
            }
          }
          next({});
        });
      }
      /**
       * Gets all the PropertyDescriptors of an object
       */
      _getProperties(objectId, next) {
        this._session.post(
          "Runtime.getProperties",
          {
            objectId,
            ownProperties: true
          },
          (err, params) => {
            if (err) {
              next([]);
            } else {
              next(params.result);
            }
          }
        );
      }
      /**
       * Unrolls an array property
       */
      _unrollArray(objectId, name, vars, next) {
        this._getProperties(objectId, (props) => {
          vars[name] = props.filter((v3) => v3.name !== "length" && !isNaN(parseInt(v3.name, 10))).sort((a3, b) => parseInt(a3.name, 10) - parseInt(b.name, 10)).map((v3) => _optionalChain([v3, "optionalAccess", (_14) => _14.value, "optionalAccess", (_15) => _15.value]));
          next(vars);
        });
      }
      /**
       * Unrolls an object property
       */
      _unrollObject(objectId, name, vars, next) {
        this._getProperties(objectId, (props) => {
          vars[name] = props.map((v3) => [v3.name, _optionalChain([v3, "optionalAccess", (_16) => _16.value, "optionalAccess", (_17) => _17.value])]).reduce((obj, [key, val]) => {
            obj[key] = val;
            return obj;
          }, {});
          next(vars);
        });
      }
      /**
       * Unrolls other properties
       */
      _unrollOther(prop, vars, next) {
        if (_optionalChain([prop, "optionalAccess", (_18) => _18.value, "optionalAccess", (_19) => _19.value]) != null) {
          vars[prop.name] = prop.value.value;
        } else if (_optionalChain([prop, "optionalAccess", (_20) => _20.value, "optionalAccess", (_21) => _21.description]) != null && _optionalChain([prop, "optionalAccess", (_22) => _22.value, "optionalAccess", (_23) => _23.type]) !== "function") {
          vars[prop.name] = `<${prop.value.description}>`;
        }
        next(vars);
      }
    };
    function tryNewAsyncSession() {
      try {
        return new AsyncSession();
      } catch (e2) {
        return void 0;
      }
    }
    var INTEGRATION_NAME = "LocalVariables";
    var _localVariablesSyncIntegration = (options = {}, session = tryNewAsyncSession()) => {
      const cachedFrames = new utils.LRUMap(20);
      let rateLimiter;
      let shouldProcessEvent = false;
      function handlePaused(stackParser, { params: { reason, data, callFrames } }, complete) {
        if (reason !== "exception" && reason !== "promiseRejection") {
          complete();
          return;
        }
        _optionalChain([rateLimiter, "optionalCall", (_24) => _24()]);
        const exceptionHash = common.hashFromStack(stackParser, _optionalChain([data, "optionalAccess", (_25) => _25.description]));
        if (exceptionHash == void 0) {
          complete();
          return;
        }
        const { add, next } = createCallbackList((frames) => {
          cachedFrames.set(exceptionHash, frames);
          complete();
        });
        for (let i2 = 0; i2 < Math.min(callFrames.length, 5); i2++) {
          const { scopeChain, functionName, this: obj } = callFrames[i2];
          const localScope = scopeChain.find((scope) => scope.type === "local");
          const fn = obj.className === "global" || !obj.className ? functionName : `${obj.className}.${functionName}`;
          if (_optionalChain([localScope, "optionalAccess", (_26) => _26.object, "access", (_27) => _27.objectId]) === void 0) {
            add((frames) => {
              frames[i2] = { function: fn };
              next(frames);
            });
          } else {
            const id = localScope.object.objectId;
            add(
              (frames) => _optionalChain([session, "optionalAccess", (_28) => _28.getLocalVariables, "call", (_29) => _29(id, (vars) => {
                frames[i2] = { function: fn, vars };
                next(frames);
              })])
            );
          }
        }
        next([]);
      }
      function addLocalVariablesToException(exception) {
        const hash = common.hashFrames(_optionalChain([exception, "optionalAccess", (_30) => _30.stacktrace, "optionalAccess", (_31) => _31.frames]));
        if (hash === void 0) {
          return;
        }
        const cachedFrame = cachedFrames.remove(hash);
        if (cachedFrame === void 0) {
          return;
        }
        const frames = (_optionalChain([exception, "access", (_32) => _32.stacktrace, "optionalAccess", (_33) => _33.frames]) || []).filter((frame) => frame.function !== "new Promise");
        for (let i2 = 0; i2 < frames.length; i2++) {
          const frameIndex = frames.length - i2 - 1;
          if (!frames[frameIndex] || !cachedFrame[i2]) {
            break;
          }
          if (
            // We need to have vars to add
            cachedFrame[i2].vars === void 0 || // We're not interested in frames that are not in_app because the vars are not relevant
            frames[frameIndex].in_app === false || // The function names need to match
            !common.functionNamesMatch(frames[frameIndex].function, cachedFrame[i2].function)
          ) {
            continue;
          }
          frames[frameIndex].vars = cachedFrame[i2].vars;
        }
      }
      function addLocalVariablesToEvent(event) {
        for (const exception of _optionalChain([event, "optionalAccess", (_34) => _34.exception, "optionalAccess", (_35) => _35.values]) || []) {
          addLocalVariablesToException(exception);
        }
        return event;
      }
      return {
        name: INTEGRATION_NAME,
        setupOnce() {
          const client = core.getClient();
          const clientOptions = _optionalChain([client, "optionalAccess", (_36) => _36.getOptions, "call", (_37) => _37()]);
          if (session && _optionalChain([clientOptions, "optionalAccess", (_38) => _38.includeLocalVariables])) {
            const unsupportedNodeVersion = nodeVersion.NODE_VERSION.major < 18;
            if (unsupportedNodeVersion) {
              utils.logger.log("The `LocalVariables` integration is only supported on Node >= v18.");
              return;
            }
            const captureAll = options.captureAllExceptions !== false;
            session.configureAndConnect(
              (ev, complete) => handlePaused(clientOptions.stackParser, ev, complete),
              captureAll
            );
            if (captureAll) {
              const max = options.maxExceptionsPerSecond || 50;
              rateLimiter = common.createRateLimiter(
                max,
                () => {
                  utils.logger.log("Local variables rate-limit lifted.");
                  _optionalChain([session, "optionalAccess", (_39) => _39.setPauseOnExceptions, "call", (_40) => _40(true)]);
                },
                (seconds) => {
                  utils.logger.log(
                    `Local variables rate-limit exceeded. Disabling capturing of caught exceptions for ${seconds} seconds.`
                  );
                  _optionalChain([session, "optionalAccess", (_41) => _41.setPauseOnExceptions, "call", (_42) => _42(false)]);
                }
              );
            }
            shouldProcessEvent = true;
          }
        },
        processEvent(event) {
          if (shouldProcessEvent) {
            return addLocalVariablesToEvent(event);
          }
          return event;
        },
        // These are entirely for testing
        _getCachedFramesCount() {
          return cachedFrames.size;
        },
        _getFirstCachedFrame() {
          return cachedFrames.values()[0];
        }
      };
    };
    var localVariablesSyncIntegration = core.defineIntegration(_localVariablesSyncIntegration);
    var LocalVariablesSync = core.convertIntegrationFnToClass(
      INTEGRATION_NAME,
      localVariablesSyncIntegration
    );
    exports.LocalVariablesSync = LocalVariablesSync;
    exports.createCallbackList = createCallbackList;
    exports.localVariablesSyncIntegration = localVariablesSyncIntegration;
  }
});

// ../../../node_modules/.pnpm/@sentry+node@7.120.2/node_modules/@sentry/node/cjs/integrations/local-variables/index.js
var require_local_variables = __commonJS({
  "../../../node_modules/.pnpm/@sentry+node@7.120.2/node_modules/@sentry/node/cjs/integrations/local-variables/index.js"(exports) {
    init_define_ENV_DEFINED_IN_BUILD_STEP();
    Object.defineProperty(exports, "__esModule", { value: true });
    var localVariablesSync = require_local_variables_sync();
    var LocalVariables = localVariablesSync.LocalVariablesSync;
    var localVariablesIntegration = localVariablesSync.localVariablesSyncIntegration;
    exports.LocalVariables = LocalVariables;
    exports.localVariablesIntegration = localVariablesIntegration;
  }
});

// ../../../node_modules/.pnpm/@sentry+node@7.120.2/node_modules/@sentry/node/cjs/integrations/modules.js
var require_modules = __commonJS({
  "../../../node_modules/.pnpm/@sentry+node@7.120.2/node_modules/@sentry/node/cjs/integrations/modules.js"(exports) {
    init_define_ENV_DEFINED_IN_BUILD_STEP();
    Object.defineProperty(exports, "__esModule", { value: true });
    var fs3 = __require("fs");
    var path2 = __require("path");
    var core = require_cjs2();
    var moduleCache;
    var INTEGRATION_NAME = "Modules";
    function getPaths() {
      try {
        return __require.cache ? Object.keys(__require.cache) : [];
      } catch (e2) {
        return [];
      }
    }
    function collectModules() {
      const mainPaths = __require.main && __require.main.paths || [];
      const paths = getPaths();
      const infos = {};
      const seen = {};
      paths.forEach((path$1) => {
        let dir = path$1;
        const updir = () => {
          const orig = dir;
          dir = path2.dirname(orig);
          if (!dir || orig === dir || seen[orig]) {
            return void 0;
          }
          if (mainPaths.indexOf(dir) < 0) {
            return updir();
          }
          const pkgfile = path2.join(orig, "package.json");
          seen[orig] = true;
          if (!fs3.existsSync(pkgfile)) {
            return updir();
          }
          try {
            const info = JSON.parse(fs3.readFileSync(pkgfile, "utf8"));
            infos[info.name] = info.version;
          } catch (_oO) {
          }
        };
        updir();
      });
      return infos;
    }
    function _getModules() {
      if (!moduleCache) {
        moduleCache = collectModules();
      }
      return moduleCache;
    }
    var _modulesIntegration = () => {
      return {
        name: INTEGRATION_NAME,
        // TODO v8: Remove this
        setupOnce() {
        },
        // eslint-disable-line @typescript-eslint/no-empty-function
        processEvent(event) {
          event.modules = {
            ...event.modules,
            ..._getModules()
          };
          return event;
        }
      };
    };
    var modulesIntegration = core.defineIntegration(_modulesIntegration);
    var Modules = core.convertIntegrationFnToClass(INTEGRATION_NAME, modulesIntegration);
    exports.Modules = Modules;
    exports.modulesIntegration = modulesIntegration;
  }
});

// ../../../node_modules/.pnpm/@sentry+node@7.120.2/node_modules/@sentry/node/cjs/integrations/utils/errorhandling.js
var require_errorhandling = __commonJS({
  "../../../node_modules/.pnpm/@sentry+node@7.120.2/node_modules/@sentry/node/cjs/integrations/utils/errorhandling.js"(exports) {
    init_define_ENV_DEFINED_IN_BUILD_STEP();
    Object.defineProperty(exports, "__esModule", { value: true });
    var core = require_cjs2();
    var utils = require_cjs();
    var debugBuild = require_debug_build4();
    var DEFAULT_SHUTDOWN_TIMEOUT = 2e3;
    function logAndExitProcess(error) {
      utils.consoleSandbox(() => {
        console.error(error);
      });
      const client = core.getClient();
      if (client === void 0) {
        debugBuild.DEBUG_BUILD && utils.logger.warn("No NodeClient was defined, we are exiting the process now.");
        global.process.exit(1);
      }
      const options = client.getOptions();
      const timeout = options && options.shutdownTimeout && options.shutdownTimeout > 0 && options.shutdownTimeout || DEFAULT_SHUTDOWN_TIMEOUT;
      client.close(timeout).then(
        (result) => {
          if (!result) {
            debugBuild.DEBUG_BUILD && utils.logger.warn("We reached the timeout for emptying the request buffer, still exiting now!");
          }
          global.process.exit(1);
        },
        (error2) => {
          debugBuild.DEBUG_BUILD && utils.logger.error(error2);
        }
      );
    }
    exports.logAndExitProcess = logAndExitProcess;
  }
});

// ../../../node_modules/.pnpm/@sentry+node@7.120.2/node_modules/@sentry/node/cjs/integrations/onuncaughtexception.js
var require_onuncaughtexception = __commonJS({
  "../../../node_modules/.pnpm/@sentry+node@7.120.2/node_modules/@sentry/node/cjs/integrations/onuncaughtexception.js"(exports) {
    init_define_ENV_DEFINED_IN_BUILD_STEP();
    Object.defineProperty(exports, "__esModule", { value: true });
    var core = require_cjs2();
    var utils = require_cjs();
    var debugBuild = require_debug_build4();
    var errorhandling = require_errorhandling();
    var INTEGRATION_NAME = "OnUncaughtException";
    var _onUncaughtExceptionIntegration = (options = {}) => {
      const _options = {
        exitEvenIfOtherHandlersAreRegistered: true,
        ...options
      };
      return {
        name: INTEGRATION_NAME,
        // TODO v8: Remove this
        setupOnce() {
        },
        // eslint-disable-line @typescript-eslint/no-empty-function
        setup(client) {
          global.process.on("uncaughtException", makeErrorHandler(client, _options));
        }
      };
    };
    var onUncaughtExceptionIntegration = core.defineIntegration(_onUncaughtExceptionIntegration);
    var OnUncaughtException = core.convertIntegrationFnToClass(
      INTEGRATION_NAME,
      onUncaughtExceptionIntegration
    );
    function makeErrorHandler(client, options) {
      const timeout = 2e3;
      let caughtFirstError = false;
      let caughtSecondError = false;
      let calledFatalError = false;
      let firstError;
      const clientOptions = client.getOptions();
      return Object.assign(
        (error) => {
          let onFatalError = errorhandling.logAndExitProcess;
          if (options.onFatalError) {
            onFatalError = options.onFatalError;
          } else if (clientOptions.onFatalError) {
            onFatalError = clientOptions.onFatalError;
          }
          const userProvidedListenersCount = global.process.listeners("uncaughtException").reduce((acc, listener) => {
            if (
              // There are 3 listeners we ignore:
              listener.name === "domainUncaughtExceptionClear" || // as soon as we're using domains this listener is attached by node itself
              listener.tag && listener.tag === "sentry_tracingErrorCallback" || // the handler we register for tracing
              listener._errorHandler
            ) {
              return acc;
            } else {
              return acc + 1;
            }
          }, 0);
          const processWouldExit = userProvidedListenersCount === 0;
          const shouldApplyFatalHandlingLogic = options.exitEvenIfOtherHandlersAreRegistered || processWouldExit;
          if (!caughtFirstError) {
            firstError = error;
            caughtFirstError = true;
            if (core.getClient() === client) {
              core.captureException(error, {
                originalException: error,
                captureContext: {
                  level: "fatal"
                },
                mechanism: {
                  handled: false,
                  type: "onuncaughtexception"
                }
              });
            }
            if (!calledFatalError && shouldApplyFatalHandlingLogic) {
              calledFatalError = true;
              onFatalError(error);
            }
          } else {
            if (shouldApplyFatalHandlingLogic) {
              if (calledFatalError) {
                debugBuild.DEBUG_BUILD && utils.logger.warn(
                  "uncaught exception after calling fatal error shutdown callback - this is bad! forcing shutdown"
                );
                errorhandling.logAndExitProcess(error);
              } else if (!caughtSecondError) {
                caughtSecondError = true;
                setTimeout(() => {
                  if (!calledFatalError) {
                    calledFatalError = true;
                    onFatalError(firstError, error);
                  }
                }, timeout);
              }
            }
          }
        },
        { _errorHandler: true }
      );
    }
    exports.OnUncaughtException = OnUncaughtException;
    exports.makeErrorHandler = makeErrorHandler;
    exports.onUncaughtExceptionIntegration = onUncaughtExceptionIntegration;
  }
});

// ../../../node_modules/.pnpm/@sentry+node@7.120.2/node_modules/@sentry/node/cjs/integrations/onunhandledrejection.js
var require_onunhandledrejection = __commonJS({
  "../../../node_modules/.pnpm/@sentry+node@7.120.2/node_modules/@sentry/node/cjs/integrations/onunhandledrejection.js"(exports) {
    init_define_ENV_DEFINED_IN_BUILD_STEP();
    Object.defineProperty(exports, "__esModule", { value: true });
    var core = require_cjs2();
    var utils = require_cjs();
    var errorhandling = require_errorhandling();
    var INTEGRATION_NAME = "OnUnhandledRejection";
    var _onUnhandledRejectionIntegration = (options = {}) => {
      const mode = options.mode || "warn";
      return {
        name: INTEGRATION_NAME,
        // TODO v8: Remove this
        setupOnce() {
        },
        // eslint-disable-line @typescript-eslint/no-empty-function
        setup(client) {
          global.process.on("unhandledRejection", makeUnhandledPromiseHandler(client, { mode }));
        }
      };
    };
    var onUnhandledRejectionIntegration = core.defineIntegration(_onUnhandledRejectionIntegration);
    var OnUnhandledRejection = core.convertIntegrationFnToClass(
      INTEGRATION_NAME,
      onUnhandledRejectionIntegration
    );
    function makeUnhandledPromiseHandler(client, options) {
      return function sendUnhandledPromise(reason, promise) {
        if (core.getClient() !== client) {
          return;
        }
        core.captureException(reason, {
          originalException: promise,
          captureContext: {
            extra: { unhandledPromiseRejection: true }
          },
          mechanism: {
            handled: false,
            type: "onunhandledrejection"
          }
        });
        handleRejection(reason, options);
      };
    }
    function handleRejection(reason, options) {
      const rejectionWarning = "This error originated either by throwing inside of an async function without a catch block, or by rejecting a promise which was not handled with .catch(). The promise rejected with the reason:";
      if (options.mode === "warn") {
        utils.consoleSandbox(() => {
          console.warn(rejectionWarning);
          console.error(reason && reason.stack ? reason.stack : reason);
        });
      } else if (options.mode === "strict") {
        utils.consoleSandbox(() => {
          console.warn(rejectionWarning);
        });
        errorhandling.logAndExitProcess(reason);
      }
    }
    exports.OnUnhandledRejection = OnUnhandledRejection;
    exports.makeUnhandledPromiseHandler = makeUnhandledPromiseHandler;
    exports.onUnhandledRejectionIntegration = onUnhandledRejectionIntegration;
  }
});

// ../../../node_modules/.pnpm/@sentry+node@7.120.2/node_modules/@sentry/node/cjs/integrations/spotlight.js
var require_spotlight = __commonJS({
  "../../../node_modules/.pnpm/@sentry+node@7.120.2/node_modules/@sentry/node/cjs/integrations/spotlight.js"(exports) {
    init_define_ENV_DEFINED_IN_BUILD_STEP();
    Object.defineProperty(exports, "__esModule", { value: true });
    var http = __require("http");
    var url = __require("url");
    var core = require_cjs2();
    var utils = require_cjs();
    var INTEGRATION_NAME = "Spotlight";
    var _spotlightIntegration = (options = {}) => {
      const _options = {
        sidecarUrl: options.sidecarUrl || "http://localhost:8969/stream"
      };
      return {
        name: INTEGRATION_NAME,
        // TODO v8: Remove this
        setupOnce() {
        },
        // eslint-disable-line @typescript-eslint/no-empty-function
        setup(client) {
          if (typeof process === "object" && process.env && process.env.NODE_ENV !== "development") {
            utils.logger.warn("[Spotlight] It seems you're not in dev mode. Do you really want to have Spotlight enabled?");
          }
          connectToSpotlight(client, _options);
        }
      };
    };
    var spotlightIntegration = core.defineIntegration(_spotlightIntegration);
    var Spotlight = core.convertIntegrationFnToClass(INTEGRATION_NAME, spotlightIntegration);
    function connectToSpotlight(client, options) {
      const spotlightUrl = parseSidecarUrl(options.sidecarUrl);
      if (!spotlightUrl) {
        return;
      }
      let failedRequests = 0;
      if (typeof client.on !== "function") {
        utils.logger.warn("[Spotlight] Cannot connect to spotlight due to missing method on SDK client (`client.on`)");
        return;
      }
      client.on("beforeEnvelope", (envelope) => {
        if (failedRequests > 3) {
          utils.logger.warn("[Spotlight] Disabled Sentry -> Spotlight integration due to too many failed requests");
          return;
        }
        const serializedEnvelope = utils.serializeEnvelope(envelope);
        const request = getNativeHttpRequest();
        const req = request(
          {
            method: "POST",
            path: spotlightUrl.pathname,
            hostname: spotlightUrl.hostname,
            port: spotlightUrl.port,
            headers: {
              "Content-Type": "application/x-sentry-envelope"
            }
          },
          (res) => {
            res.on("data", () => {
            });
            res.on("end", () => {
            });
            res.setEncoding("utf8");
          }
        );
        req.on("error", () => {
          failedRequests++;
          utils.logger.warn("[Spotlight] Failed to send envelope to Spotlight Sidecar");
        });
        req.write(serializedEnvelope);
        req.end();
      });
    }
    function parseSidecarUrl(url$1) {
      try {
        return new url.URL(`${url$1}`);
      } catch (e2) {
        utils.logger.warn(`[Spotlight] Invalid sidecar URL: ${url$1}`);
        return void 0;
      }
    }
    function getNativeHttpRequest() {
      const { request } = http;
      if (isWrapped(request)) {
        return request.__sentry_original__;
      }
      return request;
    }
    function isWrapped(impl) {
      return "__sentry_original__" in impl;
    }
    exports.Spotlight = Spotlight;
    exports.getNativeHttpRequest = getNativeHttpRequest;
    exports.spotlightIntegration = spotlightIntegration;
  }
});

// ../../../node_modules/.pnpm/@sentry+node@7.120.2/node_modules/@sentry/node/cjs/integrations/undici/index.js
var require_undici = __commonJS({
  "../../../node_modules/.pnpm/@sentry+node@7.120.2/node_modules/@sentry/node/cjs/integrations/undici/index.js"(exports) {
    init_define_ENV_DEFINED_IN_BUILD_STEP();
    var {
      _optionalChain
    } = require_cjs();
    Object.defineProperty(exports, "__esModule", { value: true });
    var core = require_cjs2();
    var utils = require_cjs();
    var nodeVersion = require_nodeVersion();
    exports.ChannelName = void 0;
    (function(ChannelName) {
      const RequestCreate = "undici:request:create";
      ChannelName["RequestCreate"] = RequestCreate;
      const RequestEnd = "undici:request:headers";
      ChannelName["RequestEnd"] = RequestEnd;
      const RequestError = "undici:request:error";
      ChannelName["RequestError"] = RequestError;
    })(exports.ChannelName || (exports.ChannelName = {}));
    var _nativeNodeFetchintegration = (options) => {
      return new Undici(options);
    };
    var nativeNodeFetchintegration = core.defineIntegration(_nativeNodeFetchintegration);
    var Undici = class _Undici {
      /**
       * @inheritDoc
       */
      static __initStatic() {
        this.id = "Undici";
      }
      /**
       * @inheritDoc
       */
      // eslint-disable-next-line deprecation/deprecation
      __init() {
        this.name = _Undici.id;
      }
      __init2() {
        this._createSpanUrlMap = new utils.LRUMap(100);
      }
      __init3() {
        this._headersUrlMap = new utils.LRUMap(100);
      }
      constructor(_options = {}) {
        _Undici.prototype.__init.call(this);
        _Undici.prototype.__init2.call(this);
        _Undici.prototype.__init3.call(this);
        _Undici.prototype.__init4.call(this);
        _Undici.prototype.__init5.call(this);
        _Undici.prototype.__init6.call(this);
        this._options = {
          breadcrumbs: _options.breadcrumbs === void 0 ? true : _options.breadcrumbs,
          tracing: _options.tracing,
          shouldCreateSpanForRequest: _options.shouldCreateSpanForRequest
        };
      }
      /**
       * @inheritDoc
       */
      setupOnce(_addGlobalEventProcessor) {
        if (nodeVersion.NODE_VERSION.major < 16) {
          return;
        }
        let ds;
        try {
          ds = __require("diagnostics_channel");
        } catch (e2) {
        }
        if (!ds || !ds.subscribe) {
          return;
        }
        ds.subscribe(exports.ChannelName.RequestCreate, this._onRequestCreate);
        ds.subscribe(exports.ChannelName.RequestEnd, this._onRequestEnd);
        ds.subscribe(exports.ChannelName.RequestError, this._onRequestError);
      }
      /** Helper that wraps shouldCreateSpanForRequest option */
      _shouldCreateSpan(url) {
        if (this._options.tracing === false || this._options.tracing === void 0 && !core.hasTracingEnabled()) {
          return false;
        }
        if (this._options.shouldCreateSpanForRequest === void 0) {
          return true;
        }
        const cachedDecision = this._createSpanUrlMap.get(url);
        if (cachedDecision !== void 0) {
          return cachedDecision;
        }
        const decision = this._options.shouldCreateSpanForRequest(url);
        this._createSpanUrlMap.set(url, decision);
        return decision;
      }
      __init4() {
        this._onRequestCreate = (message) => {
          if (!_optionalChain([core.getClient, "call", (_10) => _10(), "optionalAccess", (_11) => _11.getIntegration, "call", (_12) => _12(_Undici)])) {
            return;
          }
          const { request } = message;
          const stringUrl = request.origin ? request.origin.toString() + request.path : request.path;
          const client = core.getClient();
          if (!client) {
            return;
          }
          if (core.isSentryRequestUrl(stringUrl, client) || request.__sentry_span__ !== void 0) {
            return;
          }
          const clientOptions = client.getOptions();
          const scope = core.getCurrentScope();
          const isolationScope = core.getIsolationScope();
          const parentSpan = core.getActiveSpan();
          const span = this._shouldCreateSpan(stringUrl) ? createRequestSpan(parentSpan, request, stringUrl) : void 0;
          if (span) {
            request.__sentry_span__ = span;
          }
          const shouldAttachTraceData = (url) => {
            if (clientOptions.tracePropagationTargets === void 0) {
              return true;
            }
            const cachedDecision = this._headersUrlMap.get(url);
            if (cachedDecision !== void 0) {
              return cachedDecision;
            }
            const decision = utils.stringMatchesSomePattern(url, clientOptions.tracePropagationTargets);
            this._headersUrlMap.set(url, decision);
            return decision;
          };
          if (shouldAttachTraceData(stringUrl)) {
            const { traceId, spanId, sampled, dsc } = {
              ...isolationScope.getPropagationContext(),
              ...scope.getPropagationContext()
            };
            const sentryTraceHeader = span ? core.spanToTraceHeader(span) : utils.generateSentryTraceHeader(traceId, spanId, sampled);
            const sentryBaggageHeader = utils.dynamicSamplingContextToSentryBaggageHeader(
              dsc || (span ? core.getDynamicSamplingContextFromSpan(span) : core.getDynamicSamplingContextFromClient(traceId, client, scope))
            );
            setHeadersOnRequest(request, sentryTraceHeader, sentryBaggageHeader);
          }
        };
      }
      __init5() {
        this._onRequestEnd = (message) => {
          if (!_optionalChain([core.getClient, "call", (_13) => _13(), "optionalAccess", (_14) => _14.getIntegration, "call", (_15) => _15(_Undici)])) {
            return;
          }
          const { request, response } = message;
          const stringUrl = request.origin ? request.origin.toString() + request.path : request.path;
          if (core.isSentryRequestUrl(stringUrl, core.getClient())) {
            return;
          }
          const span = request.__sentry_span__;
          if (span) {
            core.setHttpStatus(span, response.statusCode);
            span.end();
          }
          if (this._options.breadcrumbs) {
            core.addBreadcrumb(
              {
                category: "http",
                data: {
                  method: request.method,
                  status_code: response.statusCode,
                  url: stringUrl
                },
                type: "http"
              },
              {
                event: "response",
                request,
                response
              }
            );
          }
        };
      }
      __init6() {
        this._onRequestError = (message) => {
          if (!_optionalChain([core.getClient, "call", (_16) => _16(), "optionalAccess", (_17) => _17.getIntegration, "call", (_18) => _18(_Undici)])) {
            return;
          }
          const { request } = message;
          const stringUrl = request.origin ? request.origin.toString() + request.path : request.path;
          if (core.isSentryRequestUrl(stringUrl, core.getClient())) {
            return;
          }
          const span = request.__sentry_span__;
          if (span) {
            span.setStatus("internal_error");
            span.end();
          }
          if (this._options.breadcrumbs) {
            core.addBreadcrumb(
              {
                category: "http",
                data: {
                  method: request.method,
                  url: stringUrl
                },
                level: "error",
                type: "http"
              },
              {
                event: "error",
                request
              }
            );
          }
        };
      }
    };
    Undici.__initStatic();
    function setHeadersOnRequest(request, sentryTrace, sentryBaggageHeader) {
      let hasSentryHeaders;
      if (Array.isArray(request.headers)) {
        hasSentryHeaders = request.headers.some((headerLine) => headerLine === "sentry-trace");
      } else {
        const headerLines = request.headers.split("\r\n");
        hasSentryHeaders = headerLines.some((headerLine) => headerLine.startsWith("sentry-trace:"));
      }
      if (hasSentryHeaders) {
        return;
      }
      request.addHeader("sentry-trace", sentryTrace);
      if (sentryBaggageHeader) {
        request.addHeader("baggage", sentryBaggageHeader);
      }
    }
    function createRequestSpan(activeSpan, request, stringUrl) {
      const url = utils.parseUrl(stringUrl);
      const method = request.method || "GET";
      const data = {
        "http.method": method
      };
      if (url.search) {
        data["http.query"] = url.search;
      }
      if (url.hash) {
        data["http.fragment"] = url.hash;
      }
      return _optionalChain([activeSpan, "optionalAccess", (_19) => _19.startChild, "call", (_20) => _20({
        op: "http.client",
        origin: "auto.http.node.undici",
        description: `${method} ${utils.getSanitizedUrlString(url)}`,
        data
      })]);
    }
    exports.Undici = Undici;
    exports.nativeNodeFetchintegration = nativeNodeFetchintegration;
  }
});

// ../../../node_modules/.pnpm/@sentry+node@7.120.2/node_modules/@sentry/node/cjs/module.js
var require_module = __commonJS({
  "../../../node_modules/.pnpm/@sentry+node@7.120.2/node_modules/@sentry/node/cjs/module.js"(exports) {
    init_define_ENV_DEFINED_IN_BUILD_STEP();
    Object.defineProperty(exports, "__esModule", { value: true });
    var path2 = __require("path");
    var utils = require_cjs();
    function normalizeWindowsPath(path3) {
      return path3.replace(/^[A-Z]:/, "").replace(/\\/g, "/");
    }
    function createGetModuleFromFilename(basePath = process.argv[1] ? utils.dirname(process.argv[1]) : process.cwd(), isWindows2 = path2.sep === "\\") {
      const normalizedBase = isWindows2 ? normalizeWindowsPath(basePath) : basePath;
      return (filename) => {
        if (!filename) {
          return;
        }
        const normalizedFilename = isWindows2 ? normalizeWindowsPath(filename) : filename;
        let { dir, base: file, ext } = path2.posix.parse(normalizedFilename);
        if (ext === ".js" || ext === ".mjs" || ext === ".cjs") {
          file = file.slice(0, ext.length * -1);
        }
        if (!dir) {
          dir = ".";
        }
        const n2 = dir.lastIndexOf("/node_modules");
        if (n2 > -1) {
          return `${dir.slice(n2 + 14).replace(/\//g, ".")}:${file}`;
        }
        if (dir.startsWith(normalizedBase)) {
          let moduleName = dir.slice(normalizedBase.length + 1).replace(/\//g, ".");
          if (moduleName) {
            moduleName += ":";
          }
          moduleName += file;
          return moduleName;
        }
        return file;
      };
    }
    exports.createGetModuleFromFilename = createGetModuleFromFilename;
  }
});

// ../../../node_modules/.pnpm/@sentry+node@7.120.2/node_modules/@sentry/node/cjs/sdk.js
var require_sdk2 = __commonJS({
  "../../../node_modules/.pnpm/@sentry+node@7.120.2/node_modules/@sentry/node/cjs/sdk.js"(exports) {
    init_define_ENV_DEFINED_IN_BUILD_STEP();
    var {
      _optionalChain
    } = require_cjs();
    Object.defineProperty(exports, "__esModule", { value: true });
    var core = require_cjs2();
    var utils = require_cjs();
    var index$2 = require_async();
    var client = require_client2();
    var console2 = require_console2();
    var context2 = require_context();
    var contextlines = require_contextlines();
    var http = require_http3();
    var index$1 = require_local_variables();
    var modules = require_modules();
    var onuncaughtexception = require_onuncaughtexception();
    var onunhandledrejection = require_onunhandledrejection();
    var spotlight = require_spotlight();
    var index = require_undici();
    var module$1 = require_module();
    var http$1 = require_http();
    var defaultIntegrations = [
      // Common
      core.inboundFiltersIntegration(),
      core.functionToStringIntegration(),
      core.linkedErrorsIntegration(),
      core.requestDataIntegration(),
      // Native Wrappers
      console2.consoleIntegration(),
      http.httpIntegration(),
      index.nativeNodeFetchintegration(),
      // Global Handlers
      onuncaughtexception.onUncaughtExceptionIntegration(),
      onunhandledrejection.onUnhandledRejectionIntegration(),
      // Event Info
      contextlines.contextLinesIntegration(),
      index$1.localVariablesIntegration(),
      context2.nodeContextIntegration(),
      modules.modulesIntegration()
    ];
    function getDefaultIntegrations(_options) {
      const carrier = core.getMainCarrier();
      const autoloadedIntegrations = _optionalChain([carrier, "access", (_3) => _3.__SENTRY__, "optionalAccess", (_22) => _22.integrations]) || [];
      return [
        // eslint-disable-next-line deprecation/deprecation
        ...defaultIntegrations,
        ...autoloadedIntegrations
      ];
    }
    function init3(options = {}) {
      index$2.setNodeAsyncContextStrategy();
      if (options.defaultIntegrations === void 0) {
        options.defaultIntegrations = getDefaultIntegrations();
      }
      if (options.dsn === void 0 && process.env.SENTRY_DSN) {
        options.dsn = process.env.SENTRY_DSN;
      }
      const sentryTracesSampleRate = process.env.SENTRY_TRACES_SAMPLE_RATE;
      if (options.tracesSampleRate === void 0 && sentryTracesSampleRate) {
        const tracesSampleRate = parseFloat(sentryTracesSampleRate);
        if (isFinite(tracesSampleRate)) {
          options.tracesSampleRate = tracesSampleRate;
        }
      }
      if (options.release === void 0) {
        const detectedRelease = getSentryRelease();
        if (detectedRelease !== void 0) {
          options.release = detectedRelease;
        } else {
          options.autoSessionTracking = false;
        }
      }
      if (options.environment === void 0 && process.env.SENTRY_ENVIRONMENT) {
        options.environment = process.env.SENTRY_ENVIRONMENT;
      }
      if (options.autoSessionTracking === void 0 && options.dsn !== void 0) {
        options.autoSessionTracking = true;
      }
      if (options.instrumenter === void 0) {
        options.instrumenter = "sentry";
      }
      const clientOptions = {
        ...options,
        stackParser: utils.stackParserFromStackParserOptions(options.stackParser || defaultStackParser),
        integrations: core.getIntegrationsToSetup(options),
        transport: options.transport || http$1.makeNodeTransport
      };
      core.initAndBind(options.clientClass || client.NodeClient, clientOptions);
      if (options.autoSessionTracking) {
        startSessionTracking();
      }
      updateScopeFromEnvVariables();
      if (options.spotlight) {
        const client2 = core.getClient();
        if (client2 && client2.addIntegration) {
          const integrations = client2.getOptions().integrations;
          for (const integration of integrations) {
            client2.addIntegration(integration);
          }
          client2.addIntegration(
            spotlight.spotlightIntegration({ sidecarUrl: typeof options.spotlight === "string" ? options.spotlight : void 0 })
          );
        }
      }
    }
    function isAutoSessionTrackingEnabled(client2) {
      if (client2 === void 0) {
        return false;
      }
      const clientOptions = client2 && client2.getOptions();
      if (clientOptions && clientOptions.autoSessionTracking !== void 0) {
        return clientOptions.autoSessionTracking;
      }
      return false;
    }
    function getSentryRelease(fallback) {
      if (process.env.SENTRY_RELEASE) {
        return process.env.SENTRY_RELEASE;
      }
      if (utils.GLOBAL_OBJ.SENTRY_RELEASE && utils.GLOBAL_OBJ.SENTRY_RELEASE.id) {
        return utils.GLOBAL_OBJ.SENTRY_RELEASE.id;
      }
      return (
        // GitHub Actions - https://help.github.com/en/actions/configuring-and-managing-workflows/using-environment-variables#default-environment-variables
        process.env.GITHUB_SHA || // Netlify - https://docs.netlify.com/configure-builds/environment-variables/#build-metadata
        process.env.COMMIT_REF || // Vercel - https://vercel.com/docs/v2/build-step#system-environment-variables
        process.env.VERCEL_GIT_COMMIT_SHA || process.env.VERCEL_GITHUB_COMMIT_SHA || process.env.VERCEL_GITLAB_COMMIT_SHA || process.env.VERCEL_BITBUCKET_COMMIT_SHA || // Zeit (now known as Vercel)
        process.env.ZEIT_GITHUB_COMMIT_SHA || process.env.ZEIT_GITLAB_COMMIT_SHA || process.env.ZEIT_BITBUCKET_COMMIT_SHA || // Cloudflare Pages - https://developers.cloudflare.com/pages/platform/build-configuration/#environment-variables
        process.env.CF_PAGES_COMMIT_SHA || fallback
      );
    }
    var defaultStackParser = utils.createStackParser(utils.nodeStackLineParser(module$1.createGetModuleFromFilename()));
    function startSessionTracking() {
      core.startSession();
      process.on("beforeExit", () => {
        const session = core.getIsolationScope().getSession();
        const terminalStates = ["exited", "crashed"];
        if (session && !terminalStates.includes(session.status)) {
          core.endSession();
        }
      });
    }
    function updateScopeFromEnvVariables() {
      const sentryUseEnvironment = (process.env.SENTRY_USE_ENVIRONMENT || "").toLowerCase();
      if (!["false", "n", "no", "off", "0"].includes(sentryUseEnvironment)) {
        const sentryTraceEnv = process.env.SENTRY_TRACE;
        const baggageEnv = process.env.SENTRY_BAGGAGE;
        const propagationContext = utils.propagationContextFromHeaders(sentryTraceEnv, baggageEnv);
        core.getCurrentScope().setPropagationContext(propagationContext);
      }
    }
    exports.defaultIntegrations = defaultIntegrations;
    exports.defaultStackParser = defaultStackParser;
    exports.getDefaultIntegrations = getDefaultIntegrations;
    exports.getSentryRelease = getSentryRelease;
    exports.init = init3;
    exports.isAutoSessionTrackingEnabled = isAutoSessionTrackingEnabled;
  }
});

// ../../../node_modules/.pnpm/@sentry+node@7.120.2/node_modules/@sentry/node/cjs/utils.js
var require_utils4 = __commonJS({
  "../../../node_modules/.pnpm/@sentry+node@7.120.2/node_modules/@sentry/node/cjs/utils.js"(exports) {
    init_define_ENV_DEFINED_IN_BUILD_STEP();
    Object.defineProperty(exports, "__esModule", { value: true });
    var fs3 = __require("fs");
    var path2 = __require("path");
    function deepReadDirSync(targetDir) {
      const targetDirAbsPath = path2.resolve(targetDir);
      if (!fs3.existsSync(targetDirAbsPath)) {
        throw new Error(`Cannot read contents of ${targetDirAbsPath}. Directory does not exist.`);
      }
      if (!fs3.statSync(targetDirAbsPath).isDirectory()) {
        throw new Error(`Cannot read contents of ${targetDirAbsPath}, because it is not a directory.`);
      }
      const deepReadCurrentDir = (currentDirAbsPath) => {
        return fs3.readdirSync(currentDirAbsPath).reduce((absPaths, itemName) => {
          const itemAbsPath = path2.join(currentDirAbsPath, itemName);
          if (fs3.statSync(itemAbsPath).isDirectory()) {
            return absPaths.concat(deepReadCurrentDir(itemAbsPath));
          }
          absPaths.push(itemAbsPath);
          return absPaths;
        }, []);
      };
      return deepReadCurrentDir(targetDirAbsPath).map((absPath) => path2.relative(targetDirAbsPath, absPath));
    }
    exports.deepReadDirSync = deepReadDirSync;
  }
});

// ../../../node_modules/.pnpm/@sentry+node@7.120.2/node_modules/@sentry/node/cjs/integrations/anr/worker-script.js
var require_worker_script = __commonJS({
  "../../../node_modules/.pnpm/@sentry+node@7.120.2/node_modules/@sentry/node/cjs/integrations/anr/worker-script.js"(exports) {
    init_define_ENV_DEFINED_IN_BUILD_STEP();
    exports.base64WorkerScript = "aW1wb3J0IHsgU2Vzc2lvbiB9IGZyb20gJ2luc3BlY3Rvcic7CmltcG9ydCB7IHdvcmtlckRhdGEsIHBhcmVudFBvcnQgfSBmcm9tICd3b3JrZXJfdGhyZWFkcyc7CmltcG9ydCB7IHBvc2l4LCBzZXAgfSBmcm9tICdwYXRoJzsKaW1wb3J0ICogYXMgaHR0cCBmcm9tICdodHRwJzsKaW1wb3J0ICogYXMgaHR0cHMgZnJvbSAnaHR0cHMnOwppbXBvcnQgeyBSZWFkYWJsZSB9IGZyb20gJ3N0cmVhbSc7CmltcG9ydCB7IFVSTCB9IGZyb20gJ3VybCc7CmltcG9ydCB7IGNyZWF0ZUd6aXAgfSBmcm9tICd6bGliJzsKaW1wb3J0ICogYXMgbmV0IGZyb20gJ25ldCc7CmltcG9ydCAqIGFzIHRscyBmcm9tICd0bHMnOwoKLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC91bmJvdW5kLW1ldGhvZApjb25zdCBvYmplY3RUb1N0cmluZyA9IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmc7CgovKioKICogQ2hlY2tzIHdoZXRoZXIgZ2l2ZW4gdmFsdWUncyB0eXBlIGlzIG9uZSBvZiBhIGZldyBFcnJvciBvciBFcnJvci1saWtlCiAqIHtAbGluayBpc0Vycm9yfS4KICoKICogQHBhcmFtIHdhdCBBIHZhbHVlIHRvIGJlIGNoZWNrZWQuCiAqIEByZXR1cm5zIEEgYm9vbGVhbiByZXByZXNlbnRpbmcgdGhlIHJlc3VsdC4KICovCmZ1bmN0aW9uIGlzRXJyb3Iod2F0KSB7CiAgc3dpdGNoIChvYmplY3RUb1N0cmluZy5jYWxsKHdhdCkpIHsKICAgIGNhc2UgJ1tvYmplY3QgRXJyb3JdJzoKICAgIGNhc2UgJ1tvYmplY3QgRXhjZXB0aW9uXSc6CiAgICBjYXNlICdbb2JqZWN0IERPTUV4Y2VwdGlvbl0nOgogICAgICByZXR1cm4gdHJ1ZTsKICAgIGRlZmF1bHQ6CiAgICAgIHJldHVybiBpc0luc3RhbmNlT2Yod2F0LCBFcnJvcik7CiAgfQp9Ci8qKgogKiBDaGVja3Mgd2hldGhlciBnaXZlbiB2YWx1ZSBpcyBhbiBpbnN0YW5jZSBvZiB0aGUgZ2l2ZW4gYnVpbHQtaW4gY2xhc3MuCiAqCiAqIEBwYXJhbSB3YXQgVGhlIHZhbHVlIHRvIGJlIGNoZWNrZWQKICogQHBhcmFtIGNsYXNzTmFtZQogKiBAcmV0dXJucyBBIGJvb2xlYW4gcmVwcmVzZW50aW5nIHRoZSByZXN1bHQuCiAqLwpmdW5jdGlvbiBpc0J1aWx0aW4od2F0LCBjbGFzc05hbWUpIHsKICByZXR1cm4gb2JqZWN0VG9TdHJpbmcuY2FsbCh3YXQpID09PSBgW29iamVjdCAke2NsYXNzTmFtZX1dYDsKfQoKLyoqCiAqIENoZWNrcyB3aGV0aGVyIGdpdmVuIHZhbHVlJ3MgdHlwZSBpcyBhIHN0cmluZwogKiB7QGxpbmsgaXNTdHJpbmd9LgogKgogKiBAcGFyYW0gd2F0IEEgdmFsdWUgdG8gYmUgY2hlY2tlZC4KICogQHJldHVybnMgQSBib29sZWFuIHJlcHJlc2VudGluZyB0aGUgcmVzdWx0LgogKi8KZnVuY3Rpb24gaXNTdHJpbmcod2F0KSB7CiAgcmV0dXJuIGlzQnVpbHRpbih3YXQsICdTdHJpbmcnKTsKfQoKLyoqCiAqIENoZWNrcyB3aGV0aGVyIGdpdmVuIHZhbHVlJ3MgdHlwZSBpcyBhbiBvYmplY3QgbGl0ZXJhbCwgb3IgYSBjbGFzcyBpbnN0YW5jZS4KICoge0BsaW5rIGlzUGxhaW5PYmplY3R9LgogKgogKiBAcGFyYW0gd2F0IEEgdmFsdWUgdG8gYmUgY2hlY2tlZC4KICogQHJldHVybnMgQSBib29sZWFuIHJlcHJlc2VudGluZyB0aGUgcmVzdWx0LgogKi8KZnVuY3Rpb24gaXNQbGFpbk9iamVjdCh3YXQpIHsKICByZXR1cm4gaXNCdWlsdGluKHdhdCwgJ09iamVjdCcpOwp9CgovKioKICogQ2hlY2tzIHdoZXRoZXIgZ2l2ZW4gdmFsdWUncyB0eXBlIGlzIGFuIEV2ZW50IGluc3RhbmNlCiAqIHtAbGluayBpc0V2ZW50fS4KICoKICogQHBhcmFtIHdhdCBBIHZhbHVlIHRvIGJlIGNoZWNrZWQuCiAqIEByZXR1cm5zIEEgYm9vbGVhbiByZXByZXNlbnRpbmcgdGhlIHJlc3VsdC4KICovCmZ1bmN0aW9uIGlzRXZlbnQod2F0KSB7CiAgcmV0dXJuIHR5cGVvZiBFdmVudCAhPT0gJ3VuZGVmaW5lZCcgJiYgaXNJbnN0YW5jZU9mKHdhdCwgRXZlbnQpOwp9CgovKioKICogQ2hlY2tzIHdoZXRoZXIgZ2l2ZW4gdmFsdWUncyB0eXBlIGlzIGFuIEVsZW1lbnQgaW5zdGFuY2UKICoge0BsaW5rIGlzRWxlbWVudH0uCiAqCiAqIEBwYXJhbSB3YXQgQSB2YWx1ZSB0byBiZSBjaGVja2VkLgogKiBAcmV0dXJucyBBIGJvb2xlYW4gcmVwcmVzZW50aW5nIHRoZSByZXN1bHQuCiAqLwpmdW5jdGlvbiBpc0VsZW1lbnQod2F0KSB7CiAgcmV0dXJuIHR5cGVvZiBFbGVtZW50ICE9PSAndW5kZWZpbmVkJyAmJiBpc0luc3RhbmNlT2Yod2F0LCBFbGVtZW50KTsKfQoKLyoqCiAqIENoZWNrcyB3aGV0aGVyIGdpdmVuIHZhbHVlIGhhcyBhIHRoZW4gZnVuY3Rpb24uCiAqIEBwYXJhbSB3YXQgQSB2YWx1ZSB0byBiZSBjaGVja2VkLgogKi8KZnVuY3Rpb24gaXNUaGVuYWJsZSh3YXQpIHsKICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLXVuc2FmZS1tZW1iZXItYWNjZXNzCiAgcmV0dXJuIEJvb2xlYW4od2F0ICYmIHdhdC50aGVuICYmIHR5cGVvZiB3YXQudGhlbiA9PT0gJ2Z1bmN0aW9uJyk7Cn0KCi8qKgogKiBDaGVja3Mgd2hldGhlciBnaXZlbiB2YWx1ZSdzIHR5cGUgaXMgYSBTeW50aGV0aWNFdmVudAogKiB7QGxpbmsgaXNTeW50aGV0aWNFdmVudH0uCiAqCiAqIEBwYXJhbSB3YXQgQSB2YWx1ZSB0byBiZSBjaGVja2VkLgogKiBAcmV0dXJucyBBIGJvb2xlYW4gcmVwcmVzZW50aW5nIHRoZSByZXN1bHQuCiAqLwpmdW5jdGlvbiBpc1N5bnRoZXRpY0V2ZW50KHdhdCkgewogIHJldHVybiBpc1BsYWluT2JqZWN0KHdhdCkgJiYgJ25hdGl2ZUV2ZW50JyBpbiB3YXQgJiYgJ3ByZXZlbnREZWZhdWx0JyBpbiB3YXQgJiYgJ3N0b3BQcm9wYWdhdGlvbicgaW4gd2F0Owp9CgovKioKICogQ2hlY2tzIHdoZXRoZXIgZ2l2ZW4gdmFsdWUgaXMgTmFOCiAqIHtAbGluayBpc05hTn0uCiAqCiAqIEBwYXJhbSB3YXQgQSB2YWx1ZSB0byBiZSBjaGVja2VkLgogKiBAcmV0dXJucyBBIGJvb2xlYW4gcmVwcmVzZW50aW5nIHRoZSByZXN1bHQuCiAqLwpmdW5jdGlvbiBpc05hTiQxKHdhdCkgewogIHJldHVybiB0eXBlb2Ygd2F0ID09PSAnbnVtYmVyJyAmJiB3YXQgIT09IHdhdDsKfQoKLyoqCiAqIENoZWNrcyB3aGV0aGVyIGdpdmVuIHZhbHVlJ3MgdHlwZSBpcyBhbiBpbnN0YW5jZSBvZiBwcm92aWRlZCBjb25zdHJ1Y3Rvci4KICoge0BsaW5rIGlzSW5zdGFuY2VPZn0uCiAqCiAqIEBwYXJhbSB3YXQgQSB2YWx1ZSB0byBiZSBjaGVja2VkLgogKiBAcGFyYW0gYmFzZSBBIGNvbnN0cnVjdG9yIHRvIGJlIHVzZWQgaW4gYSBjaGVjay4KICogQHJldHVybnMgQSBib29sZWFuIHJlcHJlc2VudGluZyB0aGUgcmVzdWx0LgogKi8KZnVuY3Rpb24gaXNJbnN0YW5jZU9mKHdhdCwgYmFzZSkgewogIHRyeSB7CiAgICByZXR1cm4gd2F0IGluc3RhbmNlb2YgYmFzZTsKICB9IGNhdGNoIChfZSkgewogICAgcmV0dXJuIGZhbHNlOwogIH0KfQoKLyoqCiAqIENoZWNrcyB3aGV0aGVyIGdpdmVuIHZhbHVlJ3MgdHlwZSBpcyBhIFZ1ZSBWaWV3TW9kZWwuCiAqCiAqIEBwYXJhbSB3YXQgQSB2YWx1ZSB0byBiZSBjaGVja2VkLgogKiBAcmV0dXJucyBBIGJvb2xlYW4gcmVwcmVzZW50aW5nIHRoZSByZXN1bHQuCiAqLwpmdW5jdGlvbiBpc1Z1ZVZpZXdNb2RlbCh3YXQpIHsKICAvLyBOb3QgdXNpbmcgT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZyBiZWNhdXNlIGluIFZ1ZSAzIGl0IHdvdWxkIHJlYWQgdGhlIGluc3RhbmNlJ3MgU3ltYm9sKFN5bWJvbC50b1N0cmluZ1RhZykgcHJvcGVydHkuCiAgcmV0dXJuICEhKHR5cGVvZiB3YXQgPT09ICdvYmplY3QnICYmIHdhdCAhPT0gbnVsbCAmJiAoKHdhdCApLl9faXNWdWUgfHwgKHdhdCApLl9pc1Z1ZSkpOwp9CgovKiogSW50ZXJuYWwgZ2xvYmFsIHdpdGggY29tbW9uIHByb3BlcnRpZXMgYW5kIFNlbnRyeSBleHRlbnNpb25zICAqLwoKLy8gVGhlIGNvZGUgYmVsb3cgZm9yICdpc0dsb2JhbE9iaicgYW5kICdHTE9CQUxfT0JKJyB3YXMgY29waWVkIGZyb20gY29yZS1qcyBiZWZvcmUgbW9kaWZpY2F0aW9uCi8vIGh0dHBzOi8vZ2l0aHViLmNvbS96bG9pcm9jay9jb3JlLWpzL2Jsb2IvMWI5NDRkZjU1MjgyY2RjOTljOTBkYjVmNDllYjBiNmVkYTJjYzBhMy9wYWNrYWdlcy9jb3JlLWpzL2ludGVybmFscy9nbG9iYWwuanMKLy8gY29yZS1qcyBoYXMgdGhlIGZvbGxvd2luZyBsaWNlbmNlOgovLwovLyBDb3B5cmlnaHQgKGMpIDIwMTQtMjAyMiBEZW5pcyBQdXNoa2FyZXYKLy8KLy8gUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGEgY29weQovLyBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZSAiU29mdHdhcmUiKSwgdG8gZGVhbAovLyBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzCi8vIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCwgZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGwKLy8gY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdCBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzCi8vIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGUgZm9sbG93aW5nIGNvbmRpdGlvbnM6Ci8vCi8vIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkIGluCi8vIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLgovLwovLyBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgIkFTIElTIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTUyBPUgovLyBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GIE1FUkNIQU5UQUJJTElUWSwKLy8gRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFCi8vIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sIERBTUFHRVMgT1IgT1RIRVIKLy8gTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUiBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSwKLy8gT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTgovLyBUSEUgU09GVFdBUkUuCgovKiogUmV0dXJucyAnb2JqJyBpZiBpdCdzIHRoZSBnbG9iYWwgb2JqZWN0LCBvdGhlcndpc2UgcmV0dXJucyB1bmRlZmluZWQgKi8KZnVuY3Rpb24gaXNHbG9iYWxPYmoob2JqKSB7CiAgcmV0dXJuIG9iaiAmJiBvYmouTWF0aCA9PSBNYXRoID8gb2JqIDogdW5kZWZpbmVkOwp9CgovKiogR2V0J3MgdGhlIGdsb2JhbCBvYmplY3QgZm9yIHRoZSBjdXJyZW50IEphdmFTY3JpcHQgcnVudGltZSAqLwpjb25zdCBHTE9CQUxfT0JKID0KICAodHlwZW9mIGdsb2JhbFRoaXMgPT0gJ29iamVjdCcgJiYgaXNHbG9iYWxPYmooZ2xvYmFsVGhpcykpIHx8CiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXJlc3RyaWN0ZWQtZ2xvYmFscwogICh0eXBlb2Ygd2luZG93ID09ICdvYmplY3QnICYmIGlzR2xvYmFsT2JqKHdpbmRvdykpIHx8CiAgKHR5cGVvZiBzZWxmID09ICdvYmplY3QnICYmIGlzR2xvYmFsT2JqKHNlbGYpKSB8fAogICh0eXBlb2YgZ2xvYmFsID09ICdvYmplY3QnICYmIGlzR2xvYmFsT2JqKGdsb2JhbCkpIHx8CiAgKGZ1bmN0aW9uICgpIHsKICAgIHJldHVybiB0aGlzOwogIH0pKCkgfHwKICB7fTsKCi8qKgogKiBAZGVwcmVjYXRlZCBVc2UgR0xPQkFMX09CSiBpbnN0ZWFkIG9yIFdJTkRPVyBmcm9tIEBzZW50cnkvYnJvd3Nlci4gVGhpcyB3aWxsIGJlIHJlbW92ZWQgaW4gdjgKICovCmZ1bmN0aW9uIGdldEdsb2JhbE9iamVjdCgpIHsKICByZXR1cm4gR0xPQkFMX09CSiA7Cn0KCi8qKgogKiBSZXR1cm5zIGEgZ2xvYmFsIHNpbmdsZXRvbiBjb250YWluZWQgaW4gdGhlIGdsb2JhbCBgX19TRU5UUllfX2Agb2JqZWN0LgogKgogKiBJZiB0aGUgc2luZ2xldG9uIGRvZXNuJ3QgYWxyZWFkeSBleGlzdCBpbiBgX19TRU5UUllfX2AsIGl0IHdpbGwgYmUgY3JlYXRlZCB1c2luZyB0aGUgZ2l2ZW4gZmFjdG9yeQogKiBmdW5jdGlvbiBhbmQgYWRkZWQgdG8gdGhlIGBfX1NFTlRSWV9fYCBvYmplY3QuCiAqCiAqIEBwYXJhbSBuYW1lIG5hbWUgb2YgdGhlIGdsb2JhbCBzaW5nbGV0b24gb24gX19TRU5UUllfXwogKiBAcGFyYW0gY3JlYXRvciBjcmVhdG9yIEZhY3RvcnkgZnVuY3Rpb24gdG8gY3JlYXRlIHRoZSBzaW5nbGV0b24gaWYgaXQgZG9lc24ndCBhbHJlYWR5IGV4aXN0IG9uIGBfX1NFTlRSWV9fYAogKiBAcGFyYW0gb2JqIChPcHRpb25hbCkgVGhlIGdsb2JhbCBvYmplY3Qgb24gd2hpY2ggdG8gbG9vayBmb3IgYF9fU0VOVFJZX19gLCBpZiBub3QgYEdMT0JBTF9PQkpgJ3MgcmV0dXJuIHZhbHVlCiAqIEByZXR1cm5zIHRoZSBzaW5nbGV0b24KICovCmZ1bmN0aW9uIGdldEdsb2JhbFNpbmdsZXRvbihuYW1lLCBjcmVhdG9yLCBvYmopIHsKICBjb25zdCBnYmwgPSAob2JqIHx8IEdMT0JBTF9PQkopIDsKICBjb25zdCBfX1NFTlRSWV9fID0gKGdibC5fX1NFTlRSWV9fID0gZ2JsLl9fU0VOVFJZX18gfHwge30pOwogIGNvbnN0IHNpbmdsZXRvbiA9IF9fU0VOVFJZX19bbmFtZV0gfHwgKF9fU0VOVFJZX19bbmFtZV0gPSBjcmVhdG9yKCkpOwogIHJldHVybiBzaW5nbGV0b247Cn0KCi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBkZXByZWNhdGlvbi9kZXByZWNhdGlvbgpjb25zdCBXSU5ET1cgPSBnZXRHbG9iYWxPYmplY3QoKTsKCmNvbnN0IERFRkFVTFRfTUFYX1NUUklOR19MRU5HVEggPSA4MDsKCi8qKgogKiBHaXZlbiBhIGNoaWxkIERPTSBlbGVtZW50LCByZXR1cm5zIGEgcXVlcnktc2VsZWN0b3Igc3RhdGVtZW50IGRlc2NyaWJpbmcgdGhhdAogKiBhbmQgaXRzIGFuY2VzdG9ycwogKiBlLmcuIFtIVE1MRWxlbWVudF0gPT4gYm9keSA+IGRpdiA+IGlucHV0I2Zvby5idG5bbmFtZT1iYXpdCiAqIEByZXR1cm5zIGdlbmVyYXRlZCBET00gcGF0aAogKi8KZnVuY3Rpb24gaHRtbFRyZWVBc1N0cmluZygKICBlbGVtLAogIG9wdGlvbnMgPSB7fSwKKSB7CiAgaWYgKCFlbGVtKSB7CiAgICByZXR1cm4gJzx1bmtub3duPic7CiAgfQoKICAvLyB0cnkvY2F0Y2ggYm90aDoKICAvLyAtIGFjY2Vzc2luZyBldmVudC50YXJnZXQgKHNlZSBnZXRzZW50cnkvcmF2ZW4tanMjODM4LCAjNzY4KQogIC8vIC0gYGh0bWxUcmVlQXNTdHJpbmdgIGJlY2F1c2UgaXQncyBjb21wbGV4LCBhbmQganVzdCBhY2Nlc3NpbmcgdGhlIERPTSBpbmNvcnJlY3RseQogIC8vIC0gY2FuIHRocm93IGFuIGV4Y2VwdGlvbiBpbiBzb21lIGNpcmN1bXN0YW5jZXMuCiAgdHJ5IHsKICAgIGxldCBjdXJyZW50RWxlbSA9IGVsZW0gOwogICAgY29uc3QgTUFYX1RSQVZFUlNFX0hFSUdIVCA9IDU7CiAgICBjb25zdCBvdXQgPSBbXTsKICAgIGxldCBoZWlnaHQgPSAwOwogICAgbGV0IGxlbiA9IDA7CiAgICBjb25zdCBzZXBhcmF0b3IgPSAnID4gJzsKICAgIGNvbnN0IHNlcExlbmd0aCA9IHNlcGFyYXRvci5sZW5ndGg7CiAgICBsZXQgbmV4dFN0cjsKICAgIGNvbnN0IGtleUF0dHJzID0gQXJyYXkuaXNBcnJheShvcHRpb25zKSA/IG9wdGlvbnMgOiBvcHRpb25zLmtleUF0dHJzOwogICAgY29uc3QgbWF4U3RyaW5nTGVuZ3RoID0gKCFBcnJheS5pc0FycmF5KG9wdGlvbnMpICYmIG9wdGlvbnMubWF4U3RyaW5nTGVuZ3RoKSB8fCBERUZBVUxUX01BWF9TVFJJTkdfTEVOR1RIOwoKICAgIHdoaWxlIChjdXJyZW50RWxlbSAmJiBoZWlnaHQrKyA8IE1BWF9UUkFWRVJTRV9IRUlHSFQpIHsKICAgICAgbmV4dFN0ciA9IF9odG1sRWxlbWVudEFzU3RyaW5nKGN1cnJlbnRFbGVtLCBrZXlBdHRycyk7CiAgICAgIC8vIGJhaWwgb3V0IGlmCiAgICAgIC8vIC0gbmV4dFN0ciBpcyB0aGUgJ2h0bWwnIGVsZW1lbnQKICAgICAgLy8gLSB0aGUgbGVuZ3RoIG9mIHRoZSBzdHJpbmcgdGhhdCB3b3VsZCBiZSBjcmVhdGVkIGV4Y2VlZHMgbWF4U3RyaW5nTGVuZ3RoCiAgICAgIC8vICAgKGlnbm9yZSB0aGlzIGxpbWl0IGlmIHdlIGFyZSBvbiB0aGUgZmlyc3QgaXRlcmF0aW9uKQogICAgICBpZiAobmV4dFN0ciA9PT0gJ2h0bWwnIHx8IChoZWlnaHQgPiAxICYmIGxlbiArIG91dC5sZW5ndGggKiBzZXBMZW5ndGggKyBuZXh0U3RyLmxlbmd0aCA+PSBtYXhTdHJpbmdMZW5ndGgpKSB7CiAgICAgICAgYnJlYWs7CiAgICAgIH0KCiAgICAgIG91dC5wdXNoKG5leHRTdHIpOwoKICAgICAgbGVuICs9IG5leHRTdHIubGVuZ3RoOwogICAgICBjdXJyZW50RWxlbSA9IGN1cnJlbnRFbGVtLnBhcmVudE5vZGU7CiAgICB9CgogICAgcmV0dXJuIG91dC5yZXZlcnNlKCkuam9pbihzZXBhcmF0b3IpOwogIH0gY2F0Y2ggKF9vTykgewogICAgcmV0dXJuICc8dW5rbm93bj4nOwogIH0KfQoKLyoqCiAqIFJldHVybnMgYSBzaW1wbGUsIHF1ZXJ5LXNlbGVjdG9yIHJlcHJlc2VudGF0aW9uIG9mIGEgRE9NIGVsZW1lbnQKICogZS5nLiBbSFRNTEVsZW1lbnRdID0+IGlucHV0I2Zvby5idG5bbmFtZT1iYXpdCiAqIEByZXR1cm5zIGdlbmVyYXRlZCBET00gcGF0aAogKi8KZnVuY3Rpb24gX2h0bWxFbGVtZW50QXNTdHJpbmcoZWwsIGtleUF0dHJzKSB7CiAgY29uc3QgZWxlbSA9IGVsCgo7CgogIGNvbnN0IG91dCA9IFtdOwogIGxldCBjbGFzc05hbWU7CiAgbGV0IGNsYXNzZXM7CiAgbGV0IGtleTsKICBsZXQgYXR0cjsKICBsZXQgaTsKCiAgaWYgKCFlbGVtIHx8ICFlbGVtLnRhZ05hbWUpIHsKICAgIHJldHVybiAnJzsKICB9CgogIC8vIEB0cy1leHBlY3QtZXJyb3IgV0lORE9XIGhhcyBIVE1MRWxlbWVudAogIGlmIChXSU5ET1cuSFRNTEVsZW1lbnQpIHsKICAgIC8vIElmIHVzaW5nIHRoZSBjb21wb25lbnQgbmFtZSBhbm5vdGF0aW9uIHBsdWdpbiwgdGhpcyB2YWx1ZSBtYXkgYmUgYXZhaWxhYmxlIG9uIHRoZSBET00gbm9kZQogICAgaWYgKGVsZW0gaW5zdGFuY2VvZiBIVE1MRWxlbWVudCAmJiBlbGVtLmRhdGFzZXQgJiYgZWxlbS5kYXRhc2V0WydzZW50cnlDb21wb25lbnQnXSkgewogICAgICByZXR1cm4gZWxlbS5kYXRhc2V0WydzZW50cnlDb21wb25lbnQnXTsKICAgIH0KICB9CgogIG91dC5wdXNoKGVsZW0udGFnTmFtZS50b0xvd2VyQ2FzZSgpKTsKCiAgLy8gUGFpcnMgb2YgYXR0cmlidXRlIGtleXMgZGVmaW5lZCBpbiBgc2VyaWFsaXplQXR0cmlidXRlYCBhbmQgdGhlaXIgdmFsdWVzIG9uIGVsZW1lbnQuCiAgY29uc3Qga2V5QXR0clBhaXJzID0KICAgIGtleUF0dHJzICYmIGtleUF0dHJzLmxlbmd0aAogICAgICA/IGtleUF0dHJzLmZpbHRlcihrZXlBdHRyID0+IGVsZW0uZ2V0QXR0cmlidXRlKGtleUF0dHIpKS5tYXAoa2V5QXR0ciA9PiBba2V5QXR0ciwgZWxlbS5nZXRBdHRyaWJ1dGUoa2V5QXR0cildKQogICAgICA6IG51bGw7CgogIGlmIChrZXlBdHRyUGFpcnMgJiYga2V5QXR0clBhaXJzLmxlbmd0aCkgewogICAga2V5QXR0clBhaXJzLmZvckVhY2goa2V5QXR0clBhaXIgPT4gewogICAgICBvdXQucHVzaChgWyR7a2V5QXR0clBhaXJbMF19PSIke2tleUF0dHJQYWlyWzFdfSJdYCk7CiAgICB9KTsKICB9IGVsc2UgewogICAgaWYgKGVsZW0uaWQpIHsKICAgICAgb3V0LnB1c2goYCMke2VsZW0uaWR9YCk7CiAgICB9CgogICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIHByZWZlci1jb25zdAogICAgY2xhc3NOYW1lID0gZWxlbS5jbGFzc05hbWU7CiAgICBpZiAoY2xhc3NOYW1lICYmIGlzU3RyaW5nKGNsYXNzTmFtZSkpIHsKICAgICAgY2xhc3NlcyA9IGNsYXNzTmFtZS5zcGxpdCgvXHMrLyk7CiAgICAgIGZvciAoaSA9IDA7IGkgPCBjbGFzc2VzLmxlbmd0aDsgaSsrKSB7CiAgICAgICAgb3V0LnB1c2goYC4ke2NsYXNzZXNbaV19YCk7CiAgICAgIH0KICAgIH0KICB9CiAgY29uc3QgYWxsb3dlZEF0dHJzID0gWydhcmlhLWxhYmVsJywgJ3R5cGUnLCAnbmFtZScsICd0aXRsZScsICdhbHQnXTsKICBmb3IgKGkgPSAwOyBpIDwgYWxsb3dlZEF0dHJzLmxlbmd0aDsgaSsrKSB7CiAgICBrZXkgPSBhbGxvd2VkQXR0cnNbaV07CiAgICBhdHRyID0gZWxlbS5nZXRBdHRyaWJ1dGUoa2V5KTsKICAgIGlmIChhdHRyKSB7CiAgICAgIG91dC5wdXNoKGBbJHtrZXl9PSIke2F0dHJ9Il1gKTsKICAgIH0KICB9CiAgcmV0dXJuIG91dC5qb2luKCcnKTsKfQoKLyoqCiAqIFRoaXMgc2VydmVzIGFzIGEgYnVpbGQgdGltZSBmbGFnIHRoYXQgd2lsbCBiZSB0cnVlIGJ5IGRlZmF1bHQsIGJ1dCBmYWxzZSBpbiBub24tZGVidWcgYnVpbGRzIG9yIGlmIHVzZXJzIHJlcGxhY2UgYF9fU0VOVFJZX0RFQlVHX19gIGluIHRoZWlyIGdlbmVyYXRlZCBjb2RlLgogKgogKiBBVFRFTlRJT046IFRoaXMgY29uc3RhbnQgbXVzdCBuZXZlciBjcm9zcyBwYWNrYWdlIGJvdW5kYXJpZXMgKGkuZS4gYmUgZXhwb3J0ZWQpIHRvIGd1YXJhbnRlZSB0aGF0IGl0IGNhbiBiZSB1c2VkIGZvciB0cmVlIHNoYWtpbmcuCiAqLwpjb25zdCBERUJVR19CVUlMRCQxID0gKHR5cGVvZiBfX1NFTlRSWV9ERUJVR19fID09PSAndW5kZWZpbmVkJyB8fCBfX1NFTlRSWV9ERUJVR19fKTsKCi8qKiBQcmVmaXggZm9yIGxvZ2dpbmcgc3RyaW5ncyAqLwpjb25zdCBQUkVGSVggPSAnU2VudHJ5IExvZ2dlciAnOwoKY29uc3QgQ09OU09MRV9MRVZFTFMgPSBbCiAgJ2RlYnVnJywKICAnaW5mbycsCiAgJ3dhcm4nLAogICdlcnJvcicsCiAgJ2xvZycsCiAgJ2Fzc2VydCcsCiAgJ3RyYWNlJywKXSA7CgovKiogVGhpcyBtYXkgYmUgbXV0YXRlZCBieSB0aGUgY29uc29sZSBpbnN0cnVtZW50YXRpb24uICovCmNvbnN0IG9yaWdpbmFsQ29uc29sZU1ldGhvZHMKCiA9IHt9OwoKLyoqIEpTRG9jICovCgovKioKICogVGVtcG9yYXJpbHkgZGlzYWJsZSBzZW50cnkgY29uc29sZSBpbnN0cnVtZW50YXRpb25zLgogKgogKiBAcGFyYW0gY2FsbGJhY2sgVGhlIGZ1bmN0aW9uIHRvIHJ1biBhZ2FpbnN0IHRoZSBvcmlnaW5hbCBgY29uc29sZWAgbWVzc2FnZXMKICogQHJldHVybnMgVGhlIHJlc3VsdHMgb2YgdGhlIGNhbGxiYWNrCiAqLwpmdW5jdGlvbiBjb25zb2xlU2FuZGJveChjYWxsYmFjaykgewogIGlmICghKCdjb25zb2xlJyBpbiBHTE9CQUxfT0JKKSkgewogICAgcmV0dXJuIGNhbGxiYWNrKCk7CiAgfQoKICBjb25zdCBjb25zb2xlID0gR0xPQkFMX09CSi5jb25zb2xlIDsKICBjb25zdCB3cmFwcGVkRnVuY3MgPSB7fTsKCiAgY29uc3Qgd3JhcHBlZExldmVscyA9IE9iamVjdC5rZXlzKG9yaWdpbmFsQ29uc29sZU1ldGhvZHMpIDsKCiAgLy8gUmVzdG9yZSBhbGwgd3JhcHBlZCBjb25zb2xlIG1ldGhvZHMKICB3cmFwcGVkTGV2ZWxzLmZvckVhY2gobGV2ZWwgPT4gewogICAgY29uc3Qgb3JpZ2luYWxDb25zb2xlTWV0aG9kID0gb3JpZ2luYWxDb25zb2xlTWV0aG9kc1tsZXZlbF0gOwogICAgd3JhcHBlZEZ1bmNzW2xldmVsXSA9IGNvbnNvbGVbbGV2ZWxdIDsKICAgIGNvbnNvbGVbbGV2ZWxdID0gb3JpZ2luYWxDb25zb2xlTWV0aG9kOwogIH0pOwoKICB0cnkgewogICAgcmV0dXJuIGNhbGxiYWNrKCk7CiAgfSBmaW5hbGx5IHsKICAgIC8vIFJldmVydCByZXN0b3JhdGlvbiB0byB3cmFwcGVkIHN0YXRlCiAgICB3cmFwcGVkTGV2ZWxzLmZvckVhY2gobGV2ZWwgPT4gewogICAgICBjb25zb2xlW2xldmVsXSA9IHdyYXBwZWRGdW5jc1tsZXZlbF0gOwogICAgfSk7CiAgfQp9CgpmdW5jdGlvbiBtYWtlTG9nZ2VyKCkgewogIGxldCBlbmFibGVkID0gZmFsc2U7CiAgY29uc3QgbG9nZ2VyID0gewogICAgZW5hYmxlOiAoKSA9PiB7CiAgICAgIGVuYWJsZWQgPSB0cnVlOwogICAgfSwKICAgIGRpc2FibGU6ICgpID0+IHsKICAgICAgZW5hYmxlZCA9IGZhbHNlOwogICAgfSwKICAgIGlzRW5hYmxlZDogKCkgPT4gZW5hYmxlZCwKICB9OwoKICBpZiAoREVCVUdfQlVJTEQkMSkgewogICAgQ09OU09MRV9MRVZFTFMuZm9yRWFjaChuYW1lID0+IHsKICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnkKICAgICAgbG9nZ2VyW25hbWVdID0gKC4uLmFyZ3MpID0+IHsKICAgICAgICBpZiAoZW5hYmxlZCkgewogICAgICAgICAgY29uc29sZVNhbmRib3goKCkgPT4gewogICAgICAgICAgICBHTE9CQUxfT0JKLmNvbnNvbGVbbmFtZV0oYCR7UFJFRklYfVske25hbWV9XTpgLCAuLi5hcmdzKTsKICAgICAgICAgIH0pOwogICAgICAgIH0KICAgICAgfTsKICAgIH0pOwogIH0gZWxzZSB7CiAgICBDT05TT0xFX0xFVkVMUy5mb3JFYWNoKG5hbWUgPT4gewogICAgICBsb2dnZXJbbmFtZV0gPSAoKSA9PiB1bmRlZmluZWQ7CiAgICB9KTsKICB9CgogIHJldHVybiBsb2dnZXIgOwp9Cgpjb25zdCBsb2dnZXIgPSBtYWtlTG9nZ2VyKCk7CgovKioKICogUmVuZGVycyB0aGUgc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIHRoaXMgRHNuLgogKgogKiBCeSBkZWZhdWx0LCB0aGlzIHdpbGwgcmVuZGVyIHRoZSBwdWJsaWMgcmVwcmVzZW50YXRpb24gd2l0aG91dCB0aGUgcGFzc3dvcmQKICogY29tcG9uZW50LiBUbyBnZXQgdGhlIGRlcHJlY2F0ZWQgcHJpdmF0ZSByZXByZXNlbnRhdGlvbiwgc2V0IGB3aXRoUGFzc3dvcmRgCiAqIHRvIHRydWUuCiAqCiAqIEBwYXJhbSB3aXRoUGFzc3dvcmQgV2hlbiBzZXQgdG8gdHJ1ZSwgdGhlIHBhc3N3b3JkIHdpbGwgYmUgaW5jbHVkZWQuCiAqLwpmdW5jdGlvbiBkc25Ub1N0cmluZyhkc24sIHdpdGhQYXNzd29yZCA9IGZhbHNlKSB7CiAgY29uc3QgeyBob3N0LCBwYXRoLCBwYXNzLCBwb3J0LCBwcm9qZWN0SWQsIHByb3RvY29sLCBwdWJsaWNLZXkgfSA9IGRzbjsKICByZXR1cm4gKAogICAgYCR7cHJvdG9jb2x9Oi8vJHtwdWJsaWNLZXl9JHt3aXRoUGFzc3dvcmQgJiYgcGFzcyA/IGA6JHtwYXNzfWAgOiAnJ31gICsKICAgIGBAJHtob3N0fSR7cG9ydCA/IGA6JHtwb3J0fWAgOiAnJ30vJHtwYXRoID8gYCR7cGF0aH0vYCA6IHBhdGh9JHtwcm9qZWN0SWR9YAogICk7Cn0KCi8qKiBBbiBlcnJvciBlbWl0dGVkIGJ5IFNlbnRyeSBTREtzIGFuZCByZWxhdGVkIHV0aWxpdGllcy4gKi8KY2xhc3MgU2VudHJ5RXJyb3IgZXh0ZW5kcyBFcnJvciB7CiAgLyoqIERpc3BsYXkgbmFtZSBvZiB0aGlzIGVycm9yIGluc3RhbmNlLiAqLwoKICAgY29uc3RydWN0b3IoIG1lc3NhZ2UsIGxvZ0xldmVsID0gJ3dhcm4nKSB7CiAgICBzdXBlcihtZXNzYWdlKTt0aGlzLm1lc3NhZ2UgPSBtZXNzYWdlOwogICAgdGhpcy5uYW1lID0gbmV3LnRhcmdldC5wcm90b3R5cGUuY29uc3RydWN0b3IubmFtZTsKICAgIC8vIFRoaXMgc2V0cyB0aGUgcHJvdG90eXBlIHRvIGJlIGBFcnJvcmAsIG5vdCBgU2VudHJ5RXJyb3JgLiBJdCdzIHVuY2xlYXIgd2h5IHdlIGRvIHRoaXMsIGJ1dCBjb21tZW50aW5nIHRoaXMgbGluZQogICAgLy8gb3V0IGNhdXNlcyB2YXJpb3VzIChzZWVtaW5nbHkgdG90YWxseSB1bnJlbGF0ZWQpIHBsYXl3cmlnaHQgdGVzdHMgY29uc2lzdGVudGx5IHRpbWUgb3V0LiBGWUksIHRoaXMgbWFrZXMKICAgIC8vIGluc3RhbmNlcyBvZiBgU2VudHJ5RXJyb3JgIGZhaWwgYG9iaiBpbnN0YW5jZW9mIFNlbnRyeUVycm9yYCBjaGVja3MuCiAgICBPYmplY3Quc2V0UHJvdG90eXBlT2YodGhpcywgbmV3LnRhcmdldC5wcm90b3R5cGUpOwogICAgdGhpcy5sb2dMZXZlbCA9IGxvZ0xldmVsOwogIH0KfQoKLyoqCiAqIEVuY29kZXMgZ2l2ZW4gb2JqZWN0IGludG8gdXJsLWZyaWVuZGx5IGZvcm1hdAogKgogKiBAcGFyYW0gb2JqZWN0IEFuIG9iamVjdCB0aGF0IGNvbnRhaW5zIHNlcmlhbGl6YWJsZSB2YWx1ZXMKICogQHJldHVybnMgc3RyaW5nIEVuY29kZWQKICovCmZ1bmN0aW9uIHVybEVuY29kZShvYmplY3QpIHsKICByZXR1cm4gT2JqZWN0LmtleXMob2JqZWN0KQogICAgLm1hcChrZXkgPT4gYCR7ZW5jb2RlVVJJQ29tcG9uZW50KGtleSl9PSR7ZW5jb2RlVVJJQ29tcG9uZW50KG9iamVjdFtrZXldKX1gKQogICAgLmpvaW4oJyYnKTsKfQoKLyoqCiAqIFRyYW5zZm9ybXMgYW55IGBFcnJvcmAgb3IgYEV2ZW50YCBpbnRvIGEgcGxhaW4gb2JqZWN0IHdpdGggYWxsIG9mIHRoZWlyIGVudW1lcmFibGUgcHJvcGVydGllcywgYW5kIHNvbWUgb2YgdGhlaXIKICogbm9uLWVudW1lcmFibGUgcHJvcGVydGllcyBhdHRhY2hlZC4KICoKICogQHBhcmFtIHZhbHVlIEluaXRpYWwgc291cmNlIHRoYXQgd2UgaGF2ZSB0byB0cmFuc2Zvcm0gaW4gb3JkZXIgZm9yIGl0IHRvIGJlIHVzYWJsZSBieSB0aGUgc2VyaWFsaXplcgogKiBAcmV0dXJucyBBbiBFdmVudCBvciBFcnJvciB0dXJuZWQgaW50byBhbiBvYmplY3QgLSBvciB0aGUgdmFsdWUgYXJndXJtZW50IGl0c2VsZiwgd2hlbiB2YWx1ZSBpcyBuZWl0aGVyIGFuIEV2ZW50IG5vcgogKiAgYW4gRXJyb3IuCiAqLwpmdW5jdGlvbiBjb252ZXJ0VG9QbGFpbk9iamVjdCgKICB2YWx1ZSwKKQoKIHsKICBpZiAoaXNFcnJvcih2YWx1ZSkpIHsKICAgIHJldHVybiB7CiAgICAgIG1lc3NhZ2U6IHZhbHVlLm1lc3NhZ2UsCiAgICAgIG5hbWU6IHZhbHVlLm5hbWUsCiAgICAgIHN0YWNrOiB2YWx1ZS5zdGFjaywKICAgICAgLi4uZ2V0T3duUHJvcGVydGllcyh2YWx1ZSksCiAgICB9OwogIH0gZWxzZSBpZiAoaXNFdmVudCh2YWx1ZSkpIHsKICAgIGNvbnN0IG5ld09iagoKID0gewogICAgICB0eXBlOiB2YWx1ZS50eXBlLAogICAgICB0YXJnZXQ6IHNlcmlhbGl6ZUV2ZW50VGFyZ2V0KHZhbHVlLnRhcmdldCksCiAgICAgIGN1cnJlbnRUYXJnZXQ6IHNlcmlhbGl6ZUV2ZW50VGFyZ2V0KHZhbHVlLmN1cnJlbnRUYXJnZXQpLAogICAgICAuLi5nZXRPd25Qcm9wZXJ0aWVzKHZhbHVlKSwKICAgIH07CgogICAgaWYgKHR5cGVvZiBDdXN0b21FdmVudCAhPT0gJ3VuZGVmaW5lZCcgJiYgaXNJbnN0YW5jZU9mKHZhbHVlLCBDdXN0b21FdmVudCkpIHsKICAgICAgbmV3T2JqLmRldGFpbCA9IHZhbHVlLmRldGFpbDsKICAgIH0KCiAgICByZXR1cm4gbmV3T2JqOwogIH0gZWxzZSB7CiAgICByZXR1cm4gdmFsdWU7CiAgfQp9CgovKiogQ3JlYXRlcyBhIHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiB0aGUgdGFyZ2V0IG9mIGFuIGBFdmVudGAgb2JqZWN0ICovCmZ1bmN0aW9uIHNlcmlhbGl6ZUV2ZW50VGFyZ2V0KHRhcmdldCkgewogIHRyeSB7CiAgICByZXR1cm4gaXNFbGVtZW50KHRhcmdldCkgPyBodG1sVHJlZUFzU3RyaW5nKHRhcmdldCkgOiBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwodGFyZ2V0KTsKICB9IGNhdGNoIChfb08pIHsKICAgIHJldHVybiAnPHVua25vd24+JzsKICB9Cn0KCi8qKiBGaWx0ZXJzIG91dCBhbGwgYnV0IGFuIG9iamVjdCdzIG93biBwcm9wZXJ0aWVzICovCmZ1bmN0aW9uIGdldE93blByb3BlcnRpZXMob2JqKSB7CiAgaWYgKHR5cGVvZiBvYmogPT09ICdvYmplY3QnICYmIG9iaiAhPT0gbnVsbCkgewogICAgY29uc3QgZXh0cmFjdGVkUHJvcHMgPSB7fTsKICAgIGZvciAoY29uc3QgcHJvcGVydHkgaW4gb2JqKSB7CiAgICAgIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob2JqLCBwcm9wZXJ0eSkpIHsKICAgICAgICBleHRyYWN0ZWRQcm9wc1twcm9wZXJ0eV0gPSAob2JqIClbcHJvcGVydHldOwogICAgICB9CiAgICB9CiAgICByZXR1cm4gZXh0cmFjdGVkUHJvcHM7CiAgfSBlbHNlIHsKICAgIHJldHVybiB7fTsKICB9Cn0KCi8qKgogKiBHaXZlbiBhbnkgb2JqZWN0LCByZXR1cm4gYSBuZXcgb2JqZWN0IGhhdmluZyByZW1vdmVkIGFsbCBmaWVsZHMgd2hvc2UgdmFsdWUgd2FzIGB1bmRlZmluZWRgLgogKiBXb3JrcyByZWN1cnNpdmVseSBvbiBvYmplY3RzIGFuZCBhcnJheXMuCiAqCiAqIEF0dGVudGlvbjogVGhpcyBmdW5jdGlvbiBrZWVwcyBjaXJjdWxhciByZWZlcmVuY2VzIGluIHRoZSByZXR1cm5lZCBvYmplY3QuCiAqLwpmdW5jdGlvbiBkcm9wVW5kZWZpbmVkS2V5cyhpbnB1dFZhbHVlKSB7CiAgLy8gVGhpcyBtYXAga2VlcHMgdHJhY2sgb2Ygd2hhdCBhbHJlYWR5IHZpc2l0ZWQgbm9kZXMgbWFwIHRvLgogIC8vIE91ciBTZXQgLSBiYXNlZCBtZW1vQnVpbGRlciBkb2Vzbid0IHdvcmsgaGVyZSBiZWNhdXNlIHdlIHdhbnQgdG8gdGhlIG91dHB1dCBvYmplY3QgdG8gaGF2ZSB0aGUgc2FtZSBjaXJjdWxhcgogIC8vIHJlZmVyZW5jZXMgYXMgdGhlIGlucHV0IG9iamVjdC4KICBjb25zdCBtZW1vaXphdGlvbk1hcCA9IG5ldyBNYXAoKTsKCiAgLy8gVGhpcyBmdW5jdGlvbiBqdXN0IHByb3hpZXMgYF9kcm9wVW5kZWZpbmVkS2V5c2AgdG8ga2VlcCB0aGUgYG1lbW9CdWlsZGVyYCBvdXQgb2YgdGhpcyBmdW5jdGlvbidzIEFQSQogIHJldHVybiBfZHJvcFVuZGVmaW5lZEtleXMoaW5wdXRWYWx1ZSwgbWVtb2l6YXRpb25NYXApOwp9CgpmdW5jdGlvbiBfZHJvcFVuZGVmaW5lZEtleXMoaW5wdXRWYWx1ZSwgbWVtb2l6YXRpb25NYXApIHsKICBpZiAoaXNQb2pvKGlucHV0VmFsdWUpKSB7CiAgICAvLyBJZiB0aGlzIG5vZGUgaGFzIGFscmVhZHkgYmVlbiB2aXNpdGVkIGR1ZSB0byBhIGNpcmN1bGFyIHJlZmVyZW5jZSwgcmV0dXJuIHRoZSBvYmplY3QgaXQgd2FzIG1hcHBlZCB0byBpbiB0aGUgbmV3IG9iamVjdAogICAgY29uc3QgbWVtb1ZhbCA9IG1lbW9pemF0aW9uTWFwLmdldChpbnB1dFZhbHVlKTsKICAgIGlmIChtZW1vVmFsICE9PSB1bmRlZmluZWQpIHsKICAgICAgcmV0dXJuIG1lbW9WYWwgOwogICAgfQoKICAgIGNvbnN0IHJldHVyblZhbHVlID0ge307CiAgICAvLyBTdG9yZSB0aGUgbWFwcGluZyBvZiB0aGlzIHZhbHVlIGluIGNhc2Ugd2UgdmlzaXQgaXQgYWdhaW4sIGluIGNhc2Ugb2YgY2lyY3VsYXIgZGF0YQogICAgbWVtb2l6YXRpb25NYXAuc2V0KGlucHV0VmFsdWUsIHJldHVyblZhbHVlKTsKCiAgICBmb3IgKGNvbnN0IGtleSBvZiBPYmplY3Qua2V5cyhpbnB1dFZhbHVlKSkgewogICAgICBpZiAodHlwZW9mIGlucHV0VmFsdWVba2V5XSAhPT0gJ3VuZGVmaW5lZCcpIHsKICAgICAgICByZXR1cm5WYWx1ZVtrZXldID0gX2Ryb3BVbmRlZmluZWRLZXlzKGlucHV0VmFsdWVba2V5XSwgbWVtb2l6YXRpb25NYXApOwogICAgICB9CiAgICB9CgogICAgcmV0dXJuIHJldHVyblZhbHVlIDsKICB9CgogIGlmIChBcnJheS5pc0FycmF5KGlucHV0VmFsdWUpKSB7CiAgICAvLyBJZiB0aGlzIG5vZGUgaGFzIGFscmVhZHkgYmVlbiB2aXNpdGVkIGR1ZSB0byBhIGNpcmN1bGFyIHJlZmVyZW5jZSwgcmV0dXJuIHRoZSBhcnJheSBpdCB3YXMgbWFwcGVkIHRvIGluIHRoZSBuZXcgb2JqZWN0CiAgICBjb25zdCBtZW1vVmFsID0gbWVtb2l6YXRpb25NYXAuZ2V0KGlucHV0VmFsdWUpOwogICAgaWYgKG1lbW9WYWwgIT09IHVuZGVmaW5lZCkgewogICAgICByZXR1cm4gbWVtb1ZhbCA7CiAgICB9CgogICAgY29uc3QgcmV0dXJuVmFsdWUgPSBbXTsKICAgIC8vIFN0b3JlIHRoZSBtYXBwaW5nIG9mIHRoaXMgdmFsdWUgaW4gY2FzZSB3ZSB2aXNpdCBpdCBhZ2FpbiwgaW4gY2FzZSBvZiBjaXJjdWxhciBkYXRhCiAgICBtZW1vaXphdGlvbk1hcC5zZXQoaW5wdXRWYWx1ZSwgcmV0dXJuVmFsdWUpOwoKICAgIGlucHV0VmFsdWUuZm9yRWFjaCgoaXRlbSkgPT4gewogICAgICByZXR1cm5WYWx1ZS5wdXNoKF9kcm9wVW5kZWZpbmVkS2V5cyhpdGVtLCBtZW1vaXphdGlvbk1hcCkpOwogICAgfSk7CgogICAgcmV0dXJuIHJldHVyblZhbHVlIDsKICB9CgogIHJldHVybiBpbnB1dFZhbHVlOwp9CgpmdW5jdGlvbiBpc1Bvam8oaW5wdXQpIHsKICBpZiAoIWlzUGxhaW5PYmplY3QoaW5wdXQpKSB7CiAgICByZXR1cm4gZmFsc2U7CiAgfQoKICB0cnkgewogICAgY29uc3QgbmFtZSA9IChPYmplY3QuZ2V0UHJvdG90eXBlT2YoaW5wdXQpICkuY29uc3RydWN0b3IubmFtZTsKICAgIHJldHVybiAhbmFtZSB8fCBuYW1lID09PSAnT2JqZWN0JzsKICB9IGNhdGNoIChlKSB7CiAgICByZXR1cm4gdHJ1ZTsKICB9Cn0KCi8qKgogKiBEb2VzIHRoaXMgZmlsZW5hbWUgbG9vayBsaWtlIGl0J3MgcGFydCBvZiB0aGUgYXBwIGNvZGU/CiAqLwpmdW5jdGlvbiBmaWxlbmFtZUlzSW5BcHAoZmlsZW5hbWUsIGlzTmF0aXZlID0gZmFsc2UpIHsKICBjb25zdCBpc0ludGVybmFsID0KICAgIGlzTmF0aXZlIHx8CiAgICAoZmlsZW5hbWUgJiYKICAgICAgLy8gSXQncyBub3QgaW50ZXJuYWwgaWYgaXQncyBhbiBhYnNvbHV0ZSBsaW51eCBwYXRoCiAgICAgICFmaWxlbmFtZS5zdGFydHNXaXRoKCcvJykgJiYKICAgICAgLy8gSXQncyBub3QgaW50ZXJuYWwgaWYgaXQncyBhbiBhYnNvbHV0ZSB3aW5kb3dzIHBhdGgKICAgICAgIWZpbGVuYW1lLm1hdGNoKC9eW0EtWl06LykgJiYKICAgICAgLy8gSXQncyBub3QgaW50ZXJuYWwgaWYgdGhlIHBhdGggaXMgc3RhcnRpbmcgd2l0aCBhIGRvdAogICAgICAhZmlsZW5hbWUuc3RhcnRzV2l0aCgnLicpICYmCiAgICAgIC8vIEl0J3Mgbm90IGludGVybmFsIGlmIHRoZSBmcmFtZSBoYXMgYSBwcm90b2NvbC4gSW4gbm9kZSwgdGhpcyBpcyB1c3VhbGx5IHRoZSBjYXNlIGlmIHRoZSBmaWxlIGdvdCBwcmUtcHJvY2Vzc2VkIHdpdGggYSBidW5kbGVyIGxpa2Ugd2VicGFjawogICAgICAhZmlsZW5hbWUubWF0Y2goL15bYS16QS1aXShbYS16QS1aMC05LlwtK10pKjpcL1wvLykpOyAvLyBTY2hlbWEgZnJvbTogaHR0cHM6Ly9zdGFja292ZXJmbG93LmNvbS9hLzM2NDE3ODIKCiAgLy8gaW5fYXBwIGlzIGFsbCB0aGF0J3Mgbm90IGFuIGludGVybmFsIE5vZGUgZnVuY3Rpb24gb3IgYSBtb2R1bGUgd2l0aGluIG5vZGVfbW9kdWxlcwogIC8vIG5vdGUgdGhhdCBpc05hdGl2ZSBhcHBlYXJzIHRvIHJldHVybiB0cnVlIGV2ZW4gZm9yIG5vZGUgY29yZSBsaWJyYXJpZXMKICAvLyBzZWUgaHR0cHM6Ly9naXRodWIuY29tL2dldHNlbnRyeS9yYXZlbi1ub2RlL2lzc3Vlcy8xNzYKCiAgcmV0dXJuICFpc0ludGVybmFsICYmIGZpbGVuYW1lICE9PSB1bmRlZmluZWQgJiYgIWZpbGVuYW1lLmluY2x1ZGVzKCdub2RlX21vZHVsZXMvJyk7Cn0KCmNvbnN0IFNUQUNLVFJBQ0VfRlJBTUVfTElNSVQgPSA1MDsKY29uc3QgU1RSSVBfRlJBTUVfUkVHRVhQID0gL2NhcHR1cmVNZXNzYWdlfGNhcHR1cmVFeGNlcHRpb24vOwoKLyoqCiAqIFJlbW92ZXMgU2VudHJ5IGZyYW1lcyBmcm9tIHRoZSB0b3AgYW5kIGJvdHRvbSBvZiB0aGUgc3RhY2sgaWYgcHJlc2VudCBhbmQgZW5mb3JjZXMgYSBsaW1pdCBvZiBtYXggbnVtYmVyIG9mIGZyYW1lcy4KICogQXNzdW1lcyBzdGFjayBpbnB1dCBpcyBvcmRlcmVkIGZyb20gdG9wIHRvIGJvdHRvbSBhbmQgcmV0dXJucyB0aGUgcmV2ZXJzZSByZXByZXNlbnRhdGlvbiBzbyBjYWxsIHNpdGUgb2YgdGhlCiAqIGZ1bmN0aW9uIHRoYXQgY2F1c2VkIHRoZSBjcmFzaCBpcyB0aGUgbGFzdCBmcmFtZSBpbiB0aGUgYXJyYXkuCiAqIEBoaWRkZW4KICovCmZ1bmN0aW9uIHN0cmlwU2VudHJ5RnJhbWVzQW5kUmV2ZXJzZShzdGFjaykgewogIGlmICghc3RhY2subGVuZ3RoKSB7CiAgICByZXR1cm4gW107CiAgfQoKICBjb25zdCBsb2NhbFN0YWNrID0gQXJyYXkuZnJvbShzdGFjayk7CgogIC8vIElmIHN0YWNrIHN0YXJ0cyB3aXRoIG9uZSBvZiBvdXIgQVBJIGNhbGxzLCByZW1vdmUgaXQgKHN0YXJ0cywgbWVhbmluZyBpdCdzIHRoZSB0b3Agb2YgdGhlIHN0YWNrIC0gYWthIGxhc3QgY2FsbCkKICBpZiAoL3NlbnRyeVdyYXBwZWQvLnRlc3QobG9jYWxTdGFja1tsb2NhbFN0YWNrLmxlbmd0aCAtIDFdLmZ1bmN0aW9uIHx8ICcnKSkgewogICAgbG9jYWxTdGFjay5wb3AoKTsKICB9CgogIC8vIFJldmVyc2luZyBpbiB0aGUgbWlkZGxlIG9mIHRoZSBwcm9jZWR1cmUgYWxsb3dzIHVzIHRvIGp1c3QgcG9wIHRoZSB2YWx1ZXMgb2ZmIHRoZSBzdGFjawogIGxvY2FsU3RhY2sucmV2ZXJzZSgpOwoKICAvLyBJZiBzdGFjayBlbmRzIHdpdGggb25lIG9mIG91ciBpbnRlcm5hbCBBUEkgY2FsbHMsIHJlbW92ZSBpdCAoZW5kcywgbWVhbmluZyBpdCdzIHRoZSBib3R0b20gb2YgdGhlIHN0YWNrIC0gYWthIHRvcC1tb3N0IGNhbGwpCiAgaWYgKFNUUklQX0ZSQU1FX1JFR0VYUC50ZXN0KGxvY2FsU3RhY2tbbG9jYWxTdGFjay5sZW5ndGggLSAxXS5mdW5jdGlvbiB8fCAnJykpIHsKICAgIGxvY2FsU3RhY2sucG9wKCk7CgogICAgLy8gV2hlbiB1c2luZyBzeW50aGV0aWMgZXZlbnRzLCB3ZSB3aWxsIGhhdmUgYSAyIGxldmVscyBkZWVwIHN0YWNrLCBhcyBgbmV3IEVycm9yKCdTZW50cnkgc3ludGhldGljRXhjZXB0aW9uJylgCiAgICAvLyBpcyBwcm9kdWNlZCB3aXRoaW4gdGhlIGh1YiBpdHNlbGYsIG1ha2luZyBpdDoKICAgIC8vCiAgICAvLyAgIFNlbnRyeS5jYXB0dXJlRXhjZXB0aW9uKCkKICAgIC8vICAgZ2V0Q3VycmVudEh1YigpLmNhcHR1cmVFeGNlcHRpb24oKQogICAgLy8KICAgIC8vIGluc3RlYWQgb2YganVzdCB0aGUgdG9wIGBTZW50cnlgIGNhbGwgaXRzZWxmLgogICAgLy8gVGhpcyBmb3JjZXMgdXMgdG8gcG9zc2libHkgc3RyaXAgYW4gYWRkaXRpb25hbCBmcmFtZSBpbiB0aGUgZXhhY3Qgc2FtZSB3YXMgYXMgYWJvdmUuCiAgICBpZiAoU1RSSVBfRlJBTUVfUkVHRVhQLnRlc3QobG9jYWxTdGFja1tsb2NhbFN0YWNrLmxlbmd0aCAtIDFdLmZ1bmN0aW9uIHx8ICcnKSkgewogICAgICBsb2NhbFN0YWNrLnBvcCgpOwogICAgfQogIH0KCiAgcmV0dXJuIGxvY2FsU3RhY2suc2xpY2UoMCwgU1RBQ0tUUkFDRV9GUkFNRV9MSU1JVCkubWFwKGZyYW1lID0+ICh7CiAgICAuLi5mcmFtZSwKICAgIGZpbGVuYW1lOiBmcmFtZS5maWxlbmFtZSB8fCBsb2NhbFN0YWNrW2xvY2FsU3RhY2subGVuZ3RoIC0gMV0uZmlsZW5hbWUsCiAgICBmdW5jdGlvbjogZnJhbWUuZnVuY3Rpb24gfHwgJz8nLAogIH0pKTsKfQoKY29uc3QgZGVmYXVsdEZ1bmN0aW9uTmFtZSA9ICc8YW5vbnltb3VzPic7CgovKioKICogU2FmZWx5IGV4dHJhY3QgZnVuY3Rpb24gbmFtZSBmcm9tIGl0c2VsZgogKi8KZnVuY3Rpb24gZ2V0RnVuY3Rpb25OYW1lKGZuKSB7CiAgdHJ5IHsKICAgIGlmICghZm4gfHwgdHlwZW9mIGZuICE9PSAnZnVuY3Rpb24nKSB7CiAgICAgIHJldHVybiBkZWZhdWx0RnVuY3Rpb25OYW1lOwogICAgfQogICAgcmV0dXJuIGZuLm5hbWUgfHwgZGVmYXVsdEZ1bmN0aW9uTmFtZTsKICB9IGNhdGNoIChlKSB7CiAgICAvLyBKdXN0IGFjY2Vzc2luZyBjdXN0b20gcHJvcHMgaW4gc29tZSBTZWxlbml1bSBlbnZpcm9ubWVudHMKICAgIC8vIGNhbiBjYXVzZSBhICJQZXJtaXNzaW9uIGRlbmllZCIgZXhjZXB0aW9uIChzZWUgcmF2ZW4tanMjNDk1KS4KICAgIHJldHVybiBkZWZhdWx0RnVuY3Rpb25OYW1lOwogIH0KfQoKLyoqCiAqIFVVSUQ0IGdlbmVyYXRvcgogKgogKiBAcmV0dXJucyBzdHJpbmcgR2VuZXJhdGVkIFVVSUQ0LgogKi8KZnVuY3Rpb24gdXVpZDQoKSB7CiAgY29uc3QgZ2JsID0gR0xPQkFMX09CSiA7CiAgY29uc3QgY3J5cHRvID0gZ2JsLmNyeXB0byB8fCBnYmwubXNDcnlwdG87CgogIGxldCBnZXRSYW5kb21CeXRlID0gKCkgPT4gTWF0aC5yYW5kb20oKSAqIDE2OwogIHRyeSB7CiAgICBpZiAoY3J5cHRvICYmIGNyeXB0by5yYW5kb21VVUlEKSB7CiAgICAgIHJldHVybiBjcnlwdG8ucmFuZG9tVVVJRCgpLnJlcGxhY2UoLy0vZywgJycpOwogICAgfQogICAgaWYgKGNyeXB0byAmJiBjcnlwdG8uZ2V0UmFuZG9tVmFsdWVzKSB7CiAgICAgIGdldFJhbmRvbUJ5dGUgPSAoKSA9PiB7CiAgICAgICAgLy8gY3J5cHRvLmdldFJhbmRvbVZhbHVlcyBtaWdodCByZXR1cm4gdW5kZWZpbmVkIGluc3RlYWQgb2YgdGhlIHR5cGVkIGFycmF5CiAgICAgICAgLy8gaW4gb2xkIENocm9taXVtIHZlcnNpb25zIChlLmcuIDIzLjAuMTIzNS4wICgxNTE0MjIpKQogICAgICAgIC8vIEhvd2V2ZXIsIGB0eXBlZEFycmF5YCBpcyBzdGlsbCBmaWxsZWQgaW4tcGxhY2UuCiAgICAgICAgLy8gQHNlZSBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9BUEkvQ3J5cHRvL2dldFJhbmRvbVZhbHVlcyN0eXBlZGFycmF5CiAgICAgICAgY29uc3QgdHlwZWRBcnJheSA9IG5ldyBVaW50OEFycmF5KDEpOwogICAgICAgIGNyeXB0by5nZXRSYW5kb21WYWx1ZXModHlwZWRBcnJheSk7CiAgICAgICAgcmV0dXJuIHR5cGVkQXJyYXlbMF07CiAgICAgIH07CiAgICB9CiAgfSBjYXRjaCAoXykgewogICAgLy8gc29tZSBydW50aW1lcyBjYW4gY3Jhc2ggaW52b2tpbmcgY3J5cHRvCiAgICAvLyBodHRwczovL2dpdGh1Yi5jb20vZ2V0c2VudHJ5L3NlbnRyeS1qYXZhc2NyaXB0L2lzc3Vlcy84OTM1CiAgfQoKICAvLyBodHRwOi8vc3RhY2tvdmVyZmxvdy5jb20vcXVlc3Rpb25zLzEwNTAzNC9ob3ctdG8tY3JlYXRlLWEtZ3VpZC11dWlkLWluLWphdmFzY3JpcHQvMjExNzUyMyMyMTE3NTIzCiAgLy8gQ29uY2F0ZW5hdGluZyB0aGUgZm9sbG93aW5nIG51bWJlcnMgYXMgc3RyaW5ncyByZXN1bHRzIGluICcxMDAwMDAwMDEwMDA0MDAwODAwMDEwMDAwMDAwMDAwMCcKICByZXR1cm4gKChbMWU3XSApICsgMWUzICsgNGUzICsgOGUzICsgMWUxMSkucmVwbGFjZSgvWzAxOF0vZywgYyA9PgogICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLWJpdHdpc2UKICAgICgoYyApIF4gKChnZXRSYW5kb21CeXRlKCkgJiAxNSkgPj4gKChjICkgLyA0KSkpLnRvU3RyaW5nKDE2KSwKICApOwp9CgovKioKICogQ2hlY2tzIHdoZXRoZXIgdGhlIGdpdmVuIGlucHV0IGlzIGFscmVhZHkgYW4gYXJyYXksIGFuZCBpZiBpdCBpc24ndCwgd3JhcHMgaXQgaW4gb25lLgogKgogKiBAcGFyYW0gbWF5YmVBcnJheSBJbnB1dCB0byB0dXJuIGludG8gYW4gYXJyYXksIGlmIG5lY2Vzc2FyeQogKiBAcmV0dXJucyBUaGUgaW5wdXQsIGlmIGFscmVhZHkgYW4gYXJyYXksIG9yIGFuIGFycmF5IHdpdGggdGhlIGlucHV0IGFzIHRoZSBvbmx5IGVsZW1lbnQsIGlmIG5vdAogKi8KZnVuY3Rpb24gYXJyYXlpZnkobWF5YmVBcnJheSkgewogIHJldHVybiBBcnJheS5pc0FycmF5KG1heWJlQXJyYXkpID8gbWF5YmVBcnJheSA6IFttYXliZUFycmF5XTsKfQoKLyogZXNsaW50LWRpc2FibGUgQHR5cGVzY3JpcHQtZXNsaW50L25vLXVuc2FmZS1tZW1iZXItYWNjZXNzICovCi8qIGVzbGludC1kaXNhYmxlIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnkgKi8KCi8qKgogKiBIZWxwZXIgdG8gZGVjeWNsZSBqc29uIG9iamVjdHMKICovCmZ1bmN0aW9uIG1lbW9CdWlsZGVyKCkgewogIGNvbnN0IGhhc1dlYWtTZXQgPSB0eXBlb2YgV2Vha1NldCA9PT0gJ2Z1bmN0aW9uJzsKICBjb25zdCBpbm5lciA9IGhhc1dlYWtTZXQgPyBuZXcgV2Vha1NldCgpIDogW107CiAgZnVuY3Rpb24gbWVtb2l6ZShvYmopIHsKICAgIGlmIChoYXNXZWFrU2V0KSB7CiAgICAgIGlmIChpbm5lci5oYXMob2JqKSkgewogICAgICAgIHJldHVybiB0cnVlOwogICAgICB9CiAgICAgIGlubmVyLmFkZChvYmopOwogICAgICByZXR1cm4gZmFsc2U7CiAgICB9CiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L3ByZWZlci1mb3Itb2YKICAgIGZvciAobGV0IGkgPSAwOyBpIDwgaW5uZXIubGVuZ3RoOyBpKyspIHsKICAgICAgY29uc3QgdmFsdWUgPSBpbm5lcltpXTsKICAgICAgaWYgKHZhbHVlID09PSBvYmopIHsKICAgICAgICByZXR1cm4gdHJ1ZTsKICAgICAgfQogICAgfQogICAgaW5uZXIucHVzaChvYmopOwogICAgcmV0dXJuIGZhbHNlOwogIH0KCiAgZnVuY3Rpb24gdW5tZW1vaXplKG9iaikgewogICAgaWYgKGhhc1dlYWtTZXQpIHsKICAgICAgaW5uZXIuZGVsZXRlKG9iaik7CiAgICB9IGVsc2UgewogICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGlubmVyLmxlbmd0aDsgaSsrKSB7CiAgICAgICAgaWYgKGlubmVyW2ldID09PSBvYmopIHsKICAgICAgICAgIGlubmVyLnNwbGljZShpLCAxKTsKICAgICAgICAgIGJyZWFrOwogICAgICAgIH0KICAgICAgfQogICAgfQogIH0KICByZXR1cm4gW21lbW9pemUsIHVubWVtb2l6ZV07Cn0KCi8qKgogKiBSZWN1cnNpdmVseSBub3JtYWxpemVzIHRoZSBnaXZlbiBvYmplY3QuCiAqCiAqIC0gQ3JlYXRlcyBhIGNvcHkgdG8gcHJldmVudCBvcmlnaW5hbCBpbnB1dCBtdXRhdGlvbgogKiAtIFNraXBzIG5vbi1lbnVtZXJhYmxlIHByb3BlcnRpZXMKICogLSBXaGVuIHN0cmluZ2lmeWluZywgY2FsbHMgYHRvSlNPTmAgaWYgaW1wbGVtZW50ZWQKICogLSBSZW1vdmVzIGNpcmN1bGFyIHJlZmVyZW5jZXMKICogLSBUcmFuc2xhdGVzIG5vbi1zZXJpYWxpemFibGUgdmFsdWVzIChgdW5kZWZpbmVkYC9gTmFOYC9mdW5jdGlvbnMpIHRvIHNlcmlhbGl6YWJsZSBmb3JtYXQKICogLSBUcmFuc2xhdGVzIGtub3duIGdsb2JhbCBvYmplY3RzL2NsYXNzZXMgdG8gYSBzdHJpbmcgcmVwcmVzZW50YXRpb25zCiAqIC0gVGFrZXMgY2FyZSBvZiBgRXJyb3JgIG9iamVjdCBzZXJpYWxpemF0aW9uCiAqIC0gT3B0aW9uYWxseSBsaW1pdHMgZGVwdGggb2YgZmluYWwgb3V0cHV0CiAqIC0gT3B0aW9uYWxseSBsaW1pdHMgbnVtYmVyIG9mIHByb3BlcnRpZXMvZWxlbWVudHMgaW5jbHVkZWQgaW4gYW55IHNpbmdsZSBvYmplY3QvYXJyYXkKICoKICogQHBhcmFtIGlucHV0IFRoZSBvYmplY3QgdG8gYmUgbm9ybWFsaXplZC4KICogQHBhcmFtIGRlcHRoIFRoZSBtYXggZGVwdGggdG8gd2hpY2ggdG8gbm9ybWFsaXplIHRoZSBvYmplY3QuIChBbnl0aGluZyBkZWVwZXIgc3RyaW5naWZpZWQgd2hvbGUuKQogKiBAcGFyYW0gbWF4UHJvcGVydGllcyBUaGUgbWF4IG51bWJlciBvZiBlbGVtZW50cyBvciBwcm9wZXJ0aWVzIHRvIGJlIGluY2x1ZGVkIGluIGFueSBzaW5nbGUgYXJyYXkgb3IKICogb2JqZWN0IGluIHRoZSBub3JtYWxsaXplZCBvdXRwdXQuCiAqIEByZXR1cm5zIEEgbm9ybWFsaXplZCB2ZXJzaW9uIG9mIHRoZSBvYmplY3QsIG9yIGAiKipub24tc2VyaWFsaXphYmxlKioiYCBpZiBhbnkgZXJyb3JzIGFyZSB0aHJvd24gZHVyaW5nIG5vcm1hbGl6YXRpb24uCiAqLwovLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueQpmdW5jdGlvbiBub3JtYWxpemUoaW5wdXQsIGRlcHRoID0gMTAwLCBtYXhQcm9wZXJ0aWVzID0gK0luZmluaXR5KSB7CiAgdHJ5IHsKICAgIC8vIHNpbmNlIHdlJ3JlIGF0IHRoZSBvdXRlcm1vc3QgbGV2ZWwsIHdlIGRvbid0IHByb3ZpZGUgYSBrZXkKICAgIHJldHVybiB2aXNpdCgnJywgaW5wdXQsIGRlcHRoLCBtYXhQcm9wZXJ0aWVzKTsKICB9IGNhdGNoIChlcnIpIHsKICAgIHJldHVybiB7IEVSUk9SOiBgKipub24tc2VyaWFsaXphYmxlKiogKCR7ZXJyfSlgIH07CiAgfQp9CgovKioKICogVmlzaXRzIGEgbm9kZSB0byBwZXJmb3JtIG5vcm1hbGl6YXRpb24gb24gaXQKICoKICogQHBhcmFtIGtleSBUaGUga2V5IGNvcnJlc3BvbmRpbmcgdG8gdGhlIGdpdmVuIG5vZGUKICogQHBhcmFtIHZhbHVlIFRoZSBub2RlIHRvIGJlIHZpc2l0ZWQKICogQHBhcmFtIGRlcHRoIE9wdGlvbmFsIG51bWJlciBpbmRpY2F0aW5nIHRoZSBtYXhpbXVtIHJlY3Vyc2lvbiBkZXB0aAogKiBAcGFyYW0gbWF4UHJvcGVydGllcyBPcHRpb25hbCBtYXhpbXVtIG51bWJlciBvZiBwcm9wZXJ0aWVzL2VsZW1lbnRzIGluY2x1ZGVkIGluIGFueSBzaW5nbGUgb2JqZWN0L2FycmF5CiAqIEBwYXJhbSBtZW1vIE9wdGlvbmFsIE1lbW8gY2xhc3MgaGFuZGxpbmcgZGVjeWNsaW5nCiAqLwpmdW5jdGlvbiB2aXNpdCgKICBrZXksCiAgdmFsdWUsCiAgZGVwdGggPSArSW5maW5pdHksCiAgbWF4UHJvcGVydGllcyA9ICtJbmZpbml0eSwKICBtZW1vID0gbWVtb0J1aWxkZXIoKSwKKSB7CiAgY29uc3QgW21lbW9pemUsIHVubWVtb2l6ZV0gPSBtZW1vOwoKICAvLyBHZXQgdGhlIHNpbXBsZSBjYXNlcyBvdXQgb2YgdGhlIHdheSBmaXJzdAogIGlmICgKICAgIHZhbHVlID09IG51bGwgfHwgLy8gdGhpcyBtYXRjaGVzIG51bGwgYW5kIHVuZGVmaW5lZCAtPiBlcWVxIG5vdCBlcWVxZXEKICAgIChbJ251bWJlcicsICdib29sZWFuJywgJ3N0cmluZyddLmluY2x1ZGVzKHR5cGVvZiB2YWx1ZSkgJiYgIWlzTmFOJDEodmFsdWUpKQogICkgewogICAgcmV0dXJuIHZhbHVlIDsKICB9CgogIGNvbnN0IHN0cmluZ2lmaWVkID0gc3RyaW5naWZ5VmFsdWUoa2V5LCB2YWx1ZSk7CgogIC8vIEFueXRoaW5nIHdlIGNvdWxkIHBvdGVudGlhbGx5IGRpZyBpbnRvIG1vcmUgKG9iamVjdHMgb3IgYXJyYXlzKSB3aWxsIGhhdmUgY29tZSBiYWNrIGFzIGAiW29iamVjdCBYWFhYXSJgLgogIC8vIEV2ZXJ5dGhpbmcgZWxzZSB3aWxsIGhhdmUgYWxyZWFkeSBiZWVuIHNlcmlhbGl6ZWQsIHNvIGlmIHdlIGRvbid0IHNlZSB0aGF0IHBhdHRlcm4sIHdlJ3JlIGRvbmUuCiAgaWYgKCFzdHJpbmdpZmllZC5zdGFydHNXaXRoKCdbb2JqZWN0ICcpKSB7CiAgICByZXR1cm4gc3RyaW5naWZpZWQ7CiAgfQoKICAvLyBGcm9tIGhlcmUgb24sIHdlIGNhbiBhc3NlcnQgdGhhdCBgdmFsdWVgIGlzIGVpdGhlciBhbiBvYmplY3Qgb3IgYW4gYXJyYXkuCgogIC8vIERvIG5vdCBub3JtYWxpemUgb2JqZWN0cyB0aGF0IHdlIGtub3cgaGF2ZSBhbHJlYWR5IGJlZW4gbm9ybWFsaXplZC4gQXMgYSBnZW5lcmFsIHJ1bGUsIHRoZQogIC8vICJfX3NlbnRyeV9za2lwX25vcm1hbGl6YXRpb25fXyIgcHJvcGVydHkgc2hvdWxkIG9ubHkgYmUgdXNlZCBzcGFyaW5nbHkgYW5kIG9ubHkgc2hvdWxkIG9ubHkgYmUgc2V0IG9uIG9iamVjdHMgdGhhdAogIC8vIGhhdmUgYWxyZWFkeSBiZWVuIG5vcm1hbGl6ZWQuCiAgaWYgKCh2YWx1ZSApWydfX3NlbnRyeV9za2lwX25vcm1hbGl6YXRpb25fXyddKSB7CiAgICByZXR1cm4gdmFsdWUgOwogIH0KCiAgLy8gV2UgY2FuIHNldCBgX19zZW50cnlfb3ZlcnJpZGVfbm9ybWFsaXphdGlvbl9kZXB0aF9fYCBvbiBhbiBvYmplY3QgdG8gZW5zdXJlIHRoYXQgZnJvbSB0aGVyZQogIC8vIFdlIGtlZXAgYSBjZXJ0YWluIGFtb3VudCBvZiBkZXB0aC4KICAvLyBUaGlzIHNob3VsZCBiZSB1c2VkIHNwYXJpbmdseSwgZS5nLiB3ZSB1c2UgaXQgZm9yIHRoZSByZWR1eCBpbnRlZ3JhdGlvbiB0byBlbnN1cmUgd2UgZ2V0IGEgY2VydGFpbiBhbW91bnQgb2Ygc3RhdGUuCiAgY29uc3QgcmVtYWluaW5nRGVwdGggPQogICAgdHlwZW9mICh2YWx1ZSApWydfX3NlbnRyeV9vdmVycmlkZV9ub3JtYWxpemF0aW9uX2RlcHRoX18nXSA9PT0gJ251bWJlcicKICAgICAgPyAoKHZhbHVlIClbJ19fc2VudHJ5X292ZXJyaWRlX25vcm1hbGl6YXRpb25fZGVwdGhfXyddICkKICAgICAgOiBkZXB0aDsKCiAgLy8gV2UncmUgYWxzbyBkb25lIGlmIHdlJ3ZlIHJlYWNoZWQgdGhlIG1heCBkZXB0aAogIGlmIChyZW1haW5pbmdEZXB0aCA9PT0gMCkgewogICAgLy8gQXQgdGhpcyBwb2ludCB3ZSBrbm93IGBzZXJpYWxpemVkYCBpcyBhIHN0cmluZyBvZiB0aGUgZm9ybSBgIltvYmplY3QgWFhYWF0iYC4gQ2xlYW4gaXQgdXAgc28gaXQncyBqdXN0IGAiW1hYWFhdImAuCiAgICByZXR1cm4gc3RyaW5naWZpZWQucmVwbGFjZSgnb2JqZWN0ICcsICcnKTsKICB9CgogIC8vIElmIHdlJ3ZlIGFscmVhZHkgdmlzaXRlZCB0aGlzIGJyYW5jaCwgYmFpbCBvdXQsIGFzIGl0J3MgY2lyY3VsYXIgcmVmZXJlbmNlLiBJZiBub3QsIG5vdGUgdGhhdCB3ZSdyZSBzZWVpbmcgaXQgbm93LgogIGlmIChtZW1vaXplKHZhbHVlKSkgewogICAgcmV0dXJuICdbQ2lyY3VsYXIgfl0nOwogIH0KCiAgLy8gSWYgdGhlIHZhbHVlIGhhcyBhIGB0b0pTT05gIG1ldGhvZCwgd2UgY2FsbCBpdCB0byBleHRyYWN0IG1vcmUgaW5mb3JtYXRpb24KICBjb25zdCB2YWx1ZVdpdGhUb0pTT04gPSB2YWx1ZSA7CiAgaWYgKHZhbHVlV2l0aFRvSlNPTiAmJiB0eXBlb2YgdmFsdWVXaXRoVG9KU09OLnRvSlNPTiA9PT0gJ2Z1bmN0aW9uJykgewogICAgdHJ5IHsKICAgICAgY29uc3QganNvblZhbHVlID0gdmFsdWVXaXRoVG9KU09OLnRvSlNPTigpOwogICAgICAvLyBXZSBuZWVkIHRvIG5vcm1hbGl6ZSB0aGUgcmV0dXJuIHZhbHVlIG9mIGAudG9KU09OKClgIGluIGNhc2UgaXQgaGFzIGNpcmN1bGFyIHJlZmVyZW5jZXMKICAgICAgcmV0dXJuIHZpc2l0KCcnLCBqc29uVmFsdWUsIHJlbWFpbmluZ0RlcHRoIC0gMSwgbWF4UHJvcGVydGllcywgbWVtbyk7CiAgICB9IGNhdGNoIChlcnIpIHsKICAgICAgLy8gcGFzcyAoVGhlIGJ1aWx0LWluIGB0b0pTT05gIGZhaWxlZCwgYnV0IHdlIGNhbiBzdGlsbCB0cnkgdG8gZG8gaXQgb3Vyc2VsdmVzKQogICAgfQogIH0KCiAgLy8gQXQgdGhpcyBwb2ludCB3ZSBrbm93IHdlIGVpdGhlciBoYXZlIGFuIG9iamVjdCBvciBhbiBhcnJheSwgd2UgaGF2ZW4ndCBzZWVuIGl0IGJlZm9yZSwgYW5kIHdlJ3JlIGdvaW5nIHRvIHJlY3Vyc2UKICAvLyBiZWNhdXNlIHdlIGhhdmVuJ3QgeWV0IHJlYWNoZWQgdGhlIG1heCBkZXB0aC4gQ3JlYXRlIGFuIGFjY3VtdWxhdG9yIHRvIGhvbGQgdGhlIHJlc3VsdHMgb2YgdmlzaXRpbmcgZWFjaAogIC8vIHByb3BlcnR5L2VudHJ5LCBhbmQga2VlcCB0cmFjayBvZiB0aGUgbnVtYmVyIG9mIGl0ZW1zIHdlIGFkZCB0byBpdC4KICBjb25zdCBub3JtYWxpemVkID0gKEFycmF5LmlzQXJyYXkodmFsdWUpID8gW10gOiB7fSkgOwogIGxldCBudW1BZGRlZCA9IDA7CgogIC8vIEJlZm9yZSB3ZSBiZWdpbiwgY29udmVydGBFcnJvcmAgYW5kYEV2ZW50YCBpbnN0YW5jZXMgaW50byBwbGFpbiBvYmplY3RzLCBzaW5jZSBzb21lIG9mIGVhY2ggb2YgdGhlaXIgcmVsZXZhbnQKICAvLyBwcm9wZXJ0aWVzIGFyZSBub24tZW51bWVyYWJsZSBhbmQgb3RoZXJ3aXNlIHdvdWxkIGdldCBtaXNzZWQuCiAgY29uc3QgdmlzaXRhYmxlID0gY29udmVydFRvUGxhaW5PYmplY3QodmFsdWUgKTsKCiAgZm9yIChjb25zdCB2aXNpdEtleSBpbiB2aXNpdGFibGUpIHsKICAgIC8vIEF2b2lkIGl0ZXJhdGluZyBvdmVyIGZpZWxkcyBpbiB0aGUgcHJvdG90eXBlIGlmIHRoZXkndmUgc29tZWhvdyBiZWVuIGV4cG9zZWQgdG8gZW51bWVyYXRpb24uCiAgICBpZiAoIU9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbCh2aXNpdGFibGUsIHZpc2l0S2V5KSkgewogICAgICBjb250aW51ZTsKICAgIH0KCiAgICBpZiAobnVtQWRkZWQgPj0gbWF4UHJvcGVydGllcykgewogICAgICBub3JtYWxpemVkW3Zpc2l0S2V5XSA9ICdbTWF4UHJvcGVydGllcyB+XSc7CiAgICAgIGJyZWFrOwogICAgfQoKICAgIC8vIFJlY3Vyc2l2ZWx5IHZpc2l0IGFsbCB0aGUgY2hpbGQgbm9kZXMKICAgIGNvbnN0IHZpc2l0VmFsdWUgPSB2aXNpdGFibGVbdmlzaXRLZXldOwogICAgbm9ybWFsaXplZFt2aXNpdEtleV0gPSB2aXNpdCh2aXNpdEtleSwgdmlzaXRWYWx1ZSwgcmVtYWluaW5nRGVwdGggLSAxLCBtYXhQcm9wZXJ0aWVzLCBtZW1vKTsKCiAgICBudW1BZGRlZCsrOwogIH0KCiAgLy8gT25jZSB3ZSd2ZSB2aXNpdGVkIGFsbCB0aGUgYnJhbmNoZXMsIHJlbW92ZSB0aGUgcGFyZW50IGZyb20gbWVtbyBzdG9yYWdlCiAgdW5tZW1vaXplKHZhbHVlKTsKCiAgLy8gUmV0dXJuIGFjY3VtdWxhdGVkIHZhbHVlcwogIHJldHVybiBub3JtYWxpemVkOwp9CgovKiBlc2xpbnQtZGlzYWJsZSBjb21wbGV4aXR5ICovCi8qKgogKiBTdHJpbmdpZnkgdGhlIGdpdmVuIHZhbHVlLiBIYW5kbGVzIHZhcmlvdXMga25vd24gc3BlY2lhbCB2YWx1ZXMgYW5kIHR5cGVzLgogKgogKiBOb3QgbWVhbnQgdG8gYmUgdXNlZCBvbiBzaW1wbGUgcHJpbWl0aXZlcyB3aGljaCBhbHJlYWR5IGhhdmUgYSBzdHJpbmcgcmVwcmVzZW50YXRpb24sIGFzIGl0IHdpbGwsIGZvciBleGFtcGxlLCB0dXJuCiAqIHRoZSBudW1iZXIgMTIzMSBpbnRvICJbT2JqZWN0IE51bWJlcl0iLCBub3Igb24gYG51bGxgLCBhcyBpdCB3aWxsIHRocm93LgogKgogKiBAcGFyYW0gdmFsdWUgVGhlIHZhbHVlIHRvIHN0cmluZ2lmeQogKiBAcmV0dXJucyBBIHN0cmluZ2lmaWVkIHJlcHJlc2VudGF0aW9uIG9mIHRoZSBnaXZlbiB2YWx1ZQogKi8KZnVuY3Rpb24gc3RyaW5naWZ5VmFsdWUoCiAga2V5LAogIC8vIHRoaXMgdHlwZSBpcyBhIHRpbnkgYml0IG9mIGEgY2hlYXQsIHNpbmNlIHRoaXMgZnVuY3Rpb24gZG9lcyBoYW5kbGUgTmFOICh3aGljaCBpcyB0ZWNobmljYWxseSBhIG51bWJlciksIGJ1dCBmb3IKICAvLyBvdXIgaW50ZXJuYWwgdXNlLCBpdCdsbCBkbwogIHZhbHVlLAopIHsKICB0cnkgewogICAgaWYgKGtleSA9PT0gJ2RvbWFpbicgJiYgdmFsdWUgJiYgdHlwZW9mIHZhbHVlID09PSAnb2JqZWN0JyAmJiAodmFsdWUgKS5fZXZlbnRzKSB7CiAgICAgIHJldHVybiAnW0RvbWFpbl0nOwogICAgfQoKICAgIGlmIChrZXkgPT09ICdkb21haW5FbWl0dGVyJykgewogICAgICByZXR1cm4gJ1tEb21haW5FbWl0dGVyXSc7CiAgICB9CgogICAgLy8gSXQncyBzYWZlIHRvIHVzZSBgZ2xvYmFsYCwgYHdpbmRvd2AsIGFuZCBgZG9jdW1lbnRgIGhlcmUgaW4gdGhpcyBtYW5uZXIsIGFzIHdlIGFyZSBhc3NlcnRpbmcgdXNpbmcgYHR5cGVvZmAgZmlyc3QKICAgIC8vIHdoaWNoIHdvbid0IHRocm93IGlmIHRoZXkgYXJlIG5vdCBwcmVzZW50LgoKICAgIGlmICh0eXBlb2YgZ2xvYmFsICE9PSAndW5kZWZpbmVkJyAmJiB2YWx1ZSA9PT0gZ2xvYmFsKSB7CiAgICAgIHJldHVybiAnW0dsb2JhbF0nOwogICAgfQoKICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1yZXN0cmljdGVkLWdsb2JhbHMKICAgIGlmICh0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJyAmJiB2YWx1ZSA9PT0gd2luZG93KSB7CiAgICAgIHJldHVybiAnW1dpbmRvd10nOwogICAgfQoKICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1yZXN0cmljdGVkLWdsb2JhbHMKICAgIGlmICh0eXBlb2YgZG9jdW1lbnQgIT09ICd1bmRlZmluZWQnICYmIHZhbHVlID09PSBkb2N1bWVudCkgewogICAgICByZXR1cm4gJ1tEb2N1bWVudF0nOwogICAgfQoKICAgIGlmIChpc1Z1ZVZpZXdNb2RlbCh2YWx1ZSkpIHsKICAgICAgcmV0dXJuICdbVnVlVmlld01vZGVsXSc7CiAgICB9CgogICAgLy8gUmVhY3QncyBTeW50aGV0aWNFdmVudCB0aGluZ3kKICAgIGlmIChpc1N5bnRoZXRpY0V2ZW50KHZhbHVlKSkgewogICAgICByZXR1cm4gJ1tTeW50aGV0aWNFdmVudF0nOwogICAgfQoKICAgIGlmICh0eXBlb2YgdmFsdWUgPT09ICdudW1iZXInICYmIHZhbHVlICE9PSB2YWx1ZSkgewogICAgICByZXR1cm4gJ1tOYU5dJzsKICAgIH0KCiAgICBpZiAodHlwZW9mIHZhbHVlID09PSAnZnVuY3Rpb24nKSB7CiAgICAgIHJldHVybiBgW0Z1bmN0aW9uOiAke2dldEZ1bmN0aW9uTmFtZSh2YWx1ZSl9XWA7CiAgICB9CgogICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ3N5bWJvbCcpIHsKICAgICAgcmV0dXJuIGBbJHtTdHJpbmcodmFsdWUpfV1gOwogICAgfQoKICAgIC8vIHN0cmluZ2lmaWVkIEJpZ0ludHMgYXJlIGluZGlzdGluZ3Vpc2hhYmxlIGZyb20gcmVndWxhciBudW1iZXJzLCBzbyB3ZSBuZWVkIHRvIGxhYmVsIHRoZW0gdG8gYXZvaWQgY29uZnVzaW9uCiAgICBpZiAodHlwZW9mIHZhbHVlID09PSAnYmlnaW50JykgewogICAgICByZXR1cm4gYFtCaWdJbnQ6ICR7U3RyaW5nKHZhbHVlKX1dYDsKICAgIH0KCiAgICAvLyBOb3cgdGhhdCB3ZSd2ZSBrbm9ja2VkIG91dCBhbGwgdGhlIHNwZWNpYWwgY2FzZXMgYW5kIHRoZSBwcmltaXRpdmVzLCBhbGwgd2UgaGF2ZSBsZWZ0IGFyZSBvYmplY3RzLiBTaW1wbHkgY2FzdGluZwogICAgLy8gdGhlbSB0byBzdHJpbmdzIG1lYW5zIHRoYXQgaW5zdGFuY2VzIG9mIGNsYXNzZXMgd2hpY2ggaGF2ZW4ndCBkZWZpbmVkIHRoZWlyIGB0b1N0cmluZ1RhZ2Agd2lsbCBqdXN0IGNvbWUgb3V0IGFzCiAgICAvLyBgIltvYmplY3QgT2JqZWN0XSJgLiBJZiB3ZSBpbnN0ZWFkIGxvb2sgYXQgdGhlIGNvbnN0cnVjdG9yJ3MgbmFtZSAod2hpY2ggaXMgdGhlIHNhbWUgYXMgdGhlIG5hbWUgb2YgdGhlIGNsYXNzKSwKICAgIC8vIHdlIGNhbiBtYWtlIHN1cmUgdGhhdCBvbmx5IHBsYWluIG9iamVjdHMgY29tZSBvdXQgdGhhdCB3YXkuCiAgICBjb25zdCBvYmpOYW1lID0gZ2V0Q29uc3RydWN0b3JOYW1lKHZhbHVlKTsKCiAgICAvLyBIYW5kbGUgSFRNTCBFbGVtZW50cwogICAgaWYgKC9eSFRNTChcdyopRWxlbWVudCQvLnRlc3Qob2JqTmFtZSkpIHsKICAgICAgcmV0dXJuIGBbSFRNTEVsZW1lbnQ6ICR7b2JqTmFtZX1dYDsKICAgIH0KCiAgICByZXR1cm4gYFtvYmplY3QgJHtvYmpOYW1lfV1gOwogIH0gY2F0Y2ggKGVycikgewogICAgcmV0dXJuIGAqKm5vbi1zZXJpYWxpemFibGUqKiAoJHtlcnJ9KWA7CiAgfQp9Ci8qIGVzbGludC1lbmFibGUgY29tcGxleGl0eSAqLwoKZnVuY3Rpb24gZ2V0Q29uc3RydWN0b3JOYW1lKHZhbHVlKSB7CiAgY29uc3QgcHJvdG90eXBlID0gT2JqZWN0LmdldFByb3RvdHlwZU9mKHZhbHVlKTsKCiAgcmV0dXJuIHByb3RvdHlwZSA/IHByb3RvdHlwZS5jb25zdHJ1Y3Rvci5uYW1lIDogJ251bGwgcHJvdG90eXBlJzsKfQoKLyoqCiAqIE5vcm1hbGl6ZXMgVVJMcyBpbiBleGNlcHRpb25zIGFuZCBzdGFja3RyYWNlcyB0byBhIGJhc2UgcGF0aCBzbyBTZW50cnkgY2FuIGZpbmdlcnByaW50CiAqIGFjcm9zcyBwbGF0Zm9ybXMgYW5kIHdvcmtpbmcgZGlyZWN0b3J5LgogKgogKiBAcGFyYW0gdXJsIFRoZSBVUkwgdG8gYmUgbm9ybWFsaXplZC4KICogQHBhcmFtIGJhc2VQYXRoIFRoZSBhcHBsaWNhdGlvbiBiYXNlIHBhdGguCiAqIEByZXR1cm5zIFRoZSBub3JtYWxpemVkIFVSTC4KICovCmZ1bmN0aW9uIG5vcm1hbGl6ZVVybFRvQmFzZSh1cmwsIGJhc2VQYXRoKSB7CiAgY29uc3QgZXNjYXBlZEJhc2UgPSBiYXNlUGF0aAogICAgLy8gQmFja3NsYXNoIHRvIGZvcndhcmQKICAgIC5yZXBsYWNlKC9cXC9nLCAnLycpCiAgICAvLyBFc2NhcGUgUmVnRXhwIHNwZWNpYWwgY2hhcmFjdGVycwogICAgLnJlcGxhY2UoL1t8XFx7fSgpW1xdXiQrKj8uXS9nLCAnXFwkJicpOwoKICBsZXQgbmV3VXJsID0gdXJsOwogIHRyeSB7CiAgICBuZXdVcmwgPSBkZWNvZGVVUkkodXJsKTsKICB9IGNhdGNoIChfT28pIHsKICAgIC8vIFNvbWV0aW1lIHRoaXMgYnJlYWtzCiAgfQogIHJldHVybiAoCiAgICBuZXdVcmwKICAgICAgLnJlcGxhY2UoL1xcL2csICcvJykKICAgICAgLnJlcGxhY2UoL3dlYnBhY2s6XC8/L2csICcnKSAvLyBSZW1vdmUgaW50ZXJtZWRpYXRlIGJhc2UgcGF0aAogICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHNlbnRyeS1pbnRlcm5hbC9zZGsvbm8tcmVnZXhwLWNvbnN0cnVjdG9yCiAgICAgIC5yZXBsYWNlKG5ldyBSZWdFeHAoYChmaWxlOi8vKT8vKiR7ZXNjYXBlZEJhc2V9LypgLCAnaWcnKSwgJ2FwcDovLy8nKQogICk7Cn0KCi8vIFNsaWdodGx5IG1vZGlmaWVkIChubyBJRTggc3VwcG9ydCwgRVM2KSBhbmQgdHJhbnNjcmliZWQgdG8gVHlwZVNjcmlwdAoKLy8gU3BsaXQgYSBmaWxlbmFtZSBpbnRvIFtyb290LCBkaXIsIGJhc2VuYW1lLCBleHRdLCB1bml4IHZlcnNpb24KLy8gJ3Jvb3QnIGlzIGp1c3QgYSBzbGFzaCwgb3Igbm90aGluZy4KY29uc3Qgc3BsaXRQYXRoUmUgPSAvXihcUys6XFx8XC8/KShbXHNcU10qPykoKD86XC57MSwyfXxbXi9cXF0rP3wpKFwuW14uL1xcXSp8KSkoPzpbL1xcXSopJC87Ci8qKiBKU0RvYyAqLwpmdW5jdGlvbiBzcGxpdFBhdGgoZmlsZW5hbWUpIHsKICAvLyBUcnVuY2F0ZSBmaWxlcyBuYW1lcyBncmVhdGVyIHRoYW4gMTAyNCBjaGFyYWN0ZXJzIHRvIGF2b2lkIHJlZ2V4IGRvcwogIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9nZXRzZW50cnkvc2VudHJ5LWphdmFzY3JpcHQvcHVsbC84NzM3I2Rpc2N1c3Npb25fcjEyODU3MTkxNzIKICBjb25zdCB0cnVuY2F0ZWQgPSBmaWxlbmFtZS5sZW5ndGggPiAxMDI0ID8gYDx0cnVuY2F0ZWQ+JHtmaWxlbmFtZS5zbGljZSgtMTAyNCl9YCA6IGZpbGVuYW1lOwogIGNvbnN0IHBhcnRzID0gc3BsaXRQYXRoUmUuZXhlYyh0cnVuY2F0ZWQpOwogIHJldHVybiBwYXJ0cyA/IHBhcnRzLnNsaWNlKDEpIDogW107Cn0KCi8qKiBKU0RvYyAqLwpmdW5jdGlvbiBkaXJuYW1lKHBhdGgpIHsKICBjb25zdCByZXN1bHQgPSBzcGxpdFBhdGgocGF0aCk7CiAgY29uc3Qgcm9vdCA9IHJlc3VsdFswXTsKICBsZXQgZGlyID0gcmVzdWx0WzFdOwoKICBpZiAoIXJvb3QgJiYgIWRpcikgewogICAgLy8gTm8gZGlybmFtZSB3aGF0c29ldmVyCiAgICByZXR1cm4gJy4nOwogIH0KCiAgaWYgKGRpcikgewogICAgLy8gSXQgaGFzIGEgZGlybmFtZSwgc3RyaXAgdHJhaWxpbmcgc2xhc2gKICAgIGRpciA9IGRpci5zbGljZSgwLCBkaXIubGVuZ3RoIC0gMSk7CiAgfQoKICByZXR1cm4gcm9vdCArIGRpcjsKfQoKLyogZXNsaW50LWRpc2FibGUgQHR5cGVzY3JpcHQtZXNsaW50L2V4cGxpY2l0LWZ1bmN0aW9uLXJldHVybi10eXBlICovCgovKiogU3luY1Byb21pc2UgaW50ZXJuYWwgc3RhdGVzICovCnZhciBTdGF0ZXM7IChmdW5jdGlvbiAoU3RhdGVzKSB7CiAgLyoqIFBlbmRpbmcgKi8KICBjb25zdCBQRU5ESU5HID0gMDsgU3RhdGVzW1N0YXRlc1siUEVORElORyJdID0gUEVORElOR10gPSAiUEVORElORyI7CiAgLyoqIFJlc29sdmVkIC8gT0sgKi8KICBjb25zdCBSRVNPTFZFRCA9IDE7IFN0YXRlc1tTdGF0ZXNbIlJFU09MVkVEIl0gPSBSRVNPTFZFRF0gPSAiUkVTT0xWRUQiOwogIC8qKiBSZWplY3RlZCAvIEVycm9yICovCiAgY29uc3QgUkVKRUNURUQgPSAyOyBTdGF0ZXNbU3RhdGVzWyJSRUpFQ1RFRCJdID0gUkVKRUNURURdID0gIlJFSkVDVEVEIjsKfSkoU3RhdGVzIHx8IChTdGF0ZXMgPSB7fSkpOwoKLy8gT3ZlcmxvYWRzIHNvIHdlIGNhbiBjYWxsIHJlc29sdmVkU3luY1Byb21pc2Ugd2l0aG91dCBhcmd1bWVudHMgYW5kIGdlbmVyaWMgYXJndW1lbnQKCi8qKgogKiBDcmVhdGVzIGEgcmVzb2x2ZWQgc3luYyBwcm9taXNlLgogKgogKiBAcGFyYW0gdmFsdWUgdGhlIHZhbHVlIHRvIHJlc29sdmUgdGhlIHByb21pc2Ugd2l0aAogKiBAcmV0dXJucyB0aGUgcmVzb2x2ZWQgc3luYyBwcm9taXNlCiAqLwpmdW5jdGlvbiByZXNvbHZlZFN5bmNQcm9taXNlKHZhbHVlKSB7CiAgcmV0dXJuIG5ldyBTeW5jUHJvbWlzZShyZXNvbHZlID0+IHsKICAgIHJlc29sdmUodmFsdWUpOwogIH0pOwp9CgovKioKICogQ3JlYXRlcyBhIHJlamVjdGVkIHN5bmMgcHJvbWlzZS4KICoKICogQHBhcmFtIHZhbHVlIHRoZSB2YWx1ZSB0byByZWplY3QgdGhlIHByb21pc2Ugd2l0aAogKiBAcmV0dXJucyB0aGUgcmVqZWN0ZWQgc3luYyBwcm9taXNlCiAqLwpmdW5jdGlvbiByZWplY3RlZFN5bmNQcm9taXNlKHJlYXNvbikgewogIHJldHVybiBuZXcgU3luY1Byb21pc2UoKF8sIHJlamVjdCkgPT4gewogICAgcmVqZWN0KHJlYXNvbik7CiAgfSk7Cn0KCi8qKgogKiBUaGVuYWJsZSBjbGFzcyB0aGF0IGJlaGF2ZXMgbGlrZSBhIFByb21pc2UgYW5kIGZvbGxvd3MgaXQncyBpbnRlcmZhY2UKICogYnV0IGlzIG5vdCBhc3luYyBpbnRlcm5hbGx5CiAqLwpjbGFzcyBTeW5jUHJvbWlzZSB7CgogICBjb25zdHJ1Y3RvcigKICAgIGV4ZWN1dG9yLAogICkge1N5bmNQcm9taXNlLnByb3RvdHlwZS5fX2luaXQuY2FsbCh0aGlzKTtTeW5jUHJvbWlzZS5wcm90b3R5cGUuX19pbml0Mi5jYWxsKHRoaXMpO1N5bmNQcm9taXNlLnByb3RvdHlwZS5fX2luaXQzLmNhbGwodGhpcyk7U3luY1Byb21pc2UucHJvdG90eXBlLl9faW5pdDQuY2FsbCh0aGlzKTsKICAgIHRoaXMuX3N0YXRlID0gU3RhdGVzLlBFTkRJTkc7CiAgICB0aGlzLl9oYW5kbGVycyA9IFtdOwoKICAgIHRyeSB7CiAgICAgIGV4ZWN1dG9yKHRoaXMuX3Jlc29sdmUsIHRoaXMuX3JlamVjdCk7CiAgICB9IGNhdGNoIChlKSB7CiAgICAgIHRoaXMuX3JlamVjdChlKTsKICAgIH0KICB9CgogIC8qKiBKU0RvYyAqLwogICB0aGVuKAogICAgb25mdWxmaWxsZWQsCiAgICBvbnJlamVjdGVkLAogICkgewogICAgcmV0dXJuIG5ldyBTeW5jUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7CiAgICAgIHRoaXMuX2hhbmRsZXJzLnB1c2goWwogICAgICAgIGZhbHNlLAogICAgICAgIHJlc3VsdCA9PiB7CiAgICAgICAgICBpZiAoIW9uZnVsZmlsbGVkKSB7CiAgICAgICAgICAgIC8vIFRPRE86IMKvXF8o44OEKV8vwq8KICAgICAgICAgICAgLy8gVE9ETzogRklYTUUKICAgICAgICAgICAgcmVzb2x2ZShyZXN1bHQgKTsKICAgICAgICAgIH0gZWxzZSB7CiAgICAgICAgICAgIHRyeSB7CiAgICAgICAgICAgICAgcmVzb2x2ZShvbmZ1bGZpbGxlZChyZXN1bHQpKTsKICAgICAgICAgICAgfSBjYXRjaCAoZSkgewogICAgICAgICAgICAgIHJlamVjdChlKTsKICAgICAgICAgICAgfQogICAgICAgICAgfQogICAgICAgIH0sCiAgICAgICAgcmVhc29uID0+IHsKICAgICAgICAgIGlmICghb25yZWplY3RlZCkgewogICAgICAgICAgICByZWplY3QocmVhc29uKTsKICAgICAgICAgIH0gZWxzZSB7CiAgICAgICAgICAgIHRyeSB7CiAgICAgICAgICAgICAgcmVzb2x2ZShvbnJlamVjdGVkKHJlYXNvbikpOwogICAgICAgICAgICB9IGNhdGNoIChlKSB7CiAgICAgICAgICAgICAgcmVqZWN0KGUpOwogICAgICAgICAgICB9CiAgICAgICAgICB9CiAgICAgICAgfSwKICAgICAgXSk7CiAgICAgIHRoaXMuX2V4ZWN1dGVIYW5kbGVycygpOwogICAgfSk7CiAgfQoKICAvKiogSlNEb2MgKi8KICAgY2F0Y2goCiAgICBvbnJlamVjdGVkLAogICkgewogICAgcmV0dXJuIHRoaXMudGhlbih2YWwgPT4gdmFsLCBvbnJlamVjdGVkKTsKICB9CgogIC8qKiBKU0RvYyAqLwogICBmaW5hbGx5KG9uZmluYWxseSkgewogICAgcmV0dXJuIG5ldyBTeW5jUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7CiAgICAgIGxldCB2YWw7CiAgICAgIGxldCBpc1JlamVjdGVkOwoKICAgICAgcmV0dXJuIHRoaXMudGhlbigKICAgICAgICB2YWx1ZSA9PiB7CiAgICAgICAgICBpc1JlamVjdGVkID0gZmFsc2U7CiAgICAgICAgICB2YWwgPSB2YWx1ZTsKICAgICAgICAgIGlmIChvbmZpbmFsbHkpIHsKICAgICAgICAgICAgb25maW5hbGx5KCk7CiAgICAgICAgICB9CiAgICAgICAgfSwKICAgICAgICByZWFzb24gPT4gewogICAgICAgICAgaXNSZWplY3RlZCA9IHRydWU7CiAgICAgICAgICB2YWwgPSByZWFzb247CiAgICAgICAgICBpZiAob25maW5hbGx5KSB7CiAgICAgICAgICAgIG9uZmluYWxseSgpOwogICAgICAgICAgfQogICAgICAgIH0sCiAgICAgICkudGhlbigoKSA9PiB7CiAgICAgICAgaWYgKGlzUmVqZWN0ZWQpIHsKICAgICAgICAgIHJlamVjdCh2YWwpOwogICAgICAgICAgcmV0dXJuOwogICAgICAgIH0KCiAgICAgICAgcmVzb2x2ZSh2YWwgKTsKICAgICAgfSk7CiAgICB9KTsKICB9CgogIC8qKiBKU0RvYyAqLwogICAgX19pbml0KCkge3RoaXMuX3Jlc29sdmUgPSAodmFsdWUpID0+IHsKICAgIHRoaXMuX3NldFJlc3VsdChTdGF0ZXMuUkVTT0xWRUQsIHZhbHVlKTsKICB9O30KCiAgLyoqIEpTRG9jICovCiAgICBfX2luaXQyKCkge3RoaXMuX3JlamVjdCA9IChyZWFzb24pID0+IHsKICAgIHRoaXMuX3NldFJlc3VsdChTdGF0ZXMuUkVKRUNURUQsIHJlYXNvbik7CiAgfTt9CgogIC8qKiBKU0RvYyAqLwogICAgX19pbml0MygpIHt0aGlzLl9zZXRSZXN1bHQgPSAoc3RhdGUsIHZhbHVlKSA9PiB7CiAgICBpZiAodGhpcy5fc3RhdGUgIT09IFN0YXRlcy5QRU5ESU5HKSB7CiAgICAgIHJldHVybjsKICAgIH0KCiAgICBpZiAoaXNUaGVuYWJsZSh2YWx1ZSkpIHsKICAgICAgdm9pZCAodmFsdWUgKS50aGVuKHRoaXMuX3Jlc29sdmUsIHRoaXMuX3JlamVjdCk7CiAgICAgIHJldHVybjsKICAgIH0KCiAgICB0aGlzLl9zdGF0ZSA9IHN0YXRlOwogICAgdGhpcy5fdmFsdWUgPSB2YWx1ZTsKCiAgICB0aGlzLl9leGVjdXRlSGFuZGxlcnMoKTsKICB9O30KCiAgLyoqIEpTRG9jICovCiAgICBfX2luaXQ0KCkge3RoaXMuX2V4ZWN1dGVIYW5kbGVycyA9ICgpID0+IHsKICAgIGlmICh0aGlzLl9zdGF0ZSA9PT0gU3RhdGVzLlBFTkRJTkcpIHsKICAgICAgcmV0dXJuOwogICAgfQoKICAgIGNvbnN0IGNhY2hlZEhhbmRsZXJzID0gdGhpcy5faGFuZGxlcnMuc2xpY2UoKTsKICAgIHRoaXMuX2hhbmRsZXJzID0gW107CgogICAgY2FjaGVkSGFuZGxlcnMuZm9yRWFjaChoYW5kbGVyID0+IHsKICAgICAgaWYgKGhhbmRsZXJbMF0pIHsKICAgICAgICByZXR1cm47CiAgICAgIH0KCiAgICAgIGlmICh0aGlzLl9zdGF0ZSA9PT0gU3RhdGVzLlJFU09MVkVEKSB7CiAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1mbG9hdGluZy1wcm9taXNlcwogICAgICAgIGhhbmRsZXJbMV0odGhpcy5fdmFsdWUgKTsKICAgICAgfQoKICAgICAgaWYgKHRoaXMuX3N0YXRlID09PSBTdGF0ZXMuUkVKRUNURUQpIHsKICAgICAgICBoYW5kbGVyWzJdKHRoaXMuX3ZhbHVlKTsKICAgICAgfQoKICAgICAgaGFuZGxlclswXSA9IHRydWU7CiAgICB9KTsKICB9O30KfQoKLyoqCiAqIENyZWF0ZXMgYW4gbmV3IFByb21pc2VCdWZmZXIgb2JqZWN0IHdpdGggdGhlIHNwZWNpZmllZCBsaW1pdAogKiBAcGFyYW0gbGltaXQgbWF4IG51bWJlciBvZiBwcm9taXNlcyB0aGF0IGNhbiBiZSBzdG9yZWQgaW4gdGhlIGJ1ZmZlcgogKi8KZnVuY3Rpb24gbWFrZVByb21pc2VCdWZmZXIobGltaXQpIHsKICBjb25zdCBidWZmZXIgPSBbXTsKCiAgZnVuY3Rpb24gaXNSZWFkeSgpIHsKICAgIHJldHVybiBsaW1pdCA9PT0gdW5kZWZpbmVkIHx8IGJ1ZmZlci5sZW5ndGggPCBsaW1pdDsKICB9CgogIC8qKgogICAqIFJlbW92ZSBhIHByb21pc2UgZnJvbSB0aGUgcXVldWUuCiAgICoKICAgKiBAcGFyYW0gdGFzayBDYW4gYmUgYW55IFByb21pc2VMaWtlPFQ+CiAgICogQHJldHVybnMgUmVtb3ZlZCBwcm9taXNlLgogICAqLwogIGZ1bmN0aW9uIHJlbW92ZSh0YXNrKSB7CiAgICByZXR1cm4gYnVmZmVyLnNwbGljZShidWZmZXIuaW5kZXhPZih0YXNrKSwgMSlbMF07CiAgfQoKICAvKioKICAgKiBBZGQgYSBwcm9taXNlIChyZXByZXNlbnRpbmcgYW4gaW4tZmxpZ2h0IGFjdGlvbikgdG8gdGhlIHF1ZXVlLCBhbmQgc2V0IGl0IHRvIHJlbW92ZSBpdHNlbGYgb24gZnVsZmlsbG1lbnQuCiAgICoKICAgKiBAcGFyYW0gdGFza1Byb2R1Y2VyIEEgZnVuY3Rpb24gcHJvZHVjaW5nIGFueSBQcm9taXNlTGlrZTxUPjsgSW4gcHJldmlvdXMgdmVyc2lvbnMgdGhpcyB1c2VkIHRvIGJlIGB0YXNrOgogICAqICAgICAgICBQcm9taXNlTGlrZTxUPmAsIGJ1dCB1bmRlciB0aGF0IG1vZGVsLCBQcm9taXNlcyB3ZXJlIGluc3RhbnRseSBjcmVhdGVkIG9uIHRoZSBjYWxsLXNpdGUgYW5kIHRoZWlyIGV4ZWN1dG9yCiAgICogICAgICAgIGZ1bmN0aW9ucyB0aGVyZWZvcmUgcmFuIGltbWVkaWF0ZWx5LiBUaHVzLCBldmVuIGlmIHRoZSBidWZmZXIgd2FzIGZ1bGwsIHRoZSBhY3Rpb24gc3RpbGwgaGFwcGVuZWQuIEJ5CiAgICogICAgICAgIHJlcXVpcmluZyB0aGUgcHJvbWlzZSB0byBiZSB3cmFwcGVkIGluIGEgZnVuY3Rpb24sIHdlIGNhbiBkZWZlciBwcm9taXNlIGNyZWF0aW9uIHVudGlsIGFmdGVyIHRoZSBidWZmZXIKICAgKiAgICAgICAgbGltaXQgY2hlY2suCiAgICogQHJldHVybnMgVGhlIG9yaWdpbmFsIHByb21pc2UuCiAgICovCiAgZnVuY3Rpb24gYWRkKHRhc2tQcm9kdWNlcikgewogICAgaWYgKCFpc1JlYWR5KCkpIHsKICAgICAgcmV0dXJuIHJlamVjdGVkU3luY1Byb21pc2UobmV3IFNlbnRyeUVycm9yKCdOb3QgYWRkaW5nIFByb21pc2UgYmVjYXVzZSBidWZmZXIgbGltaXQgd2FzIHJlYWNoZWQuJykpOwogICAgfQoKICAgIC8vIHN0YXJ0IHRoZSB0YXNrIGFuZCBhZGQgaXRzIHByb21pc2UgdG8gdGhlIHF1ZXVlCiAgICBjb25zdCB0YXNrID0gdGFza1Byb2R1Y2VyKCk7CiAgICBpZiAoYnVmZmVyLmluZGV4T2YodGFzaykgPT09IC0xKSB7CiAgICAgIGJ1ZmZlci5wdXNoKHRhc2spOwogICAgfQogICAgdm9pZCB0YXNrCiAgICAgIC50aGVuKCgpID0+IHJlbW92ZSh0YXNrKSkKICAgICAgLy8gVXNlIGB0aGVuKG51bGwsIHJlamVjdGlvbkhhbmRsZXIpYCByYXRoZXIgdGhhbiBgY2F0Y2gocmVqZWN0aW9uSGFuZGxlcilgIHNvIHRoYXQgd2UgY2FuIHVzZSBgUHJvbWlzZUxpa2VgCiAgICAgIC8vIHJhdGhlciB0aGFuIGBQcm9taXNlYC4gYFByb21pc2VMaWtlYCBkb2Vzbid0IGhhdmUgYSBgLmNhdGNoYCBtZXRob2QsIG1ha2luZyBpdHMgcG9seWZpbGwgc21hbGxlci4gKEVTNSBkaWRuJ3QKICAgICAgLy8gaGF2ZSBwcm9taXNlcywgc28gVFMgaGFzIHRvIHBvbHlmaWxsIHdoZW4gZG93bi1jb21waWxpbmcuKQogICAgICAudGhlbihudWxsLCAoKSA9PgogICAgICAgIHJlbW92ZSh0YXNrKS50aGVuKG51bGwsICgpID0+IHsKICAgICAgICAgIC8vIFdlIGhhdmUgdG8gYWRkIGFub3RoZXIgY2F0Y2ggaGVyZSBiZWNhdXNlIGByZW1vdmUoKWAgc3RhcnRzIGEgbmV3IHByb21pc2UgY2hhaW4uCiAgICAgICAgfSksCiAgICAgICk7CiAgICByZXR1cm4gdGFzazsKICB9CgogIC8qKgogICAqIFdhaXQgZm9yIGFsbCBwcm9taXNlcyBpbiB0aGUgcXVldWUgdG8gcmVzb2x2ZSBvciBmb3IgdGltZW91dCB0byBleHBpcmUsIHdoaWNoZXZlciBjb21lcyBmaXJzdC4KICAgKgogICAqIEBwYXJhbSB0aW1lb3V0IFRoZSB0aW1lLCBpbiBtcywgYWZ0ZXIgd2hpY2ggdG8gcmVzb2x2ZSB0byBgZmFsc2VgIGlmIHRoZSBxdWV1ZSBpcyBzdGlsbCBub24tZW1wdHkuIFBhc3NpbmcgYDBgIChvcgogICAqIG5vdCBwYXNzaW5nIGFueXRoaW5nKSB3aWxsIG1ha2UgdGhlIHByb21pc2Ugd2FpdCBhcyBsb25nIGFzIGl0IHRha2VzIGZvciB0aGUgcXVldWUgdG8gZHJhaW4gYmVmb3JlIHJlc29sdmluZyB0bwogICAqIGB0cnVlYC4KICAgKiBAcmV0dXJucyBBIHByb21pc2Ugd2hpY2ggd2lsbCByZXNvbHZlIHRvIGB0cnVlYCBpZiB0aGUgcXVldWUgaXMgYWxyZWFkeSBlbXB0eSBvciBkcmFpbnMgYmVmb3JlIHRoZSB0aW1lb3V0LCBhbmQKICAgKiBgZmFsc2VgIG90aGVyd2lzZQogICAqLwogIGZ1bmN0aW9uIGRyYWluKHRpbWVvdXQpIHsKICAgIHJldHVybiBuZXcgU3luY1Byb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4gewogICAgICBsZXQgY291bnRlciA9IGJ1ZmZlci5sZW5ndGg7CgogICAgICBpZiAoIWNvdW50ZXIpIHsKICAgICAgICByZXR1cm4gcmVzb2x2ZSh0cnVlKTsKICAgICAgfQoKICAgICAgLy8gd2FpdCBmb3IgYHRpbWVvdXRgIG1zIGFuZCB0aGVuIHJlc29sdmUgdG8gYGZhbHNlYCAoaWYgbm90IGNhbmNlbGxlZCBmaXJzdCkKICAgICAgY29uc3QgY2FwdHVyZWRTZXRUaW1lb3V0ID0gc2V0VGltZW91dCgoKSA9PiB7CiAgICAgICAgaWYgKHRpbWVvdXQgJiYgdGltZW91dCA+IDApIHsKICAgICAgICAgIHJlc29sdmUoZmFsc2UpOwogICAgICAgIH0KICAgICAgfSwgdGltZW91dCk7CgogICAgICAvLyBpZiBhbGwgcHJvbWlzZXMgcmVzb2x2ZSBpbiB0aW1lLCBjYW5jZWwgdGhlIHRpbWVyIGFuZCByZXNvbHZlIHRvIGB0cnVlYAogICAgICBidWZmZXIuZm9yRWFjaChpdGVtID0+IHsKICAgICAgICB2b2lkIHJlc29sdmVkU3luY1Byb21pc2UoaXRlbSkudGhlbigoKSA9PiB7CiAgICAgICAgICBpZiAoIS0tY291bnRlcikgewogICAgICAgICAgICBjbGVhclRpbWVvdXQoY2FwdHVyZWRTZXRUaW1lb3V0KTsKICAgICAgICAgICAgcmVzb2x2ZSh0cnVlKTsKICAgICAgICAgIH0KICAgICAgICB9LCByZWplY3QpOwogICAgICB9KTsKICAgIH0pOwogIH0KCiAgcmV0dXJuIHsKICAgICQ6IGJ1ZmZlciwKICAgIGFkZCwKICAgIGRyYWluLAogIH07Cn0KCmNvbnN0IE9ORV9TRUNPTkRfSU5fTVMgPSAxMDAwOwoKLyoqCiAqIEEgcGFydGlhbCBkZWZpbml0aW9uIG9mIHRoZSBbUGVyZm9ybWFuY2UgV2ViIEFQSV17QGxpbmsgaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQVBJL1BlcmZvcm1hbmNlfQogKiBmb3IgYWNjZXNzaW5nIGEgaGlnaC1yZXNvbHV0aW9uIG1vbm90b25pYyBjbG9jay4KICovCgovKioKICogUmV0dXJucyBhIHRpbWVzdGFtcCBpbiBzZWNvbmRzIHNpbmNlIHRoZSBVTklYIGVwb2NoIHVzaW5nIHRoZSBEYXRlIEFQSS4KICoKICogVE9ETyh2OCk6IFJldHVybiB0eXBlIHNob3VsZCBiZSByb3VuZGVkLgogKi8KZnVuY3Rpb24gZGF0ZVRpbWVzdGFtcEluU2Vjb25kcygpIHsKICByZXR1cm4gRGF0ZS5ub3coKSAvIE9ORV9TRUNPTkRfSU5fTVM7Cn0KCi8qKgogKiBSZXR1cm5zIGEgd3JhcHBlciBhcm91bmQgdGhlIG5hdGl2ZSBQZXJmb3JtYW5jZSBBUEkgYnJvd3NlciBpbXBsZW1lbnRhdGlvbiwgb3IgdW5kZWZpbmVkIGZvciBicm93c2VycyB0aGF0IGRvIG5vdAogKiBzdXBwb3J0IHRoZSBBUEkuCiAqCiAqIFdyYXBwaW5nIHRoZSBuYXRpdmUgQVBJIHdvcmtzIGFyb3VuZCBkaWZmZXJlbmNlcyBpbiBiZWhhdmlvciBmcm9tIGRpZmZlcmVudCBicm93c2Vycy4KICovCmZ1bmN0aW9uIGNyZWF0ZVVuaXhUaW1lc3RhbXBJblNlY29uZHNGdW5jKCkgewogIGNvbnN0IHsgcGVyZm9ybWFuY2UgfSA9IEdMT0JBTF9PQkogOwogIGlmICghcGVyZm9ybWFuY2UgfHwgIXBlcmZvcm1hbmNlLm5vdykgewogICAgcmV0dXJuIGRhdGVUaW1lc3RhbXBJblNlY29uZHM7CiAgfQoKICAvLyBTb21lIGJyb3dzZXIgYW5kIGVudmlyb25tZW50cyBkb24ndCBoYXZlIGEgdGltZU9yaWdpbiwgc28gd2UgZmFsbGJhY2sgdG8KICAvLyB1c2luZyBEYXRlLm5vdygpIHRvIGNvbXB1dGUgdGhlIHN0YXJ0aW5nIHRpbWUuCiAgY29uc3QgYXBwcm94U3RhcnRpbmdUaW1lT3JpZ2luID0gRGF0ZS5ub3coKSAtIHBlcmZvcm1hbmNlLm5vdygpOwogIGNvbnN0IHRpbWVPcmlnaW4gPSBwZXJmb3JtYW5jZS50aW1lT3JpZ2luID09IHVuZGVmaW5lZCA/IGFwcHJveFN0YXJ0aW5nVGltZU9yaWdpbiA6IHBlcmZvcm1hbmNlLnRpbWVPcmlnaW47CgogIC8vIHBlcmZvcm1hbmNlLm5vdygpIGlzIGEgbW9ub3RvbmljIGNsb2NrLCB3aGljaCBtZWFucyBpdCBzdGFydHMgYXQgMCB3aGVuIHRoZSBwcm9jZXNzIGJlZ2lucy4gVG8gZ2V0IHRoZSBjdXJyZW50CiAgLy8gd2FsbCBjbG9jayB0aW1lIChhY3R1YWwgVU5JWCB0aW1lc3RhbXApLCB3ZSBuZWVkIHRvIGFkZCB0aGUgc3RhcnRpbmcgdGltZSBvcmlnaW4gYW5kIHRoZSBjdXJyZW50IHRpbWUgZWxhcHNlZC4KICAvLwogIC8vIFRPRE86IFRoaXMgZG9lcyBub3QgYWNjb3VudCBmb3IgdGhlIGNhc2Ugd2hlcmUgdGhlIG1vbm90b25pYyBjbG9jayB0aGF0IHBvd2VycyBwZXJmb3JtYW5jZS5ub3coKSBkcmlmdHMgZnJvbSB0aGUKICAvLyB3YWxsIGNsb2NrIHRpbWUsIHdoaWNoIGNhdXNlcyB0aGUgcmV0dXJuZWQgdGltZXN0YW1wIHRvIGJlIGluYWNjdXJhdGUuIFdlIHNob3VsZCBpbnZlc3RpZ2F0ZSBob3cgdG8gZGV0ZWN0IGFuZAogIC8vIGNvcnJlY3QgZm9yIHRoaXMuCiAgLy8gU2VlOiBodHRwczovL2dpdGh1Yi5jb20vZ2V0c2VudHJ5L3NlbnRyeS1qYXZhc2NyaXB0L2lzc3Vlcy8yNTkwCiAgLy8gU2VlOiBodHRwczovL2dpdGh1Yi5jb20vbWRuL2NvbnRlbnQvaXNzdWVzLzQ3MTMKICAvLyBTZWU6IGh0dHBzOi8vZGV2LnRvL25vYW1yL3doZW4tYS1taWxsaXNlY29uZC1pcy1ub3QtYS1taWxsaXNlY29uZC0zaDYKICByZXR1cm4gKCkgPT4gewogICAgcmV0dXJuICh0aW1lT3JpZ2luICsgcGVyZm9ybWFuY2Uubm93KCkpIC8gT05FX1NFQ09ORF9JTl9NUzsKICB9Owp9CgovKioKICogUmV0dXJucyBhIHRpbWVzdGFtcCBpbiBzZWNvbmRzIHNpbmNlIHRoZSBVTklYIGVwb2NoIHVzaW5nIGVpdGhlciB0aGUgUGVyZm9ybWFuY2Ugb3IgRGF0ZSBBUElzLCBkZXBlbmRpbmcgb24gdGhlCiAqIGF2YWlsYWJpbGl0eSBvZiB0aGUgUGVyZm9ybWFuY2UgQVBJLgogKgogKiBCVUc6IE5vdGUgdGhhdCBiZWNhdXNlIG9mIGhvdyBicm93c2VycyBpbXBsZW1lbnQgdGhlIFBlcmZvcm1hbmNlIEFQSSwgdGhlIGNsb2NrIG1pZ2h0IHN0b3Agd2hlbiB0aGUgY29tcHV0ZXIgaXMKICogYXNsZWVwLiBUaGlzIGNyZWF0ZXMgYSBza2V3IGJldHdlZW4gYGRhdGVUaW1lc3RhbXBJblNlY29uZHNgIGFuZCBgdGltZXN0YW1wSW5TZWNvbmRzYC4gVGhlCiAqIHNrZXcgY2FuIGdyb3cgdG8gYXJiaXRyYXJ5IGFtb3VudHMgbGlrZSBkYXlzLCB3ZWVrcyBvciBtb250aHMuCiAqIFNlZSBodHRwczovL2dpdGh1Yi5jb20vZ2V0c2VudHJ5L3NlbnRyeS1qYXZhc2NyaXB0L2lzc3Vlcy8yNTkwLgogKi8KY29uc3QgdGltZXN0YW1wSW5TZWNvbmRzID0gY3JlYXRlVW5peFRpbWVzdGFtcEluU2Vjb25kc0Z1bmMoKTsKCi8qKgogKiBUaGUgbnVtYmVyIG9mIG1pbGxpc2Vjb25kcyBzaW5jZSB0aGUgVU5JWCBlcG9jaC4gVGhpcyB2YWx1ZSBpcyBvbmx5IHVzYWJsZSBpbiBhIGJyb3dzZXIsIGFuZCBvbmx5IHdoZW4gdGhlCiAqIHBlcmZvcm1hbmNlIEFQSSBpcyBhdmFpbGFibGUuCiAqLwooKCkgPT4gewogIC8vIFVuZm9ydHVuYXRlbHkgYnJvd3NlcnMgbWF5IHJlcG9ydCBhbiBpbmFjY3VyYXRlIHRpbWUgb3JpZ2luIGRhdGEsIHRocm91Z2ggZWl0aGVyIHBlcmZvcm1hbmNlLnRpbWVPcmlnaW4gb3IKICAvLyBwZXJmb3JtYW5jZS50aW1pbmcubmF2aWdhdGlvblN0YXJ0LCB3aGljaCByZXN1bHRzIGluIHBvb3IgcmVzdWx0cyBpbiBwZXJmb3JtYW5jZSBkYXRhLiBXZSBvbmx5IHRyZWF0IHRpbWUgb3JpZ2luCiAgLy8gZGF0YSBhcyByZWxpYWJsZSBpZiB0aGV5IGFyZSB3aXRoaW4gYSByZWFzb25hYmxlIHRocmVzaG9sZCBvZiB0aGUgY3VycmVudCB0aW1lLgoKICBjb25zdCB7IHBlcmZvcm1hbmNlIH0gPSBHTE9CQUxfT0JKIDsKICBpZiAoIXBlcmZvcm1hbmNlIHx8ICFwZXJmb3JtYW5jZS5ub3cpIHsKICAgIHJldHVybiB1bmRlZmluZWQ7CiAgfQoKICBjb25zdCB0aHJlc2hvbGQgPSAzNjAwICogMTAwMDsKICBjb25zdCBwZXJmb3JtYW5jZU5vdyA9IHBlcmZvcm1hbmNlLm5vdygpOwogIGNvbnN0IGRhdGVOb3cgPSBEYXRlLm5vdygpOwoKICAvLyBpZiB0aW1lT3JpZ2luIGlzbid0IGF2YWlsYWJsZSBzZXQgZGVsdGEgdG8gdGhyZXNob2xkIHNvIGl0IGlzbid0IHVzZWQKICBjb25zdCB0aW1lT3JpZ2luRGVsdGEgPSBwZXJmb3JtYW5jZS50aW1lT3JpZ2luCiAgICA/IE1hdGguYWJzKHBlcmZvcm1hbmNlLnRpbWVPcmlnaW4gKyBwZXJmb3JtYW5jZU5vdyAtIGRhdGVOb3cpCiAgICA6IHRocmVzaG9sZDsKICBjb25zdCB0aW1lT3JpZ2luSXNSZWxpYWJsZSA9IHRpbWVPcmlnaW5EZWx0YSA8IHRocmVzaG9sZDsKCiAgLy8gV2hpbGUgcGVyZm9ybWFuY2UudGltaW5nLm5hdmlnYXRpb25TdGFydCBpcyBkZXByZWNhdGVkIGluIGZhdm9yIG9mIHBlcmZvcm1hbmNlLnRpbWVPcmlnaW4sIHBlcmZvcm1hbmNlLnRpbWVPcmlnaW4KICAvLyBpcyBub3QgYXMgd2lkZWx5IHN1cHBvcnRlZC4gTmFtZWx5LCBwZXJmb3JtYW5jZS50aW1lT3JpZ2luIGlzIHVuZGVmaW5lZCBpbiBTYWZhcmkgYXMgb2Ygd3JpdGluZy4KICAvLyBBbHNvIGFzIG9mIHdyaXRpbmcsIHBlcmZvcm1hbmNlLnRpbWluZyBpcyBub3QgYXZhaWxhYmxlIGluIFdlYiBXb3JrZXJzIGluIG1haW5zdHJlYW0gYnJvd3NlcnMsIHNvIGl0IGlzIG5vdCBhbHdheXMKICAvLyBhIHZhbGlkIGZhbGxiYWNrLiBJbiB0aGUgYWJzZW5jZSBvZiBhbiBpbml0aWFsIHRpbWUgcHJvdmlkZWQgYnkgdGhlIGJyb3dzZXIsIGZhbGxiYWNrIHRvIHRoZSBjdXJyZW50IHRpbWUgZnJvbSB0aGUKICAvLyBEYXRlIEFQSS4KICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgZGVwcmVjYXRpb24vZGVwcmVjYXRpb24KICBjb25zdCBuYXZpZ2F0aW9uU3RhcnQgPSBwZXJmb3JtYW5jZS50aW1pbmcgJiYgcGVyZm9ybWFuY2UudGltaW5nLm5hdmlnYXRpb25TdGFydDsKICBjb25zdCBoYXNOYXZpZ2F0aW9uU3RhcnQgPSB0eXBlb2YgbmF2aWdhdGlvblN0YXJ0ID09PSAnbnVtYmVyJzsKICAvLyBpZiBuYXZpZ2F0aW9uU3RhcnQgaXNuJ3QgYXZhaWxhYmxlIHNldCBkZWx0YSB0byB0aHJlc2hvbGQgc28gaXQgaXNuJ3QgdXNlZAogIGNvbnN0IG5hdmlnYXRpb25TdGFydERlbHRhID0gaGFzTmF2aWdhdGlvblN0YXJ0ID8gTWF0aC5hYnMobmF2aWdhdGlvblN0YXJ0ICsgcGVyZm9ybWFuY2VOb3cgLSBkYXRlTm93KSA6IHRocmVzaG9sZDsKICBjb25zdCBuYXZpZ2F0aW9uU3RhcnRJc1JlbGlhYmxlID0gbmF2aWdhdGlvblN0YXJ0RGVsdGEgPCB0aHJlc2hvbGQ7CgogIGlmICh0aW1lT3JpZ2luSXNSZWxpYWJsZSB8fCBuYXZpZ2F0aW9uU3RhcnRJc1JlbGlhYmxlKSB7CiAgICAvLyBVc2UgdGhlIG1vcmUgcmVsaWFibGUgdGltZSBvcmlnaW4KICAgIGlmICh0aW1lT3JpZ2luRGVsdGEgPD0gbmF2aWdhdGlvblN0YXJ0RGVsdGEpIHsKICAgICAgcmV0dXJuIHBlcmZvcm1hbmNlLnRpbWVPcmlnaW47CiAgICB9IGVsc2UgewogICAgICByZXR1cm4gbmF2aWdhdGlvblN0YXJ0OwogICAgfQogIH0KICByZXR1cm4gZGF0ZU5vdzsKfSkoKTsKCi8qKgogKiBDcmVhdGVzIGFuIGVudmVsb3BlLgogKiBNYWtlIHN1cmUgdG8gYWx3YXlzIGV4cGxpY2l0bHkgcHJvdmlkZSB0aGUgZ2VuZXJpYyB0byB0aGlzIGZ1bmN0aW9uCiAqIHNvIHRoYXQgdGhlIGVudmVsb3BlIHR5cGVzIHJlc29sdmUgY29ycmVjdGx5LgogKi8KZnVuY3Rpb24gY3JlYXRlRW52ZWxvcGUoaGVhZGVycywgaXRlbXMgPSBbXSkgewogIHJldHVybiBbaGVhZGVycywgaXRlbXNdIDsKfQoKLyoqCiAqIENvbnZlbmllbmNlIGZ1bmN0aW9uIHRvIGxvb3AgdGhyb3VnaCB0aGUgaXRlbXMgYW5kIGl0ZW0gdHlwZXMgb2YgYW4gZW52ZWxvcGUuCiAqIChUaGlzIGZ1bmN0aW9uIHdhcyBtb3N0bHkgY3JlYXRlZCBiZWNhdXNlIHdvcmtpbmcgd2l0aCBlbnZlbG9wZSB0eXBlcyBpcyBwYWluZnVsIGF0IHRoZSBtb21lbnQpCiAqCiAqIElmIHRoZSBjYWxsYmFjayByZXR1cm5zIHRydWUsIHRoZSByZXN0IG9mIHRoZSBpdGVtcyB3aWxsIGJlIHNraXBwZWQuCiAqLwpmdW5jdGlvbiBmb3JFYWNoRW52ZWxvcGVJdGVtKAogIGVudmVsb3BlLAogIGNhbGxiYWNrLAopIHsKICBjb25zdCBlbnZlbG9wZUl0ZW1zID0gZW52ZWxvcGVbMV07CgogIGZvciAoY29uc3QgZW52ZWxvcGVJdGVtIG9mIGVudmVsb3BlSXRlbXMpIHsKICAgIGNvbnN0IGVudmVsb3BlSXRlbVR5cGUgPSBlbnZlbG9wZUl0ZW1bMF0udHlwZTsKICAgIGNvbnN0IHJlc3VsdCA9IGNhbGxiYWNrKGVudmVsb3BlSXRlbSwgZW52ZWxvcGVJdGVtVHlwZSk7CgogICAgaWYgKHJlc3VsdCkgewogICAgICByZXR1cm4gdHJ1ZTsKICAgIH0KICB9CgogIHJldHVybiBmYWxzZTsKfQoKLyoqCiAqIEVuY29kZSBhIHN0cmluZyB0byBVVEY4LgogKi8KZnVuY3Rpb24gZW5jb2RlVVRGOChpbnB1dCwgdGV4dEVuY29kZXIpIHsKICBjb25zdCB1dGY4ID0gdGV4dEVuY29kZXIgfHwgbmV3IFRleHRFbmNvZGVyKCk7CiAgcmV0dXJuIHV0ZjguZW5jb2RlKGlucHV0KTsKfQoKLyoqCiAqIFNlcmlhbGl6ZXMgYW4gZW52ZWxvcGUuCiAqLwpmdW5jdGlvbiBzZXJpYWxpemVFbnZlbG9wZShlbnZlbG9wZSwgdGV4dEVuY29kZXIpIHsKICBjb25zdCBbZW52SGVhZGVycywgaXRlbXNdID0gZW52ZWxvcGU7CgogIC8vIEluaXRpYWxseSB3ZSBjb25zdHJ1Y3Qgb3VyIGVudmVsb3BlIGFzIGEgc3RyaW5nIGFuZCBvbmx5IGNvbnZlcnQgdG8gYmluYXJ5IGNodW5rcyBpZiB3ZSBlbmNvdW50ZXIgYmluYXJ5IGRhdGEKICBsZXQgcGFydHMgPSBKU09OLnN0cmluZ2lmeShlbnZIZWFkZXJzKTsKCiAgZnVuY3Rpb24gYXBwZW5kKG5leHQpIHsKICAgIGlmICh0eXBlb2YgcGFydHMgPT09ICdzdHJpbmcnKSB7CiAgICAgIHBhcnRzID0gdHlwZW9mIG5leHQgPT09ICdzdHJpbmcnID8gcGFydHMgKyBuZXh0IDogW2VuY29kZVVURjgocGFydHMsIHRleHRFbmNvZGVyKSwgbmV4dF07CiAgICB9IGVsc2UgewogICAgICBwYXJ0cy5wdXNoKHR5cGVvZiBuZXh0ID09PSAnc3RyaW5nJyA/IGVuY29kZVVURjgobmV4dCwgdGV4dEVuY29kZXIpIDogbmV4dCk7CiAgICB9CiAgfQoKICBmb3IgKGNvbnN0IGl0ZW0gb2YgaXRlbXMpIHsKICAgIGNvbnN0IFtpdGVtSGVhZGVycywgcGF5bG9hZF0gPSBpdGVtOwoKICAgIGFwcGVuZChgXG4ke0pTT04uc3RyaW5naWZ5KGl0ZW1IZWFkZXJzKX1cbmApOwoKICAgIGlmICh0eXBlb2YgcGF5bG9hZCA9PT0gJ3N0cmluZycgfHwgcGF5bG9hZCBpbnN0YW5jZW9mIFVpbnQ4QXJyYXkpIHsKICAgICAgYXBwZW5kKHBheWxvYWQpOwogICAgfSBlbHNlIHsKICAgICAgbGV0IHN0cmluZ2lmaWVkUGF5bG9hZDsKICAgICAgdHJ5IHsKICAgICAgICBzdHJpbmdpZmllZFBheWxvYWQgPSBKU09OLnN0cmluZ2lmeShwYXlsb2FkKTsKICAgICAgfSBjYXRjaCAoZSkgewogICAgICAgIC8vIEluIGNhc2UsIGRlc3BpdGUgYWxsIG91ciBlZmZvcnRzIHRvIGtlZXAgYHBheWxvYWRgIGNpcmN1bGFyLWRlcGVuZGVuY3ktZnJlZSwgYEpTT04uc3RyaW5pZnkoKWAgc3RpbGwKICAgICAgICAvLyBmYWlscywgd2UgdHJ5IGFnYWluIGFmdGVyIG5vcm1hbGl6aW5nIGl0IGFnYWluIHdpdGggaW5maW5pdGUgbm9ybWFsaXphdGlvbiBkZXB0aC4gVGhpcyBvZiBjb3Vyc2UgaGFzIGEKICAgICAgICAvLyBwZXJmb3JtYW5jZSBpbXBhY3QgYnV0IGluIHRoaXMgY2FzZSBhIHBlcmZvcm1hbmNlIGhpdCBpcyBiZXR0ZXIgdGhhbiB0aHJvd2luZy4KICAgICAgICBzdHJpbmdpZmllZFBheWxvYWQgPSBKU09OLnN0cmluZ2lmeShub3JtYWxpemUocGF5bG9hZCkpOwogICAgICB9CiAgICAgIGFwcGVuZChzdHJpbmdpZmllZFBheWxvYWQpOwogICAgfQogIH0KCiAgcmV0dXJuIHR5cGVvZiBwYXJ0cyA9PT0gJ3N0cmluZycgPyBwYXJ0cyA6IGNvbmNhdEJ1ZmZlcnMocGFydHMpOwp9CgpmdW5jdGlvbiBjb25jYXRCdWZmZXJzKGJ1ZmZlcnMpIHsKICBjb25zdCB0b3RhbExlbmd0aCA9IGJ1ZmZlcnMucmVkdWNlKChhY2MsIGJ1ZikgPT4gYWNjICsgYnVmLmxlbmd0aCwgMCk7CgogIGNvbnN0IG1lcmdlZCA9IG5ldyBVaW50OEFycmF5KHRvdGFsTGVuZ3RoKTsKICBsZXQgb2Zmc2V0ID0gMDsKICBmb3IgKGNvbnN0IGJ1ZmZlciBvZiBidWZmZXJzKSB7CiAgICBtZXJnZWQuc2V0KGJ1ZmZlciwgb2Zmc2V0KTsKICAgIG9mZnNldCArPSBidWZmZXIubGVuZ3RoOwogIH0KCiAgcmV0dXJuIG1lcmdlZDsKfQoKY29uc3QgSVRFTV9UWVBFX1RPX0RBVEFfQ0FURUdPUllfTUFQID0gewogIHNlc3Npb246ICdzZXNzaW9uJywKICBzZXNzaW9uczogJ3Nlc3Npb24nLAogIGF0dGFjaG1lbnQ6ICdhdHRhY2htZW50JywKICB0cmFuc2FjdGlvbjogJ3RyYW5zYWN0aW9uJywKICBldmVudDogJ2Vycm9yJywKICBjbGllbnRfcmVwb3J0OiAnaW50ZXJuYWwnLAogIHVzZXJfcmVwb3J0OiAnZGVmYXVsdCcsCiAgcHJvZmlsZTogJ3Byb2ZpbGUnLAogIHJlcGxheV9ldmVudDogJ3JlcGxheScsCiAgcmVwbGF5X3JlY29yZGluZzogJ3JlcGxheScsCiAgY2hlY2tfaW46ICdtb25pdG9yJywKICBmZWVkYmFjazogJ2ZlZWRiYWNrJywKICBzcGFuOiAnc3BhbicsCiAgc3RhdHNkOiAnbWV0cmljX2J1Y2tldCcsCn07CgovKioKICogTWFwcyB0aGUgdHlwZSBvZiBhbiBlbnZlbG9wZSBpdGVtIHRvIGEgZGF0YSBjYXRlZ29yeS4KICovCmZ1bmN0aW9uIGVudmVsb3BlSXRlbVR5cGVUb0RhdGFDYXRlZ29yeSh0eXBlKSB7CiAgcmV0dXJuIElURU1fVFlQRV9UT19EQVRBX0NBVEVHT1JZX01BUFt0eXBlXTsKfQoKLyoqIEV4dHJhY3RzIHRoZSBtaW5pbWFsIFNESyBpbmZvIGZyb20gdGhlIG1ldGFkYXRhIG9yIGFuIGV2ZW50cyAqLwpmdW5jdGlvbiBnZXRTZGtNZXRhZGF0YUZvckVudmVsb3BlSGVhZGVyKG1ldGFkYXRhT3JFdmVudCkgewogIGlmICghbWV0YWRhdGFPckV2ZW50IHx8ICFtZXRhZGF0YU9yRXZlbnQuc2RrKSB7CiAgICByZXR1cm47CiAgfQogIGNvbnN0IHsgbmFtZSwgdmVyc2lvbiB9ID0gbWV0YWRhdGFPckV2ZW50LnNkazsKICByZXR1cm4geyBuYW1lLCB2ZXJzaW9uIH07Cn0KCi8qKgogKiBDcmVhdGVzIGV2ZW50IGVudmVsb3BlIGhlYWRlcnMsIGJhc2VkIG9uIGV2ZW50LCBzZGsgaW5mbyBhbmQgdHVubmVsCiAqIE5vdGU6IFRoaXMgZnVuY3Rpb24gd2FzIGV4dHJhY3RlZCBmcm9tIHRoZSBjb3JlIHBhY2thZ2UgdG8gbWFrZSBpdCBhdmFpbGFibGUgaW4gUmVwbGF5CiAqLwpmdW5jdGlvbiBjcmVhdGVFdmVudEVudmVsb3BlSGVhZGVycygKICBldmVudCwKICBzZGtJbmZvLAogIHR1bm5lbCwKICBkc24sCikgewogIGNvbnN0IGR5bmFtaWNTYW1wbGluZ0NvbnRleHQgPSBldmVudC5zZGtQcm9jZXNzaW5nTWV0YWRhdGEgJiYgZXZlbnQuc2RrUHJvY2Vzc2luZ01ldGFkYXRhLmR5bmFtaWNTYW1wbGluZ0NvbnRleHQ7CiAgcmV0dXJuIHsKICAgIGV2ZW50X2lkOiBldmVudC5ldmVudF9pZCAsCiAgICBzZW50X2F0OiBuZXcgRGF0ZSgpLnRvSVNPU3RyaW5nKCksCiAgICAuLi4oc2RrSW5mbyAmJiB7IHNkazogc2RrSW5mbyB9KSwKICAgIC4uLighIXR1bm5lbCAmJiBkc24gJiYgeyBkc246IGRzblRvU3RyaW5nKGRzbikgfSksCiAgICAuLi4oZHluYW1pY1NhbXBsaW5nQ29udGV4dCAmJiB7CiAgICAgIHRyYWNlOiBkcm9wVW5kZWZpbmVkS2V5cyh7IC4uLmR5bmFtaWNTYW1wbGluZ0NvbnRleHQgfSksCiAgICB9KSwKICB9Owp9CgovLyBJbnRlbnRpb25hbGx5IGtlZXBpbmcgdGhlIGtleSBicm9hZCwgYXMgd2UgZG9uJ3Qga25vdyBmb3Igc3VyZSB3aGF0IHJhdGUgbGltaXQgaGVhZGVycyBnZXQgcmV0dXJuZWQgZnJvbSBiYWNrZW5kCgpjb25zdCBERUZBVUxUX1JFVFJZX0FGVEVSID0gNjAgKiAxMDAwOyAvLyA2MCBzZWNvbmRzCgovKioKICogRXh0cmFjdHMgUmV0cnktQWZ0ZXIgdmFsdWUgZnJvbSB0aGUgcmVxdWVzdCBoZWFkZXIgb3IgcmV0dXJucyBkZWZhdWx0IHZhbHVlCiAqIEBwYXJhbSBoZWFkZXIgc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mICdSZXRyeS1BZnRlcicgaGVhZGVyCiAqIEBwYXJhbSBub3cgY3VycmVudCB1bml4IHRpbWVzdGFtcAogKgogKi8KZnVuY3Rpb24gcGFyc2VSZXRyeUFmdGVySGVhZGVyKGhlYWRlciwgbm93ID0gRGF0ZS5ub3coKSkgewogIGNvbnN0IGhlYWRlckRlbGF5ID0gcGFyc2VJbnQoYCR7aGVhZGVyfWAsIDEwKTsKICBpZiAoIWlzTmFOKGhlYWRlckRlbGF5KSkgewogICAgcmV0dXJuIGhlYWRlckRlbGF5ICogMTAwMDsKICB9CgogIGNvbnN0IGhlYWRlckRhdGUgPSBEYXRlLnBhcnNlKGAke2hlYWRlcn1gKTsKICBpZiAoIWlzTmFOKGhlYWRlckRhdGUpKSB7CiAgICByZXR1cm4gaGVhZGVyRGF0ZSAtIG5vdzsKICB9CgogIHJldHVybiBERUZBVUxUX1JFVFJZX0FGVEVSOwp9CgovKioKICogR2V0cyB0aGUgdGltZSB0aGF0IHRoZSBnaXZlbiBjYXRlZ29yeSBpcyBkaXNhYmxlZCB1bnRpbCBmb3IgcmF0ZSBsaW1pdGluZy4KICogSW4gY2FzZSBubyBjYXRlZ29yeS1zcGVjaWZpYyBsaW1pdCBpcyBzZXQgYnV0IGEgZ2VuZXJhbCByYXRlIGxpbWl0IGFjcm9zcyBhbGwgY2F0ZWdvcmllcyBpcyBhY3RpdmUsCiAqIHRoYXQgdGltZSBpcyByZXR1cm5lZC4KICoKICogQHJldHVybiB0aGUgdGltZSBpbiBtcyB0aGF0IHRoZSBjYXRlZ29yeSBpcyBkaXNhYmxlZCB1bnRpbCBvciAwIGlmIHRoZXJlJ3Mgbm8gYWN0aXZlIHJhdGUgbGltaXQuCiAqLwpmdW5jdGlvbiBkaXNhYmxlZFVudGlsKGxpbWl0cywgZGF0YUNhdGVnb3J5KSB7CiAgcmV0dXJuIGxpbWl0c1tkYXRhQ2F0ZWdvcnldIHx8IGxpbWl0cy5hbGwgfHwgMDsKfQoKLyoqCiAqIENoZWNrcyBpZiBhIGNhdGVnb3J5IGlzIHJhdGUgbGltaXRlZAogKi8KZnVuY3Rpb24gaXNSYXRlTGltaXRlZChsaW1pdHMsIGRhdGFDYXRlZ29yeSwgbm93ID0gRGF0ZS5ub3coKSkgewogIHJldHVybiBkaXNhYmxlZFVudGlsKGxpbWl0cywgZGF0YUNhdGVnb3J5KSA+IG5vdzsKfQoKLyoqCiAqIFVwZGF0ZSByYXRlbGltaXRzIGZyb20gaW5jb21pbmcgaGVhZGVycy4KICoKICogQHJldHVybiB0aGUgdXBkYXRlZCBSYXRlTGltaXRzIG9iamVjdC4KICovCmZ1bmN0aW9uIHVwZGF0ZVJhdGVMaW1pdHMoCiAgbGltaXRzLAogIHsgc3RhdHVzQ29kZSwgaGVhZGVycyB9LAogIG5vdyA9IERhdGUubm93KCksCikgewogIGNvbnN0IHVwZGF0ZWRSYXRlTGltaXRzID0gewogICAgLi4ubGltaXRzLAogIH07CgogIC8vICJUaGUgbmFtZSBpcyBjYXNlLWluc2Vuc2l0aXZlLiIKICAvLyBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9BUEkvSGVhZGVycy9nZXQKICBjb25zdCByYXRlTGltaXRIZWFkZXIgPSBoZWFkZXJzICYmIGhlYWRlcnNbJ3gtc2VudHJ5LXJhdGUtbGltaXRzJ107CiAgY29uc3QgcmV0cnlBZnRlckhlYWRlciA9IGhlYWRlcnMgJiYgaGVhZGVyc1sncmV0cnktYWZ0ZXInXTsKCiAgaWYgKHJhdGVMaW1pdEhlYWRlcikgewogICAgLyoqCiAgICAgKiByYXRlIGxpbWl0IGhlYWRlcnMgYXJlIG9mIHRoZSBmb3JtCiAgICAgKiAgICAgPGhlYWRlcj4sPGhlYWRlcj4sLi4KICAgICAqIHdoZXJlIGVhY2ggPGhlYWRlcj4gaXMgb2YgdGhlIGZvcm0KICAgICAqICAgICA8cmV0cnlfYWZ0ZXI+OiA8Y2F0ZWdvcmllcz46IDxzY29wZT46IDxyZWFzb25fY29kZT46IDxuYW1lc3BhY2VzPgogICAgICogd2hlcmUKICAgICAqICAgICA8cmV0cnlfYWZ0ZXI+IGlzIGEgZGVsYXkgaW4gc2Vjb25kcwogICAgICogICAgIDxjYXRlZ29yaWVzPiBpcyB0aGUgZXZlbnQgdHlwZShzKSAoZXJyb3IsIHRyYW5zYWN0aW9uLCBldGMpIGJlaW5nIHJhdGUgbGltaXRlZCBhbmQgaXMgb2YgdGhlIGZvcm0KICAgICAqICAgICAgICAgPGNhdGVnb3J5Pjs8Y2F0ZWdvcnk+Oy4uLgogICAgICogICAgIDxzY29wZT4gaXMgd2hhdCdzIGJlaW5nIGxpbWl0ZWQgKG9yZywgcHJvamVjdCwgb3Iga2V5KSAtIGlnbm9yZWQgYnkgU0RLCiAgICAgKiAgICAgPHJlYXNvbl9jb2RlPiBpcyBhbiBhcmJpdHJhcnkgc3RyaW5nIGxpa2UgIm9yZ19xdW90YSIgLSBpZ25vcmVkIGJ5IFNESwogICAgICogICAgIDxuYW1lc3BhY2VzPiBTZW1pY29sb24tc2VwYXJhdGVkIGxpc3Qgb2YgbWV0cmljIG5hbWVzcGFjZSBpZGVudGlmaWVycy4gRGVmaW5lcyB3aGljaCBuYW1lc3BhY2Uocykgd2lsbCBiZSBhZmZlY3RlZC4KICAgICAqICAgICAgICAgT25seSBwcmVzZW50IGlmIHJhdGUgbGltaXQgYXBwbGllcyB0byB0aGUgbWV0cmljX2J1Y2tldCBkYXRhIGNhdGVnb3J5LgogICAgICovCiAgICBmb3IgKGNvbnN0IGxpbWl0IG9mIHJhdGVMaW1pdEhlYWRlci50cmltKCkuc3BsaXQoJywnKSkgewogICAgICBjb25zdCBbcmV0cnlBZnRlciwgY2F0ZWdvcmllcywgLCAsIG5hbWVzcGFjZXNdID0gbGltaXQuc3BsaXQoJzonLCA1KTsKICAgICAgY29uc3QgaGVhZGVyRGVsYXkgPSBwYXJzZUludChyZXRyeUFmdGVyLCAxMCk7CiAgICAgIGNvbnN0IGRlbGF5ID0gKCFpc05hTihoZWFkZXJEZWxheSkgPyBoZWFkZXJEZWxheSA6IDYwKSAqIDEwMDA7IC8vIDYwc2VjIGRlZmF1bHQKICAgICAgaWYgKCFjYXRlZ29yaWVzKSB7CiAgICAgICAgdXBkYXRlZFJhdGVMaW1pdHMuYWxsID0gbm93ICsgZGVsYXk7CiAgICAgIH0gZWxzZSB7CiAgICAgICAgZm9yIChjb25zdCBjYXRlZ29yeSBvZiBjYXRlZ29yaWVzLnNwbGl0KCc7JykpIHsKICAgICAgICAgIGlmIChjYXRlZ29yeSA9PT0gJ21ldHJpY19idWNrZXQnKSB7CiAgICAgICAgICAgIC8vIG5hbWVzcGFjZXMgd2lsbCBiZSBwcmVzZW50IHdoZW4gY2F0ZWdvcnkgPT09ICdtZXRyaWNfYnVja2V0JwogICAgICAgICAgICBpZiAoIW5hbWVzcGFjZXMgfHwgbmFtZXNwYWNlcy5zcGxpdCgnOycpLmluY2x1ZGVzKCdjdXN0b20nKSkgewogICAgICAgICAgICAgIHVwZGF0ZWRSYXRlTGltaXRzW2NhdGVnb3J5XSA9IG5vdyArIGRlbGF5OwogICAgICAgICAgICB9CiAgICAgICAgICB9IGVsc2UgewogICAgICAgICAgICB1cGRhdGVkUmF0ZUxpbWl0c1tjYXRlZ29yeV0gPSBub3cgKyBkZWxheTsKICAgICAgICAgIH0KICAgICAgICB9CiAgICAgIH0KICAgIH0KICB9IGVsc2UgaWYgKHJldHJ5QWZ0ZXJIZWFkZXIpIHsKICAgIHVwZGF0ZWRSYXRlTGltaXRzLmFsbCA9IG5vdyArIHBhcnNlUmV0cnlBZnRlckhlYWRlcihyZXRyeUFmdGVySGVhZGVyLCBub3cpOwogIH0gZWxzZSBpZiAoc3RhdHVzQ29kZSA9PT0gNDI5KSB7CiAgICB1cGRhdGVkUmF0ZUxpbWl0cy5hbGwgPSBub3cgKyA2MCAqIDEwMDA7CiAgfQoKICByZXR1cm4gdXBkYXRlZFJhdGVMaW1pdHM7Cn0KCi8qKgogKiBBIG5vZGUuanMgd2F0Y2hkb2cgdGltZXIKICogQHBhcmFtIHBvbGxJbnRlcnZhbCBUaGUgaW50ZXJ2YWwgdGhhdCB3ZSBleHBlY3QgdG8gZ2V0IHBvbGxlZCBhdAogKiBAcGFyYW0gYW5yVGhyZXNob2xkIFRoZSB0aHJlc2hvbGQgZm9yIHdoZW4gd2UgY29uc2lkZXIgQU5SCiAqIEBwYXJhbSBjYWxsYmFjayBUaGUgY2FsbGJhY2sgdG8gY2FsbCBmb3IgQU5SCiAqIEByZXR1cm5zIEFuIG9iamVjdCB3aXRoIGBwb2xsYCBhbmQgYGVuYWJsZWRgIGZ1bmN0aW9ucyB7QGxpbmsgV2F0Y2hkb2dSZXR1cm59CiAqLwpmdW5jdGlvbiB3YXRjaGRvZ1RpbWVyKAogIGNyZWF0ZVRpbWVyLAogIHBvbGxJbnRlcnZhbCwKICBhbnJUaHJlc2hvbGQsCiAgY2FsbGJhY2ssCikgewogIGNvbnN0IHRpbWVyID0gY3JlYXRlVGltZXIoKTsKICBsZXQgdHJpZ2dlcmVkID0gZmFsc2U7CiAgbGV0IGVuYWJsZWQgPSB0cnVlOwoKICBzZXRJbnRlcnZhbCgoKSA9PiB7CiAgICBjb25zdCBkaWZmTXMgPSB0aW1lci5nZXRUaW1lTXMoKTsKCiAgICBpZiAodHJpZ2dlcmVkID09PSBmYWxzZSAmJiBkaWZmTXMgPiBwb2xsSW50ZXJ2YWwgKyBhbnJUaHJlc2hvbGQpIHsKICAgICAgdHJpZ2dlcmVkID0gdHJ1ZTsKICAgICAgaWYgKGVuYWJsZWQpIHsKICAgICAgICBjYWxsYmFjaygpOwogICAgICB9CiAgICB9CgogICAgaWYgKGRpZmZNcyA8IHBvbGxJbnRlcnZhbCArIGFuclRocmVzaG9sZCkgewogICAgICB0cmlnZ2VyZWQgPSBmYWxzZTsKICAgIH0KICB9LCAyMCk7CgogIHJldHVybiB7CiAgICBwb2xsOiAoKSA9PiB7CiAgICAgIHRpbWVyLnJlc2V0KCk7CiAgICB9LAogICAgZW5hYmxlZDogKHN0YXRlKSA9PiB7CiAgICAgIGVuYWJsZWQgPSBzdGF0ZTsKICAgIH0sCiAgfTsKfQoKLy8gdHlwZXMgY29waWVkIGZyb20gaW5zcGVjdG9yLmQudHMKCi8qKgogKiBDb252ZXJ0cyBEZWJ1Z2dlci5DYWxsRnJhbWUgdG8gU2VudHJ5IFN0YWNrRnJhbWUKICovCmZ1bmN0aW9uIGNhbGxGcmFtZVRvU3RhY2tGcmFtZSgKICBmcmFtZSwKICB1cmwsCiAgZ2V0TW9kdWxlRnJvbUZpbGVuYW1lLAopIHsKICBjb25zdCBmaWxlbmFtZSA9IHVybCA/IHVybC5yZXBsYWNlKC9eZmlsZTpcL1wvLywgJycpIDogdW5kZWZpbmVkOwoKICAvLyBDYWxsRnJhbWUgcm93L2NvbCBhcmUgMCBiYXNlZCwgd2hlcmVhcyBTdGFja0ZyYW1lIGFyZSAxIGJhc2VkCiAgY29uc3QgY29sbm8gPSBmcmFtZS5sb2NhdGlvbi5jb2x1bW5OdW1iZXIgPyBmcmFtZS5sb2NhdGlvbi5jb2x1bW5OdW1iZXIgKyAxIDogdW5kZWZpbmVkOwogIGNvbnN0IGxpbmVubyA9IGZyYW1lLmxvY2F0aW9uLmxpbmVOdW1iZXIgPyBmcmFtZS5sb2NhdGlvbi5saW5lTnVtYmVyICsgMSA6IHVuZGVmaW5lZDsKCiAgcmV0dXJuIGRyb3BVbmRlZmluZWRLZXlzKHsKICAgIGZpbGVuYW1lLAogICAgbW9kdWxlOiBnZXRNb2R1bGVGcm9tRmlsZW5hbWUoZmlsZW5hbWUpLAogICAgZnVuY3Rpb246IGZyYW1lLmZ1bmN0aW9uTmFtZSB8fCAnPycsCiAgICBjb2xubywKICAgIGxpbmVubywKICAgIGluX2FwcDogZmlsZW5hbWUgPyBmaWxlbmFtZUlzSW5BcHAoZmlsZW5hbWUpIDogdW5kZWZpbmVkLAogIH0pOwp9CgovKioKICogVGhpcyBzZXJ2ZXMgYXMgYSBidWlsZCB0aW1lIGZsYWcgdGhhdCB3aWxsIGJlIHRydWUgYnkgZGVmYXVsdCwgYnV0IGZhbHNlIGluIG5vbi1kZWJ1ZyBidWlsZHMgb3IgaWYgdXNlcnMgcmVwbGFjZSBgX19TRU5UUllfREVCVUdfX2AgaW4gdGhlaXIgZ2VuZXJhdGVkIGNvZGUuCiAqCiAqIEFUVEVOVElPTjogVGhpcyBjb25zdGFudCBtdXN0IG5ldmVyIGNyb3NzIHBhY2thZ2UgYm91bmRhcmllcyAoaS5lLiBiZSBleHBvcnRlZCkgdG8gZ3VhcmFudGVlIHRoYXQgaXQgY2FuIGJlIHVzZWQgZm9yIHRyZWUgc2hha2luZy4KICovCmNvbnN0IERFQlVHX0JVSUxEID0gKHR5cGVvZiBfX1NFTlRSWV9ERUJVR19fID09PSAndW5kZWZpbmVkJyB8fCBfX1NFTlRSWV9ERUJVR19fKTsKCmNvbnN0IERFRkFVTFRfRU5WSVJPTk1FTlQgPSAncHJvZHVjdGlvbic7CgovKioKICogUmV0dXJucyB0aGUgZ2xvYmFsIGV2ZW50IHByb2Nlc3NvcnMuCiAqIEBkZXByZWNhdGVkIEdsb2JhbCBldmVudCBwcm9jZXNzb3JzIHdpbGwgYmUgcmVtb3ZlZCBpbiB2OC4KICovCmZ1bmN0aW9uIGdldEdsb2JhbEV2ZW50UHJvY2Vzc29ycygpIHsKICByZXR1cm4gZ2V0R2xvYmFsU2luZ2xldG9uKCdnbG9iYWxFdmVudFByb2Nlc3NvcnMnLCAoKSA9PiBbXSk7Cn0KCi8qKgogKiBQcm9jZXNzIGFuIGFycmF5IG9mIGV2ZW50IHByb2Nlc3NvcnMsIHJldHVybmluZyB0aGUgcHJvY2Vzc2VkIGV2ZW50IChvciBgbnVsbGAgaWYgdGhlIGV2ZW50IHdhcyBkcm9wcGVkKS4KICovCmZ1bmN0aW9uIG5vdGlmeUV2ZW50UHJvY2Vzc29ycygKICBwcm9jZXNzb3JzLAogIGV2ZW50LAogIGhpbnQsCiAgaW5kZXggPSAwLAopIHsKICByZXR1cm4gbmV3IFN5bmNQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHsKICAgIGNvbnN0IHByb2Nlc3NvciA9IHByb2Nlc3NvcnNbaW5kZXhdOwogICAgaWYgKGV2ZW50ID09PSBudWxsIHx8IHR5cGVvZiBwcm9jZXNzb3IgIT09ICdmdW5jdGlvbicpIHsKICAgICAgcmVzb2x2ZShldmVudCk7CiAgICB9IGVsc2UgewogICAgICBjb25zdCByZXN1bHQgPSBwcm9jZXNzb3IoeyAuLi5ldmVudCB9LCBoaW50KSA7CgogICAgICBERUJVR19CVUlMRCAmJiBwcm9jZXNzb3IuaWQgJiYgcmVzdWx0ID09PSBudWxsICYmIGxvZ2dlci5sb2coYEV2ZW50IHByb2Nlc3NvciAiJHtwcm9jZXNzb3IuaWR9IiBkcm9wcGVkIGV2ZW50YCk7CgogICAgICBpZiAoaXNUaGVuYWJsZShyZXN1bHQpKSB7CiAgICAgICAgdm9pZCByZXN1bHQKICAgICAgICAgIC50aGVuKGZpbmFsID0+IG5vdGlmeUV2ZW50UHJvY2Vzc29ycyhwcm9jZXNzb3JzLCBmaW5hbCwgaGludCwgaW5kZXggKyAxKS50aGVuKHJlc29sdmUpKQogICAgICAgICAgLnRoZW4obnVsbCwgcmVqZWN0KTsKICAgICAgfSBlbHNlIHsKICAgICAgICB2b2lkIG5vdGlmeUV2ZW50UHJvY2Vzc29ycyhwcm9jZXNzb3JzLCByZXN1bHQsIGhpbnQsIGluZGV4ICsgMSkKICAgICAgICAgIC50aGVuKHJlc29sdmUpCiAgICAgICAgICAudGhlbihudWxsLCByZWplY3QpOwogICAgICB9CiAgICB9CiAgfSk7Cn0KCi8qKgogKiBDcmVhdGVzIGEgbmV3IGBTZXNzaW9uYCBvYmplY3QgYnkgc2V0dGluZyBjZXJ0YWluIGRlZmF1bHQgcGFyYW1ldGVycy4gSWYgb3B0aW9uYWwgQHBhcmFtIGNvbnRleHQKICogaXMgcGFzc2VkLCB0aGUgcGFzc2VkIHByb3BlcnRpZXMgYXJlIGFwcGxpZWQgdG8gdGhlIHNlc3Npb24gb2JqZWN0LgogKgogKiBAcGFyYW0gY29udGV4dCAob3B0aW9uYWwpIGFkZGl0aW9uYWwgcHJvcGVydGllcyB0byBiZSBhcHBsaWVkIHRvIHRoZSByZXR1cm5lZCBzZXNzaW9uIG9iamVjdAogKgogKiBAcmV0dXJucyBhIG5ldyBgU2Vzc2lvbmAgb2JqZWN0CiAqLwpmdW5jdGlvbiBtYWtlU2Vzc2lvbihjb250ZXh0KSB7CiAgLy8gQm90aCB0aW1lc3RhbXAgYW5kIHN0YXJ0ZWQgYXJlIGluIHNlY29uZHMgc2luY2UgdGhlIFVOSVggZXBvY2guCiAgY29uc3Qgc3RhcnRpbmdUaW1lID0gdGltZXN0YW1wSW5TZWNvbmRzKCk7CgogIGNvbnN0IHNlc3Npb24gPSB7CiAgICBzaWQ6IHV1aWQ0KCksCiAgICBpbml0OiB0cnVlLAogICAgdGltZXN0YW1wOiBzdGFydGluZ1RpbWUsCiAgICBzdGFydGVkOiBzdGFydGluZ1RpbWUsCiAgICBkdXJhdGlvbjogMCwKICAgIHN0YXR1czogJ29rJywKICAgIGVycm9yczogMCwKICAgIGlnbm9yZUR1cmF0aW9uOiBmYWxzZSwKICAgIHRvSlNPTjogKCkgPT4gc2Vzc2lvblRvSlNPTihzZXNzaW9uKSwKICB9OwoKICBpZiAoY29udGV4dCkgewogICAgdXBkYXRlU2Vzc2lvbihzZXNzaW9uLCBjb250ZXh0KTsKICB9CgogIHJldHVybiBzZXNzaW9uOwp9CgovKioKICogVXBkYXRlcyBhIHNlc3Npb24gb2JqZWN0IHdpdGggdGhlIHByb3BlcnRpZXMgcGFzc2VkIGluIHRoZSBjb250ZXh0LgogKgogKiBOb3RlIHRoYXQgdGhpcyBmdW5jdGlvbiBtdXRhdGVzIHRoZSBwYXNzZWQgb2JqZWN0IGFuZCByZXR1cm5zIHZvaWQuCiAqIChIYWQgdG8gZG8gdGhpcyBpbnN0ZWFkIG9mIHJldHVybmluZyBhIG5ldyBhbmQgdXBkYXRlZCBzZXNzaW9uIGJlY2F1c2UgY2xvc2luZyBhbmQgc2VuZGluZyBhIHNlc3Npb24KICogbWFrZXMgYW4gdXBkYXRlIHRvIHRoZSBzZXNzaW9uIGFmdGVyIGl0IHdhcyBwYXNzZWQgdG8gdGhlIHNlbmRpbmcgbG9naWMuCiAqIEBzZWUgQmFzZUNsaWVudC5jYXB0dXJlU2Vzc2lvbiApCiAqCiAqIEBwYXJhbSBzZXNzaW9uIHRoZSBgU2Vzc2lvbmAgdG8gdXBkYXRlCiAqIEBwYXJhbSBjb250ZXh0IHRoZSBgU2Vzc2lvbkNvbnRleHRgIGhvbGRpbmcgdGhlIHByb3BlcnRpZXMgdGhhdCBzaG91bGQgYmUgdXBkYXRlZCBpbiBAcGFyYW0gc2Vzc2lvbgogKi8KLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGNvbXBsZXhpdHkKZnVuY3Rpb24gdXBkYXRlU2Vzc2lvbihzZXNzaW9uLCBjb250ZXh0ID0ge30pIHsKICBpZiAoY29udGV4dC51c2VyKSB7CiAgICBpZiAoIXNlc3Npb24uaXBBZGRyZXNzICYmIGNvbnRleHQudXNlci5pcF9hZGRyZXNzKSB7CiAgICAgIHNlc3Npb24uaXBBZGRyZXNzID0gY29udGV4dC51c2VyLmlwX2FkZHJlc3M7CiAgICB9CgogICAgaWYgKCFzZXNzaW9uLmRpZCAmJiAhY29udGV4dC5kaWQpIHsKICAgICAgc2Vzc2lvbi5kaWQgPSBjb250ZXh0LnVzZXIuaWQgfHwgY29udGV4dC51c2VyLmVtYWlsIHx8IGNvbnRleHQudXNlci51c2VybmFtZTsKICAgIH0KICB9CgogIHNlc3Npb24udGltZXN0YW1wID0gY29udGV4dC50aW1lc3RhbXAgfHwgdGltZXN0YW1wSW5TZWNvbmRzKCk7CgogIGlmIChjb250ZXh0LmFibm9ybWFsX21lY2hhbmlzbSkgewogICAgc2Vzc2lvbi5hYm5vcm1hbF9tZWNoYW5pc20gPSBjb250ZXh0LmFibm9ybWFsX21lY2hhbmlzbTsKICB9CgogIGlmIChjb250ZXh0Lmlnbm9yZUR1cmF0aW9uKSB7CiAgICBzZXNzaW9uLmlnbm9yZUR1cmF0aW9uID0gY29udGV4dC5pZ25vcmVEdXJhdGlvbjsKICB9CiAgaWYgKGNvbnRleHQuc2lkKSB7CiAgICAvLyBHb29kIGVub3VnaCB1dWlkIHZhbGlkYXRpb24uIOKAlCBLYW1pbAogICAgc2Vzc2lvbi5zaWQgPSBjb250ZXh0LnNpZC5sZW5ndGggPT09IDMyID8gY29udGV4dC5zaWQgOiB1dWlkNCgpOwogIH0KICBpZiAoY29udGV4dC5pbml0ICE9PSB1bmRlZmluZWQpIHsKICAgIHNlc3Npb24uaW5pdCA9IGNvbnRleHQuaW5pdDsKICB9CiAgaWYgKCFzZXNzaW9uLmRpZCAmJiBjb250ZXh0LmRpZCkgewogICAgc2Vzc2lvbi5kaWQgPSBgJHtjb250ZXh0LmRpZH1gOwogIH0KICBpZiAodHlwZW9mIGNvbnRleHQuc3RhcnRlZCA9PT0gJ251bWJlcicpIHsKICAgIHNlc3Npb24uc3RhcnRlZCA9IGNvbnRleHQuc3RhcnRlZDsKICB9CiAgaWYgKHNlc3Npb24uaWdub3JlRHVyYXRpb24pIHsKICAgIHNlc3Npb24uZHVyYXRpb24gPSB1bmRlZmluZWQ7CiAgfSBlbHNlIGlmICh0eXBlb2YgY29udGV4dC5kdXJhdGlvbiA9PT0gJ251bWJlcicpIHsKICAgIHNlc3Npb24uZHVyYXRpb24gPSBjb250ZXh0LmR1cmF0aW9uOwogIH0gZWxzZSB7CiAgICBjb25zdCBkdXJhdGlvbiA9IHNlc3Npb24udGltZXN0YW1wIC0gc2Vzc2lvbi5zdGFydGVkOwogICAgc2Vzc2lvbi5kdXJhdGlvbiA9IGR1cmF0aW9uID49IDAgPyBkdXJhdGlvbiA6IDA7CiAgfQogIGlmIChjb250ZXh0LnJlbGVhc2UpIHsKICAgIHNlc3Npb24ucmVsZWFzZSA9IGNvbnRleHQucmVsZWFzZTsKICB9CiAgaWYgKGNvbnRleHQuZW52aXJvbm1lbnQpIHsKICAgIHNlc3Npb24uZW52aXJvbm1lbnQgPSBjb250ZXh0LmVudmlyb25tZW50OwogIH0KICBpZiAoIXNlc3Npb24uaXBBZGRyZXNzICYmIGNvbnRleHQuaXBBZGRyZXNzKSB7CiAgICBzZXNzaW9uLmlwQWRkcmVzcyA9IGNvbnRleHQuaXBBZGRyZXNzOwogIH0KICBpZiAoIXNlc3Npb24udXNlckFnZW50ICYmIGNvbnRleHQudXNlckFnZW50KSB7CiAgICBzZXNzaW9uLnVzZXJBZ2VudCA9IGNvbnRleHQudXNlckFnZW50OwogIH0KICBpZiAodHlwZW9mIGNvbnRleHQuZXJyb3JzID09PSAnbnVtYmVyJykgewogICAgc2Vzc2lvbi5lcnJvcnMgPSBjb250ZXh0LmVycm9yczsKICB9CiAgaWYgKGNvbnRleHQuc3RhdHVzKSB7CiAgICBzZXNzaW9uLnN0YXR1cyA9IGNvbnRleHQuc3RhdHVzOwogIH0KfQoKLyoqCiAqIENsb3NlcyBhIHNlc3Npb24gYnkgc2V0dGluZyBpdHMgc3RhdHVzIGFuZCB1cGRhdGluZyB0aGUgc2Vzc2lvbiBvYmplY3Qgd2l0aCBpdC4KICogSW50ZXJuYWxseSBjYWxscyBgdXBkYXRlU2Vzc2lvbmAgdG8gdXBkYXRlIHRoZSBwYXNzZWQgc2Vzc2lvbiBvYmplY3QuCiAqCiAqIE5vdGUgdGhhdCB0aGlzIGZ1bmN0aW9uIG11dGF0ZXMgdGhlIHBhc3NlZCBzZXNzaW9uIChAc2VlIHVwZGF0ZVNlc3Npb24gZm9yIGV4cGxhbmF0aW9uKS4KICoKICogQHBhcmFtIHNlc3Npb24gdGhlIGBTZXNzaW9uYCBvYmplY3QgdG8gYmUgY2xvc2VkCiAqIEBwYXJhbSBzdGF0dXMgdGhlIGBTZXNzaW9uU3RhdHVzYCB3aXRoIHdoaWNoIHRoZSBzZXNzaW9uIHdhcyBjbG9zZWQuIElmIHlvdSBkb24ndCBwYXNzIGEgc3RhdHVzLAogKiAgICAgICAgICAgICAgIHRoaXMgZnVuY3Rpb24gd2lsbCBrZWVwIHRoZSBwcmV2aW91c2x5IHNldCBzdGF0dXMsIHVubGVzcyBpdCB3YXMgYCdvaydgIGluIHdoaWNoIGNhc2UKICogICAgICAgICAgICAgICBpdCBpcyBjaGFuZ2VkIHRvIGAnZXhpdGVkJ2AuCiAqLwpmdW5jdGlvbiBjbG9zZVNlc3Npb24oc2Vzc2lvbiwgc3RhdHVzKSB7CiAgbGV0IGNvbnRleHQgPSB7fTsKICBpZiAoc3RhdHVzKSB7CiAgICBjb250ZXh0ID0geyBzdGF0dXMgfTsKICB9IGVsc2UgaWYgKHNlc3Npb24uc3RhdHVzID09PSAnb2snKSB7CiAgICBjb250ZXh0ID0geyBzdGF0dXM6ICdleGl0ZWQnIH07CiAgfQoKICB1cGRhdGVTZXNzaW9uKHNlc3Npb24sIGNvbnRleHQpOwp9CgovKioKICogU2VyaWFsaXplcyBhIHBhc3NlZCBzZXNzaW9uIG9iamVjdCB0byBhIEpTT04gb2JqZWN0IHdpdGggYSBzbGlnaHRseSBkaWZmZXJlbnQgc3RydWN0dXJlLgogKiBUaGlzIGlzIG5lY2Vzc2FyeSBiZWNhdXNlIHRoZSBTZW50cnkgYmFja2VuZCByZXF1aXJlcyBhIHNsaWdodGx5IGRpZmZlcmVudCBzY2hlbWEgb2YgYSBzZXNzaW9uCiAqIHRoYW4gdGhlIG9uZSB0aGUgSlMgU0RLcyB1c2UgaW50ZXJuYWxseS4KICoKICogQHBhcmFtIHNlc3Npb24gdGhlIHNlc3Npb24gdG8gYmUgY29udmVydGVkCiAqCiAqIEByZXR1cm5zIGEgSlNPTiBvYmplY3Qgb2YgdGhlIHBhc3NlZCBzZXNzaW9uCiAqLwpmdW5jdGlvbiBzZXNzaW9uVG9KU09OKHNlc3Npb24pIHsKICByZXR1cm4gZHJvcFVuZGVmaW5lZEtleXMoewogICAgc2lkOiBgJHtzZXNzaW9uLnNpZH1gLAogICAgaW5pdDogc2Vzc2lvbi5pbml0LAogICAgLy8gTWFrZSBzdXJlIHRoYXQgc2VjIGlzIGNvbnZlcnRlZCB0byBtcyBmb3IgZGF0ZSBjb25zdHJ1Y3RvcgogICAgc3RhcnRlZDogbmV3IERhdGUoc2Vzc2lvbi5zdGFydGVkICogMTAwMCkudG9JU09TdHJpbmcoKSwKICAgIHRpbWVzdGFtcDogbmV3IERhdGUoc2Vzc2lvbi50aW1lc3RhbXAgKiAxMDAwKS50b0lTT1N0cmluZygpLAogICAgc3RhdHVzOiBzZXNzaW9uLnN0YXR1cywKICAgIGVycm9yczogc2Vzc2lvbi5lcnJvcnMsCiAgICBkaWQ6IHR5cGVvZiBzZXNzaW9uLmRpZCA9PT0gJ251bWJlcicgfHwgdHlwZW9mIHNlc3Npb24uZGlkID09PSAnc3RyaW5nJyA/IGAke3Nlc3Npb24uZGlkfWAgOiB1bmRlZmluZWQsCiAgICBkdXJhdGlvbjogc2Vzc2lvbi5kdXJhdGlvbiwKICAgIGFibm9ybWFsX21lY2hhbmlzbTogc2Vzc2lvbi5hYm5vcm1hbF9tZWNoYW5pc20sCiAgICBhdHRyczogewogICAgICByZWxlYXNlOiBzZXNzaW9uLnJlbGVhc2UsCiAgICAgIGVudmlyb25tZW50OiBzZXNzaW9uLmVudmlyb25tZW50LAogICAgICBpcF9hZGRyZXNzOiBzZXNzaW9uLmlwQWRkcmVzcywKICAgICAgdXNlcl9hZ2VudDogc2Vzc2lvbi51c2VyQWdlbnQsCiAgICB9LAogIH0pOwp9Cgpjb25zdCBUUkFDRV9GTEFHX1NBTVBMRUQgPSAweDE7CgovKioKICogQ29udmVydCBhIHNwYW4gdG8gYSB0cmFjZSBjb250ZXh0LCB3aGljaCBjYW4gYmUgc2VudCBhcyB0aGUgYHRyYWNlYCBjb250ZXh0IGluIGFuIGV2ZW50LgogKi8KZnVuY3Rpb24gc3BhblRvVHJhY2VDb250ZXh0KHNwYW4pIHsKICBjb25zdCB7IHNwYW5JZDogc3Bhbl9pZCwgdHJhY2VJZDogdHJhY2VfaWQgfSA9IHNwYW4uc3BhbkNvbnRleHQoKTsKICBjb25zdCB7IGRhdGEsIG9wLCBwYXJlbnRfc3Bhbl9pZCwgc3RhdHVzLCB0YWdzLCBvcmlnaW4gfSA9IHNwYW5Ub0pTT04oc3Bhbik7CgogIHJldHVybiBkcm9wVW5kZWZpbmVkS2V5cyh7CiAgICBkYXRhLAogICAgb3AsCiAgICBwYXJlbnRfc3Bhbl9pZCwKICAgIHNwYW5faWQsCiAgICBzdGF0dXMsCiAgICB0YWdzLAogICAgdHJhY2VfaWQsCiAgICBvcmlnaW4sCiAgfSk7Cn0KCi8qKgogKiBDb252ZXJ0IGEgc3BhbiB0byBhIEpTT04gcmVwcmVzZW50YXRpb24uCiAqIE5vdGUgdGhhdCBhbGwgZmllbGRzIHJldHVybmVkIGhlcmUgYXJlIG9wdGlvbmFsIGFuZCBuZWVkIHRvIGJlIGd1YXJkZWQgYWdhaW5zdC4KICoKICogTm90ZTogQmVjYXVzZSBvZiB0aGlzLCB3ZSBjdXJyZW50bHkgaGF2ZSBhIGNpcmN1bGFyIHR5cGUgZGVwZW5kZW5jeSAod2hpY2ggd2Ugb3B0ZWQgb3V0IG9mIGluIHBhY2thZ2UuanNvbikuCiAqIFRoaXMgaXMgbm90IGF2b2lkYWJsZSBhcyB3ZSBuZWVkIGBzcGFuVG9KU09OYCBpbiBgc3BhblV0aWxzLnRzYCwgd2hpY2ggaW4gdHVybiBpcyBuZWVkZWQgYnkgYHNwYW4udHNgIGZvciBiYWNrd2FyZHMgY29tcGF0aWJpbGl0eS4KICogQW5kIGBzcGFuVG9KU09OYCBuZWVkcyB0aGUgU3BhbiBjbGFzcyBmcm9tIGBzcGFuLnRzYCB0byBjaGVjayBoZXJlLgogKiBUT0RPIHY4OiBXaGVuIHdlIHJlbW92ZSB0aGUgZGVwcmVjYXRlZCBzdHVmZiBmcm9tIGBzcGFuLnRzYCwgd2UgY2FuIHJlbW92ZSB0aGUgY2lyY3VsYXIgZGVwZW5kZW5jeSBhZ2Fpbi4KICovCmZ1bmN0aW9uIHNwYW5Ub0pTT04oc3BhbikgewogIGlmIChzcGFuSXNTcGFuQ2xhc3Moc3BhbikpIHsKICAgIHJldHVybiBzcGFuLmdldFNwYW5KU09OKCk7CiAgfQoKICAvLyBGYWxsYmFjazogV2UgYWxzbyBjaGVjayBmb3IgYC50b0pTT04oKWAgaGVyZS4uLgogIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBkZXByZWNhdGlvbi9kZXByZWNhdGlvbgogIGlmICh0eXBlb2Ygc3Bhbi50b0pTT04gPT09ICdmdW5jdGlvbicpIHsKICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBkZXByZWNhdGlvbi9kZXByZWNhdGlvbgogICAgcmV0dXJuIHNwYW4udG9KU09OKCk7CiAgfQoKICByZXR1cm4ge307Cn0KCi8qKgogKiBTYWRseSwgZHVlIHRvIGNpcmN1bGFyIGRlcGVuZGVuY3kgY2hlY2tzIHdlIGNhbm5vdCBhY3R1YWxseSBpbXBvcnQgdGhlIFNwYW4gY2xhc3MgaGVyZSBhbmQgY2hlY2sgZm9yIGluc3RhbmNlb2YuCiAqIDooIFNvIGluc3RlYWQgd2UgYXBwcm94aW1hdGUgdGhpcyBieSBjaGVja2luZyBpZiBpdCBoYXMgdGhlIGBnZXRTcGFuSlNPTmAgbWV0aG9kLgogKi8KZnVuY3Rpb24gc3BhbklzU3BhbkNsYXNzKHNwYW4pIHsKICByZXR1cm4gdHlwZW9mIChzcGFuICkuZ2V0U3BhbkpTT04gPT09ICdmdW5jdGlvbic7Cn0KCi8qKgogKiBSZXR1cm5zIHRydWUgaWYgYSBzcGFuIGlzIHNhbXBsZWQuCiAqIEluIG1vc3QgY2FzZXMsIHlvdSBzaG91bGQganVzdCB1c2UgYHNwYW4uaXNSZWNvcmRpbmcoKWAgaW5zdGVhZC4KICogSG93ZXZlciwgdGhpcyBoYXMgYSBzbGlnaHRseSBkaWZmZXJlbnQgc2VtYW50aWMsIGFzIGl0IGFsc28gcmV0dXJucyBmYWxzZSBpZiB0aGUgc3BhbiBpcyBmaW5pc2hlZC4KICogU28gaW4gdGhlIGNhc2Ugd2hlcmUgdGhpcyBkaXN0aW5jdGlvbiBpcyBpbXBvcnRhbnQsIHVzZSB0aGlzIG1ldGhvZC4KICovCmZ1bmN0aW9uIHNwYW5Jc1NhbXBsZWQoc3BhbikgewogIC8vIFdlIGFsaWduIG91ciB0cmFjZSBmbGFncyB3aXRoIHRoZSBvbmVzIE9wZW5UZWxlbWV0cnkgdXNlCiAgLy8gU28gd2UgYWxzbyBjaGVjayBmb3Igc2FtcGxlZCB0aGUgc2FtZSB3YXkgdGhleSBkby4KICBjb25zdCB7IHRyYWNlRmxhZ3MgfSA9IHNwYW4uc3BhbkNvbnRleHQoKTsKICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tYml0d2lzZQogIHJldHVybiBCb29sZWFuKHRyYWNlRmxhZ3MgJiBUUkFDRV9GTEFHX1NBTVBMRUQpOwp9CgovKioKICogR2V0IHRoZSBjdXJyZW50bHkgYWN0aXZlIGNsaWVudC4KICovCmZ1bmN0aW9uIGdldENsaWVudCgpIHsKICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgZGVwcmVjYXRpb24vZGVwcmVjYXRpb24KICByZXR1cm4gZ2V0Q3VycmVudEh1YigpLmdldENsaWVudCgpOwp9CgovKioKICogR2V0IHRoZSBjdXJyZW50bHkgYWN0aXZlIHNjb3BlLgogKi8KZnVuY3Rpb24gZ2V0Q3VycmVudFNjb3BlKCkgewogIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBkZXByZWNhdGlvbi9kZXByZWNhdGlvbgogIHJldHVybiBnZXRDdXJyZW50SHViKCkuZ2V0U2NvcGUoKTsKfQoKLyoqCiAqIFJldHVybnMgdGhlIHJvb3Qgc3BhbiBvZiBhIGdpdmVuIHNwYW4uCiAqCiAqIEFzIGxvbmcgYXMgd2UgdXNlIGBUcmFuc2FjdGlvbmBzIGludGVybmFsbHksIHRoZSByZXR1cm5lZCByb290IHNwYW4KICogd2lsbCBiZSBhIGBUcmFuc2FjdGlvbmAgYnV0IGJlIGF3YXJlIHRoYXQgdGhpcyBtaWdodCBjaGFuZ2UgaW4gdGhlIGZ1dHVyZS4KICoKICogSWYgdGhlIGdpdmVuIHNwYW4gaGFzIG5vIHJvb3Qgc3BhbiBvciB0cmFuc2FjdGlvbiwgYHVuZGVmaW5lZGAgaXMgcmV0dXJuZWQuCiAqLwpmdW5jdGlvbiBnZXRSb290U3BhbihzcGFuKSB7CiAgLy8gVE9ETyAodjgpOiBSZW1vdmUgdGhpcyBjaGVjayBhbmQganVzdCByZXR1cm4gc3BhbgogIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBkZXByZWNhdGlvbi9kZXByZWNhdGlvbgogIHJldHVybiBzcGFuLnRyYW5zYWN0aW9uOwp9CgovKioKICogQ3JlYXRlcyBhIGR5bmFtaWMgc2FtcGxpbmcgY29udGV4dCBmcm9tIGEgY2xpZW50LgogKgogKiBEaXNwYXRjaGVzIHRoZSBgY3JlYXRlRHNjYCBsaWZlY3ljbGUgaG9vayBhcyBhIHNpZGUgZWZmZWN0LgogKi8KZnVuY3Rpb24gZ2V0RHluYW1pY1NhbXBsaW5nQ29udGV4dEZyb21DbGllbnQoCiAgdHJhY2VfaWQsCiAgY2xpZW50LAogIHNjb3BlLAopIHsKICBjb25zdCBvcHRpb25zID0gY2xpZW50LmdldE9wdGlvbnMoKTsKCiAgY29uc3QgeyBwdWJsaWNLZXk6IHB1YmxpY19rZXkgfSA9IGNsaWVudC5nZXREc24oKSB8fCB7fTsKICAvLyBUT0RPKHY4KTogUmVtb3ZlIHNlZ21lbnQgZnJvbSBVc2VyCiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGRlcHJlY2F0aW9uL2RlcHJlY2F0aW9uCiAgY29uc3QgeyBzZWdtZW50OiB1c2VyX3NlZ21lbnQgfSA9IChzY29wZSAmJiBzY29wZS5nZXRVc2VyKCkpIHx8IHt9OwoKICBjb25zdCBkc2MgPSBkcm9wVW5kZWZpbmVkS2V5cyh7CiAgICBlbnZpcm9ubWVudDogb3B0aW9ucy5lbnZpcm9ubWVudCB8fCBERUZBVUxUX0VOVklST05NRU5ULAogICAgcmVsZWFzZTogb3B0aW9ucy5yZWxlYXNlLAogICAgdXNlcl9zZWdtZW50LAogICAgcHVibGljX2tleSwKICAgIHRyYWNlX2lkLAogIH0pIDsKCiAgY2xpZW50LmVtaXQgJiYgY2xpZW50LmVtaXQoJ2NyZWF0ZURzYycsIGRzYyk7CgogIHJldHVybiBkc2M7Cn0KCi8qKgogKiBBIFNwYW4gd2l0aCBhIGZyb3plbiBkeW5hbWljIHNhbXBsaW5nIGNvbnRleHQuCiAqLwoKLyoqCiAqIENyZWF0ZXMgYSBkeW5hbWljIHNhbXBsaW5nIGNvbnRleHQgZnJvbSBhIHNwYW4gKGFuZCBjbGllbnQgYW5kIHNjb3BlKQogKgogKiBAcGFyYW0gc3BhbiB0aGUgc3BhbiBmcm9tIHdoaWNoIGEgZmV3IHZhbHVlcyBsaWtlIHRoZSByb290IHNwYW4gbmFtZSBhbmQgc2FtcGxlIHJhdGUgYXJlIGV4dHJhY3RlZC4KICoKICogQHJldHVybnMgYSBkeW5hbWljIHNhbXBsaW5nIGNvbnRleHQKICovCmZ1bmN0aW9uIGdldER5bmFtaWNTYW1wbGluZ0NvbnRleHRGcm9tU3BhbihzcGFuKSB7CiAgY29uc3QgY2xpZW50ID0gZ2V0Q2xpZW50KCk7CiAgaWYgKCFjbGllbnQpIHsKICAgIHJldHVybiB7fTsKICB9CgogIC8vIHBhc3NpbmcgZW1pdD1mYWxzZSBoZXJlIHRvIG9ubHkgZW1pdCBsYXRlciBvbmNlIHRoZSBEU0MgaXMgYWN0dWFsbHkgcG9wdWxhdGVkCiAgY29uc3QgZHNjID0gZ2V0RHluYW1pY1NhbXBsaW5nQ29udGV4dEZyb21DbGllbnQoc3BhblRvSlNPTihzcGFuKS50cmFjZV9pZCB8fCAnJywgY2xpZW50LCBnZXRDdXJyZW50U2NvcGUoKSk7CgogIC8vIFRPRE8gKHY4KTogUmVtb3ZlIHY3RnJvemVuRHNjIGFzIGEgVHJhbnNhY3Rpb24gd2lsbCBubyBsb25nZXIgaGF2ZSBfZnJvemVuRHluYW1pY1NhbXBsaW5nQ29udGV4dAogIGNvbnN0IHR4biA9IGdldFJvb3RTcGFuKHNwYW4pIDsKICBpZiAoIXR4bikgewogICAgcmV0dXJuIGRzYzsKICB9CgogIC8vIFRPRE8gKHY4KTogUmVtb3ZlIHY3RnJvemVuRHNjIGFzIGEgVHJhbnNhY3Rpb24gd2lsbCBubyBsb25nZXIgaGF2ZSBfZnJvemVuRHluYW1pY1NhbXBsaW5nQ29udGV4dAogIC8vIEZvciBub3cgd2UgbmVlZCB0byBhdm9pZCBicmVha2luZyB1c2VycyB3aG8gZGlyZWN0bHkgY3JlYXRlZCBhIHR4biB3aXRoIGEgRFNDLCB3aGVyZSB0aGlzIGZpZWxkIGlzIHN0aWxsIHNldC4KICAvLyBAc2VlIFRyYW5zYWN0aW9uIGNsYXNzIGNvbnN0cnVjdG9yCiAgY29uc3QgdjdGcm96ZW5Ec2MgPSB0eG4gJiYgdHhuLl9mcm96ZW5EeW5hbWljU2FtcGxpbmdDb250ZXh0OwogIGlmICh2N0Zyb3plbkRzYykgewogICAgcmV0dXJuIHY3RnJvemVuRHNjOwogIH0KCiAgLy8gVE9ETyAodjgpOiBSZXBsYWNlIHR4bi5tZXRhZGF0YSB3aXRoIHR4bi5hdHRyaWJ1dGVzW10KICAvLyBXZSBjYW4ndCBkbyB0aGlzIHlldCBiZWNhdXNlIGF0dHJpYnV0ZXMgYXJlbid0IGFsd2F5cyBzZXQgeWV0LgogIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBkZXByZWNhdGlvbi9kZXByZWNhdGlvbgogIGNvbnN0IHsgc2FtcGxlUmF0ZTogbWF5YmVTYW1wbGVSYXRlLCBzb3VyY2UgfSA9IHR4bi5tZXRhZGF0YTsKICBpZiAobWF5YmVTYW1wbGVSYXRlICE9IG51bGwpIHsKICAgIGRzYy5zYW1wbGVfcmF0ZSA9IGAke21heWJlU2FtcGxlUmF0ZX1gOwogIH0KCiAgLy8gV2UgZG9uJ3Qgd2FudCB0byBoYXZlIGEgdHJhbnNhY3Rpb24gbmFtZSBpbiB0aGUgRFNDIGlmIHRoZSBzb3VyY2UgaXMgInVybCIgYmVjYXVzZSBVUkxzIG1pZ2h0IGNvbnRhaW4gUElJCiAgY29uc3QganNvblNwYW4gPSBzcGFuVG9KU09OKHR4bik7CgogIC8vIGFmdGVyIEpTT04gY29udmVyc2lvbiwgdHhuLm5hbWUgYmVjb21lcyBqc29uU3Bhbi5kZXNjcmlwdGlvbgogIGlmIChzb3VyY2UgJiYgc291cmNlICE9PSAndXJsJykgewogICAgZHNjLnRyYW5zYWN0aW9uID0ganNvblNwYW4uZGVzY3JpcHRpb247CiAgfQoKICBkc2Muc2FtcGxlZCA9IFN0cmluZyhzcGFuSXNTYW1wbGVkKHR4bikpOwoKICBjbGllbnQuZW1pdCAmJiBjbGllbnQuZW1pdCgnY3JlYXRlRHNjJywgZHNjKTsKCiAgcmV0dXJuIGRzYzsKfQoKLyoqCiAqIEFwcGxpZXMgZGF0YSBmcm9tIHRoZSBzY29wZSB0byB0aGUgZXZlbnQgYW5kIHJ1bnMgYWxsIGV2ZW50IHByb2Nlc3NvcnMgb24gaXQuCiAqLwpmdW5jdGlvbiBhcHBseVNjb3BlRGF0YVRvRXZlbnQoZXZlbnQsIGRhdGEpIHsKICBjb25zdCB7IGZpbmdlcnByaW50LCBzcGFuLCBicmVhZGNydW1icywgc2RrUHJvY2Vzc2luZ01ldGFkYXRhIH0gPSBkYXRhOwoKICAvLyBBcHBseSBnZW5lcmFsIGRhdGEKICBhcHBseURhdGFUb0V2ZW50KGV2ZW50LCBkYXRhKTsKCiAgLy8gV2Ugd2FudCB0byBzZXQgdGhlIHRyYWNlIGNvbnRleHQgZm9yIG5vcm1hbCBldmVudHMgb25seSBpZiB0aGVyZSBpc24ndCBhbHJlYWR5CiAgLy8gYSB0cmFjZSBjb250ZXh0IG9uIHRoZSBldmVudC4gVGhlcmUgaXMgYSBwcm9kdWN0IGZlYXR1cmUgaW4gcGxhY2Ugd2hlcmUgd2UgbGluawogIC8vIGVycm9ycyB3aXRoIHRyYW5zYWN0aW9uIGFuZCBpdCByZWxpZXMgb24gdGhhdC4KICBpZiAoc3BhbikgewogICAgYXBwbHlTcGFuVG9FdmVudChldmVudCwgc3Bhbik7CiAgfQoKICBhcHBseUZpbmdlcnByaW50VG9FdmVudChldmVudCwgZmluZ2VycHJpbnQpOwogIGFwcGx5QnJlYWRjcnVtYnNUb0V2ZW50KGV2ZW50LCBicmVhZGNydW1icyk7CiAgYXBwbHlTZGtNZXRhZGF0YVRvRXZlbnQoZXZlbnQsIHNka1Byb2Nlc3NpbmdNZXRhZGF0YSk7Cn0KCmZ1bmN0aW9uIGFwcGx5RGF0YVRvRXZlbnQoZXZlbnQsIGRhdGEpIHsKICBjb25zdCB7CiAgICBleHRyYSwKICAgIHRhZ3MsCiAgICB1c2VyLAogICAgY29udGV4dHMsCiAgICBsZXZlbCwKICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBkZXByZWNhdGlvbi9kZXByZWNhdGlvbgogICAgdHJhbnNhY3Rpb25OYW1lLAogIH0gPSBkYXRhOwoKICBjb25zdCBjbGVhbmVkRXh0cmEgPSBkcm9wVW5kZWZpbmVkS2V5cyhleHRyYSk7CiAgaWYgKGNsZWFuZWRFeHRyYSAmJiBPYmplY3Qua2V5cyhjbGVhbmVkRXh0cmEpLmxlbmd0aCkgewogICAgZXZlbnQuZXh0cmEgPSB7IC4uLmNsZWFuZWRFeHRyYSwgLi4uZXZlbnQuZXh0cmEgfTsKICB9CgogIGNvbnN0IGNsZWFuZWRUYWdzID0gZHJvcFVuZGVmaW5lZEtleXModGFncyk7CiAgaWYgKGNsZWFuZWRUYWdzICYmIE9iamVjdC5rZXlzKGNsZWFuZWRUYWdzKS5sZW5ndGgpIHsKICAgIGV2ZW50LnRhZ3MgPSB7IC4uLmNsZWFuZWRUYWdzLCAuLi5ldmVudC50YWdzIH07CiAgfQoKICBjb25zdCBjbGVhbmVkVXNlciA9IGRyb3BVbmRlZmluZWRLZXlzKHVzZXIpOwogIGlmIChjbGVhbmVkVXNlciAmJiBPYmplY3Qua2V5cyhjbGVhbmVkVXNlcikubGVuZ3RoKSB7CiAgICBldmVudC51c2VyID0geyAuLi5jbGVhbmVkVXNlciwgLi4uZXZlbnQudXNlciB9OwogIH0KCiAgY29uc3QgY2xlYW5lZENvbnRleHRzID0gZHJvcFVuZGVmaW5lZEtleXMoY29udGV4dHMpOwogIGlmIChjbGVhbmVkQ29udGV4dHMgJiYgT2JqZWN0LmtleXMoY2xlYW5lZENvbnRleHRzKS5sZW5ndGgpIHsKICAgIGV2ZW50LmNvbnRleHRzID0geyAuLi5jbGVhbmVkQ29udGV4dHMsIC4uLmV2ZW50LmNvbnRleHRzIH07CiAgfQoKICBpZiAobGV2ZWwpIHsKICAgIGV2ZW50LmxldmVsID0gbGV2ZWw7CiAgfQoKICBpZiAodHJhbnNhY3Rpb25OYW1lKSB7CiAgICBldmVudC50cmFuc2FjdGlvbiA9IHRyYW5zYWN0aW9uTmFtZTsKICB9Cn0KCmZ1bmN0aW9uIGFwcGx5QnJlYWRjcnVtYnNUb0V2ZW50KGV2ZW50LCBicmVhZGNydW1icykgewogIGNvbnN0IG1lcmdlZEJyZWFkY3J1bWJzID0gWy4uLihldmVudC5icmVhZGNydW1icyB8fCBbXSksIC4uLmJyZWFkY3J1bWJzXTsKICBldmVudC5icmVhZGNydW1icyA9IG1lcmdlZEJyZWFkY3J1bWJzLmxlbmd0aCA/IG1lcmdlZEJyZWFkY3J1bWJzIDogdW5kZWZpbmVkOwp9CgpmdW5jdGlvbiBhcHBseVNka01ldGFkYXRhVG9FdmVudChldmVudCwgc2RrUHJvY2Vzc2luZ01ldGFkYXRhKSB7CiAgZXZlbnQuc2RrUHJvY2Vzc2luZ01ldGFkYXRhID0gewogICAgLi4uZXZlbnQuc2RrUHJvY2Vzc2luZ01ldGFkYXRhLAogICAgLi4uc2RrUHJvY2Vzc2luZ01ldGFkYXRhLAogIH07Cn0KCmZ1bmN0aW9uIGFwcGx5U3BhblRvRXZlbnQoZXZlbnQsIHNwYW4pIHsKICBldmVudC5jb250ZXh0cyA9IHsgdHJhY2U6IHNwYW5Ub1RyYWNlQ29udGV4dChzcGFuKSwgLi4uZXZlbnQuY29udGV4dHMgfTsKICBjb25zdCByb290U3BhbiA9IGdldFJvb3RTcGFuKHNwYW4pOwogIGlmIChyb290U3BhbikgewogICAgZXZlbnQuc2RrUHJvY2Vzc2luZ01ldGFkYXRhID0gewogICAgICBkeW5hbWljU2FtcGxpbmdDb250ZXh0OiBnZXREeW5hbWljU2FtcGxpbmdDb250ZXh0RnJvbVNwYW4oc3BhbiksCiAgICAgIC4uLmV2ZW50LnNka1Byb2Nlc3NpbmdNZXRhZGF0YSwKICAgIH07CiAgICBjb25zdCB0cmFuc2FjdGlvbk5hbWUgPSBzcGFuVG9KU09OKHJvb3RTcGFuKS5kZXNjcmlwdGlvbjsKICAgIGlmICh0cmFuc2FjdGlvbk5hbWUpIHsKICAgICAgZXZlbnQudGFncyA9IHsgdHJhbnNhY3Rpb246IHRyYW5zYWN0aW9uTmFtZSwgLi4uZXZlbnQudGFncyB9OwogICAgfQogIH0KfQoKLyoqCiAqIEFwcGxpZXMgZmluZ2VycHJpbnQgZnJvbSB0aGUgc2NvcGUgdG8gdGhlIGV2ZW50IGlmIHRoZXJlJ3Mgb25lLAogKiB1c2VzIG1lc3NhZ2UgaWYgdGhlcmUncyBvbmUgaW5zdGVhZCBvciBnZXQgcmlkIG9mIGVtcHR5IGZpbmdlcnByaW50CiAqLwpmdW5jdGlvbiBhcHBseUZpbmdlcnByaW50VG9FdmVudChldmVudCwgZmluZ2VycHJpbnQpIHsKICAvLyBNYWtlIHN1cmUgaXQncyBhbiBhcnJheSBmaXJzdCBhbmQgd2UgYWN0dWFsbHkgaGF2ZSBzb21ldGhpbmcgaW4gcGxhY2UKICBldmVudC5maW5nZXJwcmludCA9IGV2ZW50LmZpbmdlcnByaW50ID8gYXJyYXlpZnkoZXZlbnQuZmluZ2VycHJpbnQpIDogW107CgogIC8vIElmIHdlIGhhdmUgc29tZXRoaW5nIG9uIHRoZSBzY29wZSwgdGhlbiBtZXJnZSBpdCB3aXRoIGV2ZW50CiAgaWYgKGZpbmdlcnByaW50KSB7CiAgICBldmVudC5maW5nZXJwcmludCA9IGV2ZW50LmZpbmdlcnByaW50LmNvbmNhdChmaW5nZXJwcmludCk7CiAgfQoKICAvLyBJZiB3ZSBoYXZlIG5vIGRhdGEgYXQgYWxsLCByZW1vdmUgZW1wdHkgYXJyYXkgZGVmYXVsdAogIGlmIChldmVudC5maW5nZXJwcmludCAmJiAhZXZlbnQuZmluZ2VycHJpbnQubGVuZ3RoKSB7CiAgICBkZWxldGUgZXZlbnQuZmluZ2VycHJpbnQ7CiAgfQp9CgovKioKICogRGVmYXVsdCB2YWx1ZSBmb3IgbWF4aW11bSBudW1iZXIgb2YgYnJlYWRjcnVtYnMgYWRkZWQgdG8gYW4gZXZlbnQuCiAqLwpjb25zdCBERUZBVUxUX01BWF9CUkVBRENSVU1CUyA9IDEwMDsKCi8qKgogKiBIb2xkcyBhZGRpdGlvbmFsIGV2ZW50IGluZm9ybWF0aW9uLiB7QGxpbmsgU2NvcGUuYXBwbHlUb0V2ZW50fSB3aWxsIGJlCiAqIGNhbGxlZCBieSB0aGUgY2xpZW50IGJlZm9yZSBhbiBldmVudCB3aWxsIGJlIHNlbnQuCiAqLwpjbGFzcyBTY29wZSAgewogIC8qKiBGbGFnIGlmIG5vdGlmeWluZyBpcyBoYXBwZW5pbmcuICovCgogIC8qKiBDYWxsYmFjayBmb3IgY2xpZW50IHRvIHJlY2VpdmUgc2NvcGUgY2hhbmdlcy4gKi8KCiAgLyoqIENhbGxiYWNrIGxpc3QgdGhhdCB3aWxsIGJlIGNhbGxlZCBhZnRlciB7QGxpbmsgYXBwbHlUb0V2ZW50fS4gKi8KCiAgLyoqIEFycmF5IG9mIGJyZWFkY3J1bWJzLiAqLwoKICAvKiogVXNlciAqLwoKICAvKiogVGFncyAqLwoKICAvKiogRXh0cmEgKi8KCiAgLyoqIENvbnRleHRzICovCgogIC8qKiBBdHRhY2htZW50cyAqLwoKICAvKiogUHJvcGFnYXRpb24gQ29udGV4dCBmb3IgZGlzdHJpYnV0ZWQgdHJhY2luZyAqLwoKICAvKioKICAgKiBBIHBsYWNlIHRvIHN0YXNoIGRhdGEgd2hpY2ggaXMgbmVlZGVkIGF0IHNvbWUgcG9pbnQgaW4gdGhlIFNESydzIGV2ZW50IHByb2Nlc3NpbmcgcGlwZWxpbmUgYnV0IHdoaWNoIHNob3VsZG4ndCBnZXQKICAgKiBzZW50IHRvIFNlbnRyeQogICAqLwoKICAvKiogRmluZ2VycHJpbnQgKi8KCiAgLyoqIFNldmVyaXR5ICovCiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGRlcHJlY2F0aW9uL2RlcHJlY2F0aW9uCgogIC8qKgogICAqIFRyYW5zYWN0aW9uIE5hbWUKICAgKi8KCiAgLyoqIFNwYW4gKi8KCiAgLyoqIFNlc3Npb24gKi8KCiAgLyoqIFJlcXVlc3QgTW9kZSBTZXNzaW9uIFN0YXR1cyAqLwoKICAvKiogVGhlIGNsaWVudCBvbiB0aGlzIHNjb3BlICovCgogIC8vIE5PVEU6IEFueSBmaWVsZCB3aGljaCBnZXRzIGFkZGVkIGhlcmUgc2hvdWxkIGdldCBhZGRlZCBub3Qgb25seSB0byB0aGUgY29uc3RydWN0b3IgYnV0IGFsc28gdG8gdGhlIGBjbG9uZWAgbWV0aG9kLgoKICAgY29uc3RydWN0b3IoKSB7CiAgICB0aGlzLl9ub3RpZnlpbmdMaXN0ZW5lcnMgPSBmYWxzZTsKICAgIHRoaXMuX3Njb3BlTGlzdGVuZXJzID0gW107CiAgICB0aGlzLl9ldmVudFByb2Nlc3NvcnMgPSBbXTsKICAgIHRoaXMuX2JyZWFkY3J1bWJzID0gW107CiAgICB0aGlzLl9hdHRhY2htZW50cyA9IFtdOwogICAgdGhpcy5fdXNlciA9IHt9OwogICAgdGhpcy5fdGFncyA9IHt9OwogICAgdGhpcy5fZXh0cmEgPSB7fTsKICAgIHRoaXMuX2NvbnRleHRzID0ge307CiAgICB0aGlzLl9zZGtQcm9jZXNzaW5nTWV0YWRhdGEgPSB7fTsKICAgIHRoaXMuX3Byb3BhZ2F0aW9uQ29udGV4dCA9IGdlbmVyYXRlUHJvcGFnYXRpb25Db250ZXh0KCk7CiAgfQoKICAvKioKICAgKiBJbmhlcml0IHZhbHVlcyBmcm9tIHRoZSBwYXJlbnQgc2NvcGUuCiAgICogQGRlcHJlY2F0ZWQgVXNlIGBzY29wZS5jbG9uZSgpYCBhbmQgYG5ldyBTY29wZSgpYCBpbnN0ZWFkLgogICAqLwogICBzdGF0aWMgY2xvbmUoc2NvcGUpIHsKICAgIHJldHVybiBzY29wZSA/IHNjb3BlLmNsb25lKCkgOiBuZXcgU2NvcGUoKTsKICB9CgogIC8qKgogICAqIENsb25lIHRoaXMgc2NvcGUgaW5zdGFuY2UuCiAgICovCiAgIGNsb25lKCkgewogICAgY29uc3QgbmV3U2NvcGUgPSBuZXcgU2NvcGUoKTsKICAgIG5ld1Njb3BlLl9icmVhZGNydW1icyA9IFsuLi50aGlzLl9icmVhZGNydW1ic107CiAgICBuZXdTY29wZS5fdGFncyA9IHsgLi4udGhpcy5fdGFncyB9OwogICAgbmV3U2NvcGUuX2V4dHJhID0geyAuLi50aGlzLl9leHRyYSB9OwogICAgbmV3U2NvcGUuX2NvbnRleHRzID0geyAuLi50aGlzLl9jb250ZXh0cyB9OwogICAgbmV3U2NvcGUuX3VzZXIgPSB0aGlzLl91c2VyOwogICAgbmV3U2NvcGUuX2xldmVsID0gdGhpcy5fbGV2ZWw7CiAgICBuZXdTY29wZS5fc3BhbiA9IHRoaXMuX3NwYW47CiAgICBuZXdTY29wZS5fc2Vzc2lvbiA9IHRoaXMuX3Nlc3Npb247CiAgICBuZXdTY29wZS5fdHJhbnNhY3Rpb25OYW1lID0gdGhpcy5fdHJhbnNhY3Rpb25OYW1lOwogICAgbmV3U2NvcGUuX2ZpbmdlcnByaW50ID0gdGhpcy5fZmluZ2VycHJpbnQ7CiAgICBuZXdTY29wZS5fZXZlbnRQcm9jZXNzb3JzID0gWy4uLnRoaXMuX2V2ZW50UHJvY2Vzc29yc107CiAgICBuZXdTY29wZS5fcmVxdWVzdFNlc3Npb24gPSB0aGlzLl9yZXF1ZXN0U2Vzc2lvbjsKICAgIG5ld1Njb3BlLl9hdHRhY2htZW50cyA9IFsuLi50aGlzLl9hdHRhY2htZW50c107CiAgICBuZXdTY29wZS5fc2RrUHJvY2Vzc2luZ01ldGFkYXRhID0geyAuLi50aGlzLl9zZGtQcm9jZXNzaW5nTWV0YWRhdGEgfTsKICAgIG5ld1Njb3BlLl9wcm9wYWdhdGlvbkNvbnRleHQgPSB7IC4uLnRoaXMuX3Byb3BhZ2F0aW9uQ29udGV4dCB9OwogICAgbmV3U2NvcGUuX2NsaWVudCA9IHRoaXMuX2NsaWVudDsKCiAgICByZXR1cm4gbmV3U2NvcGU7CiAgfQoKICAvKiogVXBkYXRlIHRoZSBjbGllbnQgb24gdGhlIHNjb3BlLiAqLwogICBzZXRDbGllbnQoY2xpZW50KSB7CiAgICB0aGlzLl9jbGllbnQgPSBjbGllbnQ7CiAgfQoKICAvKioKICAgKiBHZXQgdGhlIGNsaWVudCBhc3NpZ25lZCB0byB0aGlzIHNjb3BlLgogICAqCiAgICogSXQgaXMgZ2VuZXJhbGx5IHJlY29tbWVuZGVkIHRvIHVzZSB0aGUgZ2xvYmFsIGZ1bmN0aW9uIGBTZW50cnkuZ2V0Q2xpZW50KClgIGluc3RlYWQsIHVubGVzcyB5b3Uga25vdyB3aGF0IHlvdSBhcmUgZG9pbmcuCiAgICovCiAgIGdldENsaWVudCgpIHsKICAgIHJldHVybiB0aGlzLl9jbGllbnQ7CiAgfQoKICAvKioKICAgKiBBZGQgaW50ZXJuYWwgb24gY2hhbmdlIGxpc3RlbmVyLiBVc2VkIGZvciBzdWIgU0RLcyB0aGF0IG5lZWQgdG8gc3RvcmUgdGhlIHNjb3BlLgogICAqIEBoaWRkZW4KICAgKi8KICAgYWRkU2NvcGVMaXN0ZW5lcihjYWxsYmFjaykgewogICAgdGhpcy5fc2NvcGVMaXN0ZW5lcnMucHVzaChjYWxsYmFjayk7CiAgfQoKICAvKioKICAgKiBAaW5oZXJpdERvYwogICAqLwogICBhZGRFdmVudFByb2Nlc3NvcihjYWxsYmFjaykgewogICAgdGhpcy5fZXZlbnRQcm9jZXNzb3JzLnB1c2goY2FsbGJhY2spOwogICAgcmV0dXJuIHRoaXM7CiAgfQoKICAvKioKICAgKiBAaW5oZXJpdERvYwogICAqLwogICBzZXRVc2VyKHVzZXIpIHsKICAgIC8vIElmIG51bGwgaXMgcGFzc2VkIHdlIHdhbnQgdG8gdW5zZXQgZXZlcnl0aGluZywgYnV0IHN0aWxsIGRlZmluZSBrZXlzLAogICAgLy8gc28gdGhhdCBsYXRlciBkb3duIGluIHRoZSBwaXBlbGluZSBhbnkgZXhpc3RpbmcgdmFsdWVzIGFyZSBjbGVhcmVkLgogICAgdGhpcy5fdXNlciA9IHVzZXIgfHwgewogICAgICBlbWFpbDogdW5kZWZpbmVkLAogICAgICBpZDogdW5kZWZpbmVkLAogICAgICBpcF9hZGRyZXNzOiB1bmRlZmluZWQsCiAgICAgIHNlZ21lbnQ6IHVuZGVmaW5lZCwKICAgICAgdXNlcm5hbWU6IHVuZGVmaW5lZCwKICAgIH07CgogICAgaWYgKHRoaXMuX3Nlc3Npb24pIHsKICAgICAgdXBkYXRlU2Vzc2lvbih0aGlzLl9zZXNzaW9uLCB7IHVzZXIgfSk7CiAgICB9CgogICAgdGhpcy5fbm90aWZ5U2NvcGVMaXN0ZW5lcnMoKTsKICAgIHJldHVybiB0aGlzOwogIH0KCiAgLyoqCiAgICogQGluaGVyaXREb2MKICAgKi8KICAgZ2V0VXNlcigpIHsKICAgIHJldHVybiB0aGlzLl91c2VyOwogIH0KCiAgLyoqCiAgICogQGluaGVyaXREb2MKICAgKi8KICAgZ2V0UmVxdWVzdFNlc3Npb24oKSB7CiAgICByZXR1cm4gdGhpcy5fcmVxdWVzdFNlc3Npb247CiAgfQoKICAvKioKICAgKiBAaW5oZXJpdERvYwogICAqLwogICBzZXRSZXF1ZXN0U2Vzc2lvbihyZXF1ZXN0U2Vzc2lvbikgewogICAgdGhpcy5fcmVxdWVzdFNlc3Npb24gPSByZXF1ZXN0U2Vzc2lvbjsKICAgIHJldHVybiB0aGlzOwogIH0KCiAgLyoqCiAgICogQGluaGVyaXREb2MKICAgKi8KICAgc2V0VGFncyh0YWdzKSB7CiAgICB0aGlzLl90YWdzID0gewogICAgICAuLi50aGlzLl90YWdzLAogICAgICAuLi50YWdzLAogICAgfTsKICAgIHRoaXMuX25vdGlmeVNjb3BlTGlzdGVuZXJzKCk7CiAgICByZXR1cm4gdGhpczsKICB9CgogIC8qKgogICAqIEBpbmhlcml0RG9jCiAgICovCiAgIHNldFRhZyhrZXksIHZhbHVlKSB7CiAgICB0aGlzLl90YWdzID0geyAuLi50aGlzLl90YWdzLCBba2V5XTogdmFsdWUgfTsKICAgIHRoaXMuX25vdGlmeVNjb3BlTGlzdGVuZXJzKCk7CiAgICByZXR1cm4gdGhpczsKICB9CgogIC8qKgogICAqIEBpbmhlcml0RG9jCiAgICovCiAgIHNldEV4dHJhcyhleHRyYXMpIHsKICAgIHRoaXMuX2V4dHJhID0gewogICAgICAuLi50aGlzLl9leHRyYSwKICAgICAgLi4uZXh0cmFzLAogICAgfTsKICAgIHRoaXMuX25vdGlmeVNjb3BlTGlzdGVuZXJzKCk7CiAgICByZXR1cm4gdGhpczsKICB9CgogIC8qKgogICAqIEBpbmhlcml0RG9jCiAgICovCiAgIHNldEV4dHJhKGtleSwgZXh0cmEpIHsKICAgIHRoaXMuX2V4dHJhID0geyAuLi50aGlzLl9leHRyYSwgW2tleV06IGV4dHJhIH07CiAgICB0aGlzLl9ub3RpZnlTY29wZUxpc3RlbmVycygpOwogICAgcmV0dXJuIHRoaXM7CiAgfQoKICAvKioKICAgKiBAaW5oZXJpdERvYwogICAqLwogICBzZXRGaW5nZXJwcmludChmaW5nZXJwcmludCkgewogICAgdGhpcy5fZmluZ2VycHJpbnQgPSBmaW5nZXJwcmludDsKICAgIHRoaXMuX25vdGlmeVNjb3BlTGlzdGVuZXJzKCk7CiAgICByZXR1cm4gdGhpczsKICB9CgogIC8qKgogICAqIEBpbmhlcml0RG9jCiAgICovCiAgIHNldExldmVsKAogICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGRlcHJlY2F0aW9uL2RlcHJlY2F0aW9uCiAgICBsZXZlbCwKICApIHsKICAgIHRoaXMuX2xldmVsID0gbGV2ZWw7CiAgICB0aGlzLl9ub3RpZnlTY29wZUxpc3RlbmVycygpOwogICAgcmV0dXJuIHRoaXM7CiAgfQoKICAvKioKICAgKiBTZXRzIHRoZSB0cmFuc2FjdGlvbiBuYW1lIG9uIHRoZSBzY29wZSBmb3IgZnV0dXJlIGV2ZW50cy4KICAgKi8KICAgc2V0VHJhbnNhY3Rpb25OYW1lKG5hbWUpIHsKICAgIHRoaXMuX3RyYW5zYWN0aW9uTmFtZSA9IG5hbWU7CiAgICB0aGlzLl9ub3RpZnlTY29wZUxpc3RlbmVycygpOwogICAgcmV0dXJuIHRoaXM7CiAgfQoKICAvKioKICAgKiBAaW5oZXJpdERvYwogICAqLwogICBzZXRDb250ZXh0KGtleSwgY29udGV4dCkgewogICAgaWYgKGNvbnRleHQgPT09IG51bGwpIHsKICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1keW5hbWljLWRlbGV0ZQogICAgICBkZWxldGUgdGhpcy5fY29udGV4dHNba2V5XTsKICAgIH0gZWxzZSB7CiAgICAgIHRoaXMuX2NvbnRleHRzW2tleV0gPSBjb250ZXh0OwogICAgfQoKICAgIHRoaXMuX25vdGlmeVNjb3BlTGlzdGVuZXJzKCk7CiAgICByZXR1cm4gdGhpczsKICB9CgogIC8qKgogICAqIFNldHMgdGhlIFNwYW4gb24gdGhlIHNjb3BlLgogICAqIEBwYXJhbSBzcGFuIFNwYW4KICAgKiBAZGVwcmVjYXRlZCBJbnN0ZWFkIG9mIHNldHRpbmcgYSBzcGFuIG9uIGEgc2NvcGUsIHVzZSBgc3RhcnRTcGFuKClgL2BzdGFydFNwYW5NYW51YWwoKWAgaW5zdGVhZC4KICAgKi8KICAgc2V0U3BhbihzcGFuKSB7CiAgICB0aGlzLl9zcGFuID0gc3BhbjsKICAgIHRoaXMuX25vdGlmeVNjb3BlTGlzdGVuZXJzKCk7CiAgICByZXR1cm4gdGhpczsKICB9CgogIC8qKgogICAqIFJldHVybnMgdGhlIGBTcGFuYCBpZiB0aGVyZSBpcyBvbmUuCiAgICogQGRlcHJlY2F0ZWQgVXNlIGBnZXRBY3RpdmVTcGFuKClgIGluc3RlYWQuCiAgICovCiAgIGdldFNwYW4oKSB7CiAgICByZXR1cm4gdGhpcy5fc3BhbjsKICB9CgogIC8qKgogICAqIFJldHVybnMgdGhlIGBUcmFuc2FjdGlvbmAgYXR0YWNoZWQgdG8gdGhlIHNjb3BlIChpZiB0aGVyZSBpcyBvbmUpLgogICAqIEBkZXByZWNhdGVkIFlvdSBzaG91bGQgbm90IHJlbHkgb24gdGhlIHRyYW5zYWN0aW9uLCBidXQganVzdCB1c2UgYHN0YXJ0U3BhbigpYCBBUElzIGluc3RlYWQuCiAgICovCiAgIGdldFRyYW5zYWN0aW9uKCkgewogICAgLy8gT2Z0ZW4sIHRoaXMgc3BhbiAoaWYgaXQgZXhpc3RzIGF0IGFsbCkgd2lsbCBiZSBhIHRyYW5zYWN0aW9uLCBidXQgaXQncyBub3QgZ3VhcmFudGVlZCB0byBiZS4gUmVnYXJkbGVzcywgaXQgd2lsbAogICAgLy8gaGF2ZSBhIHBvaW50ZXIgdG8gdGhlIGN1cnJlbnRseS1hY3RpdmUgdHJhbnNhY3Rpb24uCiAgICBjb25zdCBzcGFuID0gdGhpcy5fc3BhbjsKICAgIC8vIENhbm5vdCByZXBsYWNlIHdpdGggZ2V0Um9vdFNwYW4gYmVjYXVzZSBnZXRSb290U3BhbiByZXR1cm5zIGEgc3Bhbiwgbm90IGEgdHJhbnNhY3Rpb24KICAgIC8vIEFsc28sIHRoaXMgbWV0aG9kIHdpbGwgYmUgcmVtb3ZlZCBhbnl3YXkuCiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgZGVwcmVjYXRpb24vZGVwcmVjYXRpb24KICAgIHJldHVybiBzcGFuICYmIHNwYW4udHJhbnNhY3Rpb247CiAgfQoKICAvKioKICAgKiBAaW5oZXJpdERvYwogICAqLwogICBzZXRTZXNzaW9uKHNlc3Npb24pIHsKICAgIGlmICghc2Vzc2lvbikgewogICAgICBkZWxldGUgdGhpcy5fc2Vzc2lvbjsKICAgIH0gZWxzZSB7CiAgICAgIHRoaXMuX3Nlc3Npb24gPSBzZXNzaW9uOwogICAgfQogICAgdGhpcy5fbm90aWZ5U2NvcGVMaXN0ZW5lcnMoKTsKICAgIHJldHVybiB0aGlzOwogIH0KCiAgLyoqCiAgICogQGluaGVyaXREb2MKICAgKi8KICAgZ2V0U2Vzc2lvbigpIHsKICAgIHJldHVybiB0aGlzLl9zZXNzaW9uOwogIH0KCiAgLyoqCiAgICogQGluaGVyaXREb2MKICAgKi8KICAgdXBkYXRlKGNhcHR1cmVDb250ZXh0KSB7CiAgICBpZiAoIWNhcHR1cmVDb250ZXh0KSB7CiAgICAgIHJldHVybiB0aGlzOwogICAgfQoKICAgIGNvbnN0IHNjb3BlVG9NZXJnZSA9IHR5cGVvZiBjYXB0dXJlQ29udGV4dCA9PT0gJ2Z1bmN0aW9uJyA/IGNhcHR1cmVDb250ZXh0KHRoaXMpIDogY2FwdHVyZUNvbnRleHQ7CgogICAgaWYgKHNjb3BlVG9NZXJnZSBpbnN0YW5jZW9mIFNjb3BlKSB7CiAgICAgIGNvbnN0IHNjb3BlRGF0YSA9IHNjb3BlVG9NZXJnZS5nZXRTY29wZURhdGEoKTsKCiAgICAgIHRoaXMuX3RhZ3MgPSB7IC4uLnRoaXMuX3RhZ3MsIC4uLnNjb3BlRGF0YS50YWdzIH07CiAgICAgIHRoaXMuX2V4dHJhID0geyAuLi50aGlzLl9leHRyYSwgLi4uc2NvcGVEYXRhLmV4dHJhIH07CiAgICAgIHRoaXMuX2NvbnRleHRzID0geyAuLi50aGlzLl9jb250ZXh0cywgLi4uc2NvcGVEYXRhLmNvbnRleHRzIH07CiAgICAgIGlmIChzY29wZURhdGEudXNlciAmJiBPYmplY3Qua2V5cyhzY29wZURhdGEudXNlcikubGVuZ3RoKSB7CiAgICAgICAgdGhpcy5fdXNlciA9IHNjb3BlRGF0YS51c2VyOwogICAgICB9CiAgICAgIGlmIChzY29wZURhdGEubGV2ZWwpIHsKICAgICAgICB0aGlzLl9sZXZlbCA9IHNjb3BlRGF0YS5sZXZlbDsKICAgICAgfQogICAgICBpZiAoc2NvcGVEYXRhLmZpbmdlcnByaW50Lmxlbmd0aCkgewogICAgICAgIHRoaXMuX2ZpbmdlcnByaW50ID0gc2NvcGVEYXRhLmZpbmdlcnByaW50OwogICAgICB9CiAgICAgIGlmIChzY29wZVRvTWVyZ2UuZ2V0UmVxdWVzdFNlc3Npb24oKSkgewogICAgICAgIHRoaXMuX3JlcXVlc3RTZXNzaW9uID0gc2NvcGVUb01lcmdlLmdldFJlcXVlc3RTZXNzaW9uKCk7CiAgICAgIH0KICAgICAgaWYgKHNjb3BlRGF0YS5wcm9wYWdhdGlvbkNvbnRleHQpIHsKICAgICAgICB0aGlzLl9wcm9wYWdhdGlvbkNvbnRleHQgPSBzY29wZURhdGEucHJvcGFnYXRpb25Db250ZXh0OwogICAgICB9CiAgICB9IGVsc2UgaWYgKGlzUGxhaW5PYmplY3Qoc2NvcGVUb01lcmdlKSkgewogICAgICBjb25zdCBzY29wZUNvbnRleHQgPSBjYXB0dXJlQ29udGV4dCA7CiAgICAgIHRoaXMuX3RhZ3MgPSB7IC4uLnRoaXMuX3RhZ3MsIC4uLnNjb3BlQ29udGV4dC50YWdzIH07CiAgICAgIHRoaXMuX2V4dHJhID0geyAuLi50aGlzLl9leHRyYSwgLi4uc2NvcGVDb250ZXh0LmV4dHJhIH07CiAgICAgIHRoaXMuX2NvbnRleHRzID0geyAuLi50aGlzLl9jb250ZXh0cywgLi4uc2NvcGVDb250ZXh0LmNvbnRleHRzIH07CiAgICAgIGlmIChzY29wZUNvbnRleHQudXNlcikgewogICAgICAgIHRoaXMuX3VzZXIgPSBzY29wZUNvbnRleHQudXNlcjsKICAgICAgfQogICAgICBpZiAoc2NvcGVDb250ZXh0LmxldmVsKSB7CiAgICAgICAgdGhpcy5fbGV2ZWwgPSBzY29wZUNvbnRleHQubGV2ZWw7CiAgICAgIH0KICAgICAgaWYgKHNjb3BlQ29udGV4dC5maW5nZXJwcmludCkgewogICAgICAgIHRoaXMuX2ZpbmdlcnByaW50ID0gc2NvcGVDb250ZXh0LmZpbmdlcnByaW50OwogICAgICB9CiAgICAgIGlmIChzY29wZUNvbnRleHQucmVxdWVzdFNlc3Npb24pIHsKICAgICAgICB0aGlzLl9yZXF1ZXN0U2Vzc2lvbiA9IHNjb3BlQ29udGV4dC5yZXF1ZXN0U2Vzc2lvbjsKICAgICAgfQogICAgICBpZiAoc2NvcGVDb250ZXh0LnByb3BhZ2F0aW9uQ29udGV4dCkgewogICAgICAgIHRoaXMuX3Byb3BhZ2F0aW9uQ29udGV4dCA9IHNjb3BlQ29udGV4dC5wcm9wYWdhdGlvbkNvbnRleHQ7CiAgICAgIH0KICAgIH0KCiAgICByZXR1cm4gdGhpczsKICB9CgogIC8qKgogICAqIEBpbmhlcml0RG9jCiAgICovCiAgIGNsZWFyKCkgewogICAgdGhpcy5fYnJlYWRjcnVtYnMgPSBbXTsKICAgIHRoaXMuX3RhZ3MgPSB7fTsKICAgIHRoaXMuX2V4dHJhID0ge307CiAgICB0aGlzLl91c2VyID0ge307CiAgICB0aGlzLl9jb250ZXh0cyA9IHt9OwogICAgdGhpcy5fbGV2ZWwgPSB1bmRlZmluZWQ7CiAgICB0aGlzLl90cmFuc2FjdGlvbk5hbWUgPSB1bmRlZmluZWQ7CiAgICB0aGlzLl9maW5nZXJwcmludCA9IHVuZGVmaW5lZDsKICAgIHRoaXMuX3JlcXVlc3RTZXNzaW9uID0gdW5kZWZpbmVkOwogICAgdGhpcy5fc3BhbiA9IHVuZGVmaW5lZDsKICAgIHRoaXMuX3Nlc3Npb24gPSB1bmRlZmluZWQ7CiAgICB0aGlzLl9ub3RpZnlTY29wZUxpc3RlbmVycygpOwogICAgdGhpcy5fYXR0YWNobWVudHMgPSBbXTsKICAgIHRoaXMuX3Byb3BhZ2F0aW9uQ29udGV4dCA9IGdlbmVyYXRlUHJvcGFnYXRpb25Db250ZXh0KCk7CiAgICByZXR1cm4gdGhpczsKICB9CgogIC8qKgogICAqIEBpbmhlcml0RG9jCiAgICovCiAgIGFkZEJyZWFkY3J1bWIoYnJlYWRjcnVtYiwgbWF4QnJlYWRjcnVtYnMpIHsKICAgIGNvbnN0IG1heENydW1icyA9IHR5cGVvZiBtYXhCcmVhZGNydW1icyA9PT0gJ251bWJlcicgPyBtYXhCcmVhZGNydW1icyA6IERFRkFVTFRfTUFYX0JSRUFEQ1JVTUJTOwoKICAgIC8vIE5vIGRhdGEgaGFzIGJlZW4gY2hhbmdlZCwgc28gZG9uJ3Qgbm90aWZ5IHNjb3BlIGxpc3RlbmVycwogICAgaWYgKG1heENydW1icyA8PSAwKSB7CiAgICAgIHJldHVybiB0aGlzOwogICAgfQoKICAgIGNvbnN0IG1lcmdlZEJyZWFkY3J1bWIgPSB7CiAgICAgIHRpbWVzdGFtcDogZGF0ZVRpbWVzdGFtcEluU2Vjb25kcygpLAogICAgICAuLi5icmVhZGNydW1iLAogICAgfTsKCiAgICBjb25zdCBicmVhZGNydW1icyA9IHRoaXMuX2JyZWFkY3J1bWJzOwogICAgYnJlYWRjcnVtYnMucHVzaChtZXJnZWRCcmVhZGNydW1iKTsKICAgIHRoaXMuX2JyZWFkY3J1bWJzID0gYnJlYWRjcnVtYnMubGVuZ3RoID4gbWF4Q3J1bWJzID8gYnJlYWRjcnVtYnMuc2xpY2UoLW1heENydW1icykgOiBicmVhZGNydW1iczsKCiAgICB0aGlzLl9ub3RpZnlTY29wZUxpc3RlbmVycygpOwoKICAgIHJldHVybiB0aGlzOwogIH0KCiAgLyoqCiAgICogQGluaGVyaXREb2MKICAgKi8KICAgZ2V0TGFzdEJyZWFkY3J1bWIoKSB7CiAgICByZXR1cm4gdGhpcy5fYnJlYWRjcnVtYnNbdGhpcy5fYnJlYWRjcnVtYnMubGVuZ3RoIC0gMV07CiAgfQoKICAvKioKICAgKiBAaW5oZXJpdERvYwogICAqLwogICBjbGVhckJyZWFkY3J1bWJzKCkgewogICAgdGhpcy5fYnJlYWRjcnVtYnMgPSBbXTsKICAgIHRoaXMuX25vdGlmeVNjb3BlTGlzdGVuZXJzKCk7CiAgICByZXR1cm4gdGhpczsKICB9CgogIC8qKgogICAqIEBpbmhlcml0RG9jCiAgICovCiAgIGFkZEF0dGFjaG1lbnQoYXR0YWNobWVudCkgewogICAgdGhpcy5fYXR0YWNobWVudHMucHVzaChhdHRhY2htZW50KTsKICAgIHJldHVybiB0aGlzOwogIH0KCiAgLyoqCiAgICogQGluaGVyaXREb2MKICAgKiBAZGVwcmVjYXRlZCBVc2UgYGdldFNjb3BlRGF0YSgpYCBpbnN0ZWFkLgogICAqLwogICBnZXRBdHRhY2htZW50cygpIHsKICAgIGNvbnN0IGRhdGEgPSB0aGlzLmdldFNjb3BlRGF0YSgpOwoKICAgIHJldHVybiBkYXRhLmF0dGFjaG1lbnRzOwogIH0KCiAgLyoqCiAgICogQGluaGVyaXREb2MKICAgKi8KICAgY2xlYXJBdHRhY2htZW50cygpIHsKICAgIHRoaXMuX2F0dGFjaG1lbnRzID0gW107CiAgICByZXR1cm4gdGhpczsKICB9CgogIC8qKiBAaW5oZXJpdERvYyAqLwogICBnZXRTY29wZURhdGEoKSB7CiAgICBjb25zdCB7CiAgICAgIF9icmVhZGNydW1icywKICAgICAgX2F0dGFjaG1lbnRzLAogICAgICBfY29udGV4dHMsCiAgICAgIF90YWdzLAogICAgICBfZXh0cmEsCiAgICAgIF91c2VyLAogICAgICBfbGV2ZWwsCiAgICAgIF9maW5nZXJwcmludCwKICAgICAgX2V2ZW50UHJvY2Vzc29ycywKICAgICAgX3Byb3BhZ2F0aW9uQ29udGV4dCwKICAgICAgX3Nka1Byb2Nlc3NpbmdNZXRhZGF0YSwKICAgICAgX3RyYW5zYWN0aW9uTmFtZSwKICAgICAgX3NwYW4sCiAgICB9ID0gdGhpczsKCiAgICByZXR1cm4gewogICAgICBicmVhZGNydW1iczogX2JyZWFkY3J1bWJzLAogICAgICBhdHRhY2htZW50czogX2F0dGFjaG1lbnRzLAogICAgICBjb250ZXh0czogX2NvbnRleHRzLAogICAgICB0YWdzOiBfdGFncywKICAgICAgZXh0cmE6IF9leHRyYSwKICAgICAgdXNlcjogX3VzZXIsCiAgICAgIGxldmVsOiBfbGV2ZWwsCiAgICAgIGZpbmdlcnByaW50OiBfZmluZ2VycHJpbnQgfHwgW10sCiAgICAgIGV2ZW50UHJvY2Vzc29yczogX2V2ZW50UHJvY2Vzc29ycywKICAgICAgcHJvcGFnYXRpb25Db250ZXh0OiBfcHJvcGFnYXRpb25Db250ZXh0LAogICAgICBzZGtQcm9jZXNzaW5nTWV0YWRhdGE6IF9zZGtQcm9jZXNzaW5nTWV0YWRhdGEsCiAgICAgIHRyYW5zYWN0aW9uTmFtZTogX3RyYW5zYWN0aW9uTmFtZSwKICAgICAgc3BhbjogX3NwYW4sCiAgICB9OwogIH0KCiAgLyoqCiAgICogQXBwbGllcyBkYXRhIGZyb20gdGhlIHNjb3BlIHRvIHRoZSBldmVudCBhbmQgcnVucyBhbGwgZXZlbnQgcHJvY2Vzc29ycyBvbiBpdC4KICAgKgogICAqIEBwYXJhbSBldmVudCBFdmVudAogICAqIEBwYXJhbSBoaW50IE9iamVjdCBjb250YWluaW5nIGFkZGl0aW9uYWwgaW5mb3JtYXRpb24gYWJvdXQgdGhlIG9yaWdpbmFsIGV4Y2VwdGlvbiwgZm9yIHVzZSBieSB0aGUgZXZlbnQgcHJvY2Vzc29ycy4KICAgKiBAaGlkZGVuCiAgICogQGRlcHJlY2F0ZWQgVXNlIGBhcHBseVNjb3BlRGF0YVRvRXZlbnQoKWAgZGlyZWN0bHkKICAgKi8KICAgYXBwbHlUb0V2ZW50KAogICAgZXZlbnQsCiAgICBoaW50ID0ge30sCiAgICBhZGRpdGlvbmFsRXZlbnRQcm9jZXNzb3JzID0gW10sCiAgKSB7CiAgICBhcHBseVNjb3BlRGF0YVRvRXZlbnQoZXZlbnQsIHRoaXMuZ2V0U2NvcGVEYXRhKCkpOwoKICAgIC8vIFRPRE8gKHY4KTogVXBkYXRlIHRoaXMgb3JkZXIgdG8gYmU6IEdsb2JhbCA+IENsaWVudCA+IFNjb3BlCiAgICBjb25zdCBldmVudFByb2Nlc3NvcnMgPSBbCiAgICAgIC4uLmFkZGl0aW9uYWxFdmVudFByb2Nlc3NvcnMsCiAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBkZXByZWNhdGlvbi9kZXByZWNhdGlvbgogICAgICAuLi5nZXRHbG9iYWxFdmVudFByb2Nlc3NvcnMoKSwKICAgICAgLi4udGhpcy5fZXZlbnRQcm9jZXNzb3JzLAogICAgXTsKCiAgICByZXR1cm4gbm90aWZ5RXZlbnRQcm9jZXNzb3JzKGV2ZW50UHJvY2Vzc29ycywgZXZlbnQsIGhpbnQpOwogIH0KCiAgLyoqCiAgICogQWRkIGRhdGEgd2hpY2ggd2lsbCBiZSBhY2Nlc3NpYmxlIGR1cmluZyBldmVudCBwcm9jZXNzaW5nIGJ1dCB3b24ndCBnZXQgc2VudCB0byBTZW50cnkKICAgKi8KICAgc2V0U0RLUHJvY2Vzc2luZ01ldGFkYXRhKG5ld0RhdGEpIHsKICAgIHRoaXMuX3Nka1Byb2Nlc3NpbmdNZXRhZGF0YSA9IHsgLi4udGhpcy5fc2RrUHJvY2Vzc2luZ01ldGFkYXRhLCAuLi5uZXdEYXRhIH07CgogICAgcmV0dXJuIHRoaXM7CiAgfQoKICAvKioKICAgKiBAaW5oZXJpdERvYwogICAqLwogICBzZXRQcm9wYWdhdGlvbkNvbnRleHQoY29udGV4dCkgewogICAgdGhpcy5fcHJvcGFnYXRpb25Db250ZXh0ID0gY29udGV4dDsKICAgIHJldHVybiB0aGlzOwogIH0KCiAgLyoqCiAgICogQGluaGVyaXREb2MKICAgKi8KICAgZ2V0UHJvcGFnYXRpb25Db250ZXh0KCkgewogICAgcmV0dXJuIHRoaXMuX3Byb3BhZ2F0aW9uQ29udGV4dDsKICB9CgogIC8qKgogICAqIENhcHR1cmUgYW4gZXhjZXB0aW9uIGZvciB0aGlzIHNjb3BlLgogICAqCiAgICogQHBhcmFtIGV4Y2VwdGlvbiBUaGUgZXhjZXB0aW9uIHRvIGNhcHR1cmUuCiAgICogQHBhcmFtIGhpbnQgT3B0aW5hbCBhZGRpdGlvbmFsIGRhdGEgdG8gYXR0YWNoIHRvIHRoZSBTZW50cnkgZXZlbnQuCiAgICogQHJldHVybnMgdGhlIGlkIG9mIHRoZSBjYXB0dXJlZCBTZW50cnkgZXZlbnQuCiAgICovCiAgIGNhcHR1cmVFeGNlcHRpb24oZXhjZXB0aW9uLCBoaW50KSB7CiAgICBjb25zdCBldmVudElkID0gaGludCAmJiBoaW50LmV2ZW50X2lkID8gaGludC5ldmVudF9pZCA6IHV1aWQ0KCk7CgogICAgaWYgKCF0aGlzLl9jbGllbnQpIHsKICAgICAgbG9nZ2VyLndhcm4oJ05vIGNsaWVudCBjb25maWd1cmVkIG9uIHNjb3BlIC0gd2lsbCBub3QgY2FwdHVyZSBleGNlcHRpb24hJyk7CiAgICAgIHJldHVybiBldmVudElkOwogICAgfQoKICAgIGNvbnN0IHN5bnRoZXRpY0V4Y2VwdGlvbiA9IG5ldyBFcnJvcignU2VudHJ5IHN5bnRoZXRpY0V4Y2VwdGlvbicpOwoKICAgIHRoaXMuX2NsaWVudC5jYXB0dXJlRXhjZXB0aW9uKAogICAgICBleGNlcHRpb24sCiAgICAgIHsKICAgICAgICBvcmlnaW5hbEV4Y2VwdGlvbjogZXhjZXB0aW9uLAogICAgICAgIHN5bnRoZXRpY0V4Y2VwdGlvbiwKICAgICAgICAuLi5oaW50LAogICAgICAgIGV2ZW50X2lkOiBldmVudElkLAogICAgICB9LAogICAgICB0aGlzLAogICAgKTsKCiAgICByZXR1cm4gZXZlbnRJZDsKICB9CgogIC8qKgogICAqIENhcHR1cmUgYSBtZXNzYWdlIGZvciB0aGlzIHNjb3BlLgogICAqCiAgICogQHBhcmFtIG1lc3NhZ2UgVGhlIG1lc3NhZ2UgdG8gY2FwdHVyZS4KICAgKiBAcGFyYW0gbGV2ZWwgQW4gb3B0aW9uYWwgc2V2ZXJpdHkgbGV2ZWwgdG8gcmVwb3J0IHRoZSBtZXNzYWdlIHdpdGguCiAgICogQHBhcmFtIGhpbnQgT3B0aW9uYWwgYWRkaXRpb25hbCBkYXRhIHRvIGF0dGFjaCB0byB0aGUgU2VudHJ5IGV2ZW50LgogICAqIEByZXR1cm5zIHRoZSBpZCBvZiB0aGUgY2FwdHVyZWQgbWVzc2FnZS4KICAgKi8KICAgY2FwdHVyZU1lc3NhZ2UobWVzc2FnZSwgbGV2ZWwsIGhpbnQpIHsKICAgIGNvbnN0IGV2ZW50SWQgPSBoaW50ICYmIGhpbnQuZXZlbnRfaWQgPyBoaW50LmV2ZW50X2lkIDogdXVpZDQoKTsKCiAgICBpZiAoIXRoaXMuX2NsaWVudCkgewogICAgICBsb2dnZXIud2FybignTm8gY2xpZW50IGNvbmZpZ3VyZWQgb24gc2NvcGUgLSB3aWxsIG5vdCBjYXB0dXJlIG1lc3NhZ2UhJyk7CiAgICAgIHJldHVybiBldmVudElkOwogICAgfQoKICAgIGNvbnN0IHN5bnRoZXRpY0V4Y2VwdGlvbiA9IG5ldyBFcnJvcihtZXNzYWdlKTsKCiAgICB0aGlzLl9jbGllbnQuY2FwdHVyZU1lc3NhZ2UoCiAgICAgIG1lc3NhZ2UsCiAgICAgIGxldmVsLAogICAgICB7CiAgICAgICAgb3JpZ2luYWxFeGNlcHRpb246IG1lc3NhZ2UsCiAgICAgICAgc3ludGhldGljRXhjZXB0aW9uLAogICAgICAgIC4uLmhpbnQsCiAgICAgICAgZXZlbnRfaWQ6IGV2ZW50SWQsCiAgICAgIH0sCiAgICAgIHRoaXMsCiAgICApOwoKICAgIHJldHVybiBldmVudElkOwogIH0KCiAgLyoqCiAgICogQ2FwdHVyZXMgYSBtYW51YWxseSBjcmVhdGVkIGV2ZW50IGZvciB0aGlzIHNjb3BlIGFuZCBzZW5kcyBpdCB0byBTZW50cnkuCiAgICoKICAgKiBAcGFyYW0gZXhjZXB0aW9uIFRoZSBldmVudCB0byBjYXB0dXJlLgogICAqIEBwYXJhbSBoaW50IE9wdGlvbmFsIGFkZGl0aW9uYWwgZGF0YSB0byBhdHRhY2ggdG8gdGhlIFNlbnRyeSBldmVudC4KICAgKiBAcmV0dXJucyB0aGUgaWQgb2YgdGhlIGNhcHR1cmVkIGV2ZW50LgogICAqLwogICBjYXB0dXJlRXZlbnQoZXZlbnQsIGhpbnQpIHsKICAgIGNvbnN0IGV2ZW50SWQgPSBoaW50ICYmIGhpbnQuZXZlbnRfaWQgPyBoaW50LmV2ZW50X2lkIDogdXVpZDQoKTsKCiAgICBpZiAoIXRoaXMuX2NsaWVudCkgewogICAgICBsb2dnZXIud2FybignTm8gY2xpZW50IGNvbmZpZ3VyZWQgb24gc2NvcGUgLSB3aWxsIG5vdCBjYXB0dXJlIGV2ZW50IScpOwogICAgICByZXR1cm4gZXZlbnRJZDsKICAgIH0KCiAgICB0aGlzLl9jbGllbnQuY2FwdHVyZUV2ZW50KGV2ZW50LCB7IC4uLmhpbnQsIGV2ZW50X2lkOiBldmVudElkIH0sIHRoaXMpOwoKICAgIHJldHVybiBldmVudElkOwogIH0KCiAgLyoqCiAgICogVGhpcyB3aWxsIGJlIGNhbGxlZCBvbiBldmVyeSBzZXQgY2FsbC4KICAgKi8KICAgX25vdGlmeVNjb3BlTGlzdGVuZXJzKCkgewogICAgLy8gV2UgbmVlZCB0aGlzIGNoZWNrIGZvciB0aGlzLl9ub3RpZnlpbmdMaXN0ZW5lcnMgdG8gYmUgYWJsZSB0byB3b3JrIG9uIHNjb3BlIGR1cmluZyB1cGRhdGVzCiAgICAvLyBJZiB0aGlzIGNoZWNrIGlzIG5vdCBoZXJlIHdlJ2xsIHByb2R1Y2UgZW5kbGVzcyByZWN1cnNpb24gd2hlbiBzb21ldGhpbmcgaXMgZG9uZSB3aXRoIHRoZSBzY29wZQogICAgLy8gZHVyaW5nIHRoZSBjYWxsYmFjay4KICAgIGlmICghdGhpcy5fbm90aWZ5aW5nTGlzdGVuZXJzKSB7CiAgICAgIHRoaXMuX25vdGlmeWluZ0xpc3RlbmVycyA9IHRydWU7CiAgICAgIHRoaXMuX3Njb3BlTGlzdGVuZXJzLmZvckVhY2goY2FsbGJhY2sgPT4gewogICAgICAgIGNhbGxiYWNrKHRoaXMpOwogICAgICB9KTsKICAgICAgdGhpcy5fbm90aWZ5aW5nTGlzdGVuZXJzID0gZmFsc2U7CiAgICB9CiAgfQp9CgpmdW5jdGlvbiBnZW5lcmF0ZVByb3BhZ2F0aW9uQ29udGV4dCgpIHsKICByZXR1cm4gewogICAgdHJhY2VJZDogdXVpZDQoKSwKICAgIHNwYW5JZDogdXVpZDQoKS5zdWJzdHJpbmcoMTYpLAogIH07Cn0KCmNvbnN0IFNES19WRVJTSU9OID0gJzcuMTIwLjInOwoKLyoqCiAqIEFQSSBjb21wYXRpYmlsaXR5IHZlcnNpb24gb2YgdGhpcyBodWIuCiAqCiAqIFdBUk5JTkc6IFRoaXMgbnVtYmVyIHNob3VsZCBvbmx5IGJlIGluY3JlYXNlZCB3aGVuIHRoZSBnbG9iYWwgaW50ZXJmYWNlCiAqIGNoYW5nZXMgYW5kIG5ldyBtZXRob2RzIGFyZSBpbnRyb2R1Y2VkLgogKgogKiBAaGlkZGVuCiAqLwpjb25zdCBBUElfVkVSU0lPTiA9IHBhcnNlRmxvYXQoU0RLX1ZFUlNJT04pOwoKLyoqCiAqIERlZmF1bHQgbWF4aW11bSBudW1iZXIgb2YgYnJlYWRjcnVtYnMgYWRkZWQgdG8gYW4gZXZlbnQuIENhbiBiZSBvdmVyd3JpdHRlbgogKiB3aXRoIHtAbGluayBPcHRpb25zLm1heEJyZWFkY3J1bWJzfS4KICovCmNvbnN0IERFRkFVTFRfQlJFQURDUlVNQlMgPSAxMDA7CgovKioKICogQGRlcHJlY2F0ZWQgVGhlIGBIdWJgIGNsYXNzIHdpbGwgYmUgcmVtb3ZlZCBpbiB2ZXJzaW9uIDggb2YgdGhlIFNESyBpbiBmYXZvdXIgb2YgYFNjb3BlYCBhbmQgYENsaWVudGAgb2JqZWN0cy4KICoKICogSWYgeW91IHByZXZpb3VzbHkgdXNlZCB0aGUgYEh1YmAgY2xhc3MgZGlyZWN0bHksIHJlcGxhY2UgaXQgd2l0aCBgU2NvcGVgIGFuZCBgQ2xpZW50YCBvYmplY3RzLiBNb3JlIGluZm9ybWF0aW9uOgogKiAtIFtNdWx0aXBsZSBTZW50cnkgSW5zdGFuY2VzXShodHRwczovL2RvY3Muc2VudHJ5LmlvL3BsYXRmb3Jtcy9qYXZhc2NyaXB0L2Jlc3QtcHJhY3RpY2VzL211bHRpcGxlLXNlbnRyeS1pbnN0YW5jZXMvKQogKiAtIFtCcm93c2VyIEV4dGVuc2lvbnNdKGh0dHBzOi8vZG9jcy5zZW50cnkuaW8vcGxhdGZvcm1zL2phdmFzY3JpcHQvYmVzdC1wcmFjdGljZXMvYnJvd3Nlci1leHRlbnNpb25zLykKICoKICogU29tZSBvZiBvdXIgQVBJcyBhcmUgdHlwZWQgd2l0aCB0aGUgSHViIGNsYXNzIGluc3RlYWQgb2YgdGhlIGludGVyZmFjZSAoZS5nLiBgZ2V0Q3VycmVudEh1YmApLiBNb3N0IG9mIHRoZW0gYXJlIGRlcHJlY2F0ZWQKICogdGhlbXNlbHZlcyBhbmQgd2lsbCBhbHNvIGJlIHJlbW92ZWQgaW4gdmVyc2lvbiA4LiBNb3JlIGluZm9ybWF0aW9uOgogKiAtIFtNaWdyYXRpb24gR3VpZGVdKGh0dHBzOi8vZ2l0aHViLmNvbS9nZXRzZW50cnkvc2VudHJ5LWphdmFzY3JpcHQvYmxvYi9kZXZlbG9wL01JR1JBVElPTi5tZCNkZXByZWNhdGUtaHViKQogKi8KLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGRlcHJlY2F0aW9uL2RlcHJlY2F0aW9uCmNsYXNzIEh1YiAgewogIC8qKiBJcyBhIHtAbGluayBMYXllcn1bXSBjb250YWluaW5nIHRoZSBjbGllbnQgYW5kIHNjb3BlICovCgogIC8qKiBDb250YWlucyB0aGUgbGFzdCBldmVudCBpZCBvZiBhIGNhcHR1cmVkIGV2ZW50LiAgKi8KCiAgLyoqCiAgICogQ3JlYXRlcyBhIG5ldyBpbnN0YW5jZSBvZiB0aGUgaHViLCB3aWxsIHB1c2ggb25lIHtAbGluayBMYXllcn0gaW50byB0aGUKICAgKiBpbnRlcm5hbCBzdGFjayBvbiBjcmVhdGlvbi4KICAgKgogICAqIEBwYXJhbSBjbGllbnQgYm91bmQgdG8gdGhlIGh1Yi4KICAgKiBAcGFyYW0gc2NvcGUgYm91bmQgdG8gdGhlIGh1Yi4KICAgKiBAcGFyYW0gdmVyc2lvbiBudW1iZXIsIGhpZ2hlciBudW1iZXIgbWVhbnMgaGlnaGVyIHByaW9yaXR5LgogICAqCiAgICogQGRlcHJlY2F0ZWQgSW5zdGFudGlhdGlvbiBvZiBIdWIgb2JqZWN0cyBpcyBkZXByZWNhdGVkIGFuZCB0aGUgY29uc3RydWN0b3Igd2lsbCBiZSByZW1vdmVkIGluIHZlcnNpb24gOCBvZiB0aGUgU0RLLgogICAqCiAgICogSWYgeW91IGFyZSBjdXJyZW50bHkgdXNpbmcgdGhlIEh1YiBmb3IgbXVsdGktY2xpZW50IHVzZSBsaWtlIHNvOgogICAqCiAgICogYGBgCiAgICogLy8gT0xECiAgICogY29uc3QgaHViID0gbmV3IEh1YigpOwogICAqIGh1Yi5iaW5kQ2xpZW50KGNsaWVudCk7CiAgICogbWFrZU1haW4oaHViKQogICAqIGBgYAogICAqCiAgICogaW5zdGVhZCBpbml0aWFsaXplIHRoZSBjbGllbnQgYXMgZm9sbG93czoKICAgKgogICAqIGBgYAogICAqIC8vIE5FVwogICAqIFNlbnRyeS53aXRoSXNvbGF0aW9uU2NvcGUoKCkgPT4gewogICAqICAgIFNlbnRyeS5zZXRDdXJyZW50Q2xpZW50KGNsaWVudCk7CiAgICogICAgY2xpZW50LmluaXQoKTsKICAgKiB9KTsKICAgKiBgYGAKICAgKgogICAqIElmIHlvdSBhcmUgdXNpbmcgdGhlIEh1YiB0byBjYXB0dXJlIGV2ZW50cyBsaWtlIHNvOgogICAqCiAgICogYGBgCiAgICogLy8gT0xECiAgICogY29uc3QgY2xpZW50ID0gbmV3IENsaWVudCgpOwogICAqIGNvbnN0IGh1YiA9IG5ldyBIdWIoY2xpZW50KTsKICAgKiBodWIuY2FwdHVyZUV4Y2VwdGlvbigpCiAgICogYGBgCiAgICoKICAgKiBpbnN0ZWFkIGNhcHR1cmUgaXNvbGF0ZWQgZXZlbnRzIGFzIGZvbGxvd3M6CiAgICoKICAgKiBgYGAKICAgKiAvLyBORVcKICAgKiBjb25zdCBjbGllbnQgPSBuZXcgQ2xpZW50KCk7CiAgICogY29uc3Qgc2NvcGUgPSBuZXcgU2NvcGUoKTsKICAgKiBzY29wZS5zZXRDbGllbnQoY2xpZW50KTsKICAgKiBzY29wZS5jYXB0dXJlRXhjZXB0aW9uKCk7CiAgICogYGBgCiAgICovCiAgIGNvbnN0cnVjdG9yKAogICAgY2xpZW50LAogICAgc2NvcGUsCiAgICBpc29sYXRpb25TY29wZSwKICAgICAgX3ZlcnNpb24gPSBBUElfVkVSU0lPTiwKICApIHt0aGlzLl92ZXJzaW9uID0gX3ZlcnNpb247CiAgICBsZXQgYXNzaWduZWRTY29wZTsKICAgIGlmICghc2NvcGUpIHsKICAgICAgYXNzaWduZWRTY29wZSA9IG5ldyBTY29wZSgpOwogICAgICBhc3NpZ25lZFNjb3BlLnNldENsaWVudChjbGllbnQpOwogICAgfSBlbHNlIHsKICAgICAgYXNzaWduZWRTY29wZSA9IHNjb3BlOwogICAgfQoKICAgIGxldCBhc3NpZ25lZElzb2xhdGlvblNjb3BlOwogICAgaWYgKCFpc29sYXRpb25TY29wZSkgewogICAgICBhc3NpZ25lZElzb2xhdGlvblNjb3BlID0gbmV3IFNjb3BlKCk7CiAgICAgIGFzc2lnbmVkSXNvbGF0aW9uU2NvcGUuc2V0Q2xpZW50KGNsaWVudCk7CiAgICB9IGVsc2UgewogICAgICBhc3NpZ25lZElzb2xhdGlvblNjb3BlID0gaXNvbGF0aW9uU2NvcGU7CiAgICB9CgogICAgdGhpcy5fc3RhY2sgPSBbeyBzY29wZTogYXNzaWduZWRTY29wZSB9XTsKCiAgICBpZiAoY2xpZW50KSB7CiAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBkZXByZWNhdGlvbi9kZXByZWNhdGlvbgogICAgICB0aGlzLmJpbmRDbGllbnQoY2xpZW50KTsKICAgIH0KCiAgICB0aGlzLl9pc29sYXRpb25TY29wZSA9IGFzc2lnbmVkSXNvbGF0aW9uU2NvcGU7CiAgfQoKICAvKioKICAgKiBDaGVja3MgaWYgdGhpcyBodWIncyB2ZXJzaW9uIGlzIG9sZGVyIHRoYW4gdGhlIGdpdmVuIHZlcnNpb24uCiAgICoKICAgKiBAcGFyYW0gdmVyc2lvbiBBIHZlcnNpb24gbnVtYmVyIHRvIGNvbXBhcmUgdG8uCiAgICogQHJldHVybiBUcnVlIGlmIHRoZSBnaXZlbiB2ZXJzaW9uIGlzIG5ld2VyOyBvdGhlcndpc2UgZmFsc2UuCiAgICoKICAgKiBAZGVwcmVjYXRlZCBUaGlzIHdpbGwgYmUgcmVtb3ZlZCBpbiB2OC4KICAgKi8KICAgaXNPbGRlclRoYW4odmVyc2lvbikgewogICAgcmV0dXJuIHRoaXMuX3ZlcnNpb24gPCB2ZXJzaW9uOwogIH0KCiAgLyoqCiAgICogVGhpcyBiaW5kcyB0aGUgZ2l2ZW4gY2xpZW50IHRvIHRoZSBjdXJyZW50IHNjb3BlLgogICAqIEBwYXJhbSBjbGllbnQgQW4gU0RLIGNsaWVudCAoY2xpZW50KSBpbnN0YW5jZS4KICAgKgogICAqIEBkZXByZWNhdGVkIFVzZSBgaW5pdEFuZEJpbmQoKWAgZGlyZWN0bHksIG9yIGBzZXRDdXJyZW50Q2xpZW50KClgIGFuZC9vciBgY2xpZW50LmluaXQoKWAgaW5zdGVhZC4KICAgKi8KICAgYmluZENsaWVudChjbGllbnQpIHsKICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBkZXByZWNhdGlvbi9kZXByZWNhdGlvbgogICAgY29uc3QgdG9wID0gdGhpcy5nZXRTdGFja1RvcCgpOwogICAgdG9wLmNsaWVudCA9IGNsaWVudDsKICAgIHRvcC5zY29wZS5zZXRDbGllbnQoY2xpZW50KTsKICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBkZXByZWNhdGlvbi9kZXByZWNhdGlvbgogICAgaWYgKGNsaWVudCAmJiBjbGllbnQuc2V0dXBJbnRlZ3JhdGlvbnMpIHsKICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGRlcHJlY2F0aW9uL2RlcHJlY2F0aW9uCiAgICAgIGNsaWVudC5zZXR1cEludGVncmF0aW9ucygpOwogICAgfQogIH0KCiAgLyoqCiAgICogQGluaGVyaXREb2MKICAgKgogICAqIEBkZXByZWNhdGVkIFVzZSBgd2l0aFNjb3BlYCBpbnN0ZWFkLgogICAqLwogICBwdXNoU2NvcGUoKSB7CiAgICAvLyBXZSB3YW50IHRvIGNsb25lIHRoZSBjb250ZW50IG9mIHByZXYgc2NvcGUKICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBkZXByZWNhdGlvbi9kZXByZWNhdGlvbgogICAgY29uc3Qgc2NvcGUgPSB0aGlzLmdldFNjb3BlKCkuY2xvbmUoKTsKICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBkZXByZWNhdGlvbi9kZXByZWNhdGlvbgogICAgdGhpcy5nZXRTdGFjaygpLnB1c2goewogICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgZGVwcmVjYXRpb24vZGVwcmVjYXRpb24KICAgICAgY2xpZW50OiB0aGlzLmdldENsaWVudCgpLAogICAgICBzY29wZSwKICAgIH0pOwogICAgcmV0dXJuIHNjb3BlOwogIH0KCiAgLyoqCiAgICogQGluaGVyaXREb2MKICAgKgogICAqIEBkZXByZWNhdGVkIFVzZSBgd2l0aFNjb3BlYCBpbnN0ZWFkLgogICAqLwogICBwb3BTY29wZSgpIHsKICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBkZXByZWNhdGlvbi9kZXByZWNhdGlvbgogICAgaWYgKHRoaXMuZ2V0U3RhY2soKS5sZW5ndGggPD0gMSkgcmV0dXJuIGZhbHNlOwogICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGRlcHJlY2F0aW9uL2RlcHJlY2F0aW9uCiAgICByZXR1cm4gISF0aGlzLmdldFN0YWNrKCkucG9wKCk7CiAgfQoKICAvKioKICAgKiBAaW5oZXJpdERvYwogICAqCiAgICogQGRlcHJlY2F0ZWQgVXNlIGBTZW50cnkud2l0aFNjb3BlKClgIGluc3RlYWQuCiAgICovCiAgIHdpdGhTY29wZShjYWxsYmFjaykgewogICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGRlcHJlY2F0aW9uL2RlcHJlY2F0aW9uCiAgICBjb25zdCBzY29wZSA9IHRoaXMucHVzaFNjb3BlKCk7CgogICAgbGV0IG1heWJlUHJvbWlzZVJlc3VsdDsKICAgIHRyeSB7CiAgICAgIG1heWJlUHJvbWlzZVJlc3VsdCA9IGNhbGxiYWNrKHNjb3BlKTsKICAgIH0gY2F0Y2ggKGUpIHsKICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGRlcHJlY2F0aW9uL2RlcHJlY2F0aW9uCiAgICAgIHRoaXMucG9wU2NvcGUoKTsKICAgICAgdGhyb3cgZTsKICAgIH0KCiAgICBpZiAoaXNUaGVuYWJsZShtYXliZVByb21pc2VSZXN1bHQpKSB7CiAgICAgIC8vIEB0cy1leHBlY3QtZXJyb3IgLSBpc1RoZW5hYmxlIHJldHVybnMgdGhlIHdyb25nIHR5cGUKICAgICAgcmV0dXJuIG1heWJlUHJvbWlzZVJlc3VsdC50aGVuKAogICAgICAgIHJlcyA9PiB7CiAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgZGVwcmVjYXRpb24vZGVwcmVjYXRpb24KICAgICAgICAgIHRoaXMucG9wU2NvcGUoKTsKICAgICAgICAgIHJldHVybiByZXM7CiAgICAgICAgfSwKICAgICAgICBlID0+IHsKICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBkZXByZWNhdGlvbi9kZXByZWNhdGlvbgogICAgICAgICAgdGhpcy5wb3BTY29wZSgpOwogICAgICAgICAgdGhyb3cgZTsKICAgICAgICB9LAogICAgICApOwogICAgfQoKICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBkZXByZWNhdGlvbi9kZXByZWNhdGlvbgogICAgdGhpcy5wb3BTY29wZSgpOwogICAgcmV0dXJuIG1heWJlUHJvbWlzZVJlc3VsdDsKICB9CgogIC8qKgogICAqIEBpbmhlcml0RG9jCiAgICoKICAgKiBAZGVwcmVjYXRlZCBVc2UgYFNlbnRyeS5nZXRDbGllbnQoKWAgaW5zdGVhZC4KICAgKi8KICAgZ2V0Q2xpZW50KCkgewogICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGRlcHJlY2F0aW9uL2RlcHJlY2F0aW9uCiAgICByZXR1cm4gdGhpcy5nZXRTdGFja1RvcCgpLmNsaWVudCA7CiAgfQoKICAvKioKICAgKiBSZXR1cm5zIHRoZSBzY29wZSBvZiB0aGUgdG9wIHN0YWNrLgogICAqCiAgICogQGRlcHJlY2F0ZWQgVXNlIGBTZW50cnkuZ2V0Q3VycmVudFNjb3BlKClgIGluc3RlYWQuCiAgICovCiAgIGdldFNjb3BlKCkgewogICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGRlcHJlY2F0aW9uL2RlcHJlY2F0aW9uCiAgICByZXR1cm4gdGhpcy5nZXRTdGFja1RvcCgpLnNjb3BlOwogIH0KCiAgLyoqCiAgICogQGRlcHJlY2F0ZWQgVXNlIGBTZW50cnkuZ2V0SXNvbGF0aW9uU2NvcGUoKWAgaW5zdGVhZC4KICAgKi8KICAgZ2V0SXNvbGF0aW9uU2NvcGUoKSB7CiAgICByZXR1cm4gdGhpcy5faXNvbGF0aW9uU2NvcGU7CiAgfQoKICAvKioKICAgKiBSZXR1cm5zIHRoZSBzY29wZSBzdGFjayBmb3IgZG9tYWlucyBvciB0aGUgcHJvY2Vzcy4KICAgKiBAZGVwcmVjYXRlZCBUaGlzIHdpbGwgYmUgcmVtb3ZlZCBpbiB2OC4KICAgKi8KICAgZ2V0U3RhY2soKSB7CiAgICByZXR1cm4gdGhpcy5fc3RhY2s7CiAgfQoKICAvKioKICAgKiBSZXR1cm5zIHRoZSB0b3Btb3N0IHNjb3BlIGxheWVyIGluIHRoZSBvcmRlciBkb21haW4gPiBsb2NhbCA+IHByb2Nlc3MuCiAgICogQGRlcHJlY2F0ZWQgVGhpcyB3aWxsIGJlIHJlbW92ZWQgaW4gdjguCiAgICovCiAgIGdldFN0YWNrVG9wKCkgewogICAgcmV0dXJuIHRoaXMuX3N0YWNrW3RoaXMuX3N0YWNrLmxlbmd0aCAtIDFdOwogIH0KCiAgLyoqCiAgICogQGluaGVyaXREb2MKICAgKgogICAqIEBkZXByZWNhdGVkIFVzZSBgU2VudHJ5LmNhcHR1cmVFeGNlcHRpb24oKWAgaW5zdGVhZC4KICAgKi8KICAgY2FwdHVyZUV4Y2VwdGlvbihleGNlcHRpb24sIGhpbnQpIHsKICAgIGNvbnN0IGV2ZW50SWQgPSAodGhpcy5fbGFzdEV2ZW50SWQgPSBoaW50ICYmIGhpbnQuZXZlbnRfaWQgPyBoaW50LmV2ZW50X2lkIDogdXVpZDQoKSk7CiAgICBjb25zdCBzeW50aGV0aWNFeGNlcHRpb24gPSBuZXcgRXJyb3IoJ1NlbnRyeSBzeW50aGV0aWNFeGNlcHRpb24nKTsKICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBkZXByZWNhdGlvbi9kZXByZWNhdGlvbgogICAgdGhpcy5nZXRTY29wZSgpLmNhcHR1cmVFeGNlcHRpb24oZXhjZXB0aW9uLCB7CiAgICAgIG9yaWdpbmFsRXhjZXB0aW9uOiBleGNlcHRpb24sCiAgICAgIHN5bnRoZXRpY0V4Y2VwdGlvbiwKICAgICAgLi4uaGludCwKICAgICAgZXZlbnRfaWQ6IGV2ZW50SWQsCiAgICB9KTsKCiAgICByZXR1cm4gZXZlbnRJZDsKICB9CgogIC8qKgogICAqIEBpbmhlcml0RG9jCiAgICoKICAgKiBAZGVwcmVjYXRlZCBVc2UgIGBTZW50cnkuY2FwdHVyZU1lc3NhZ2UoKWAgaW5zdGVhZC4KICAgKi8KICAgY2FwdHVyZU1lc3NhZ2UoCiAgICBtZXNzYWdlLAogICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGRlcHJlY2F0aW9uL2RlcHJlY2F0aW9uCiAgICBsZXZlbCwKICAgIGhpbnQsCiAgKSB7CiAgICBjb25zdCBldmVudElkID0gKHRoaXMuX2xhc3RFdmVudElkID0gaGludCAmJiBoaW50LmV2ZW50X2lkID8gaGludC5ldmVudF9pZCA6IHV1aWQ0KCkpOwogICAgY29uc3Qgc3ludGhldGljRXhjZXB0aW9uID0gbmV3IEVycm9yKG1lc3NhZ2UpOwogICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGRlcHJlY2F0aW9uL2RlcHJlY2F0aW9uCiAgICB0aGlzLmdldFNjb3BlKCkuY2FwdHVyZU1lc3NhZ2UobWVzc2FnZSwgbGV2ZWwsIHsKICAgICAgb3JpZ2luYWxFeGNlcHRpb246IG1lc3NhZ2UsCiAgICAgIHN5bnRoZXRpY0V4Y2VwdGlvbiwKICAgICAgLi4uaGludCwKICAgICAgZXZlbnRfaWQ6IGV2ZW50SWQsCiAgICB9KTsKCiAgICByZXR1cm4gZXZlbnRJZDsKICB9CgogIC8qKgogICAqIEBpbmhlcml0RG9jCiAgICoKICAgKiBAZGVwcmVjYXRlZCBVc2UgYFNlbnRyeS5jYXB0dXJlRXZlbnQoKWAgaW5zdGVhZC4KICAgKi8KICAgY2FwdHVyZUV2ZW50KGV2ZW50LCBoaW50KSB7CiAgICBjb25zdCBldmVudElkID0gaGludCAmJiBoaW50LmV2ZW50X2lkID8gaGludC5ldmVudF9pZCA6IHV1aWQ0KCk7CiAgICBpZiAoIWV2ZW50LnR5cGUpIHsKICAgICAgdGhpcy5fbGFzdEV2ZW50SWQgPSBldmVudElkOwogICAgfQogICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGRlcHJlY2F0aW9uL2RlcHJlY2F0aW9uCiAgICB0aGlzLmdldFNjb3BlKCkuY2FwdHVyZUV2ZW50KGV2ZW50LCB7IC4uLmhpbnQsIGV2ZW50X2lkOiBldmVudElkIH0pOwogICAgcmV0dXJuIGV2ZW50SWQ7CiAgfQoKICAvKioKICAgKiBAaW5oZXJpdERvYwogICAqCiAgICogQGRlcHJlY2F0ZWQgVGhpcyB3aWxsIGJlIHJlbW92ZWQgaW4gdjguCiAgICovCiAgIGxhc3RFdmVudElkKCkgewogICAgcmV0dXJuIHRoaXMuX2xhc3RFdmVudElkOwogIH0KCiAgLyoqCiAgICogQGluaGVyaXREb2MKICAgKgogICAqIEBkZXByZWNhdGVkIFVzZSBgU2VudHJ5LmFkZEJyZWFkY3J1bWIoKWAgaW5zdGVhZC4KICAgKi8KICAgYWRkQnJlYWRjcnVtYihicmVhZGNydW1iLCBoaW50KSB7CiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgZGVwcmVjYXRpb24vZGVwcmVjYXRpb24KICAgIGNvbnN0IHsgc2NvcGUsIGNsaWVudCB9ID0gdGhpcy5nZXRTdGFja1RvcCgpOwoKICAgIGlmICghY2xpZW50KSByZXR1cm47CgogICAgY29uc3QgeyBiZWZvcmVCcmVhZGNydW1iID0gbnVsbCwgbWF4QnJlYWRjcnVtYnMgPSBERUZBVUxUX0JSRUFEQ1JVTUJTIH0gPQogICAgICAoY2xpZW50LmdldE9wdGlvbnMgJiYgY2xpZW50LmdldE9wdGlvbnMoKSkgfHwge307CgogICAgaWYgKG1heEJyZWFkY3J1bWJzIDw9IDApIHJldHVybjsKCiAgICBjb25zdCB0aW1lc3RhbXAgPSBkYXRlVGltZXN0YW1wSW5TZWNvbmRzKCk7CiAgICBjb25zdCBtZXJnZWRCcmVhZGNydW1iID0geyB0aW1lc3RhbXAsIC4uLmJyZWFkY3J1bWIgfTsKICAgIGNvbnN0IGZpbmFsQnJlYWRjcnVtYiA9IGJlZm9yZUJyZWFkY3J1bWIKICAgICAgPyAoY29uc29sZVNhbmRib3goKCkgPT4gYmVmb3JlQnJlYWRjcnVtYihtZXJnZWRCcmVhZGNydW1iLCBoaW50KSkgKQogICAgICA6IG1lcmdlZEJyZWFkY3J1bWI7CgogICAgaWYgKGZpbmFsQnJlYWRjcnVtYiA9PT0gbnVsbCkgcmV0dXJuOwoKICAgIGlmIChjbGllbnQuZW1pdCkgewogICAgICBjbGllbnQuZW1pdCgnYmVmb3JlQWRkQnJlYWRjcnVtYicsIGZpbmFsQnJlYWRjcnVtYiwgaGludCk7CiAgICB9CgogICAgLy8gVE9ETyh2OCk6IEkga25vdyB0aGlzIGNvbW1lbnQgZG9lc24ndCBtYWtlIG11Y2ggc2Vuc2UgYmVjYXVzZSB0aGUgaHViIHdpbGwgYmUgZGVwcmVjYXRlZCBidXQgSSBzdGlsbCB3YW50ZWQgdG8KICAgIC8vIHdyaXRlIGl0IGRvd24uIEluIHRoZW9yeSwgd2Ugd291bGQgaGF2ZSB0byBhZGQgdGhlIGJyZWFkY3J1bWJzIHRvIHRoZSBpc29sYXRpb24gc2NvcGUgaGVyZSwgaG93ZXZlciwgdGhhdCB3b3VsZAogICAgLy8gZHVwbGljYXRlIGFsbCBvZiB0aGUgYnJlYWRjcnVtYnMuIFRoZXJlIHdhcyB0aGUgcG9zc2liaWxpdHkgb2YgYWRkaW5nIGJyZWFkY3J1bWJzIHRvIGJvdGgsIHRoZSBpc29sYXRpb24gc2NvcGUKICAgIC8vIGFuZCB0aGUgbm9ybWFsIHNjb3BlLCBhbmQgZGVkdXBsaWNhdGluZyBpdCBkb3duIHRoZSBsaW5lIGluIHRoZSBldmVudCBwcm9jZXNzaW5nIHBpcGVsaW5lLiBIb3dldmVyLCB0aGF0IHdvdWxkCiAgICAvLyBoYXZlIGJlZW4gdmVyeSBmcmFnaWxlLCBiZWNhdXNlIHRoZSBicmVhZGNydW1iIG9iamVjdHMgd291bGQgaGF2ZSBuZWVkZWQgdG8ga2VlcCB0aGVpciBpZGVudGl0eSBhbGwgdGhyb3VnaG91dAogICAgLy8gdGhlIGV2ZW50IHByb2Nlc3NpbmcgcGlwZWxpbmUuCiAgICAvLyBJbiB0aGUgbmV3IGltcGxlbWVudGF0aW9uLCB0aGUgdG9wIGxldmVsIGBTZW50cnkuYWRkQnJlYWRjcnVtYigpYCBzaG91bGQgT05MWSB3cml0ZSB0byB0aGUgaXNvbGF0aW9uIHNjb3BlLgoKICAgIHNjb3BlLmFkZEJyZWFkY3J1bWIoZmluYWxCcmVhZGNydW1iLCBtYXhCcmVhZGNydW1icyk7CiAgfQoKICAvKioKICAgKiBAaW5oZXJpdERvYwogICAqIEBkZXByZWNhdGVkIFVzZSBgU2VudHJ5LnNldFVzZXIoKWAgaW5zdGVhZC4KICAgKi8KICAgc2V0VXNlcih1c2VyKSB7CiAgICAvLyBUT0RPKHY4KTogVGhlIHRvcCBsZXZlbCBgU2VudHJ5LnNldFVzZXIoKWAgZnVuY3Rpb24gc2hvdWxkIHdyaXRlIE9OTFkgdG8gdGhlIGlzb2xhdGlvbiBzY29wZS4KICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBkZXByZWNhdGlvbi9kZXByZWNhdGlvbgogICAgdGhpcy5nZXRTY29wZSgpLnNldFVzZXIodXNlcik7CiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgZGVwcmVjYXRpb24vZGVwcmVjYXRpb24KICAgIHRoaXMuZ2V0SXNvbGF0aW9uU2NvcGUoKS5zZXRVc2VyKHVzZXIpOwogIH0KCiAgLyoqCiAgICogQGluaGVyaXREb2MKICAgKiBAZGVwcmVjYXRlZCBVc2UgYFNlbnRyeS5zZXRUYWdzKClgIGluc3RlYWQuCiAgICovCiAgIHNldFRhZ3ModGFncykgewogICAgLy8gVE9ETyh2OCk6IFRoZSB0b3AgbGV2ZWwgYFNlbnRyeS5zZXRUYWdzKClgIGZ1bmN0aW9uIHNob3VsZCB3cml0ZSBPTkxZIHRvIHRoZSBpc29sYXRpb24gc2NvcGUuCiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgZGVwcmVjYXRpb24vZGVwcmVjYXRpb24KICAgIHRoaXMuZ2V0U2NvcGUoKS5zZXRUYWdzKHRhZ3MpOwogICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGRlcHJlY2F0aW9uL2RlcHJlY2F0aW9uCiAgICB0aGlzLmdldElzb2xhdGlvblNjb3BlKCkuc2V0VGFncyh0YWdzKTsKICB9CgogIC8qKgogICAqIEBpbmhlcml0RG9jCiAgICogQGRlcHJlY2F0ZWQgVXNlIGBTZW50cnkuc2V0RXh0cmFzKClgIGluc3RlYWQuCiAgICovCiAgIHNldEV4dHJhcyhleHRyYXMpIHsKICAgIC8vIFRPRE8odjgpOiBUaGUgdG9wIGxldmVsIGBTZW50cnkuc2V0RXh0cmFzKClgIGZ1bmN0aW9uIHNob3VsZCB3cml0ZSBPTkxZIHRvIHRoZSBpc29sYXRpb24gc2NvcGUuCiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgZGVwcmVjYXRpb24vZGVwcmVjYXRpb24KICAgIHRoaXMuZ2V0U2NvcGUoKS5zZXRFeHRyYXMoZXh0cmFzKTsKICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBkZXByZWNhdGlvbi9kZXByZWNhdGlvbgogICAgdGhpcy5nZXRJc29sYXRpb25TY29wZSgpLnNldEV4dHJhcyhleHRyYXMpOwogIH0KCiAgLyoqCiAgICogQGluaGVyaXREb2MKICAgKiBAZGVwcmVjYXRlZCBVc2UgYFNlbnRyeS5zZXRUYWcoKWAgaW5zdGVhZC4KICAgKi8KICAgc2V0VGFnKGtleSwgdmFsdWUpIHsKICAgIC8vIFRPRE8odjgpOiBUaGUgdG9wIGxldmVsIGBTZW50cnkuc2V0VGFnKClgIGZ1bmN0aW9uIHNob3VsZCB3cml0ZSBPTkxZIHRvIHRoZSBpc29sYXRpb24gc2NvcGUuCiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgZGVwcmVjYXRpb24vZGVwcmVjYXRpb24KICAgIHRoaXMuZ2V0U2NvcGUoKS5zZXRUYWcoa2V5LCB2YWx1ZSk7CiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgZGVwcmVjYXRpb24vZGVwcmVjYXRpb24KICAgIHRoaXMuZ2V0SXNvbGF0aW9uU2NvcGUoKS5zZXRUYWcoa2V5LCB2YWx1ZSk7CiAgfQoKICAvKioKICAgKiBAaW5oZXJpdERvYwogICAqIEBkZXByZWNhdGVkIFVzZSBgU2VudHJ5LnNldEV4dHJhKClgIGluc3RlYWQuCiAgICovCiAgIHNldEV4dHJhKGtleSwgZXh0cmEpIHsKICAgIC8vIFRPRE8odjgpOiBUaGUgdG9wIGxldmVsIGBTZW50cnkuc2V0RXh0cmEoKWAgZnVuY3Rpb24gc2hvdWxkIHdyaXRlIE9OTFkgdG8gdGhlIGlzb2xhdGlvbiBzY29wZS4KICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBkZXByZWNhdGlvbi9kZXByZWNhdGlvbgogICAgdGhpcy5nZXRTY29wZSgpLnNldEV4dHJhKGtleSwgZXh0cmEpOwogICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGRlcHJlY2F0aW9uL2RlcHJlY2F0aW9uCiAgICB0aGlzLmdldElzb2xhdGlvblNjb3BlKCkuc2V0RXh0cmEoa2V5LCBleHRyYSk7CiAgfQoKICAvKioKICAgKiBAaW5oZXJpdERvYwogICAqIEBkZXByZWNhdGVkIFVzZSBgU2VudHJ5LnNldENvbnRleHQoKWAgaW5zdGVhZC4KICAgKi8KICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueQogICBzZXRDb250ZXh0KG5hbWUsIGNvbnRleHQpIHsKICAgIC8vIFRPRE8odjgpOiBUaGUgdG9wIGxldmVsIGBTZW50cnkuc2V0Q29udGV4dCgpYCBmdW5jdGlvbiBzaG91bGQgd3JpdGUgT05MWSB0byB0aGUgaXNvbGF0aW9uIHNjb3BlLgogICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGRlcHJlY2F0aW9uL2RlcHJlY2F0aW9uCiAgICB0aGlzLmdldFNjb3BlKCkuc2V0Q29udGV4dChuYW1lLCBjb250ZXh0KTsKICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBkZXByZWNhdGlvbi9kZXByZWNhdGlvbgogICAgdGhpcy5nZXRJc29sYXRpb25TY29wZSgpLnNldENvbnRleHQobmFtZSwgY29udGV4dCk7CiAgfQoKICAvKioKICAgKiBAaW5oZXJpdERvYwogICAqCiAgICogQGRlcHJlY2F0ZWQgVXNlIGBnZXRTY29wZSgpYCBkaXJlY3RseS4KICAgKi8KICAgY29uZmlndXJlU2NvcGUoY2FsbGJhY2spIHsKICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBkZXByZWNhdGlvbi9kZXByZWNhdGlvbgogICAgY29uc3QgeyBzY29wZSwgY2xpZW50IH0gPSB0aGlzLmdldFN0YWNrVG9wKCk7CiAgICBpZiAoY2xpZW50KSB7CiAgICAgIGNhbGxiYWNrKHNjb3BlKTsKICAgIH0KICB9CgogIC8qKgogICAqIEBpbmhlcml0RG9jCiAgICovCiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGRlcHJlY2F0aW9uL2RlcHJlY2F0aW9uCiAgIHJ1bihjYWxsYmFjaykgewogICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGRlcHJlY2F0aW9uL2RlcHJlY2F0aW9uCiAgICBjb25zdCBvbGRIdWIgPSBtYWtlTWFpbih0aGlzKTsKICAgIHRyeSB7CiAgICAgIGNhbGxiYWNrKHRoaXMpOwogICAgfSBmaW5hbGx5IHsKICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGRlcHJlY2F0aW9uL2RlcHJlY2F0aW9uCiAgICAgIG1ha2VNYWluKG9sZEh1Yik7CiAgICB9CiAgfQoKICAvKioKICAgKiBAaW5oZXJpdERvYwogICAqIEBkZXByZWNhdGVkIFVzZSBgU2VudHJ5LmdldENsaWVudCgpLmdldEludGVncmF0aW9uQnlOYW1lKClgIGluc3RlYWQuCiAgICovCiAgIGdldEludGVncmF0aW9uKGludGVncmF0aW9uKSB7CiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgZGVwcmVjYXRpb24vZGVwcmVjYXRpb24KICAgIGNvbnN0IGNsaWVudCA9IHRoaXMuZ2V0Q2xpZW50KCk7CiAgICBpZiAoIWNsaWVudCkgcmV0dXJuIG51bGw7CiAgICB0cnkgewogICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgZGVwcmVjYXRpb24vZGVwcmVjYXRpb24KICAgICAgcmV0dXJuIGNsaWVudC5nZXRJbnRlZ3JhdGlvbihpbnRlZ3JhdGlvbik7CiAgICB9IGNhdGNoIChfb08pIHsKICAgICAgREVCVUdfQlVJTEQgJiYgbG9nZ2VyLndhcm4oYENhbm5vdCByZXRyaWV2ZSBpbnRlZ3JhdGlvbiAke2ludGVncmF0aW9uLmlkfSBmcm9tIHRoZSBjdXJyZW50IEh1YmApOwogICAgICByZXR1cm4gbnVsbDsKICAgIH0KICB9CgogIC8qKgogICAqIFN0YXJ0cyBhIG5ldyBgVHJhbnNhY3Rpb25gIGFuZCByZXR1cm5zIGl0LiBUaGlzIGlzIHRoZSBlbnRyeSBwb2ludCB0byBtYW51YWwgdHJhY2luZyBpbnN0cnVtZW50YXRpb24uCiAgICoKICAgKiBBIHRyZWUgc3RydWN0dXJlIGNhbiBiZSBidWlsdCBieSBhZGRpbmcgY2hpbGQgc3BhbnMgdG8gdGhlIHRyYW5zYWN0aW9uLCBhbmQgY2hpbGQgc3BhbnMgdG8gb3RoZXIgc3BhbnMuIFRvIHN0YXJ0IGEKICAgKiBuZXcgY2hpbGQgc3BhbiB3aXRoaW4gdGhlIHRyYW5zYWN0aW9uIG9yIGFueSBzcGFuLCBjYWxsIHRoZSByZXNwZWN0aXZlIGAuc3RhcnRDaGlsZCgpYCBtZXRob2QuCiAgICoKICAgKiBFdmVyeSBjaGlsZCBzcGFuIG11c3QgYmUgZmluaXNoZWQgYmVmb3JlIHRoZSB0cmFuc2FjdGlvbiBpcyBmaW5pc2hlZCwgb3RoZXJ3aXNlIHRoZSB1bmZpbmlzaGVkIHNwYW5zIGFyZSBkaXNjYXJkZWQuCiAgICoKICAgKiBUaGUgdHJhbnNhY3Rpb24gbXVzdCBiZSBmaW5pc2hlZCB3aXRoIGEgY2FsbCB0byBpdHMgYC5lbmQoKWAgbWV0aG9kLCBhdCB3aGljaCBwb2ludCB0aGUgdHJhbnNhY3Rpb24gd2l0aCBhbGwgaXRzCiAgICogZmluaXNoZWQgY2hpbGQgc3BhbnMgd2lsbCBiZSBzZW50IHRvIFNlbnRyeS4KICAgKgogICAqIEBwYXJhbSBjb250ZXh0IFByb3BlcnRpZXMgb2YgdGhlIG5ldyBgVHJhbnNhY3Rpb25gLgogICAqIEBwYXJhbSBjdXN0b21TYW1wbGluZ0NvbnRleHQgSW5mb3JtYXRpb24gZ2l2ZW4gdG8gdGhlIHRyYW5zYWN0aW9uIHNhbXBsaW5nIGZ1bmN0aW9uIChhbG9uZyB3aXRoIGNvbnRleHQtZGVwZW5kZW50CiAgICogZGVmYXVsdCB2YWx1ZXMpLiBTZWUge0BsaW5rIE9wdGlvbnMudHJhY2VzU2FtcGxlcn0uCiAgICoKICAgKiBAcmV0dXJucyBUaGUgdHJhbnNhY3Rpb24gd2hpY2ggd2FzIGp1c3Qgc3RhcnRlZAogICAqCiAgICogQGRlcHJlY2F0ZWQgVXNlIGBzdGFydFNwYW4oKWAsIGBzdGFydFNwYW5NYW51YWwoKWAgb3IgYHN0YXJ0SW5hY3RpdmVTcGFuKClgIGluc3RlYWQuCiAgICovCiAgIHN0YXJ0VHJhbnNhY3Rpb24oY29udGV4dCwgY3VzdG9tU2FtcGxpbmdDb250ZXh0KSB7CiAgICBjb25zdCByZXN1bHQgPSB0aGlzLl9jYWxsRXh0ZW5zaW9uTWV0aG9kKCdzdGFydFRyYW5zYWN0aW9uJywgY29udGV4dCwgY3VzdG9tU2FtcGxpbmdDb250ZXh0KTsKCiAgICBpZiAoREVCVUdfQlVJTEQgJiYgIXJlc3VsdCkgewogICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgZGVwcmVjYXRpb24vZGVwcmVjYXRpb24KICAgICAgY29uc3QgY2xpZW50ID0gdGhpcy5nZXRDbGllbnQoKTsKICAgICAgaWYgKCFjbGllbnQpIHsKICAgICAgICBsb2dnZXIud2FybigKICAgICAgICAgICJUcmFjaW5nIGV4dGVuc2lvbiAnc3RhcnRUcmFuc2FjdGlvbicgaXMgbWlzc2luZy4gWW91IHNob3VsZCAnaW5pdCcgdGhlIFNESyBiZWZvcmUgY2FsbGluZyAnc3RhcnRUcmFuc2FjdGlvbiciLAogICAgICAgICk7CiAgICAgIH0gZWxzZSB7CiAgICAgICAgbG9nZ2VyLndhcm4oYFRyYWNpbmcgZXh0ZW5zaW9uICdzdGFydFRyYW5zYWN0aW9uJyBoYXMgbm90IGJlZW4gYWRkZWQuIENhbGwgJ2FkZFRyYWNpbmdFeHRlbnNpb25zJyBiZWZvcmUgY2FsbGluZyAnaW5pdCc6ClNlbnRyeS5hZGRUcmFjaW5nRXh0ZW5zaW9ucygpOwpTZW50cnkuaW5pdCh7Li4ufSk7CmApOwogICAgICB9CiAgICB9CgogICAgcmV0dXJuIHJlc3VsdDsKICB9CgogIC8qKgogICAqIEBpbmhlcml0RG9jCiAgICogQGRlcHJlY2F0ZWQgVXNlIGBzcGFuVG9UcmFjZUhlYWRlcigpYCBpbnN0ZWFkLgogICAqLwogICB0cmFjZUhlYWRlcnMoKSB7CiAgICByZXR1cm4gdGhpcy5fY2FsbEV4dGVuc2lvbk1ldGhvZCgndHJhY2VIZWFkZXJzJyk7CiAgfQoKICAvKioKICAgKiBAaW5oZXJpdERvYwogICAqCiAgICogQGRlcHJlY2F0ZWQgVXNlIHRvcCBsZXZlbCBgY2FwdHVyZVNlc3Npb25gIGluc3RlYWQuCiAgICovCiAgIGNhcHR1cmVTZXNzaW9uKGVuZFNlc3Npb24gPSBmYWxzZSkgewogICAgLy8gYm90aCBzZW5kIHRoZSB1cGRhdGUgYW5kIHB1bGwgdGhlIHNlc3Npb24gZnJvbSB0aGUgc2NvcGUKICAgIGlmIChlbmRTZXNzaW9uKSB7CiAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBkZXByZWNhdGlvbi9kZXByZWNhdGlvbgogICAgICByZXR1cm4gdGhpcy5lbmRTZXNzaW9uKCk7CiAgICB9CgogICAgLy8gb25seSBzZW5kIHRoZSB1cGRhdGUKICAgIHRoaXMuX3NlbmRTZXNzaW9uVXBkYXRlKCk7CiAgfQoKICAvKioKICAgKiBAaW5oZXJpdERvYwogICAqIEBkZXByZWNhdGVkIFVzZSB0b3AgbGV2ZWwgYGVuZFNlc3Npb25gIGluc3RlYWQuCiAgICovCiAgIGVuZFNlc3Npb24oKSB7CiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgZGVwcmVjYXRpb24vZGVwcmVjYXRpb24KICAgIGNvbnN0IGxheWVyID0gdGhpcy5nZXRTdGFja1RvcCgpOwogICAgY29uc3Qgc2NvcGUgPSBsYXllci5zY29wZTsKICAgIGNvbnN0IHNlc3Npb24gPSBzY29wZS5nZXRTZXNzaW9uKCk7CiAgICBpZiAoc2Vzc2lvbikgewogICAgICBjbG9zZVNlc3Npb24oc2Vzc2lvbik7CiAgICB9CiAgICB0aGlzLl9zZW5kU2Vzc2lvblVwZGF0ZSgpOwoKICAgIC8vIHRoZSBzZXNzaW9uIGlzIG92ZXI7IHRha2UgaXQgb2ZmIG9mIHRoZSBzY29wZQogICAgc2NvcGUuc2V0U2Vzc2lvbigpOwogIH0KCiAgLyoqCiAgICogQGluaGVyaXREb2MKICAgKiBAZGVwcmVjYXRlZCBVc2UgdG9wIGxldmVsIGBzdGFydFNlc3Npb25gIGluc3RlYWQuCiAgICovCiAgIHN0YXJ0U2Vzc2lvbihjb250ZXh0KSB7CiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgZGVwcmVjYXRpb24vZGVwcmVjYXRpb24KICAgIGNvbnN0IHsgc2NvcGUsIGNsaWVudCB9ID0gdGhpcy5nZXRTdGFja1RvcCgpOwogICAgY29uc3QgeyByZWxlYXNlLCBlbnZpcm9ubWVudCA9IERFRkFVTFRfRU5WSVJPTk1FTlQgfSA9IChjbGllbnQgJiYgY2xpZW50LmdldE9wdGlvbnMoKSkgfHwge307CgogICAgLy8gV2lsbCBmZXRjaCB1c2VyQWdlbnQgaWYgY2FsbGVkIGZyb20gYnJvd3NlciBzZGsKICAgIGNvbnN0IHsgdXNlckFnZW50IH0gPSBHTE9CQUxfT0JKLm5hdmlnYXRvciB8fCB7fTsKCiAgICBjb25zdCBzZXNzaW9uID0gbWFrZVNlc3Npb24oewogICAgICByZWxlYXNlLAogICAgICBlbnZpcm9ubWVudCwKICAgICAgdXNlcjogc2NvcGUuZ2V0VXNlcigpLAogICAgICAuLi4odXNlckFnZW50ICYmIHsgdXNlckFnZW50IH0pLAogICAgICAuLi5jb250ZXh0LAogICAgfSk7CgogICAgLy8gRW5kIGV4aXN0aW5nIHNlc3Npb24gaWYgdGhlcmUncyBvbmUKICAgIGNvbnN0IGN1cnJlbnRTZXNzaW9uID0gc2NvcGUuZ2V0U2Vzc2lvbiAmJiBzY29wZS5nZXRTZXNzaW9uKCk7CiAgICBpZiAoY3VycmVudFNlc3Npb24gJiYgY3VycmVudFNlc3Npb24uc3RhdHVzID09PSAnb2snKSB7CiAgICAgIHVwZGF0ZVNlc3Npb24oY3VycmVudFNlc3Npb24sIHsgc3RhdHVzOiAnZXhpdGVkJyB9KTsKICAgIH0KICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBkZXByZWNhdGlvbi9kZXByZWNhdGlvbgogICAgdGhpcy5lbmRTZXNzaW9uKCk7CgogICAgLy8gQWZ0ZXJ3YXJkcyB3ZSBzZXQgdGhlIG5ldyBzZXNzaW9uIG9uIHRoZSBzY29wZQogICAgc2NvcGUuc2V0U2Vzc2lvbihzZXNzaW9uKTsKCiAgICByZXR1cm4gc2Vzc2lvbjsKICB9CgogIC8qKgogICAqIFJldHVybnMgaWYgZGVmYXVsdCBQSUkgc2hvdWxkIGJlIHNlbnQgdG8gU2VudHJ5IGFuZCBwcm9wYWdhdGVkIGluIG91cmdvaW5nIHJlcXVlc3RzCiAgICogd2hlbiBUcmFjaW5nIGlzIHVzZWQuCiAgICoKICAgKiBAZGVwcmVjYXRlZCBVc2UgdG9wLWxldmVsIGBnZXRDbGllbnQoKS5nZXRPcHRpb25zKCkuc2VuZERlZmF1bHRQaWlgIGluc3RlYWQuIFRoaXMgZnVuY3Rpb24KICAgKiBvbmx5IHVubmVjZXNzYXJpbHkgaW5jcmVhc2VkIEFQSSBzdXJmYWNlIGJ1dCBvbmx5IHdyYXBwZWQgYWNjZXNzaW5nIHRoZSBvcHRpb24uCiAgICovCiAgIHNob3VsZFNlbmREZWZhdWx0UGlpKCkgewogICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGRlcHJlY2F0aW9uL2RlcHJlY2F0aW9uCiAgICBjb25zdCBjbGllbnQgPSB0aGlzLmdldENsaWVudCgpOwogICAgY29uc3Qgb3B0aW9ucyA9IGNsaWVudCAmJiBjbGllbnQuZ2V0T3B0aW9ucygpOwogICAgcmV0dXJuIEJvb2xlYW4ob3B0aW9ucyAmJiBvcHRpb25zLnNlbmREZWZhdWx0UGlpKTsKICB9CgogIC8qKgogICAqIFNlbmRzIHRoZSBjdXJyZW50IFNlc3Npb24gb24gdGhlIHNjb3BlCiAgICovCiAgIF9zZW5kU2Vzc2lvblVwZGF0ZSgpIHsKICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBkZXByZWNhdGlvbi9kZXByZWNhdGlvbgogICAgY29uc3QgeyBzY29wZSwgY2xpZW50IH0gPSB0aGlzLmdldFN0YWNrVG9wKCk7CgogICAgY29uc3Qgc2Vzc2lvbiA9IHNjb3BlLmdldFNlc3Npb24oKTsKICAgIGlmIChzZXNzaW9uICYmIGNsaWVudCAmJiBjbGllbnQuY2FwdHVyZVNlc3Npb24pIHsKICAgICAgY2xpZW50LmNhcHR1cmVTZXNzaW9uKHNlc3Npb24pOwogICAgfQogIH0KCiAgLyoqCiAgICogQ2FsbHMgZ2xvYmFsIGV4dGVuc2lvbiBtZXRob2QgYW5kIGJpbmRpbmcgY3VycmVudCBpbnN0YW5jZSB0byB0aGUgZnVuY3Rpb24gY2FsbAogICAqLwogIC8vIEB0cy1leHBlY3QtZXJyb3IgRnVuY3Rpb24gbGFja3MgZW5kaW5nIHJldHVybiBzdGF0ZW1lbnQgYW5kIHJldHVybiB0eXBlIGRvZXMgbm90IGluY2x1ZGUgJ3VuZGVmaW5lZCcuIHRzKDIzNjYpCiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnkKICAgX2NhbGxFeHRlbnNpb25NZXRob2QobWV0aG9kLCAuLi5hcmdzKSB7CiAgICBjb25zdCBjYXJyaWVyID0gZ2V0TWFpbkNhcnJpZXIoKTsKICAgIGNvbnN0IHNlbnRyeSA9IGNhcnJpZXIuX19TRU5UUllfXzsKICAgIGlmIChzZW50cnkgJiYgc2VudHJ5LmV4dGVuc2lvbnMgJiYgdHlwZW9mIHNlbnRyeS5leHRlbnNpb25zW21ldGhvZF0gPT09ICdmdW5jdGlvbicpIHsKICAgICAgcmV0dXJuIHNlbnRyeS5leHRlbnNpb25zW21ldGhvZF0uYXBwbHkodGhpcywgYXJncyk7CiAgICB9CiAgICBERUJVR19CVUlMRCAmJiBsb2dnZXIud2FybihgRXh0ZW5zaW9uIG1ldGhvZCAke21ldGhvZH0gY291bGRuJ3QgYmUgZm91bmQsIGRvaW5nIG5vdGhpbmcuYCk7CiAgfQp9CgovKioKICogUmV0dXJucyB0aGUgZ2xvYmFsIHNoaW0gcmVnaXN0cnkuCiAqCiAqIEZJWE1FOiBUaGlzIGZ1bmN0aW9uIGlzIHByb2JsZW1hdGljLCBiZWNhdXNlIGRlc3BpdGUgYWx3YXlzIHJldHVybmluZyBhIHZhbGlkIENhcnJpZXIsCiAqIGl0IGhhcyBhbiBvcHRpb25hbCBgX19TRU5UUllfX2AgcHJvcGVydHksIHdoaWNoIHRoZW4gaW4gdHVybiByZXF1aXJlcyB1cyB0byBhbHdheXMgcGVyZm9ybSBhbiB1bm5lY2Vzc2FyeSBjaGVjawogKiBhdCB0aGUgY2FsbC1zaXRlLiBXZSBhbHdheXMgYWNjZXNzIHRoZSBjYXJyaWVyIHRocm91Z2ggdGhpcyBmdW5jdGlvbiwgc28gd2UgY2FuIGd1YXJhbnRlZSB0aGF0IGBfX1NFTlRSWV9fYCBpcyB0aGVyZS4KICoqLwpmdW5jdGlvbiBnZXRNYWluQ2FycmllcigpIHsKICBHTE9CQUxfT0JKLl9fU0VOVFJZX18gPSBHTE9CQUxfT0JKLl9fU0VOVFJZX18gfHwgewogICAgZXh0ZW5zaW9uczoge30sCiAgICBodWI6IHVuZGVmaW5lZCwKICB9OwogIHJldHVybiBHTE9CQUxfT0JKOwp9CgovKioKICogUmVwbGFjZXMgdGhlIGN1cnJlbnQgbWFpbiBodWIgd2l0aCB0aGUgcGFzc2VkIG9uZSBvbiB0aGUgZ2xvYmFsIG9iamVjdAogKgogKiBAcmV0dXJucyBUaGUgb2xkIHJlcGxhY2VkIGh1YgogKgogKiBAZGVwcmVjYXRlZCBVc2UgYHNldEN1cnJlbnRDbGllbnQoKWAgaW5zdGVhZC4KICovCi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBkZXByZWNhdGlvbi9kZXByZWNhdGlvbgpmdW5jdGlvbiBtYWtlTWFpbihodWIpIHsKICBjb25zdCByZWdpc3RyeSA9IGdldE1haW5DYXJyaWVyKCk7CiAgY29uc3Qgb2xkSHViID0gZ2V0SHViRnJvbUNhcnJpZXIocmVnaXN0cnkpOwogIHNldEh1Yk9uQ2FycmllcihyZWdpc3RyeSwgaHViKTsKICByZXR1cm4gb2xkSHViOwp9CgovKioKICogUmV0dXJucyB0aGUgZGVmYXVsdCBodWIgaW5zdGFuY2UuCiAqCiAqIElmIGEgaHViIGlzIGFscmVhZHkgcmVnaXN0ZXJlZCBpbiB0aGUgZ2xvYmFsIGNhcnJpZXIgYnV0IHRoaXMgbW9kdWxlCiAqIGNvbnRhaW5zIGEgbW9yZSByZWNlbnQgdmVyc2lvbiwgaXQgcmVwbGFjZXMgdGhlIHJlZ2lzdGVyZWQgdmVyc2lvbi4KICogT3RoZXJ3aXNlLCB0aGUgY3VycmVudGx5IHJlZ2lzdGVyZWQgaHViIHdpbGwgYmUgcmV0dXJuZWQuCiAqCiAqIEBkZXByZWNhdGVkIFVzZSB0aGUgcmVzcGVjdGl2ZSByZXBsYWNlbWVudCBtZXRob2QgZGlyZWN0bHkgaW5zdGVhZC4KICovCi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBkZXByZWNhdGlvbi9kZXByZWNhdGlvbgpmdW5jdGlvbiBnZXRDdXJyZW50SHViKCkgewogIC8vIEdldCBtYWluIGNhcnJpZXIgKGdsb2JhbCBmb3IgZXZlcnkgZW52aXJvbm1lbnQpCiAgY29uc3QgcmVnaXN0cnkgPSBnZXRNYWluQ2FycmllcigpOwoKICBpZiAocmVnaXN0cnkuX19TRU5UUllfXyAmJiByZWdpc3RyeS5fX1NFTlRSWV9fLmFjcykgewogICAgY29uc3QgaHViID0gcmVnaXN0cnkuX19TRU5UUllfXy5hY3MuZ2V0Q3VycmVudEh1YigpOwoKICAgIGlmIChodWIpIHsKICAgICAgcmV0dXJuIGh1YjsKICAgIH0KICB9CgogIC8vIFJldHVybiBodWIgdGhhdCBsaXZlcyBvbiBhIGdsb2JhbCBvYmplY3QKICByZXR1cm4gZ2V0R2xvYmFsSHViKHJlZ2lzdHJ5KTsKfQoKLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGRlcHJlY2F0aW9uL2RlcHJlY2F0aW9uCmZ1bmN0aW9uIGdldEdsb2JhbEh1YihyZWdpc3RyeSA9IGdldE1haW5DYXJyaWVyKCkpIHsKICAvLyBJZiB0aGVyZSdzIG5vIGh1Yiwgb3IgaXRzIGFuIG9sZCBBUEksIGFzc2lnbiBhIG5ldyBvbmUKCiAgaWYgKAogICAgIWhhc0h1Yk9uQ2FycmllcihyZWdpc3RyeSkgfHwKICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBkZXByZWNhdGlvbi9kZXByZWNhdGlvbgogICAgZ2V0SHViRnJvbUNhcnJpZXIocmVnaXN0cnkpLmlzT2xkZXJUaGFuKEFQSV9WRVJTSU9OKQogICkgewogICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGRlcHJlY2F0aW9uL2RlcHJlY2F0aW9uCiAgICBzZXRIdWJPbkNhcnJpZXIocmVnaXN0cnksIG5ldyBIdWIoKSk7CiAgfQoKICAvLyBSZXR1cm4gaHViIHRoYXQgbGl2ZXMgb24gYSBnbG9iYWwgb2JqZWN0CiAgcmV0dXJuIGdldEh1YkZyb21DYXJyaWVyKHJlZ2lzdHJ5KTsKfQoKLyoqCiAqIFRoaXMgd2lsbCB0ZWxsIHdoZXRoZXIgYSBjYXJyaWVyIGhhcyBhIGh1YiBvbiBpdCBvciBub3QKICogQHBhcmFtIGNhcnJpZXIgb2JqZWN0CiAqLwpmdW5jdGlvbiBoYXNIdWJPbkNhcnJpZXIoY2FycmllcikgewogIHJldHVybiAhIShjYXJyaWVyICYmIGNhcnJpZXIuX19TRU5UUllfXyAmJiBjYXJyaWVyLl9fU0VOVFJZX18uaHViKTsKfQoKLyoqCiAqIFRoaXMgd2lsbCBjcmVhdGUgYSBuZXcge0BsaW5rIEh1Yn0gYW5kIGFkZCB0byB0aGUgcGFzc2VkIG9iamVjdCBvbgogKiBfX1NFTlRSWV9fLmh1Yi4KICogQHBhcmFtIGNhcnJpZXIgb2JqZWN0CiAqIEBoaWRkZW4KICovCi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBkZXByZWNhdGlvbi9kZXByZWNhdGlvbgpmdW5jdGlvbiBnZXRIdWJGcm9tQ2FycmllcihjYXJyaWVyKSB7CiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGRlcHJlY2F0aW9uL2RlcHJlY2F0aW9uCiAgcmV0dXJuIGdldEdsb2JhbFNpbmdsZXRvbignaHViJywgKCkgPT4gbmV3IEh1YigpLCBjYXJyaWVyKTsKfQoKLyoqCiAqIFRoaXMgd2lsbCBzZXQgcGFzc2VkIHtAbGluayBIdWJ9IG9uIHRoZSBwYXNzZWQgb2JqZWN0J3MgX19TRU5UUllfXy5odWIgYXR0cmlidXRlCiAqIEBwYXJhbSBjYXJyaWVyIG9iamVjdAogKiBAcGFyYW0gaHViIEh1YgogKiBAcmV0dXJucyBBIGJvb2xlYW4gaW5kaWNhdGluZyBzdWNjZXNzIG9yIGZhaWx1cmUKICovCi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBkZXByZWNhdGlvbi9kZXByZWNhdGlvbgpmdW5jdGlvbiBzZXRIdWJPbkNhcnJpZXIoY2FycmllciwgaHViKSB7CiAgaWYgKCFjYXJyaWVyKSByZXR1cm4gZmFsc2U7CiAgY29uc3QgX19TRU5UUllfXyA9IChjYXJyaWVyLl9fU0VOVFJZX18gPSBjYXJyaWVyLl9fU0VOVFJZX18gfHwge30pOwogIF9fU0VOVFJZX18uaHViID0gaHViOwogIHJldHVybiB0cnVlOwp9CgovKioKICogQXBwbHkgU2RrSW5mbyAobmFtZSwgdmVyc2lvbiwgcGFja2FnZXMsIGludGVncmF0aW9ucykgdG8gdGhlIGNvcnJlc3BvbmRpbmcgZXZlbnQga2V5LgogKiBNZXJnZSB3aXRoIGV4aXN0aW5nIGRhdGEgaWYgYW55LgogKiovCmZ1bmN0aW9uIGVuaGFuY2VFdmVudFdpdGhTZGtJbmZvKGV2ZW50LCBzZGtJbmZvKSB7CiAgaWYgKCFzZGtJbmZvKSB7CiAgICByZXR1cm4gZXZlbnQ7CiAgfQogIGV2ZW50LnNkayA9IGV2ZW50LnNkayB8fCB7fTsKICBldmVudC5zZGsubmFtZSA9IGV2ZW50LnNkay5uYW1lIHx8IHNka0luZm8ubmFtZTsKICBldmVudC5zZGsudmVyc2lvbiA9IGV2ZW50LnNkay52ZXJzaW9uIHx8IHNka0luZm8udmVyc2lvbjsKICBldmVudC5zZGsuaW50ZWdyYXRpb25zID0gWy4uLihldmVudC5zZGsuaW50ZWdyYXRpb25zIHx8IFtdKSwgLi4uKHNka0luZm8uaW50ZWdyYXRpb25zIHx8IFtdKV07CiAgZXZlbnQuc2RrLnBhY2thZ2VzID0gWy4uLihldmVudC5zZGsucGFja2FnZXMgfHwgW10pLCAuLi4oc2RrSW5mby5wYWNrYWdlcyB8fCBbXSldOwogIHJldHVybiBldmVudDsKfQoKLyoqIENyZWF0ZXMgYW4gZW52ZWxvcGUgZnJvbSBhIFNlc3Npb24gKi8KZnVuY3Rpb24gY3JlYXRlU2Vzc2lvbkVudmVsb3BlKAogIHNlc3Npb24sCiAgZHNuLAogIG1ldGFkYXRhLAogIHR1bm5lbCwKKSB7CiAgY29uc3Qgc2RrSW5mbyA9IGdldFNka01ldGFkYXRhRm9yRW52ZWxvcGVIZWFkZXIobWV0YWRhdGEpOwogIGNvbnN0IGVudmVsb3BlSGVhZGVycyA9IHsKICAgIHNlbnRfYXQ6IG5ldyBEYXRlKCkudG9JU09TdHJpbmcoKSwKICAgIC4uLihzZGtJbmZvICYmIHsgc2RrOiBzZGtJbmZvIH0pLAogICAgLi4uKCEhdHVubmVsICYmIGRzbiAmJiB7IGRzbjogZHNuVG9TdHJpbmcoZHNuKSB9KSwKICB9OwoKICBjb25zdCBlbnZlbG9wZUl0ZW0gPQogICAgJ2FnZ3JlZ2F0ZXMnIGluIHNlc3Npb24gPyBbeyB0eXBlOiAnc2Vzc2lvbnMnIH0sIHNlc3Npb25dIDogW3sgdHlwZTogJ3Nlc3Npb24nIH0sIHNlc3Npb24udG9KU09OKCldOwoKICByZXR1cm4gY3JlYXRlRW52ZWxvcGUoZW52ZWxvcGVIZWFkZXJzLCBbZW52ZWxvcGVJdGVtXSk7Cn0KCi8qKgogKiBDcmVhdGUgYW4gRW52ZWxvcGUgZnJvbSBhbiBldmVudC4KICovCmZ1bmN0aW9uIGNyZWF0ZUV2ZW50RW52ZWxvcGUoCiAgZXZlbnQsCiAgZHNuLAogIG1ldGFkYXRhLAogIHR1bm5lbCwKKSB7CiAgY29uc3Qgc2RrSW5mbyA9IGdldFNka01ldGFkYXRhRm9yRW52ZWxvcGVIZWFkZXIobWV0YWRhdGEpOwoKICAvKgogICAgTm90ZTogRHVlIHRvIFRTLCBldmVudC50eXBlIG1heSBiZSBgcmVwbGF5X2V2ZW50YCwgdGhlb3JldGljYWxseS4KICAgIEluIHByYWN0aWNlLCB3ZSBuZXZlciBjYWxsIGBjcmVhdGVFdmVudEVudmVsb3BlYCB3aXRoIGByZXBsYXlfZXZlbnRgIHR5cGUsCiAgICBhbmQgd2UnZCBoYXZlIHRvIGFkanV0IGEgbG9vb3Qgb2YgdHlwZXMgdG8gbWFrZSB0aGlzIHdvcmsgcHJvcGVybHkuCiAgICBXZSB3YW50IHRvIGF2b2lkIGNhc3RpbmcgdGhpcyBhcm91bmQsIGFzIHRoYXQgY291bGQgbGVhZCB0byBidWdzIChlLmcuIHdoZW4gd2UgYWRkIGFub3RoZXIgdHlwZSkKICAgIFNvIHRoZSBzYWZlIGNob2ljZSBpcyB0byByZWFsbHkgZ3VhcmQgYWdhaW5zdCB0aGUgcmVwbGF5X2V2ZW50IHR5cGUgaGVyZS4KICAqLwogIGNvbnN0IGV2ZW50VHlwZSA9IGV2ZW50LnR5cGUgJiYgZXZlbnQudHlwZSAhPT0gJ3JlcGxheV9ldmVudCcgPyBldmVudC50eXBlIDogJ2V2ZW50JzsKCiAgZW5oYW5jZUV2ZW50V2l0aFNka0luZm8oZXZlbnQsIG1ldGFkYXRhICYmIG1ldGFkYXRhLnNkayk7CgogIGNvbnN0IGVudmVsb3BlSGVhZGVycyA9IGNyZWF0ZUV2ZW50RW52ZWxvcGVIZWFkZXJzKGV2ZW50LCBzZGtJbmZvLCB0dW5uZWwsIGRzbik7CgogIC8vIFByZXZlbnQgdGhpcyBkYXRhICh3aGljaCwgaWYgaXQgZXhpc3RzLCB3YXMgdXNlZCBpbiBlYXJsaWVyIHN0ZXBzIGluIHRoZSBwcm9jZXNzaW5nIHBpcGVsaW5lKSBmcm9tIGJlaW5nIHNlbnQgdG8KICAvLyBzZW50cnkuIChOb3RlOiBPdXIgdXNlIG9mIHRoaXMgcHJvcGVydHkgY29tZXMgYW5kIGdvZXMgd2l0aCB3aGF0ZXZlciB3ZSBtaWdodCBiZSBkZWJ1Z2dpbmcsIHdoYXRldmVyIGhhY2tzIHdlIG1heQogIC8vIGhhdmUgdGVtcG9yYXJpbHkgYWRkZWQsIGV0Yy4gRXZlbiBpZiB3ZSBkb24ndCBoYXBwZW4gdG8gYmUgdXNpbmcgaXQgYXQgc29tZSBwb2ludCBpbiB0aGUgZnV0dXJlLCBsZXQncyBub3QgZ2V0IHJpZAogIC8vIG9mIHRoaXMgYGRlbGV0ZWAsIGxlc3Qgd2UgbWlzcyBwdXR0aW5nIGl0IGJhY2sgaW4gdGhlIG5leHQgdGltZSB0aGUgcHJvcGVydHkgaXMgaW4gdXNlLikKICBkZWxldGUgZXZlbnQuc2RrUHJvY2Vzc2luZ01ldGFkYXRhOwoKICBjb25zdCBldmVudEl0ZW0gPSBbeyB0eXBlOiBldmVudFR5cGUgfSwgZXZlbnRdOwogIHJldHVybiBjcmVhdGVFbnZlbG9wZShlbnZlbG9wZUhlYWRlcnMsIFtldmVudEl0ZW1dKTsKfQoKY29uc3QgU0VOVFJZX0FQSV9WRVJTSU9OID0gJzcnOwoKLyoqIFJldHVybnMgdGhlIHByZWZpeCB0byBjb25zdHJ1Y3QgU2VudHJ5IGluZ2VzdGlvbiBBUEkgZW5kcG9pbnRzLiAqLwpmdW5jdGlvbiBnZXRCYXNlQXBpRW5kcG9pbnQoZHNuKSB7CiAgY29uc3QgcHJvdG9jb2wgPSBkc24ucHJvdG9jb2wgPyBgJHtkc24ucHJvdG9jb2x9OmAgOiAnJzsKICBjb25zdCBwb3J0ID0gZHNuLnBvcnQgPyBgOiR7ZHNuLnBvcnR9YCA6ICcnOwogIHJldHVybiBgJHtwcm90b2NvbH0vLyR7ZHNuLmhvc3R9JHtwb3J0fSR7ZHNuLnBhdGggPyBgLyR7ZHNuLnBhdGh9YCA6ICcnfS9hcGkvYDsKfQoKLyoqIFJldHVybnMgdGhlIGluZ2VzdCBBUEkgZW5kcG9pbnQgZm9yIHRhcmdldC4gKi8KZnVuY3Rpb24gX2dldEluZ2VzdEVuZHBvaW50KGRzbikgewogIHJldHVybiBgJHtnZXRCYXNlQXBpRW5kcG9pbnQoZHNuKX0ke2Rzbi5wcm9qZWN0SWR9L2VudmVsb3BlL2A7Cn0KCi8qKiBSZXR1cm5zIGEgVVJMLWVuY29kZWQgc3RyaW5nIHdpdGggYXV0aCBjb25maWcgc3VpdGFibGUgZm9yIGEgcXVlcnkgc3RyaW5nLiAqLwpmdW5jdGlvbiBfZW5jb2RlZEF1dGgoZHNuLCBzZGtJbmZvKSB7CiAgcmV0dXJuIHVybEVuY29kZSh7CiAgICAvLyBXZSBzZW5kIG9ubHkgdGhlIG1pbmltdW0gc2V0IG9mIHJlcXVpcmVkIGluZm9ybWF0aW9uLiBTZWUKICAgIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9nZXRzZW50cnkvc2VudHJ5LWphdmFzY3JpcHQvaXNzdWVzLzI1NzIuCiAgICBzZW50cnlfa2V5OiBkc24ucHVibGljS2V5LAogICAgc2VudHJ5X3ZlcnNpb246IFNFTlRSWV9BUElfVkVSU0lPTiwKICAgIC4uLihzZGtJbmZvICYmIHsgc2VudHJ5X2NsaWVudDogYCR7c2RrSW5mby5uYW1lfS8ke3Nka0luZm8udmVyc2lvbn1gIH0pLAogIH0pOwp9CgovKioKICogUmV0dXJucyB0aGUgZW52ZWxvcGUgZW5kcG9pbnQgVVJMIHdpdGggYXV0aCBpbiB0aGUgcXVlcnkgc3RyaW5nLgogKgogKiBTZW5kaW5nIGF1dGggYXMgcGFydCBvZiB0aGUgcXVlcnkgc3RyaW5nIGFuZCBub3QgYXMgY3VzdG9tIEhUVFAgaGVhZGVycyBhdm9pZHMgQ09SUyBwcmVmbGlnaHQgcmVxdWVzdHMuCiAqLwpmdW5jdGlvbiBnZXRFbnZlbG9wZUVuZHBvaW50V2l0aFVybEVuY29kZWRBdXRoKAogIGRzbiwKICAvLyBUT0RPICh2OCk6IFJlbW92ZSBgdHVubmVsT3JPcHRpb25zYCBpbiBmYXZvciBvZiBgb3B0aW9uc2AsIGFuZCB1c2UgdGhlIHN1YnN0aXR1dGUgY29kZSBiZWxvdwogIC8vIG9wdGlvbnM6IENsaWVudE9wdGlvbnMgPSB7fSBhcyBDbGllbnRPcHRpb25zLAogIHR1bm5lbE9yT3B0aW9ucyA9IHt9ICwKKSB7CiAgLy8gVE9ETyAodjgpOiBVc2UgdGhpcyBjb2RlIGluc3RlYWQKICAvLyBjb25zdCB7IHR1bm5lbCwgX21ldGFkYXRhID0ge30gfSA9IG9wdGlvbnM7CiAgLy8gcmV0dXJuIHR1bm5lbCA/IHR1bm5lbCA6IGAke19nZXRJbmdlc3RFbmRwb2ludChkc24pfT8ke19lbmNvZGVkQXV0aChkc24sIF9tZXRhZGF0YS5zZGspfWA7CgogIGNvbnN0IHR1bm5lbCA9IHR5cGVvZiB0dW5uZWxPck9wdGlvbnMgPT09ICdzdHJpbmcnID8gdHVubmVsT3JPcHRpb25zIDogdHVubmVsT3JPcHRpb25zLnR1bm5lbDsKICBjb25zdCBzZGtJbmZvID0KICAgIHR5cGVvZiB0dW5uZWxPck9wdGlvbnMgPT09ICdzdHJpbmcnIHx8ICF0dW5uZWxPck9wdGlvbnMuX21ldGFkYXRhID8gdW5kZWZpbmVkIDogdHVubmVsT3JPcHRpb25zLl9tZXRhZGF0YS5zZGs7CgogIHJldHVybiB0dW5uZWwgPyB0dW5uZWwgOiBgJHtfZ2V0SW5nZXN0RW5kcG9pbnQoZHNuKX0/JHtfZW5jb2RlZEF1dGgoZHNuLCBzZGtJbmZvKX1gOwp9Cgpjb25zdCBERUZBVUxUX1RSQU5TUE9SVF9CVUZGRVJfU0laRSA9IDMwOwoKLyoqCiAqIENyZWF0ZXMgYW4gaW5zdGFuY2Ugb2YgYSBTZW50cnkgYFRyYW5zcG9ydGAKICoKICogQHBhcmFtIG9wdGlvbnMKICogQHBhcmFtIG1ha2VSZXF1ZXN0CiAqLwpmdW5jdGlvbiBjcmVhdGVUcmFuc3BvcnQoCiAgb3B0aW9ucywKICBtYWtlUmVxdWVzdCwKICBidWZmZXIgPSBtYWtlUHJvbWlzZUJ1ZmZlcigKICAgIG9wdGlvbnMuYnVmZmVyU2l6ZSB8fCBERUZBVUxUX1RSQU5TUE9SVF9CVUZGRVJfU0laRSwKICApLAopIHsKICBsZXQgcmF0ZUxpbWl0cyA9IHt9OwogIGNvbnN0IGZsdXNoID0gKHRpbWVvdXQpID0+IGJ1ZmZlci5kcmFpbih0aW1lb3V0KTsKCiAgZnVuY3Rpb24gc2VuZChlbnZlbG9wZSkgewogICAgY29uc3QgZmlsdGVyZWRFbnZlbG9wZUl0ZW1zID0gW107CgogICAgLy8gRHJvcCByYXRlIGxpbWl0ZWQgaXRlbXMgZnJvbSBlbnZlbG9wZQogICAgZm9yRWFjaEVudmVsb3BlSXRlbShlbnZlbG9wZSwgKGl0ZW0sIHR5cGUpID0+IHsKICAgICAgY29uc3QgZGF0YUNhdGVnb3J5ID0gZW52ZWxvcGVJdGVtVHlwZVRvRGF0YUNhdGVnb3J5KHR5cGUpOwogICAgICBpZiAoaXNSYXRlTGltaXRlZChyYXRlTGltaXRzLCBkYXRhQ2F0ZWdvcnkpKSB7CiAgICAgICAgY29uc3QgZXZlbnQgPSBnZXRFdmVudEZvckVudmVsb3BlSXRlbShpdGVtLCB0eXBlKTsKICAgICAgICBvcHRpb25zLnJlY29yZERyb3BwZWRFdmVudCgncmF0ZWxpbWl0X2JhY2tvZmYnLCBkYXRhQ2F0ZWdvcnksIGV2ZW50KTsKICAgICAgfSBlbHNlIHsKICAgICAgICBmaWx0ZXJlZEVudmVsb3BlSXRlbXMucHVzaChpdGVtKTsKICAgICAgfQogICAgfSk7CgogICAgLy8gU2tpcCBzZW5kaW5nIGlmIGVudmVsb3BlIGlzIGVtcHR5IGFmdGVyIGZpbHRlcmluZyBvdXQgcmF0ZSBsaW1pdGVkIGV2ZW50cwogICAgaWYgKGZpbHRlcmVkRW52ZWxvcGVJdGVtcy5sZW5ndGggPT09IDApIHsKICAgICAgcmV0dXJuIHJlc29sdmVkU3luY1Byb21pc2UoKTsKICAgIH0KCiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueQogICAgY29uc3QgZmlsdGVyZWRFbnZlbG9wZSA9IGNyZWF0ZUVudmVsb3BlKGVudmVsb3BlWzBdLCBmaWx0ZXJlZEVudmVsb3BlSXRlbXMgKTsKCiAgICAvLyBDcmVhdGVzIGNsaWVudCByZXBvcnQgZm9yIGVhY2ggaXRlbSBpbiBhbiBlbnZlbG9wZQogICAgY29uc3QgcmVjb3JkRW52ZWxvcGVMb3NzID0gKHJlYXNvbikgPT4gewogICAgICBmb3JFYWNoRW52ZWxvcGVJdGVtKGZpbHRlcmVkRW52ZWxvcGUsIChpdGVtLCB0eXBlKSA9PiB7CiAgICAgICAgY29uc3QgZXZlbnQgPSBnZXRFdmVudEZvckVudmVsb3BlSXRlbShpdGVtLCB0eXBlKTsKICAgICAgICBvcHRpb25zLnJlY29yZERyb3BwZWRFdmVudChyZWFzb24sIGVudmVsb3BlSXRlbVR5cGVUb0RhdGFDYXRlZ29yeSh0eXBlKSwgZXZlbnQpOwogICAgICB9KTsKICAgIH07CgogICAgY29uc3QgcmVxdWVzdFRhc2sgPSAoKSA9PgogICAgICBtYWtlUmVxdWVzdCh7IGJvZHk6IHNlcmlhbGl6ZUVudmVsb3BlKGZpbHRlcmVkRW52ZWxvcGUsIG9wdGlvbnMudGV4dEVuY29kZXIpIH0pLnRoZW4oCiAgICAgICAgcmVzcG9uc2UgPT4gewogICAgICAgICAgLy8gV2UgZG9uJ3Qgd2FudCB0byB0aHJvdyBvbiBOT0sgcmVzcG9uc2VzLCBidXQgd2Ugd2FudCB0byBhdCBsZWFzdCBsb2cgdGhlbQogICAgICAgICAgaWYgKHJlc3BvbnNlLnN0YXR1c0NvZGUgIT09IHVuZGVmaW5lZCAmJiAocmVzcG9uc2Uuc3RhdHVzQ29kZSA8IDIwMCB8fCByZXNwb25zZS5zdGF0dXNDb2RlID49IDMwMCkpIHsKICAgICAgICAgICAgREVCVUdfQlVJTEQgJiYgbG9nZ2VyLndhcm4oYFNlbnRyeSByZXNwb25kZWQgd2l0aCBzdGF0dXMgY29kZSAke3Jlc3BvbnNlLnN0YXR1c0NvZGV9IHRvIHNlbnQgZXZlbnQuYCk7CiAgICAgICAgICB9CgogICAgICAgICAgcmF0ZUxpbWl0cyA9IHVwZGF0ZVJhdGVMaW1pdHMocmF0ZUxpbWl0cywgcmVzcG9uc2UpOwogICAgICAgICAgcmV0dXJuIHJlc3BvbnNlOwogICAgICAgIH0sCiAgICAgICAgZXJyb3IgPT4gewogICAgICAgICAgcmVjb3JkRW52ZWxvcGVMb3NzKCduZXR3b3JrX2Vycm9yJyk7CiAgICAgICAgICB0aHJvdyBlcnJvcjsKICAgICAgICB9LAogICAgICApOwoKICAgIHJldHVybiBidWZmZXIuYWRkKHJlcXVlc3RUYXNrKS50aGVuKAogICAgICByZXN1bHQgPT4gcmVzdWx0LAogICAgICBlcnJvciA9PiB7CiAgICAgICAgaWYgKGVycm9yIGluc3RhbmNlb2YgU2VudHJ5RXJyb3IpIHsKICAgICAgICAgIERFQlVHX0JVSUxEICYmIGxvZ2dlci5lcnJvcignU2tpcHBlZCBzZW5kaW5nIGV2ZW50IGJlY2F1c2UgYnVmZmVyIGlzIGZ1bGwuJyk7CiAgICAgICAgICByZWNvcmRFbnZlbG9wZUxvc3MoJ3F1ZXVlX292ZXJmbG93Jyk7CiAgICAgICAgICByZXR1cm4gcmVzb2x2ZWRTeW5jUHJvbWlzZSgpOwogICAgICAgIH0gZWxzZSB7CiAgICAgICAgICB0aHJvdyBlcnJvcjsKICAgICAgICB9CiAgICAgIH0sCiAgICApOwogIH0KCiAgLy8gV2UgdXNlIHRoaXMgdG8gaWRlbnRpZmlmeSBpZiB0aGUgdHJhbnNwb3J0IGlzIHRoZSBiYXNlIHRyYW5zcG9ydAogIC8vIFRPRE8gKHY4KTogUmVtb3ZlIHRoaXMgYWdhaW4gYXMgd2UnbGwgbm8gbG9uZ2VyIG5lZWQgaXQKICBzZW5kLl9fc2VudHJ5X19iYXNlVHJhbnNwb3J0X18gPSB0cnVlOwoKICByZXR1cm4gewogICAgc2VuZCwKICAgIGZsdXNoLAogIH07Cn0KCmZ1bmN0aW9uIGdldEV2ZW50Rm9yRW52ZWxvcGVJdGVtKGl0ZW0sIHR5cGUpIHsKICBpZiAodHlwZSAhPT0gJ2V2ZW50JyAmJiB0eXBlICE9PSAndHJhbnNhY3Rpb24nKSB7CiAgICByZXR1cm4gdW5kZWZpbmVkOwogIH0KCiAgcmV0dXJuIEFycmF5LmlzQXJyYXkoaXRlbSkgPyAoaXRlbSApWzFdIDogdW5kZWZpbmVkOwp9CgovKiogbm9ybWFsaXplcyBXaW5kb3dzIHBhdGhzICovCmZ1bmN0aW9uIG5vcm1hbGl6ZVdpbmRvd3NQYXRoKHBhdGgpIHsKICByZXR1cm4gcGF0aAogICAgLnJlcGxhY2UoL15bQS1aXTovLCAnJykgLy8gcmVtb3ZlIFdpbmRvd3Mtc3R5bGUgcHJlZml4CiAgICAucmVwbGFjZSgvXFwvZywgJy8nKTsgLy8gcmVwbGFjZSBhbGwgYFxgIGluc3RhbmNlcyB3aXRoIGAvYAp9CgovKiogQ3JlYXRlcyBhIGZ1bmN0aW9uIHRoYXQgZ2V0cyB0aGUgbW9kdWxlIG5hbWUgZnJvbSBhIGZpbGVuYW1lICovCmZ1bmN0aW9uIGNyZWF0ZUdldE1vZHVsZUZyb21GaWxlbmFtZSgKICBiYXNlUGF0aCA9IHByb2Nlc3MuYXJndlsxXSA/IGRpcm5hbWUocHJvY2Vzcy5hcmd2WzFdKSA6IHByb2Nlc3MuY3dkKCksCiAgaXNXaW5kb3dzID0gc2VwID09PSAnXFwnLAopIHsKICBjb25zdCBub3JtYWxpemVkQmFzZSA9IGlzV2luZG93cyA/IG5vcm1hbGl6ZVdpbmRvd3NQYXRoKGJhc2VQYXRoKSA6IGJhc2VQYXRoOwoKICByZXR1cm4gKGZpbGVuYW1lKSA9PiB7CiAgICBpZiAoIWZpbGVuYW1lKSB7CiAgICAgIHJldHVybjsKICAgIH0KCiAgICBjb25zdCBub3JtYWxpemVkRmlsZW5hbWUgPSBpc1dpbmRvd3MgPyBub3JtYWxpemVXaW5kb3dzUGF0aChmaWxlbmFtZSkgOiBmaWxlbmFtZTsKCiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgcHJlZmVyLWNvbnN0CiAgICBsZXQgeyBkaXIsIGJhc2U6IGZpbGUsIGV4dCB9ID0gcG9zaXgucGFyc2Uobm9ybWFsaXplZEZpbGVuYW1lKTsKCiAgICBpZiAoZXh0ID09PSAnLmpzJyB8fCBleHQgPT09ICcubWpzJyB8fCBleHQgPT09ICcuY2pzJykgewogICAgICBmaWxlID0gZmlsZS5zbGljZSgwLCBleHQubGVuZ3RoICogLTEpOwogICAgfQoKICAgIGlmICghZGlyKSB7CiAgICAgIC8vIE5vIGRpcm5hbWUgd2hhdHNvZXZlcgogICAgICBkaXIgPSAnLic7CiAgICB9CgogICAgY29uc3QgbiA9IGRpci5sYXN0SW5kZXhPZignL25vZGVfbW9kdWxlcycpOwogICAgaWYgKG4gPiAtMSkgewogICAgICByZXR1cm4gYCR7ZGlyLnNsaWNlKG4gKyAxNCkucmVwbGFjZSgvXC8vZywgJy4nKX06JHtmaWxlfWA7CiAgICB9CgogICAgLy8gTGV0J3Mgc2VlIGlmIGl0J3MgYSBwYXJ0IG9mIHRoZSBtYWluIG1vZHVsZQogICAgLy8gVG8gYmUgYSBwYXJ0IG9mIG1haW4gbW9kdWxlLCBpdCBoYXMgdG8gc2hhcmUgdGhlIHNhbWUgYmFzZQogICAgaWYgKGRpci5zdGFydHNXaXRoKG5vcm1hbGl6ZWRCYXNlKSkgewogICAgICBsZXQgbW9kdWxlTmFtZSA9IGRpci5zbGljZShub3JtYWxpemVkQmFzZS5sZW5ndGggKyAxKS5yZXBsYWNlKC9cLy9nLCAnLicpOwoKICAgICAgaWYgKG1vZHVsZU5hbWUpIHsKICAgICAgICBtb2R1bGVOYW1lICs9ICc6JzsKICAgICAgfQogICAgICBtb2R1bGVOYW1lICs9IGZpbGU7CgogICAgICByZXR1cm4gbW9kdWxlTmFtZTsKICAgIH0KCiAgICByZXR1cm4gZmlsZTsKICB9Owp9CgpmdW5jdGlvbiBfbnVsbGlzaENvYWxlc2NlJDIobGhzLCByaHNGbikgeyBpZiAobGhzICE9IG51bGwpIHsgcmV0dXJuIGxoczsgfSBlbHNlIHsgcmV0dXJuIHJoc0ZuKCk7IH0gfS8qKgogKiBUaGlzIGNvZGUgd2FzIG9yaWdpbmFsbHkgZm9ya2VkIGZyb20gaHR0cHM6Ly9naXRodWIuY29tL1Rvb1RhbGxOYXRlL3Byb3h5LWFnZW50cy90cmVlL2IxMzMyOTVmZDE2ZjY0NzU1NzhiNmIxNWJkOWI0ZTMzZWNiMGQwYjcKICogV2l0aCB0aGUgZm9sbG93aW5nIGxpY2VuY2U6CiAqCiAqIChUaGUgTUlUIExpY2Vuc2UpCiAqCiAqIENvcHlyaWdodCAoYykgMjAxMyBOYXRoYW4gUmFqbGljaCA8bmF0aGFuQHRvb3RhbGxuYXRlLm5ldD4qCiAqCiAqIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZwogKiBhIGNvcHkgb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGUKICogJ1NvZnR3YXJlJyksIHRvIGRlYWwgaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZwogKiB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0cyB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsCiAqIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0bwogKiBwZXJtaXQgcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpcyBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8KICogdGhlIGZvbGxvd2luZyBjb25kaXRpb25zOioKICoKICogVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUKICogaW5jbHVkZWQgaW4gYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuKgogKgogKiBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgJ0FTIElTJywgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwKICogRVhQUkVTUyBPUiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GCiAqIE1FUkNIQU5UQUJJTElUWSwgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4KICogSU4gTk8gRVZFTlQgU0hBTEwgVEhFIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkKICogQ0xBSU0sIERBTUFHRVMgT1IgT1RIRVIgTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwKICogVE9SVCBPUiBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSwgT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUKICogU09GVFdBUkUgT1IgVEhFIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTiBUSEUgU09GVFdBUkUuCiAqLwoKY29uc3QgSU5URVJOQUwgPSBTeW1ib2woJ0FnZW50QmFzZUludGVybmFsU3RhdGUnKTsKCmNsYXNzIEFnZW50IGV4dGVuZHMgaHR0cC5BZ2VudCB7CgogIC8vIFNldCBieSBgaHR0cC5BZ2VudGAgLSBtaXNzaW5nIGZyb20gYEB0eXBlcy9ub2RlYAoKICBjb25zdHJ1Y3RvcihvcHRzKSB7CiAgICBzdXBlcihvcHRzKTsKICAgIHRoaXNbSU5URVJOQUxdID0ge307CiAgfQoKICAvKioKICAgKiBEZXRlcm1pbmUgd2hldGhlciB0aGlzIGlzIGFuIGBodHRwYCBvciBgaHR0cHNgIHJlcXVlc3QuCiAgICovCiAgaXNTZWN1cmVFbmRwb2ludChvcHRpb25zKSB7CiAgICBpZiAob3B0aW9ucykgewogICAgICAvLyBGaXJzdCBjaGVjayB0aGUgYHNlY3VyZUVuZHBvaW50YCBwcm9wZXJ0eSBleHBsaWNpdGx5LCBzaW5jZSB0aGlzCiAgICAgIC8vIG1lYW5zIHRoYXQgYSBwYXJlbnQgYEFnZW50YCBpcyAicGFzc2luZyB0aHJvdWdoIiB0byB0aGlzIGluc3RhbmNlLgogICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueSwgQHR5cGVzY3JpcHQtZXNsaW50L25vLXVuc2FmZS1tZW1iZXItYWNjZXNzCiAgICAgIGlmICh0eXBlb2YgKG9wdGlvbnMgKS5zZWN1cmVFbmRwb2ludCA9PT0gJ2Jvb2xlYW4nKSB7CiAgICAgICAgcmV0dXJuIG9wdGlvbnMuc2VjdXJlRW5kcG9pbnQ7CiAgICAgIH0KCiAgICAgIC8vIElmIG5vIGV4cGxpY2l0IGBzZWN1cmVgIGVuZHBvaW50LCBjaGVjayBpZiBgcHJvdG9jb2xgIHByb3BlcnR5IGlzCiAgICAgIC8vIHNldC4gVGhpcyB3aWxsIHVzdWFsbHkgYmUgdGhlIGNhc2Ugc2luY2UgdXNpbmcgYSBmdWxsIHN0cmluZyBVUkwKICAgICAgLy8gb3IgYFVSTGAgaW5zdGFuY2Ugc2hvdWxkIGJlIHRoZSBtb3N0IGNvbW1vbiB1c2FnZS4KICAgICAgaWYgKHR5cGVvZiBvcHRpb25zLnByb3RvY29sID09PSAnc3RyaW5nJykgewogICAgICAgIHJldHVybiBvcHRpb25zLnByb3RvY29sID09PSAnaHR0cHM6JzsKICAgICAgfQogICAgfQoKICAgIC8vIEZpbmFsbHksIGlmIG5vIGBwcm90b2NvbGAgcHJvcGVydHkgd2FzIHNldCwgdGhlbiBmYWxsIGJhY2sgdG8KICAgIC8vIGNoZWNraW5nIHRoZSBzdGFjayB0cmFjZSBvZiB0aGUgY3VycmVudCBjYWxsIHN0YWNrLCBhbmQgdHJ5IHRvCiAgICAvLyBkZXRlY3QgdGhlICJodHRwcyIgbW9kdWxlLgogICAgY29uc3QgeyBzdGFjayB9ID0gbmV3IEVycm9yKCk7CiAgICBpZiAodHlwZW9mIHN0YWNrICE9PSAnc3RyaW5nJykgcmV0dXJuIGZhbHNlOwogICAgcmV0dXJuIHN0YWNrLnNwbGl0KCdcbicpLnNvbWUobCA9PiBsLmluZGV4T2YoJyhodHRwcy5qczonKSAhPT0gLTEgfHwgbC5pbmRleE9mKCdub2RlOmh0dHBzOicpICE9PSAtMSk7CiAgfQoKICBjcmVhdGVTb2NrZXQocmVxLCBvcHRpb25zLCBjYikgewogICAgY29uc3QgY29ubmVjdE9wdHMgPSB7CiAgICAgIC4uLm9wdGlvbnMsCiAgICAgIHNlY3VyZUVuZHBvaW50OiB0aGlzLmlzU2VjdXJlRW5kcG9pbnQob3B0aW9ucyksCiAgICB9OwogICAgUHJvbWlzZS5yZXNvbHZlKCkKICAgICAgLnRoZW4oKCkgPT4gdGhpcy5jb25uZWN0KHJlcSwgY29ubmVjdE9wdHMpKQogICAgICAudGhlbihzb2NrZXQgPT4gewogICAgICAgIGlmIChzb2NrZXQgaW5zdGFuY2VvZiBodHRwLkFnZW50KSB7CiAgICAgICAgICAvLyBAdHMtZXhwZWN0LWVycm9yIGBhZGRSZXF1ZXN0KClgIGlzbid0IGRlZmluZWQgaW4gYEB0eXBlcy9ub2RlYAogICAgICAgICAgcmV0dXJuIHNvY2tldC5hZGRSZXF1ZXN0KHJlcSwgY29ubmVjdE9wdHMpOwogICAgICAgIH0KICAgICAgICB0aGlzW0lOVEVSTkFMXS5jdXJyZW50U29ja2V0ID0gc29ja2V0OwogICAgICAgIC8vIEB0cy1leHBlY3QtZXJyb3IgYGNyZWF0ZVNvY2tldCgpYCBpc24ndCBkZWZpbmVkIGluIGBAdHlwZXMvbm9kZWAKICAgICAgICBzdXBlci5jcmVhdGVTb2NrZXQocmVxLCBvcHRpb25zLCBjYik7CiAgICAgIH0sIGNiKTsKICB9CgogIGNyZWF0ZUNvbm5lY3Rpb24oKSB7CiAgICBjb25zdCBzb2NrZXQgPSB0aGlzW0lOVEVSTkFMXS5jdXJyZW50U29ja2V0OwogICAgdGhpc1tJTlRFUk5BTF0uY3VycmVudFNvY2tldCA9IHVuZGVmaW5lZDsKICAgIGlmICghc29ja2V0KSB7CiAgICAgIHRocm93IG5ldyBFcnJvcignTm8gc29ja2V0IHdhcyByZXR1cm5lZCBpbiB0aGUgYGNvbm5lY3QoKWAgZnVuY3Rpb24nKTsKICAgIH0KICAgIHJldHVybiBzb2NrZXQ7CiAgfQoKICBnZXQgZGVmYXVsdFBvcnQoKSB7CiAgICByZXR1cm4gX251bGxpc2hDb2FsZXNjZSQyKHRoaXNbSU5URVJOQUxdLmRlZmF1bHRQb3J0LCAoKSA9PiAoICh0aGlzLnByb3RvY29sID09PSAnaHR0cHM6JyA/IDQ0MyA6IDgwKSkpOwogIH0KCiAgc2V0IGRlZmF1bHRQb3J0KHYpIHsKICAgIGlmICh0aGlzW0lOVEVSTkFMXSkgewogICAgICB0aGlzW0lOVEVSTkFMXS5kZWZhdWx0UG9ydCA9IHY7CiAgICB9CiAgfQoKICBnZXQgcHJvdG9jb2woKSB7CiAgICByZXR1cm4gX251bGxpc2hDb2FsZXNjZSQyKHRoaXNbSU5URVJOQUxdLnByb3RvY29sLCAoKSA9PiAoICh0aGlzLmlzU2VjdXJlRW5kcG9pbnQoKSA/ICdodHRwczonIDogJ2h0dHA6JykpKTsKICB9CgogIHNldCBwcm90b2NvbCh2KSB7CiAgICBpZiAodGhpc1tJTlRFUk5BTF0pIHsKICAgICAgdGhpc1tJTlRFUk5BTF0ucHJvdG9jb2wgPSB2OwogICAgfQogIH0KfQoKZnVuY3Rpb24gZGVidWckMSguLi5hcmdzKSB7CiAgbG9nZ2VyLmxvZygnW2h0dHBzLXByb3h5LWFnZW50OnBhcnNlLXByb3h5LXJlc3BvbnNlXScsIC4uLmFyZ3MpOwp9CgpmdW5jdGlvbiBwYXJzZVByb3h5UmVzcG9uc2Uoc29ja2V0KSB7CiAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHsKICAgIC8vIHdlIG5lZWQgdG8gYnVmZmVyIGFueSBIVFRQIHRyYWZmaWMgdGhhdCBoYXBwZW5zIHdpdGggdGhlIHByb3h5IGJlZm9yZSB3ZSBnZXQKICAgIC8vIHRoZSBDT05ORUNUIHJlc3BvbnNlLCBzbyB0aGF0IGlmIHRoZSByZXNwb25zZSBpcyBhbnl0aGluZyBvdGhlciB0aGFuIGFuICIyMDAiCiAgICAvLyByZXNwb25zZSBjb2RlLCB0aGVuIHdlIGNhbiByZS1wbGF5IHRoZSAiZGF0YSIgZXZlbnRzIG9uIHRoZSBzb2NrZXQgb25jZSB0aGUKICAgIC8vIEhUVFAgcGFyc2VyIGlzIGhvb2tlZCB1cC4uLgogICAgbGV0IGJ1ZmZlcnNMZW5ndGggPSAwOwogICAgY29uc3QgYnVmZmVycyA9IFtdOwoKICAgIGZ1bmN0aW9uIHJlYWQoKSB7CiAgICAgIGNvbnN0IGIgPSBzb2NrZXQucmVhZCgpOwogICAgICBpZiAoYikgb25kYXRhKGIpOwogICAgICBlbHNlIHNvY2tldC5vbmNlKCdyZWFkYWJsZScsIHJlYWQpOwogICAgfQoKICAgIGZ1bmN0aW9uIGNsZWFudXAoKSB7CiAgICAgIHNvY2tldC5yZW1vdmVMaXN0ZW5lcignZW5kJywgb25lbmQpOwogICAgICBzb2NrZXQucmVtb3ZlTGlzdGVuZXIoJ2Vycm9yJywgb25lcnJvcik7CiAgICAgIHNvY2tldC5yZW1vdmVMaXN0ZW5lcigncmVhZGFibGUnLCByZWFkKTsKICAgIH0KCiAgICBmdW5jdGlvbiBvbmVuZCgpIHsKICAgICAgY2xlYW51cCgpOwogICAgICBkZWJ1ZyQxKCdvbmVuZCcpOwogICAgICByZWplY3QobmV3IEVycm9yKCdQcm94eSBjb25uZWN0aW9uIGVuZGVkIGJlZm9yZSByZWNlaXZpbmcgQ09OTkVDVCByZXNwb25zZScpKTsKICAgIH0KCiAgICBmdW5jdGlvbiBvbmVycm9yKGVycikgewogICAgICBjbGVhbnVwKCk7CiAgICAgIGRlYnVnJDEoJ29uZXJyb3IgJW8nLCBlcnIpOwogICAgICByZWplY3QoZXJyKTsKICAgIH0KCiAgICBmdW5jdGlvbiBvbmRhdGEoYikgewogICAgICBidWZmZXJzLnB1c2goYik7CiAgICAgIGJ1ZmZlcnNMZW5ndGggKz0gYi5sZW5ndGg7CgogICAgICBjb25zdCBidWZmZXJlZCA9IEJ1ZmZlci5jb25jYXQoYnVmZmVycywgYnVmZmVyc0xlbmd0aCk7CiAgICAgIGNvbnN0IGVuZE9mSGVhZGVycyA9IGJ1ZmZlcmVkLmluZGV4T2YoJ1xyXG5cclxuJyk7CgogICAgICBpZiAoZW5kT2ZIZWFkZXJzID09PSAtMSkgewogICAgICAgIC8vIGtlZXAgYnVmZmVyaW5nCiAgICAgICAgZGVidWckMSgnaGF2ZSBub3QgcmVjZWl2ZWQgZW5kIG9mIEhUVFAgaGVhZGVycyB5ZXQuLi4nKTsKICAgICAgICByZWFkKCk7CiAgICAgICAgcmV0dXJuOwogICAgICB9CgogICAgICBjb25zdCBoZWFkZXJQYXJ0cyA9IGJ1ZmZlcmVkLnNsaWNlKDAsIGVuZE9mSGVhZGVycykudG9TdHJpbmcoJ2FzY2lpJykuc3BsaXQoJ1xyXG4nKTsKICAgICAgY29uc3QgZmlyc3RMaW5lID0gaGVhZGVyUGFydHMuc2hpZnQoKTsKICAgICAgaWYgKCFmaXJzdExpbmUpIHsKICAgICAgICBzb2NrZXQuZGVzdHJveSgpOwogICAgICAgIHJldHVybiByZWplY3QobmV3IEVycm9yKCdObyBoZWFkZXIgcmVjZWl2ZWQgZnJvbSBwcm94eSBDT05ORUNUIHJlc3BvbnNlJykpOwogICAgICB9CiAgICAgIGNvbnN0IGZpcnN0TGluZVBhcnRzID0gZmlyc3RMaW5lLnNwbGl0KCcgJyk7CiAgICAgIGNvbnN0IHN0YXR1c0NvZGUgPSArZmlyc3RMaW5lUGFydHNbMV07CiAgICAgIGNvbnN0IHN0YXR1c1RleHQgPSBmaXJzdExpbmVQYXJ0cy5zbGljZSgyKS5qb2luKCcgJyk7CiAgICAgIGNvbnN0IGhlYWRlcnMgPSB7fTsKICAgICAgZm9yIChjb25zdCBoZWFkZXIgb2YgaGVhZGVyUGFydHMpIHsKICAgICAgICBpZiAoIWhlYWRlcikgY29udGludWU7CiAgICAgICAgY29uc3QgZmlyc3RDb2xvbiA9IGhlYWRlci5pbmRleE9mKCc6Jyk7CiAgICAgICAgaWYgKGZpcnN0Q29sb24gPT09IC0xKSB7CiAgICAgICAgICBzb2NrZXQuZGVzdHJveSgpOwogICAgICAgICAgcmV0dXJuIHJlamVjdChuZXcgRXJyb3IoYEludmFsaWQgaGVhZGVyIGZyb20gcHJveHkgQ09OTkVDVCByZXNwb25zZTogIiR7aGVhZGVyfSJgKSk7CiAgICAgICAgfQogICAgICAgIGNvbnN0IGtleSA9IGhlYWRlci5zbGljZSgwLCBmaXJzdENvbG9uKS50b0xvd2VyQ2FzZSgpOwogICAgICAgIGNvbnN0IHZhbHVlID0gaGVhZGVyLnNsaWNlKGZpcnN0Q29sb24gKyAxKS50cmltU3RhcnQoKTsKICAgICAgICBjb25zdCBjdXJyZW50ID0gaGVhZGVyc1trZXldOwogICAgICAgIGlmICh0eXBlb2YgY3VycmVudCA9PT0gJ3N0cmluZycpIHsKICAgICAgICAgIGhlYWRlcnNba2V5XSA9IFtjdXJyZW50LCB2YWx1ZV07CiAgICAgICAgfSBlbHNlIGlmIChBcnJheS5pc0FycmF5KGN1cnJlbnQpKSB7CiAgICAgICAgICBjdXJyZW50LnB1c2godmFsdWUpOwogICAgICAgIH0gZWxzZSB7CiAgICAgICAgICBoZWFkZXJzW2tleV0gPSB2YWx1ZTsKICAgICAgICB9CiAgICAgIH0KICAgICAgZGVidWckMSgnZ290IHByb3h5IHNlcnZlciByZXNwb25zZTogJW8gJW8nLCBmaXJzdExpbmUsIGhlYWRlcnMpOwogICAgICBjbGVhbnVwKCk7CiAgICAgIHJlc29sdmUoewogICAgICAgIGNvbm5lY3Q6IHsKICAgICAgICAgIHN0YXR1c0NvZGUsCiAgICAgICAgICBzdGF0dXNUZXh0LAogICAgICAgICAgaGVhZGVycywKICAgICAgICB9LAogICAgICAgIGJ1ZmZlcmVkLAogICAgICB9KTsKICAgIH0KCiAgICBzb2NrZXQub24oJ2Vycm9yJywgb25lcnJvcik7CiAgICBzb2NrZXQub24oJ2VuZCcsIG9uZW5kKTsKCiAgICByZWFkKCk7CiAgfSk7Cn0KCmZ1bmN0aW9uIF9udWxsaXNoQ29hbGVzY2UkMShsaHMsIHJoc0ZuKSB7IGlmIChsaHMgIT0gbnVsbCkgeyByZXR1cm4gbGhzOyB9IGVsc2UgeyByZXR1cm4gcmhzRm4oKTsgfSB9IGZ1bmN0aW9uIF9vcHRpb25hbENoYWluJDEob3BzKSB7IGxldCBsYXN0QWNjZXNzTEhTID0gdW5kZWZpbmVkOyBsZXQgdmFsdWUgPSBvcHNbMF07IGxldCBpID0gMTsgd2hpbGUgKGkgPCBvcHMubGVuZ3RoKSB7IGNvbnN0IG9wID0gb3BzW2ldOyBjb25zdCBmbiA9IG9wc1tpICsgMV07IGkgKz0gMjsgaWYgKChvcCA9PT0gJ29wdGlvbmFsQWNjZXNzJyB8fCBvcCA9PT0gJ29wdGlvbmFsQ2FsbCcpICYmIHZhbHVlID09IG51bGwpIHsgcmV0dXJuIHVuZGVmaW5lZDsgfSBpZiAob3AgPT09ICdhY2Nlc3MnIHx8IG9wID09PSAnb3B0aW9uYWxBY2Nlc3MnKSB7IGxhc3RBY2Nlc3NMSFMgPSB2YWx1ZTsgdmFsdWUgPSBmbih2YWx1ZSk7IH0gZWxzZSBpZiAob3AgPT09ICdjYWxsJyB8fCBvcCA9PT0gJ29wdGlvbmFsQ2FsbCcpIHsgdmFsdWUgPSBmbigoLi4uYXJncykgPT4gdmFsdWUuY2FsbChsYXN0QWNjZXNzTEhTLCAuLi5hcmdzKSk7IGxhc3RBY2Nlc3NMSFMgPSB1bmRlZmluZWQ7IH0gfSByZXR1cm4gdmFsdWU7IH0KCmZ1bmN0aW9uIGRlYnVnKC4uLmFyZ3MpIHsKICBsb2dnZXIubG9nKCdbaHR0cHMtcHJveHktYWdlbnRdJywgLi4uYXJncyk7Cn0KCi8qKgogKiBUaGUgYEh0dHBzUHJveHlBZ2VudGAgaW1wbGVtZW50cyBhbiBIVFRQIEFnZW50IHN1YmNsYXNzIHRoYXQgY29ubmVjdHMgdG8KICogdGhlIHNwZWNpZmllZCAiSFRUUChzKSBwcm94eSBzZXJ2ZXIiIGluIG9yZGVyIHRvIHByb3h5IEhUVFBTIHJlcXVlc3RzLgogKgogKiBPdXRnb2luZyBIVFRQIHJlcXVlc3RzIGFyZSBmaXJzdCB0dW5uZWxlZCB0aHJvdWdoIHRoZSBwcm94eSBzZXJ2ZXIgdXNpbmcgdGhlCiAqIGBDT05ORUNUYCBIVFRQIHJlcXVlc3QgbWV0aG9kIHRvIGVzdGFibGlzaCBhIGNvbm5lY3Rpb24gdG8gdGhlIHByb3h5IHNlcnZlciwKICogYW5kIHRoZW4gdGhlIHByb3h5IHNlcnZlciBjb25uZWN0cyB0byB0aGUgZGVzdGluYXRpb24gdGFyZ2V0IGFuZCBpc3N1ZXMgdGhlCiAqIEhUVFAgcmVxdWVzdCBmcm9tIHRoZSBwcm94eSBzZXJ2ZXIuCiAqCiAqIGBodHRwczpgIHJlcXVlc3RzIGhhdmUgdGhlaXIgc29ja2V0IGNvbm5lY3Rpb24gdXBncmFkZWQgdG8gVExTIG9uY2UKICogdGhlIGNvbm5lY3Rpb24gdG8gdGhlIHByb3h5IHNlcnZlciBoYXMgYmVlbiBlc3RhYmxpc2hlZC4KICovCmNsYXNzIEh0dHBzUHJveHlBZ2VudCBleHRlbmRzIEFnZW50IHsKICBzdGF0aWMgX19pbml0U3RhdGljKCkge3RoaXMucHJvdG9jb2xzID0gWydodHRwJywgJ2h0dHBzJ107IH0KCiAgY29uc3RydWN0b3IocHJveHksIG9wdHMpIHsKICAgIHN1cGVyKG9wdHMpOwogICAgdGhpcy5vcHRpb25zID0ge307CiAgICB0aGlzLnByb3h5ID0gdHlwZW9mIHByb3h5ID09PSAnc3RyaW5nJyA/IG5ldyBVUkwocHJveHkpIDogcHJveHk7CiAgICB0aGlzLnByb3h5SGVhZGVycyA9IF9udWxsaXNoQ29hbGVzY2UkMShfb3B0aW9uYWxDaGFpbiQxKFtvcHRzLCAnb3B0aW9uYWxBY2Nlc3MnLCBfMiA9PiBfMi5oZWFkZXJzXSksICgpID0+ICgge30pKTsKICAgIGRlYnVnKCdDcmVhdGluZyBuZXcgSHR0cHNQcm94eUFnZW50IGluc3RhbmNlOiAlbycsIHRoaXMucHJveHkuaHJlZik7CgogICAgLy8gVHJpbSBvZmYgdGhlIGJyYWNrZXRzIGZyb20gSVB2NiBhZGRyZXNzZXMKICAgIGNvbnN0IGhvc3QgPSAodGhpcy5wcm94eS5ob3N0bmFtZSB8fCB0aGlzLnByb3h5Lmhvc3QpLnJlcGxhY2UoL15cW3xcXSQvZywgJycpOwogICAgY29uc3QgcG9ydCA9IHRoaXMucHJveHkucG9ydCA/IHBhcnNlSW50KHRoaXMucHJveHkucG9ydCwgMTApIDogdGhpcy5wcm94eS5wcm90b2NvbCA9PT0gJ2h0dHBzOicgPyA0NDMgOiA4MDsKICAgIHRoaXMuY29ubmVjdE9wdHMgPSB7CiAgICAgIC8vIEF0dGVtcHQgdG8gbmVnb3RpYXRlIGh0dHAvMS4xIGZvciBwcm94eSBzZXJ2ZXJzIHRoYXQgc3VwcG9ydCBodHRwLzIKICAgICAgQUxQTlByb3RvY29sczogWydodHRwLzEuMSddLAogICAgICAuLi4ob3B0cyA/IG9taXQob3B0cywgJ2hlYWRlcnMnKSA6IG51bGwpLAogICAgICBob3N0LAogICAgICBwb3J0LAogICAgfTsKICB9CgogIC8qKgogICAqIENhbGxlZCB3aGVuIHRoZSBub2RlLWNvcmUgSFRUUCBjbGllbnQgbGlicmFyeSBpcyBjcmVhdGluZyBhCiAgICogbmV3IEhUVFAgcmVxdWVzdC4KICAgKi8KICBhc3luYyBjb25uZWN0KHJlcSwgb3B0cykgewogICAgY29uc3QgeyBwcm94eSB9ID0gdGhpczsKCiAgICBpZiAoIW9wdHMuaG9zdCkgewogICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdObyAiaG9zdCIgcHJvdmlkZWQnKTsKICAgIH0KCiAgICAvLyBDcmVhdGUgYSBzb2NrZXQgY29ubmVjdGlvbiB0byB0aGUgcHJveHkgc2VydmVyLgogICAgbGV0IHNvY2tldDsKICAgIGlmIChwcm94eS5wcm90b2NvbCA9PT0gJ2h0dHBzOicpIHsKICAgICAgZGVidWcoJ0NyZWF0aW5nIGB0bHMuU29ja2V0YDogJW8nLCB0aGlzLmNvbm5lY3RPcHRzKTsKICAgICAgY29uc3Qgc2VydmVybmFtZSA9IHRoaXMuY29ubmVjdE9wdHMuc2VydmVybmFtZSB8fCB0aGlzLmNvbm5lY3RPcHRzLmhvc3Q7CiAgICAgIHNvY2tldCA9IHRscy5jb25uZWN0KHsKICAgICAgICAuLi50aGlzLmNvbm5lY3RPcHRzLAogICAgICAgIHNlcnZlcm5hbWU6IHNlcnZlcm5hbWUgJiYgbmV0LmlzSVAoc2VydmVybmFtZSkgPyB1bmRlZmluZWQgOiBzZXJ2ZXJuYW1lLAogICAgICB9KTsKICAgIH0gZWxzZSB7CiAgICAgIGRlYnVnKCdDcmVhdGluZyBgbmV0LlNvY2tldGA6ICVvJywgdGhpcy5jb25uZWN0T3B0cyk7CiAgICAgIHNvY2tldCA9IG5ldC5jb25uZWN0KHRoaXMuY29ubmVjdE9wdHMpOwogICAgfQoKICAgIGNvbnN0IGhlYWRlcnMgPQogICAgICB0eXBlb2YgdGhpcy5wcm94eUhlYWRlcnMgPT09ICdmdW5jdGlvbicgPyB0aGlzLnByb3h5SGVhZGVycygpIDogeyAuLi50aGlzLnByb3h5SGVhZGVycyB9OwogICAgY29uc3QgaG9zdCA9IG5ldC5pc0lQdjYob3B0cy5ob3N0KSA/IGBbJHtvcHRzLmhvc3R9XWAgOiBvcHRzLmhvc3Q7CiAgICBsZXQgcGF5bG9hZCA9IGBDT05ORUNUICR7aG9zdH06JHtvcHRzLnBvcnR9IEhUVFAvMS4xXHJcbmA7CgogICAgLy8gSW5qZWN0IHRoZSBgUHJveHktQXV0aG9yaXphdGlvbmAgaGVhZGVyIGlmIG5lY2Vzc2FyeS4KICAgIGlmIChwcm94eS51c2VybmFtZSB8fCBwcm94eS5wYXNzd29yZCkgewogICAgICBjb25zdCBhdXRoID0gYCR7ZGVjb2RlVVJJQ29tcG9uZW50KHByb3h5LnVzZXJuYW1lKX06JHtkZWNvZGVVUklDb21wb25lbnQocHJveHkucGFzc3dvcmQpfWA7CiAgICAgIGhlYWRlcnNbJ1Byb3h5LUF1dGhvcml6YXRpb24nXSA9IGBCYXNpYyAke0J1ZmZlci5mcm9tKGF1dGgpLnRvU3RyaW5nKCdiYXNlNjQnKX1gOwogICAgfQoKICAgIGhlYWRlcnMuSG9zdCA9IGAke2hvc3R9OiR7b3B0cy5wb3J0fWA7CgogICAgaWYgKCFoZWFkZXJzWydQcm94eS1Db25uZWN0aW9uJ10pIHsKICAgICAgaGVhZGVyc1snUHJveHktQ29ubmVjdGlvbiddID0gdGhpcy5rZWVwQWxpdmUgPyAnS2VlcC1BbGl2ZScgOiAnY2xvc2UnOwogICAgfQogICAgZm9yIChjb25zdCBuYW1lIG9mIE9iamVjdC5rZXlzKGhlYWRlcnMpKSB7CiAgICAgIHBheWxvYWQgKz0gYCR7bmFtZX06ICR7aGVhZGVyc1tuYW1lXX1cclxuYDsKICAgIH0KCiAgICBjb25zdCBwcm94eVJlc3BvbnNlUHJvbWlzZSA9IHBhcnNlUHJveHlSZXNwb25zZShzb2NrZXQpOwoKICAgIHNvY2tldC53cml0ZShgJHtwYXlsb2FkfVxyXG5gKTsKCiAgICBjb25zdCB7IGNvbm5lY3QsIGJ1ZmZlcmVkIH0gPSBhd2FpdCBwcm94eVJlc3BvbnNlUHJvbWlzZTsKICAgIHJlcS5lbWl0KCdwcm94eUNvbm5lY3QnLCBjb25uZWN0KTsKICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvYmFuLXRzLWNvbW1lbnQKICAgIC8vIEB0cy1pZ25vcmUgTm90IEV2ZW50RW1pdHRlciBpbiBOb2RlIHR5cGVzCiAgICB0aGlzLmVtaXQoJ3Byb3h5Q29ubmVjdCcsIGNvbm5lY3QsIHJlcSk7CgogICAgaWYgKGNvbm5lY3Quc3RhdHVzQ29kZSA9PT0gMjAwKSB7CiAgICAgIHJlcS5vbmNlKCdzb2NrZXQnLCByZXN1bWUpOwoKICAgICAgaWYgKG9wdHMuc2VjdXJlRW5kcG9pbnQpIHsKICAgICAgICAvLyBUaGUgcHJveHkgaXMgY29ubmVjdGluZyB0byBhIFRMUyBzZXJ2ZXIsIHNvIHVwZ3JhZGUKICAgICAgICAvLyB0aGlzIHNvY2tldCBjb25uZWN0aW9uIHRvIGEgVExTIGNvbm5lY3Rpb24uCiAgICAgICAgZGVidWcoJ1VwZ3JhZGluZyBzb2NrZXQgY29ubmVjdGlvbiB0byBUTFMnKTsKICAgICAgICBjb25zdCBzZXJ2ZXJuYW1lID0gb3B0cy5zZXJ2ZXJuYW1lIHx8IG9wdHMuaG9zdDsKICAgICAgICByZXR1cm4gdGxzLmNvbm5lY3QoewogICAgICAgICAgLi4ub21pdChvcHRzLCAnaG9zdCcsICdwYXRoJywgJ3BvcnQnKSwKICAgICAgICAgIHNvY2tldCwKICAgICAgICAgIHNlcnZlcm5hbWU6IG5ldC5pc0lQKHNlcnZlcm5hbWUpID8gdW5kZWZpbmVkIDogc2VydmVybmFtZSwKICAgICAgICB9KTsKICAgICAgfQoKICAgICAgcmV0dXJuIHNvY2tldDsKICAgIH0KCiAgICAvLyBTb21lIG90aGVyIHN0YXR1cyBjb2RlIHRoYXQncyBub3QgMjAwLi4uIG5lZWQgdG8gcmUtcGxheSB0aGUgSFRUUAogICAgLy8gaGVhZGVyICJkYXRhIiBldmVudHMgb250byB0aGUgc29ja2V0IG9uY2UgdGhlIEhUVFAgbWFjaGluZXJ5IGlzCiAgICAvLyBhdHRhY2hlZCBzbyB0aGF0IHRoZSBub2RlIGNvcmUgYGh0dHBgIGNhbiBwYXJzZSBhbmQgaGFuZGxlIHRoZQogICAgLy8gZXJyb3Igc3RhdHVzIGNvZGUuCgogICAgLy8gQ2xvc2UgdGhlIG9yaWdpbmFsIHNvY2tldCwgYW5kIGEgbmV3ICJmYWtlIiBzb2NrZXQgaXMgcmV0dXJuZWQKICAgIC8vIGluc3RlYWQsIHNvIHRoYXQgdGhlIHByb3h5IGRvZXNuJ3QgZ2V0IHRoZSBIVFRQIHJlcXVlc3QKICAgIC8vIHdyaXR0ZW4gdG8gaXQgKHdoaWNoIG1heSBjb250YWluIGBBdXRob3JpemF0aW9uYCBoZWFkZXJzIG9yIG90aGVyCiAgICAvLyBzZW5zaXRpdmUgZGF0YSkuCiAgICAvLwogICAgLy8gU2VlOiBodHRwczovL2hhY2tlcm9uZS5jb20vcmVwb3J0cy81NDE1MDIKICAgIHNvY2tldC5kZXN0cm95KCk7CgogICAgY29uc3QgZmFrZVNvY2tldCA9IG5ldyBuZXQuU29ja2V0KHsgd3JpdGFibGU6IGZhbHNlIH0pOwogICAgZmFrZVNvY2tldC5yZWFkYWJsZSA9IHRydWU7CgogICAgLy8gTmVlZCB0byB3YWl0IGZvciB0aGUgInNvY2tldCIgZXZlbnQgdG8gcmUtcGxheSB0aGUgImRhdGEiIGV2ZW50cy4KICAgIHJlcS5vbmNlKCdzb2NrZXQnLCAocykgPT4gewogICAgICBkZWJ1ZygnUmVwbGF5aW5nIHByb3h5IGJ1ZmZlciBmb3IgZmFpbGVkIHJlcXVlc3QnKTsKICAgICAgLy8gUmVwbGF5IHRoZSAiYnVmZmVyZWQiIEJ1ZmZlciBvbnRvIHRoZSBmYWtlIGBzb2NrZXRgLCBzaW5jZSBhdAogICAgICAvLyB0aGlzIHBvaW50IHRoZSBIVFRQIG1vZHVsZSBtYWNoaW5lcnkgaGFzIGJlZW4gaG9va2VkIHVwIGZvcgogICAgICAvLyB0aGUgdXNlci4KICAgICAgcy5wdXNoKGJ1ZmZlcmVkKTsKICAgICAgcy5wdXNoKG51bGwpOwogICAgfSk7CgogICAgcmV0dXJuIGZha2VTb2NrZXQ7CiAgfQp9IEh0dHBzUHJveHlBZ2VudC5fX2luaXRTdGF0aWMoKTsKCmZ1bmN0aW9uIHJlc3VtZShzb2NrZXQpIHsKICBzb2NrZXQucmVzdW1lKCk7Cn0KCmZ1bmN0aW9uIG9taXQoCiAgb2JqLAogIC4uLmtleXMKKQoKIHsKICBjb25zdCByZXQgPSB7fQoKOwogIGxldCBrZXk7CiAgZm9yIChrZXkgaW4gb2JqKSB7CiAgICBpZiAoIWtleXMuaW5jbHVkZXMoa2V5KSkgewogICAgICByZXRba2V5XSA9IG9ialtrZXldOwogICAgfQogIH0KICByZXR1cm4gcmV0Owp9CgpmdW5jdGlvbiBfbnVsbGlzaENvYWxlc2NlKGxocywgcmhzRm4pIHsgaWYgKGxocyAhPSBudWxsKSB7IHJldHVybiBsaHM7IH0gZWxzZSB7IHJldHVybiByaHNGbigpOyB9IH0KLy8gRXN0aW1hdGVkIG1heGltdW0gc2l6ZSBmb3IgcmVhc29uYWJsZSBzdGFuZGFsb25lIGV2ZW50CmNvbnN0IEdaSVBfVEhSRVNIT0xEID0gMTAyNCAqIDMyOwoKLyoqCiAqIEdldHMgYSBzdHJlYW0gZnJvbSBhIFVpbnQ4QXJyYXkgb3Igc3RyaW5nCiAqIFJlYWRhYmxlLmZyb20gaXMgaWRlYWwgYnV0IHdhcyBhZGRlZCBpbiBub2RlLmpzIHYxMi4zLjAgYW5kIHYxMC4xNy4wCiAqLwpmdW5jdGlvbiBzdHJlYW1Gcm9tQm9keShib2R5KSB7CiAgcmV0dXJuIG5ldyBSZWFkYWJsZSh7CiAgICByZWFkKCkgewogICAgICB0aGlzLnB1c2goYm9keSk7CiAgICAgIHRoaXMucHVzaChudWxsKTsKICAgIH0sCiAgfSk7Cn0KCi8qKgogKiBDcmVhdGVzIGEgVHJhbnNwb3J0IHRoYXQgdXNlcyBuYXRpdmUgdGhlIG5hdGl2ZSAnaHR0cCcgYW5kICdodHRwcycgbW9kdWxlcyB0byBzZW5kIGV2ZW50cyB0byBTZW50cnkuCiAqLwpmdW5jdGlvbiBtYWtlTm9kZVRyYW5zcG9ydChvcHRpb25zKSB7CiAgbGV0IHVybFNlZ21lbnRzOwoKICB0cnkgewogICAgdXJsU2VnbWVudHMgPSBuZXcgVVJMKG9wdGlvbnMudXJsKTsKICB9IGNhdGNoIChlKSB7CiAgICBjb25zb2xlU2FuZGJveCgoKSA9PiB7CiAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1jb25zb2xlCiAgICAgIGNvbnNvbGUud2FybigKICAgICAgICAnW0BzZW50cnkvbm9kZV06IEludmFsaWQgZHNuIG9yIHR1bm5lbCBvcHRpb24sIHdpbGwgbm90IHNlbmQgYW55IGV2ZW50cy4gVGhlIHR1bm5lbCBvcHRpb24gbXVzdCBiZSBhIGZ1bGwgVVJMIHdoZW4gdXNlZC4nLAogICAgICApOwogICAgfSk7CiAgICByZXR1cm4gY3JlYXRlVHJhbnNwb3J0KG9wdGlvbnMsICgpID0+IFByb21pc2UucmVzb2x2ZSh7fSkpOwogIH0KCiAgY29uc3QgaXNIdHRwcyA9IHVybFNlZ21lbnRzLnByb3RvY29sID09PSAnaHR0cHM6JzsKCiAgLy8gUHJveHkgcHJpb3JpdGl6YXRpb246IGh0dHAgPT4gYG9wdGlvbnMucHJveHlgIHwgYHByb2Nlc3MuZW52Lmh0dHBfcHJveHlgCiAgLy8gUHJveHkgcHJpb3JpdGl6YXRpb246IGh0dHBzID0+IGBvcHRpb25zLnByb3h5YCB8IGBwcm9jZXNzLmVudi5odHRwc19wcm94eWAgfCBgcHJvY2Vzcy5lbnYuaHR0cF9wcm94eWAKICBjb25zdCBwcm94eSA9IGFwcGx5Tm9Qcm94eU9wdGlvbigKICAgIHVybFNlZ21lbnRzLAogICAgb3B0aW9ucy5wcm94eSB8fCAoaXNIdHRwcyA/IHByb2Nlc3MuZW52Lmh0dHBzX3Byb3h5IDogdW5kZWZpbmVkKSB8fCBwcm9jZXNzLmVudi5odHRwX3Byb3h5LAogICk7CgogIGNvbnN0IG5hdGl2ZUh0dHBNb2R1bGUgPSBpc0h0dHBzID8gaHR0cHMgOiBodHRwOwogIGNvbnN0IGtlZXBBbGl2ZSA9IG9wdGlvbnMua2VlcEFsaXZlID09PSB1bmRlZmluZWQgPyBmYWxzZSA6IG9wdGlvbnMua2VlcEFsaXZlOwoKICAvLyBUT0RPKHY3KTogRXZhbHVhdGUgaWYgd2UgY2FuIHNldCBrZWVwQWxpdmUgdG8gdHJ1ZS4gVGhpcyB3b3VsZCBpbnZvbHZlIHRlc3RpbmcgZm9yIG1lbW9yeSBsZWFrcyBpbiBvbGRlciBub2RlCiAgLy8gdmVyc2lvbnMoPj0gOCkgYXMgdGhleSBoYWQgbWVtb3J5IGxlYWtzIHdoZW4gdXNpbmcgaXQ6ICMyNTU1CiAgY29uc3QgYWdlbnQgPSBwcm94eQogICAgPyAobmV3IEh0dHBzUHJveHlBZ2VudChwcm94eSkgKQogICAgOiBuZXcgbmF0aXZlSHR0cE1vZHVsZS5BZ2VudCh7IGtlZXBBbGl2ZSwgbWF4U29ja2V0czogMzAsIHRpbWVvdXQ6IDIwMDAgfSk7CgogIGNvbnN0IHJlcXVlc3RFeGVjdXRvciA9IGNyZWF0ZVJlcXVlc3RFeGVjdXRvcihvcHRpb25zLCBfbnVsbGlzaENvYWxlc2NlKG9wdGlvbnMuaHR0cE1vZHVsZSwgKCkgPT4gKCBuYXRpdmVIdHRwTW9kdWxlKSksIGFnZW50KTsKICByZXR1cm4gY3JlYXRlVHJhbnNwb3J0KG9wdGlvbnMsIHJlcXVlc3RFeGVjdXRvcik7Cn0KCi8qKgogKiBIb25vcnMgdGhlIGBub19wcm94eWAgZW52IHZhcmlhYmxlIHdpdGggdGhlIGhpZ2hlc3QgcHJpb3JpdHkgdG8gYWxsb3cgZm9yIGhvc3RzIGV4Y2x1c2lvbi4KICoKICogQHBhcmFtIHRyYW5zcG9ydFVybCBUaGUgVVJMIHRoZSB0cmFuc3BvcnQgaW50ZW5kcyB0byBzZW5kIGV2ZW50cyB0by4KICogQHBhcmFtIHByb3h5IFRoZSBjbGllbnQgY29uZmlndXJlZCBwcm94eS4KICogQHJldHVybnMgQSBwcm94eSB0aGUgdHJhbnNwb3J0IHNob3VsZCB1c2UuCiAqLwpmdW5jdGlvbiBhcHBseU5vUHJveHlPcHRpb24odHJhbnNwb3J0VXJsU2VnbWVudHMsIHByb3h5KSB7CiAgY29uc3QgeyBub19wcm94eSB9ID0gcHJvY2Vzcy5lbnY7CgogIGNvbnN0IHVybElzRXhlbXB0RnJvbVByb3h5ID0KICAgIG5vX3Byb3h5ICYmCiAgICBub19wcm94eQogICAgICAuc3BsaXQoJywnKQogICAgICAuc29tZSgKICAgICAgICBleGVtcHRpb24gPT4gdHJhbnNwb3J0VXJsU2VnbWVudHMuaG9zdC5lbmRzV2l0aChleGVtcHRpb24pIHx8IHRyYW5zcG9ydFVybFNlZ21lbnRzLmhvc3RuYW1lLmVuZHNXaXRoKGV4ZW1wdGlvbiksCiAgICAgICk7CgogIGlmICh1cmxJc0V4ZW1wdEZyb21Qcm94eSkgewogICAgcmV0dXJuIHVuZGVmaW5lZDsKICB9IGVsc2UgewogICAgcmV0dXJuIHByb3h5OwogIH0KfQoKLyoqCiAqIENyZWF0ZXMgYSBSZXF1ZXN0RXhlY3V0b3IgdG8gYmUgdXNlZCB3aXRoIGBjcmVhdGVUcmFuc3BvcnRgLgogKi8KZnVuY3Rpb24gY3JlYXRlUmVxdWVzdEV4ZWN1dG9yKAogIG9wdGlvbnMsCiAgaHR0cE1vZHVsZSwKICBhZ2VudCwKKSB7CiAgY29uc3QgeyBob3N0bmFtZSwgcGF0aG5hbWUsIHBvcnQsIHByb3RvY29sLCBzZWFyY2ggfSA9IG5ldyBVUkwob3B0aW9ucy51cmwpOwogIHJldHVybiBmdW5jdGlvbiBtYWtlUmVxdWVzdChyZXF1ZXN0KSB7CiAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4gewogICAgICBsZXQgYm9keSA9IHN0cmVhbUZyb21Cb2R5KHJlcXVlc3QuYm9keSk7CgogICAgICBjb25zdCBoZWFkZXJzID0geyAuLi5vcHRpb25zLmhlYWRlcnMgfTsKCiAgICAgIGlmIChyZXF1ZXN0LmJvZHkubGVuZ3RoID4gR1pJUF9USFJFU0hPTEQpIHsKICAgICAgICBoZWFkZXJzWydjb250ZW50LWVuY29kaW5nJ10gPSAnZ3ppcCc7CiAgICAgICAgYm9keSA9IGJvZHkucGlwZShjcmVhdGVHemlwKCkpOwogICAgICB9CgogICAgICBjb25zdCByZXEgPSBodHRwTW9kdWxlLnJlcXVlc3QoCiAgICAgICAgewogICAgICAgICAgbWV0aG9kOiAnUE9TVCcsCiAgICAgICAgICBhZ2VudCwKICAgICAgICAgIGhlYWRlcnMsCiAgICAgICAgICBob3N0bmFtZSwKICAgICAgICAgIHBhdGg6IGAke3BhdGhuYW1lfSR7c2VhcmNofWAsCiAgICAgICAgICBwb3J0LAogICAgICAgICAgcHJvdG9jb2wsCiAgICAgICAgICBjYTogb3B0aW9ucy5jYUNlcnRzLAogICAgICAgIH0sCiAgICAgICAgcmVzID0+IHsKICAgICAgICAgIHJlcy5vbignZGF0YScsICgpID0+IHsKICAgICAgICAgICAgLy8gRHJhaW4gc29ja2V0CiAgICAgICAgICB9KTsKCiAgICAgICAgICByZXMub24oJ2VuZCcsICgpID0+IHsKICAgICAgICAgICAgLy8gRHJhaW4gc29ja2V0CiAgICAgICAgICB9KTsKCiAgICAgICAgICByZXMuc2V0RW5jb2RpbmcoJ3V0ZjgnKTsKCiAgICAgICAgICAvLyAiS2V5LXZhbHVlIHBhaXJzIG9mIGhlYWRlciBuYW1lcyBhbmQgdmFsdWVzLiBIZWFkZXIgbmFtZXMgYXJlIGxvd2VyLWNhc2VkLiIKICAgICAgICAgIC8vIGh0dHBzOi8vbm9kZWpzLm9yZy9hcGkvaHR0cC5odG1sI2h0dHBfbWVzc2FnZV9oZWFkZXJzCiAgICAgICAgICBjb25zdCByZXRyeUFmdGVySGVhZGVyID0gX251bGxpc2hDb2FsZXNjZShyZXMuaGVhZGVyc1sncmV0cnktYWZ0ZXInXSwgKCkgPT4gKCBudWxsKSk7CiAgICAgICAgICBjb25zdCByYXRlTGltaXRzSGVhZGVyID0gX251bGxpc2hDb2FsZXNjZShyZXMuaGVhZGVyc1sneC1zZW50cnktcmF0ZS1saW1pdHMnXSwgKCkgPT4gKCBudWxsKSk7CgogICAgICAgICAgcmVzb2x2ZSh7CiAgICAgICAgICAgIHN0YXR1c0NvZGU6IHJlcy5zdGF0dXNDb2RlLAogICAgICAgICAgICBoZWFkZXJzOiB7CiAgICAgICAgICAgICAgJ3JldHJ5LWFmdGVyJzogcmV0cnlBZnRlckhlYWRlciwKICAgICAgICAgICAgICAneC1zZW50cnktcmF0ZS1saW1pdHMnOiBBcnJheS5pc0FycmF5KHJhdGVMaW1pdHNIZWFkZXIpID8gcmF0ZUxpbWl0c0hlYWRlclswXSA6IHJhdGVMaW1pdHNIZWFkZXIsCiAgICAgICAgICAgIH0sCiAgICAgICAgICB9KTsKICAgICAgICB9LAogICAgICApOwoKICAgICAgcmVxLm9uKCdlcnJvcicsIHJlamVjdCk7CiAgICAgIGJvZHkucGlwZShyZXEpOwogICAgfSk7CiAgfTsKfQoKZnVuY3Rpb24gX29wdGlvbmFsQ2hhaW4ob3BzKSB7IGxldCBsYXN0QWNjZXNzTEhTID0gdW5kZWZpbmVkOyBsZXQgdmFsdWUgPSBvcHNbMF07IGxldCBpID0gMTsgd2hpbGUgKGkgPCBvcHMubGVuZ3RoKSB7IGNvbnN0IG9wID0gb3BzW2ldOyBjb25zdCBmbiA9IG9wc1tpICsgMV07IGkgKz0gMjsgaWYgKChvcCA9PT0gJ29wdGlvbmFsQWNjZXNzJyB8fCBvcCA9PT0gJ29wdGlvbmFsQ2FsbCcpICYmIHZhbHVlID09IG51bGwpIHsgcmV0dXJuIHVuZGVmaW5lZDsgfSBpZiAob3AgPT09ICdhY2Nlc3MnIHx8IG9wID09PSAnb3B0aW9uYWxBY2Nlc3MnKSB7IGxhc3RBY2Nlc3NMSFMgPSB2YWx1ZTsgdmFsdWUgPSBmbih2YWx1ZSk7IH0gZWxzZSBpZiAob3AgPT09ICdjYWxsJyB8fCBvcCA9PT0gJ29wdGlvbmFsQ2FsbCcpIHsgdmFsdWUgPSBmbigoLi4uYXJncykgPT4gdmFsdWUuY2FsbChsYXN0QWNjZXNzTEhTLCAuLi5hcmdzKSk7IGxhc3RBY2Nlc3NMSFMgPSB1bmRlZmluZWQ7IH0gfSByZXR1cm4gdmFsdWU7IH0KY29uc3Qgb3B0aW9ucyA9IHdvcmtlckRhdGE7CmxldCBzZXNzaW9uOwpsZXQgaGFzU2VudEFuckV2ZW50ID0gZmFsc2U7CgpmdW5jdGlvbiBsb2cobXNnKSB7CiAgaWYgKG9wdGlvbnMuZGVidWcpIHsKICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1jb25zb2xlCiAgICBjb25zb2xlLmxvZyhgW0FOUiBXb3JrZXJdICR7bXNnfWApOwogIH0KfQoKY29uc3QgdXJsID0gZ2V0RW52ZWxvcGVFbmRwb2ludFdpdGhVcmxFbmNvZGVkQXV0aChvcHRpb25zLmRzbik7CmNvbnN0IHRyYW5zcG9ydCA9IG1ha2VOb2RlVHJhbnNwb3J0KHsKICB1cmwsCiAgcmVjb3JkRHJvcHBlZEV2ZW50OiAoKSA9PiB7CiAgICAvLwogIH0sCn0pOwoKYXN5bmMgZnVuY3Rpb24gc2VuZEFibm9ybWFsU2Vzc2lvbigpIHsKICAvLyBvZiB3ZSBoYXZlIGFuIGV4aXN0aW5nIHNlc3Npb24gcGFzc2VkIGZyb20gdGhlIG1haW4gdGhyZWFkLCBzZW5kIGl0IGFzIGFibm9ybWFsCiAgaWYgKHNlc3Npb24pIHsKICAgIGxvZygnU2VuZGluZyBhYm5vcm1hbCBzZXNzaW9uJyk7CiAgICB1cGRhdGVTZXNzaW9uKHNlc3Npb24sIHsgc3RhdHVzOiAnYWJub3JtYWwnLCBhYm5vcm1hbF9tZWNoYW5pc206ICdhbnJfZm9yZWdyb3VuZCcgfSk7CgogICAgY29uc3QgZW52ZWxvcGUgPSBjcmVhdGVTZXNzaW9uRW52ZWxvcGUoc2Vzc2lvbiwgb3B0aW9ucy5kc24sIG9wdGlvbnMuc2RrTWV0YWRhdGEpOwogICAgLy8gTG9nIHRoZSBlbnZlbG9wZSBzbyB0byBhaWQgaW4gdGVzdGluZwogICAgbG9nKEpTT04uc3RyaW5naWZ5KGVudmVsb3BlKSk7CgogICAgYXdhaXQgdHJhbnNwb3J0LnNlbmQoZW52ZWxvcGUpOwoKICAgIHRyeSB7CiAgICAgIC8vIE5vdGlmeSB0aGUgbWFpbiBwcm9jZXNzIHRoYXQgdGhlIHNlc3Npb24gaGFzIGVuZGVkIHNvIHRoZSBzZXNzaW9uIGNhbiBiZSBjbGVhcmVkIGZyb20gdGhlIHNjb3BlCiAgICAgIF9vcHRpb25hbENoYWluKFtwYXJlbnRQb3J0LCAnb3B0aW9uYWxBY2Nlc3MnLCBfMiA9PiBfMi5wb3N0TWVzc2FnZSwgJ2NhbGwnLCBfMyA9PiBfMygnc2Vzc2lvbi1lbmRlZCcpXSk7CiAgICB9IGNhdGNoIChfKSB7CiAgICAgIC8vIGlnbm9yZQogICAgfQogIH0KfQoKbG9nKCdTdGFydGVkJyk7CgpmdW5jdGlvbiBwcmVwYXJlU3RhY2tGcmFtZXMoc3RhY2tGcmFtZXMpIHsKICBpZiAoIXN0YWNrRnJhbWVzKSB7CiAgICByZXR1cm4gdW5kZWZpbmVkOwogIH0KCiAgLy8gU3RyaXAgU2VudHJ5IGZyYW1lcyBhbmQgcmV2ZXJzZSB0aGUgc3RhY2sgZnJhbWVzIHNvIHRoZXkgYXJlIGluIHRoZSBjb3JyZWN0IG9yZGVyCiAgY29uc3Qgc3RyaXBwZWRGcmFtZXMgPSBzdHJpcFNlbnRyeUZyYW1lc0FuZFJldmVyc2Uoc3RhY2tGcmFtZXMpOwoKICAvLyBJZiB3ZSBoYXZlIGFuIGFwcCByb290IHBhdGgsIHJld3JpdGUgdGhlIGZpbGVuYW1lcyB0byBiZSByZWxhdGl2ZSB0byB0aGUgYXBwIHJvb3QKICBpZiAob3B0aW9ucy5hcHBSb290UGF0aCkgewogICAgZm9yIChjb25zdCBmcmFtZSBvZiBzdHJpcHBlZEZyYW1lcykgewogICAgICBpZiAoIWZyYW1lLmZpbGVuYW1lKSB7CiAgICAgICAgY29udGludWU7CiAgICAgIH0KCiAgICAgIGZyYW1lLmZpbGVuYW1lID0gbm9ybWFsaXplVXJsVG9CYXNlKGZyYW1lLmZpbGVuYW1lLCBvcHRpb25zLmFwcFJvb3RQYXRoKTsKICAgIH0KICB9CgogIHJldHVybiBzdHJpcHBlZEZyYW1lczsKfQoKZnVuY3Rpb24gYXBwbHlTY29wZVRvRXZlbnQoZXZlbnQsIHNjb3BlKSB7CiAgYXBwbHlTY29wZURhdGFUb0V2ZW50KGV2ZW50LCBzY29wZSk7CgogIGlmICghX29wdGlvbmFsQ2hhaW4oW2V2ZW50LCAnYWNjZXNzJywgXzQgPT4gXzQuY29udGV4dHMsICdvcHRpb25hbEFjY2VzcycsIF81ID0+IF81LnRyYWNlXSkpIHsKICAgIGNvbnN0IHsgdHJhY2VJZCwgc3BhbklkLCBwYXJlbnRTcGFuSWQgfSA9IHNjb3BlLnByb3BhZ2F0aW9uQ29udGV4dDsKICAgIGV2ZW50LmNvbnRleHRzID0gewogICAgICB0cmFjZTogewogICAgICAgIHRyYWNlX2lkOiB0cmFjZUlkLAogICAgICAgIHNwYW5faWQ6IHNwYW5JZCwKICAgICAgICBwYXJlbnRfc3Bhbl9pZDogcGFyZW50U3BhbklkLAogICAgICB9LAogICAgICAuLi5ldmVudC5jb250ZXh0cywKICAgIH07CiAgfQp9Cgphc3luYyBmdW5jdGlvbiBzZW5kQW5yRXZlbnQoZnJhbWVzLCBzY29wZSkgewogIGlmIChoYXNTZW50QW5yRXZlbnQpIHsKICAgIHJldHVybjsKICB9CgogIGhhc1NlbnRBbnJFdmVudCA9IHRydWU7CgogIGF3YWl0IHNlbmRBYm5vcm1hbFNlc3Npb24oKTsKCiAgbG9nKCdTZW5kaW5nIGV2ZW50Jyk7CgogIGNvbnN0IGV2ZW50ID0gewogICAgZXZlbnRfaWQ6IHV1aWQ0KCksCiAgICBjb250ZXh0czogb3B0aW9ucy5jb250ZXh0cywKICAgIHJlbGVhc2U6IG9wdGlvbnMucmVsZWFzZSwKICAgIGVudmlyb25tZW50OiBvcHRpb25zLmVudmlyb25tZW50LAogICAgZGlzdDogb3B0aW9ucy5kaXN0LAogICAgcGxhdGZvcm06ICdub2RlJywKICAgIGxldmVsOiAnZXJyb3InLAogICAgZXhjZXB0aW9uOiB7CiAgICAgIHZhbHVlczogWwogICAgICAgIHsKICAgICAgICAgIHR5cGU6ICdBcHBsaWNhdGlvbk5vdFJlc3BvbmRpbmcnLAogICAgICAgICAgdmFsdWU6IGBBcHBsaWNhdGlvbiBOb3QgUmVzcG9uZGluZyBmb3IgYXQgbGVhc3QgJHtvcHRpb25zLmFuclRocmVzaG9sZH0gbXNgLAogICAgICAgICAgc3RhY2t0cmFjZTogeyBmcmFtZXM6IHByZXBhcmVTdGFja0ZyYW1lcyhmcmFtZXMpIH0sCiAgICAgICAgICAvLyBUaGlzIGVuc3VyZXMgdGhlIFVJIGRvZXNuJ3Qgc2F5ICdDcmFzaGVkIGluJyBmb3IgdGhlIHN0YWNrIHRyYWNlCiAgICAgICAgICBtZWNoYW5pc206IHsgdHlwZTogJ0FOUicgfSwKICAgICAgICB9LAogICAgICBdLAogICAgfSwKICAgIHRhZ3M6IG9wdGlvbnMuc3RhdGljVGFncywKICB9OwoKICBpZiAoc2NvcGUpIHsKICAgIGFwcGx5U2NvcGVUb0V2ZW50KGV2ZW50LCBzY29wZSk7CiAgfQoKICBjb25zdCBlbnZlbG9wZSA9IGNyZWF0ZUV2ZW50RW52ZWxvcGUoZXZlbnQsIG9wdGlvbnMuZHNuLCBvcHRpb25zLnNka01ldGFkYXRhKTsKICAvLyBMb2cgdGhlIGVudmVsb3BlIHRvIGFpZCBpbiB0ZXN0aW5nCiAgbG9nKEpTT04uc3RyaW5naWZ5KGVudmVsb3BlKSk7CgogIGF3YWl0IHRyYW5zcG9ydC5zZW5kKGVudmVsb3BlKTsKICBhd2FpdCB0cmFuc3BvcnQuZmx1c2goMjAwMCk7CgogIC8vIERlbGF5IGZvciA1IHNlY29uZHMgc28gdGhhdCBzdGRpbyBjYW4gZmx1c2ggaW4gdGhlIG1haW4gZXZlbnQgbG9vcCBldmVyIHJlc3RhcnRzLgogIC8vIFRoaXMgaXMgbWFpbmx5IGZvciB0aGUgYmVuZWZpdCBvZiBsb2dnaW5nL2RlYnVnZ2luZyBpc3N1ZXMuCiAgc2V0VGltZW91dCgoKSA9PiB7CiAgICBwcm9jZXNzLmV4aXQoMCk7CiAgfSwgNTAwMCk7Cn0KCmxldCBkZWJ1Z2dlclBhdXNlOwoKaWYgKG9wdGlvbnMuY2FwdHVyZVN0YWNrVHJhY2UpIHsKICBsb2coJ0Nvbm5lY3RpbmcgdG8gZGVidWdnZXInKTsKCiAgY29uc3Qgc2Vzc2lvbiA9IG5ldyBTZXNzaW9uKCkgOwogIHNlc3Npb24uY29ubmVjdFRvTWFpblRocmVhZCgpOwoKICBsb2coJ0Nvbm5lY3RlZCB0byBkZWJ1Z2dlcicpOwoKICAvLyBDb2xsZWN0IHNjcmlwdElkIC0+IHVybCBtYXAgc28gd2UgY2FuIGxvb2sgdXAgdGhlIGZpbGVuYW1lcyBsYXRlcgogIGNvbnN0IHNjcmlwdHMgPSBuZXcgTWFwKCk7CgogIHNlc3Npb24ub24oJ0RlYnVnZ2VyLnNjcmlwdFBhcnNlZCcsIGV2ZW50ID0+IHsKICAgIHNjcmlwdHMuc2V0KGV2ZW50LnBhcmFtcy5zY3JpcHRJZCwgZXZlbnQucGFyYW1zLnVybCk7CiAgfSk7CgogIHNlc3Npb24ub24oJ0RlYnVnZ2VyLnBhdXNlZCcsIGV2ZW50ID0+IHsKICAgIGlmIChldmVudC5wYXJhbXMucmVhc29uICE9PSAnb3RoZXInKSB7CiAgICAgIHJldHVybjsKICAgIH0KCiAgICB0cnkgewogICAgICBsb2coJ0RlYnVnZ2VyIHBhdXNlZCcpOwoKICAgICAgLy8gY29weSB0aGUgZnJhbWVzCiAgICAgIGNvbnN0IGNhbGxGcmFtZXMgPSBbLi4uZXZlbnQucGFyYW1zLmNhbGxGcmFtZXNdOwoKICAgICAgY29uc3QgZ2V0TW9kdWxlTmFtZSA9IG9wdGlvbnMuYXBwUm9vdFBhdGggPyBjcmVhdGVHZXRNb2R1bGVGcm9tRmlsZW5hbWUob3B0aW9ucy5hcHBSb290UGF0aCkgOiAoKSA9PiB1bmRlZmluZWQ7CiAgICAgIGNvbnN0IHN0YWNrRnJhbWVzID0gY2FsbEZyYW1lcy5tYXAoZnJhbWUgPT4KICAgICAgICBjYWxsRnJhbWVUb1N0YWNrRnJhbWUoZnJhbWUsIHNjcmlwdHMuZ2V0KGZyYW1lLmxvY2F0aW9uLnNjcmlwdElkKSwgZ2V0TW9kdWxlTmFtZSksCiAgICAgICk7CgogICAgICAvLyBFdmFsdWF0ZSBhIHNjcmlwdCBpbiB0aGUgY3VycmVudGx5IHBhdXNlZCBjb250ZXh0CiAgICAgIHNlc3Npb24ucG9zdCgKICAgICAgICAnUnVudGltZS5ldmFsdWF0ZScsCiAgICAgICAgewogICAgICAgICAgLy8gR3JhYiB0aGUgdHJhY2UgY29udGV4dCBmcm9tIHRoZSBjdXJyZW50IHNjb3BlCiAgICAgICAgICBleHByZXNzaW9uOiAnZ2xvYmFsLl9fU0VOVFJZX0dFVF9TQ09QRVNfXygpOycsCiAgICAgICAgICAvLyBEb24ndCByZS10cmlnZ2VyIHRoZSBkZWJ1Z2dlciBpZiB0aGlzIGNhdXNlcyBhbiBlcnJvcgogICAgICAgICAgc2lsZW50OiB0cnVlLAogICAgICAgICAgLy8gU2VyaWFsaXplIHRoZSByZXN1bHQgdG8ganNvbiBvdGhlcndpc2Ugb25seSBwcmltaXRpdmVzIGFyZSBzdXBwb3J0ZWQKICAgICAgICAgIHJldHVybkJ5VmFsdWU6IHRydWUsCiAgICAgICAgfSwKICAgICAgICAoZXJyLCBwYXJhbSkgPT4gewogICAgICAgICAgaWYgKGVycikgewogICAgICAgICAgICBsb2coYEVycm9yIGV4ZWN1dGluZyBzY3JpcHQ6ICcke2Vyci5tZXNzYWdlfSdgKTsKICAgICAgICAgIH0KCiAgICAgICAgICBjb25zdCBzY29wZXMgPSBwYXJhbSAmJiBwYXJhbS5yZXN1bHQgPyAocGFyYW0ucmVzdWx0LnZhbHVlICkgOiB1bmRlZmluZWQ7CgogICAgICAgICAgc2Vzc2lvbi5wb3N0KCdEZWJ1Z2dlci5yZXN1bWUnKTsKICAgICAgICAgIHNlc3Npb24ucG9zdCgnRGVidWdnZXIuZGlzYWJsZScpOwoKICAgICAgICAgIHNlbmRBbnJFdmVudChzdGFja0ZyYW1lcywgc2NvcGVzKS50aGVuKG51bGwsICgpID0+IHsKICAgICAgICAgICAgbG9nKCdTZW5kaW5nIEFOUiBldmVudCBmYWlsZWQuJyk7CiAgICAgICAgICB9KTsKICAgICAgICB9LAogICAgICApOwogICAgfSBjYXRjaCAoZSkgewogICAgICBzZXNzaW9uLnBvc3QoJ0RlYnVnZ2VyLnJlc3VtZScpOwogICAgICBzZXNzaW9uLnBvc3QoJ0RlYnVnZ2VyLmRpc2FibGUnKTsKICAgICAgdGhyb3cgZTsKICAgIH0KICB9KTsKCiAgZGVidWdnZXJQYXVzZSA9ICgpID0+IHsKICAgIHRyeSB7CiAgICAgIHNlc3Npb24ucG9zdCgnRGVidWdnZXIuZW5hYmxlJywgKCkgPT4gewogICAgICAgIHNlc3Npb24ucG9zdCgnRGVidWdnZXIucGF1c2UnKTsKICAgICAgfSk7CiAgICB9IGNhdGNoIChfKSB7CiAgICAgIC8vCiAgICB9CiAgfTsKfQoKZnVuY3Rpb24gY3JlYXRlSHJUaW1lcigpIHsKICAvLyBUT0RPICh2OCk6IFdlIGNhbiB1c2UgcHJvY2Vzcy5ocnRpbWUuYmlnaW50KCkgYWZ0ZXIgd2UgZHJvcCBub2RlIHY4CiAgbGV0IGxhc3RQb2xsID0gcHJvY2Vzcy5ocnRpbWUoKTsKCiAgcmV0dXJuIHsKICAgIGdldFRpbWVNczogKCkgPT4gewogICAgICBjb25zdCBbc2Vjb25kcywgbmFub1NlY29uZHNdID0gcHJvY2Vzcy5ocnRpbWUobGFzdFBvbGwpOwogICAgICByZXR1cm4gTWF0aC5mbG9vcihzZWNvbmRzICogMWUzICsgbmFub1NlY29uZHMgLyAxZTYpOwogICAgfSwKICAgIHJlc2V0OiAoKSA9PiB7CiAgICAgIGxhc3RQb2xsID0gcHJvY2Vzcy5ocnRpbWUoKTsKICAgIH0sCiAgfTsKfQoKZnVuY3Rpb24gd2F0Y2hkb2dUaW1lb3V0KCkgewogIGxvZygnV2F0Y2hkb2cgdGltZW91dCcpOwoKICBpZiAoZGVidWdnZXJQYXVzZSkgewogICAgbG9nKCdQYXVzaW5nIGRlYnVnZ2VyIHRvIGNhcHR1cmUgc3RhY2sgdHJhY2UnKTsKICAgIGRlYnVnZ2VyUGF1c2UoKTsKICB9IGVsc2UgewogICAgbG9nKCdDYXB0dXJpbmcgZXZlbnQgd2l0aG91dCBhIHN0YWNrIHRyYWNlJyk7CiAgICBzZW5kQW5yRXZlbnQoKS50aGVuKG51bGwsICgpID0+IHsKICAgICAgbG9nKCdTZW5kaW5nIEFOUiBldmVudCBmYWlsZWQgb24gd2F0Y2hkb2cgdGltZW91dC4nKTsKICAgIH0pOwogIH0KfQoKY29uc3QgeyBwb2xsIH0gPSB3YXRjaGRvZ1RpbWVyKGNyZWF0ZUhyVGltZXIsIG9wdGlvbnMucG9sbEludGVydmFsLCBvcHRpb25zLmFuclRocmVzaG9sZCwgd2F0Y2hkb2dUaW1lb3V0KTsKCl9vcHRpb25hbENoYWluKFtwYXJlbnRQb3J0LCAnb3B0aW9uYWxBY2Nlc3MnLCBfNiA9PiBfNi5vbiwgJ2NhbGwnLCBfNyA9PiBfNygnbWVzc2FnZScsIChtc2cpID0+IHsKICBpZiAobXNnLnNlc3Npb24pIHsKICAgIHNlc3Npb24gPSBtYWtlU2Vzc2lvbihtc2cuc2Vzc2lvbik7CiAgfQoKICBwb2xsKCk7Cn0pXSk7";
  }
});

// ../../../node_modules/.pnpm/@sentry+node@7.120.2/node_modules/@sentry/node/cjs/integrations/anr/index.js
var require_anr2 = __commonJS({
  "../../../node_modules/.pnpm/@sentry+node@7.120.2/node_modules/@sentry/node/cjs/integrations/anr/index.js"(exports, module) {
    init_define_ENV_DEFINED_IN_BUILD_STEP();
    var {
      _optionalChain,
      _optionalChainDelete
    } = require_cjs();
    Object.defineProperty(exports, "__esModule", { value: true });
    var url = __require("url");
    var core = require_cjs2();
    var utils = require_cjs();
    var nodeVersion = require_nodeVersion();
    var workerScript = require_worker_script();
    var DEFAULT_INTERVAL = 50;
    var DEFAULT_HANG_THRESHOLD = 5e3;
    function log2(message, ...args) {
      utils.logger.log(`[ANR] ${message}`, ...args);
    }
    function globalWithScopeFetchFn() {
      return utils.GLOBAL_OBJ;
    }
    function getScopeData() {
      const scope = core.getGlobalScope().getScopeData();
      core.mergeScopeData(scope, core.getIsolationScope().getScopeData());
      core.mergeScopeData(scope, core.getCurrentScope().getScopeData());
      scope.attachments = [];
      scope.eventProcessors = [];
      return scope;
    }
    function getWorkerThreads() {
      return utils.dynamicRequire(module, "worker_threads");
    }
    async function getContexts(client) {
      let event = { message: "ANR" };
      const eventHint = {};
      for (const processor of client.getEventProcessors()) {
        if (event === null)
          break;
        event = await processor(event, eventHint);
      }
      return _optionalChain([event, "optionalAccess", (_22) => _22.contexts]) || {};
    }
    var INTEGRATION_NAME = "Anr";
    var _anrIntegration = (options = {}) => {
      if (nodeVersion.NODE_VERSION.major < 16 || nodeVersion.NODE_VERSION.major === 16 && nodeVersion.NODE_VERSION.minor < 17) {
        throw new Error("ANR detection requires Node 16.17.0 or later");
      }
      let worker;
      let client;
      const gbl = globalWithScopeFetchFn();
      gbl.__SENTRY_GET_SCOPES__ = getScopeData;
      return {
        name: INTEGRATION_NAME,
        // TODO v8: Remove this
        setupOnce() {
        },
        // eslint-disable-line @typescript-eslint/no-empty-function
        startWorker: () => {
          if (worker) {
            return;
          }
          if (client) {
            worker = _startWorker(client, options);
          }
        },
        stopWorker: () => {
          if (worker) {
            worker.then((stop) => {
              stop();
              worker = void 0;
            });
          }
        },
        setup(initClient) {
          client = initClient;
          setImmediate(() => this.startWorker());
        }
      };
    };
    var anrIntegration = core.defineIntegration(_anrIntegration);
    var Anr = core.convertIntegrationFnToClass(INTEGRATION_NAME, anrIntegration);
    async function _startWorker(client, integrationOptions) {
      const dsn = client.getDsn();
      if (!dsn) {
        return () => {
        };
      }
      const contexts = await getContexts(client);
      _optionalChainDelete([contexts, "access", (_3) => _3.app, "optionalAccess", (_4) => delete _4.app_memory]);
      _optionalChainDelete([contexts, "access", (_5) => _5.device, "optionalAccess", (_6) => delete _6.free_memory]);
      const initOptions = client.getOptions();
      const sdkMetadata = client.getSdkMetadata() || {};
      if (sdkMetadata.sdk) {
        sdkMetadata.sdk.integrations = initOptions.integrations.map((i2) => i2.name);
      }
      const options = {
        debug: utils.logger.isEnabled(),
        dsn,
        environment: initOptions.environment || "production",
        release: initOptions.release,
        dist: initOptions.dist,
        sdkMetadata,
        appRootPath: integrationOptions.appRootPath,
        pollInterval: integrationOptions.pollInterval || DEFAULT_INTERVAL,
        anrThreshold: integrationOptions.anrThreshold || DEFAULT_HANG_THRESHOLD,
        captureStackTrace: !!integrationOptions.captureStackTrace,
        staticTags: integrationOptions.staticTags || {},
        contexts
      };
      if (options.captureStackTrace) {
        const inspector = __require("inspector");
        if (!inspector.url()) {
          inspector.open(0);
        }
      }
      const { Worker: Worker2 } = getWorkerThreads();
      const worker = new Worker2(new url.URL(`data:application/javascript;base64,${workerScript.base64WorkerScript}`), {
        workerData: options
      });
      process.on("exit", () => {
        worker.terminate();
      });
      const timer = setInterval(() => {
        try {
          const currentSession = core.getCurrentScope().getSession();
          const session = currentSession ? { ...currentSession, toJSON: void 0 } : void 0;
          worker.postMessage({ session });
        } catch (_3) {
        }
      }, options.pollInterval);
      timer.unref();
      worker.on("message", (msg) => {
        if (msg === "session-ended") {
          log2("ANR event sent from ANR worker. Clearing session in this thread.");
          core.getCurrentScope().setSession(void 0);
        }
      });
      worker.once("error", (err) => {
        clearInterval(timer);
        log2("ANR worker error", err);
      });
      worker.once("exit", (code) => {
        clearInterval(timer);
        log2("ANR worker exit", code);
      });
      worker.unref();
      return () => {
        worker.terminate();
        clearInterval(timer);
      };
    }
    exports.Anr = Anr;
    exports.anrIntegration = anrIntegration;
  }
});

// ../../../node_modules/.pnpm/@sentry+node@7.120.2/node_modules/@sentry/node/cjs/integrations/anr/legacy.js
var require_legacy2 = __commonJS({
  "../../../node_modules/.pnpm/@sentry+node@7.120.2/node_modules/@sentry/node/cjs/integrations/anr/legacy.js"(exports) {
    init_define_ENV_DEFINED_IN_BUILD_STEP();
    Object.defineProperty(exports, "__esModule", { value: true });
    var core = require_cjs2();
    var index = require_anr2();
    function enableAnrDetection(options) {
      const client = core.getClient();
      const integration = new index.Anr(options);
      integration.setup(client);
      return Promise.resolve();
    }
    exports.enableAnrDetection = enableAnrDetection;
  }
});

// ../../../node_modules/.pnpm/@sentry+node@7.120.2/node_modules/@sentry/node/cjs/trpc.js
var require_trpc = __commonJS({
  "../../../node_modules/.pnpm/@sentry+node@7.120.2/node_modules/@sentry/node/cjs/trpc.js"(exports) {
    init_define_ENV_DEFINED_IN_BUILD_STEP();
    var {
      _optionalChain
    } = require_cjs();
    Object.defineProperty(exports, "__esModule", { value: true });
    var core = require_cjs2();
    var utils = require_cjs();
    function trpcMiddleware(options = {}) {
      return function({ path: path2, type, next, rawInput }) {
        const clientOptions = _optionalChain([core.getClient, "call", (_3) => _3(), "optionalAccess", (_22) => _22.getOptions, "call", (_3) => _3()]);
        const sentryTransaction = core.getCurrentScope().getTransaction();
        if (sentryTransaction) {
          sentryTransaction.updateName(`trpc/${path2}`);
          sentryTransaction.setAttribute(core.SEMANTIC_ATTRIBUTE_SENTRY_SOURCE, "route");
          sentryTransaction.op = "rpc.server";
          const trpcContext = {
            procedure_type: type
          };
          if (options.attachRpcInput !== void 0 ? options.attachRpcInput : _optionalChain([clientOptions, "optionalAccess", (_4) => _4.sendDefaultPii])) {
            trpcContext.input = utils.normalize(rawInput);
          }
          sentryTransaction.setContext("trpc", trpcContext);
        }
        function captureIfError(nextResult) {
          if (!nextResult.ok) {
            core.captureException(nextResult.error, { mechanism: { handled: false, data: { function: "trpcMiddleware" } } });
          }
        }
        let maybePromiseResult;
        try {
          maybePromiseResult = next();
        } catch (e2) {
          core.captureException(e2, { mechanism: { handled: false, data: { function: "trpcMiddleware" } } });
          throw e2;
        }
        if (utils.isThenable(maybePromiseResult)) {
          Promise.resolve(maybePromiseResult).then(
            (nextResult) => {
              captureIfError(nextResult);
            },
            (e2) => {
              core.captureException(e2, { mechanism: { handled: false, data: { function: "trpcMiddleware" } } });
            }
          );
        } else {
          captureIfError(maybePromiseResult);
        }
        return maybePromiseResult;
      };
    }
    exports.trpcMiddleware = trpcMiddleware;
  }
});

// ../../../node_modules/.pnpm/@sentry+node@7.120.2/node_modules/@sentry/node/cjs/requestDataDeprecated.js
var require_requestDataDeprecated = __commonJS({
  "../../../node_modules/.pnpm/@sentry+node@7.120.2/node_modules/@sentry/node/cjs/requestDataDeprecated.js"(exports) {
    init_define_ENV_DEFINED_IN_BUILD_STEP();
    Object.defineProperty(exports, "__esModule", { value: true });
    var utils = require_cjs();
    function extractRequestData(req, keys) {
      return utils.extractRequestData(req, { include: keys });
    }
    function parseRequest(event, req, options = {}) {
      return utils.addRequestDataToEvent(event, req, { include: options });
    }
    exports.extractRequestData = extractRequestData;
    exports.parseRequest = parseRequest;
  }
});

// ../../../node_modules/.pnpm/@sentry+node@7.120.2/node_modules/@sentry/node/cjs/handlers.js
var require_handlers2 = __commonJS({
  "../../../node_modules/.pnpm/@sentry+node@7.120.2/node_modules/@sentry/node/cjs/handlers.js"(exports) {
    init_define_ENV_DEFINED_IN_BUILD_STEP();
    var {
      _optionalChain
    } = require_cjs();
    Object.defineProperty(exports, "__esModule", { value: true });
    var core = require_cjs2();
    var utils = require_cjs();
    var debugBuild = require_debug_build4();
    var sdk = require_sdk2();
    var trpc = require_trpc();
    var requestDataDeprecated = require_requestDataDeprecated();
    function tracingHandler() {
      return function sentryTracingMiddleware(req, res, next) {
        const options = _optionalChain([core.getClient, "call", (_3) => _3(), "optionalAccess", (_22) => _22.getOptions, "call", (_3) => _3()]);
        if (!options || options.instrumenter !== "sentry" || _optionalChain([req, "access", (_4) => _4.method, "optionalAccess", (_5) => _5.toUpperCase, "call", (_6) => _6()]) === "OPTIONS" || _optionalChain([req, "access", (_7) => _7.method, "optionalAccess", (_8) => _8.toUpperCase, "call", (_9) => _9()]) === "HEAD") {
          return next();
        }
        const sentryTrace = req.headers && utils.isString(req.headers["sentry-trace"]) ? req.headers["sentry-trace"] : void 0;
        const baggage = _optionalChain([req, "access", (_10) => _10.headers, "optionalAccess", (_11) => _11.baggage]);
        if (!core.hasTracingEnabled(options)) {
          return next();
        }
        const [name, source] = utils.extractPathForTransaction(req, { path: true, method: true });
        const transaction = core.continueTrace(
          { sentryTrace, baggage },
          (ctx) => (
            // TODO: Refactor this to use `startSpan()`
            // eslint-disable-next-line deprecation/deprecation
            core.startTransaction(
              {
                name,
                op: "http.server",
                origin: "auto.http.node.tracingHandler",
                ...ctx,
                data: {
                  [core.SEMANTIC_ATTRIBUTE_SENTRY_SOURCE]: source
                },
                metadata: {
                  // eslint-disable-next-line deprecation/deprecation
                  ...ctx.metadata,
                  // The request should already have been stored in `scope.sdkProcessingMetadata` (which will become
                  // `event.sdkProcessingMetadata` the same way the metadata here will) by `sentryRequestMiddleware`, but on the
                  // off chance someone is using `sentryTracingMiddleware` without `sentryRequestMiddleware`, it doesn't hurt to
                  // be sure
                  request: req
                }
              },
              // extra context passed to the tracesSampler
              { request: utils.extractRequestData(req) }
            )
          )
        );
        core.getCurrentScope().setSpan(transaction);
        res.__sentry_transaction = transaction;
        res.once("finish", () => {
          setImmediate(() => {
            utils.addRequestDataToTransaction(transaction, req);
            core.setHttpStatus(transaction, res.statusCode);
            transaction.end();
          });
        });
        next();
      };
    }
    function convertReqHandlerOptsToAddReqDataOpts(reqHandlerOptions = {}) {
      let addRequestDataOptions;
      if ("include" in reqHandlerOptions) {
        addRequestDataOptions = { include: reqHandlerOptions.include };
      } else {
        const { ip, request, transaction, user } = reqHandlerOptions;
        if (ip || request || transaction || user) {
          addRequestDataOptions = { include: utils.dropUndefinedKeys({ ip, request, transaction, user }) };
        }
      }
      return addRequestDataOptions;
    }
    function requestHandler(options) {
      const requestDataOptions = convertReqHandlerOptsToAddReqDataOpts(options);
      const client = core.getClient();
      if (client && sdk.isAutoSessionTrackingEnabled(client)) {
        client.initSessionFlusher();
        const scope = core.getCurrentScope();
        if (scope.getSession()) {
          scope.setSession();
        }
      }
      return function sentryRequestMiddleware(req, res, next) {
        if (options && options.flushTimeout && options.flushTimeout > 0) {
          const _end = res.end;
          res.end = function(chunk, encoding, cb) {
            void core.flush(options.flushTimeout).then(() => {
              _end.call(this, chunk, encoding, cb);
            }).then(null, (e2) => {
              debugBuild.DEBUG_BUILD && utils.logger.error(e2);
              _end.call(this, chunk, encoding, cb);
            });
          };
        }
        core.runWithAsyncContext(() => {
          const scope = core.getCurrentScope();
          scope.setSDKProcessingMetadata({
            request: req,
            // TODO (v8): Stop passing this
            requestDataOptionsFromExpressHandler: requestDataOptions
          });
          const client2 = core.getClient();
          if (sdk.isAutoSessionTrackingEnabled(client2)) {
            scope.setRequestSession({ status: "ok" });
          }
          res.once("finish", () => {
            const client3 = core.getClient();
            if (sdk.isAutoSessionTrackingEnabled(client3)) {
              setImmediate(() => {
                if (client3 && client3._captureRequestSession) {
                  client3._captureRequestSession();
                }
              });
            }
          });
          next();
        });
      };
    }
    function getStatusCodeFromResponse(error) {
      const statusCode = error.status || error.statusCode || error.status_code || error.output && error.output.statusCode;
      return statusCode ? parseInt(statusCode, 10) : 500;
    }
    function defaultShouldHandleError(error) {
      const status = getStatusCodeFromResponse(error);
      return status >= 500;
    }
    function errorHandler(options) {
      return function sentryErrorMiddleware(error, _req, res, next) {
        const shouldHandleError = options && options.shouldHandleError || defaultShouldHandleError;
        if (shouldHandleError(error)) {
          core.withScope((_scope) => {
            _scope.setSDKProcessingMetadata({ request: _req });
            const transaction = res.__sentry_transaction;
            if (transaction && !core.getActiveSpan()) {
              _scope.setSpan(transaction);
            }
            const client = core.getClient();
            if (client && sdk.isAutoSessionTrackingEnabled(client)) {
              const isSessionAggregatesMode = client._sessionFlusher !== void 0;
              if (isSessionAggregatesMode) {
                const requestSession = _scope.getRequestSession();
                if (requestSession && requestSession.status !== void 0) {
                  requestSession.status = "crashed";
                }
              }
            }
            const eventId = core.captureException(error, { mechanism: { type: "middleware", handled: false } });
            res.sentry = eventId;
            next(error);
          });
          return;
        }
        next(error);
      };
    }
    var trpcMiddleware = trpc.trpcMiddleware;
    exports.extractRequestData = requestDataDeprecated.extractRequestData;
    exports.parseRequest = requestDataDeprecated.parseRequest;
    exports.errorHandler = errorHandler;
    exports.requestHandler = requestHandler;
    exports.tracingHandler = tracingHandler;
    exports.trpcMiddleware = trpcMiddleware;
  }
});

// ../../../node_modules/.pnpm/@sentry+node@7.120.2/node_modules/@sentry/node/cjs/integrations/hapi/index.js
var require_hapi = __commonJS({
  "../../../node_modules/.pnpm/@sentry+node@7.120.2/node_modules/@sentry/node/cjs/integrations/hapi/index.js"(exports) {
    init_define_ENV_DEFINED_IN_BUILD_STEP();
    Object.defineProperty(exports, "__esModule", { value: true });
    var core = require_cjs2();
    var utils = require_cjs();
    function isResponseObject(response) {
      return response && response.statusCode !== void 0;
    }
    function isErrorEvent(event) {
      return event && event.error !== void 0;
    }
    function sendErrorToSentry(errorData) {
      core.captureException(errorData, {
        mechanism: {
          type: "hapi",
          handled: false,
          data: {
            function: "hapiErrorPlugin"
          }
        }
      });
    }
    var hapiErrorPlugin = {
      name: "SentryHapiErrorPlugin",
      version: core.SDK_VERSION,
      // eslint-disable-next-line @typescript-eslint/no-explicit-any
      register: async function(serverArg) {
        const server = serverArg;
        server.events.on("request", (request, event) => {
          const transaction = core.getActiveTransaction();
          if (isErrorEvent(event)) {
            sendErrorToSentry(event.error);
          }
          if (transaction) {
            transaction.setStatus("internal_error");
            transaction.end();
          }
        });
      }
    };
    var hapiTracingPlugin = {
      name: "SentryHapiTracingPlugin",
      version: core.SDK_VERSION,
      // eslint-disable-next-line @typescript-eslint/no-explicit-any
      register: async function(serverArg) {
        const server = serverArg;
        server.ext("onPreHandler", (request, h2) => {
          const transaction = core.continueTrace(
            {
              sentryTrace: request.headers["sentry-trace"] || void 0,
              baggage: request.headers["baggage"] || void 0
            },
            (transactionContext) => {
              return core.startTransaction({
                ...transactionContext,
                op: "hapi.request",
                name: request.route.path,
                description: `${request.route.method} ${request.path}`
              });
            }
          );
          core.getCurrentScope().setSpan(transaction);
          return h2.continue;
        });
        server.ext("onPreResponse", (request, h2) => {
          const transaction = core.getActiveTransaction();
          if (request.response && isResponseObject(request.response) && transaction) {
            const response = request.response;
            response.header("sentry-trace", core.spanToTraceHeader(transaction));
            const dynamicSamplingContext = utils.dynamicSamplingContextToSentryBaggageHeader(
              core.getDynamicSamplingContextFromSpan(transaction)
            );
            if (dynamicSamplingContext) {
              response.header("baggage", dynamicSamplingContext);
            }
          }
          return h2.continue;
        });
        server.ext("onPostHandler", (request, h2) => {
          const transaction = core.getActiveTransaction();
          if (transaction) {
            if (request.response && isResponseObject(request.response)) {
              core.setHttpStatus(transaction, request.response.statusCode);
            }
            transaction.end();
          }
          return h2.continue;
        });
      }
    };
    var INTEGRATION_NAME = "Hapi";
    var _hapiIntegration = (options = {}) => {
      const server = options.server;
      return {
        name: INTEGRATION_NAME,
        setupOnce() {
          if (!server) {
            return;
          }
          utils.fill(server, "start", (originalStart) => {
            return async function() {
              await this.register(hapiTracingPlugin);
              await this.register(hapiErrorPlugin);
              const result = originalStart.apply(this);
              return result;
            };
          });
        }
      };
    };
    var hapiIntegration = core.defineIntegration(_hapiIntegration);
    var Hapi = core.convertIntegrationFnToClass(INTEGRATION_NAME, hapiIntegration);
    exports.Hapi = Hapi;
    exports.hapiErrorPlugin = hapiErrorPlugin;
    exports.hapiIntegration = hapiIntegration;
    exports.hapiTracingPlugin = hapiTracingPlugin;
  }
});

// ../../../node_modules/.pnpm/@sentry+node@7.120.2/node_modules/@sentry/node/cjs/integrations/index.js
var require_integrations2 = __commonJS({
  "../../../node_modules/.pnpm/@sentry+node@7.120.2/node_modules/@sentry/node/cjs/integrations/index.js"(exports) {
    init_define_ENV_DEFINED_IN_BUILD_STEP();
    Object.defineProperty(exports, "__esModule", { value: true });
    var console2 = require_console2();
    var http = require_http3();
    var onuncaughtexception = require_onuncaughtexception();
    var onunhandledrejection = require_onunhandledrejection();
    var modules = require_modules();
    var contextlines = require_contextlines();
    var context2 = require_context();
    var core = require_cjs2();
    var index = require_local_variables();
    var index$1 = require_undici();
    var spotlight = require_spotlight();
    var index$2 = require_anr2();
    var index$3 = require_hapi();
    exports.Console = console2.Console;
    exports.Http = http.Http;
    exports.OnUncaughtException = onuncaughtexception.OnUncaughtException;
    exports.OnUnhandledRejection = onunhandledrejection.OnUnhandledRejection;
    exports.Modules = modules.Modules;
    exports.ContextLines = contextlines.ContextLines;
    exports.Context = context2.Context;
    exports.RequestData = core.RequestData;
    exports.LocalVariables = index.LocalVariables;
    exports.Undici = index$1.Undici;
    exports.Spotlight = spotlight.Spotlight;
    exports.Anr = index$2.Anr;
    exports.Hapi = index$3.Hapi;
  }
});

// ../../../node_modules/.pnpm/@sentry+node@7.120.2/node_modules/@sentry/node/cjs/tracing/integrations.js
var require_integrations3 = __commonJS({
  "../../../node_modules/.pnpm/@sentry+node@7.120.2/node_modules/@sentry/node/cjs/tracing/integrations.js"(exports) {
    init_define_ENV_DEFINED_IN_BUILD_STEP();
    Object.defineProperty(exports, "__esModule", { value: true });
    var tracing = require_cjs3();
    exports.Apollo = tracing.Apollo;
    exports.Express = tracing.Express;
    exports.GraphQL = tracing.GraphQL;
    exports.Mongo = tracing.Mongo;
    exports.Mysql = tracing.Mysql;
    exports.Postgres = tracing.Postgres;
    exports.Prisma = tracing.Prisma;
  }
});

// ../../../node_modules/.pnpm/@sentry+integrations@7.120.2/node_modules/@sentry/integrations/cjs/captureconsole.js
var require_captureconsole = __commonJS({
  "../../../node_modules/.pnpm/@sentry+integrations@7.120.2/node_modules/@sentry/integrations/cjs/captureconsole.js"(exports) {
    init_define_ENV_DEFINED_IN_BUILD_STEP();
    Object.defineProperty(exports, "__esModule", { value: true });
    var core = require_cjs2();
    var utils = require_cjs();
    var INTEGRATION_NAME = "CaptureConsole";
    var _captureConsoleIntegration = (options = {}) => {
      const levels = options.levels || utils.CONSOLE_LEVELS;
      return {
        name: INTEGRATION_NAME,
        // TODO v8: Remove this
        setupOnce() {
        },
        // eslint-disable-line @typescript-eslint/no-empty-function
        setup(client) {
          if (!("console" in utils.GLOBAL_OBJ)) {
            return;
          }
          utils.addConsoleInstrumentationHandler(({ args, level }) => {
            if (core.getClient() !== client || !levels.includes(level)) {
              return;
            }
            consoleHandler(args, level);
          });
        }
      };
    };
    var captureConsoleIntegration = core.defineIntegration(_captureConsoleIntegration);
    var CaptureConsole = core.convertIntegrationFnToClass(
      INTEGRATION_NAME,
      captureConsoleIntegration
    );
    function consoleHandler(args, level) {
      const captureContext = {
        level: utils.severityLevelFromString(level),
        extra: {
          arguments: args
        }
      };
      core.withScope((scope) => {
        scope.addEventProcessor((event) => {
          event.logger = "console";
          utils.addExceptionMechanism(event, {
            handled: false,
            type: "console"
          });
          return event;
        });
        if (level === "assert" && args[0] === false) {
          const message2 = `Assertion failed: ${utils.safeJoin(args.slice(1), " ") || "console.assert"}`;
          scope.setExtra("arguments", args.slice(1));
          core.captureMessage(message2, captureContext);
          return;
        }
        const error = args.find((arg) => arg instanceof Error);
        if (level === "error" && error) {
          core.captureException(error, captureContext);
          return;
        }
        const message = utils.safeJoin(args, " ");
        core.captureMessage(message, captureContext);
      });
    }
    exports.CaptureConsole = CaptureConsole;
    exports.captureConsoleIntegration = captureConsoleIntegration;
  }
});

// ../../../node_modules/.pnpm/@sentry+integrations@7.120.2/node_modules/@sentry/integrations/cjs/debug.js
var require_debug = __commonJS({
  "../../../node_modules/.pnpm/@sentry+integrations@7.120.2/node_modules/@sentry/integrations/cjs/debug.js"(exports) {
    init_define_ENV_DEFINED_IN_BUILD_STEP();
    Object.defineProperty(exports, "__esModule", { value: true });
    var core = require_cjs2();
    var utils = require_cjs();
    var INTEGRATION_NAME = "Debug";
    var _debugIntegration = (options = {}) => {
      const _options = {
        debugger: false,
        stringify: false,
        ...options
      };
      return {
        name: INTEGRATION_NAME,
        // TODO v8: Remove this
        setupOnce() {
        },
        // eslint-disable-line @typescript-eslint/no-empty-function
        setup(client) {
          if (!client.on) {
            return;
          }
          client.on("beforeSendEvent", (event, hint) => {
            if (_options.debugger) {
              debugger;
            }
            utils.consoleSandbox(() => {
              if (_options.stringify) {
                console.log(JSON.stringify(event, null, 2));
                if (hint && Object.keys(hint).length) {
                  console.log(JSON.stringify(hint, null, 2));
                }
              } else {
                console.log(event);
                if (hint && Object.keys(hint).length) {
                  console.log(hint);
                }
              }
            });
          });
        }
      };
    };
    var debugIntegration = core.defineIntegration(_debugIntegration);
    var Debug = core.convertIntegrationFnToClass(INTEGRATION_NAME, debugIntegration);
    exports.Debug = Debug;
    exports.debugIntegration = debugIntegration;
  }
});

// ../../../node_modules/.pnpm/@sentry+integrations@7.120.2/node_modules/@sentry/integrations/cjs/debug-build.js
var require_debug_build5 = __commonJS({
  "../../../node_modules/.pnpm/@sentry+integrations@7.120.2/node_modules/@sentry/integrations/cjs/debug-build.js"(exports) {
    init_define_ENV_DEFINED_IN_BUILD_STEP();
    Object.defineProperty(exports, "__esModule", { value: true });
    var DEBUG_BUILD = typeof __SENTRY_DEBUG__ === "undefined" || __SENTRY_DEBUG__;
    exports.DEBUG_BUILD = DEBUG_BUILD;
  }
});

// ../../../node_modules/.pnpm/@sentry+integrations@7.120.2/node_modules/@sentry/integrations/cjs/dedupe.js
var require_dedupe = __commonJS({
  "../../../node_modules/.pnpm/@sentry+integrations@7.120.2/node_modules/@sentry/integrations/cjs/dedupe.js"(exports) {
    init_define_ENV_DEFINED_IN_BUILD_STEP();
    Object.defineProperty(exports, "__esModule", { value: true });
    var core = require_cjs2();
    var utils = require_cjs();
    var debugBuild = require_debug_build5();
    var INTEGRATION_NAME = "Dedupe";
    var _dedupeIntegration = () => {
      let previousEvent;
      return {
        name: INTEGRATION_NAME,
        // TODO v8: Remove this
        setupOnce() {
        },
        // eslint-disable-line @typescript-eslint/no-empty-function
        processEvent(currentEvent) {
          if (currentEvent.type) {
            return currentEvent;
          }
          try {
            if (_shouldDropEvent(currentEvent, previousEvent)) {
              debugBuild.DEBUG_BUILD && utils.logger.warn("Event dropped due to being a duplicate of previously captured event.");
              return null;
            }
          } catch (_oO) {
          }
          return previousEvent = currentEvent;
        }
      };
    };
    var dedupeIntegration = core.defineIntegration(_dedupeIntegration);
    var Dedupe = core.convertIntegrationFnToClass(INTEGRATION_NAME, dedupeIntegration);
    function _shouldDropEvent(currentEvent, previousEvent) {
      if (!previousEvent) {
        return false;
      }
      if (_isSameMessageEvent(currentEvent, previousEvent)) {
        return true;
      }
      if (_isSameExceptionEvent(currentEvent, previousEvent)) {
        return true;
      }
      return false;
    }
    function _isSameMessageEvent(currentEvent, previousEvent) {
      const currentMessage = currentEvent.message;
      const previousMessage = previousEvent.message;
      if (!currentMessage && !previousMessage) {
        return false;
      }
      if (currentMessage && !previousMessage || !currentMessage && previousMessage) {
        return false;
      }
      if (currentMessage !== previousMessage) {
        return false;
      }
      if (!_isSameFingerprint(currentEvent, previousEvent)) {
        return false;
      }
      if (!_isSameStacktrace(currentEvent, previousEvent)) {
        return false;
      }
      return true;
    }
    function _isSameExceptionEvent(currentEvent, previousEvent) {
      const previousException = _getExceptionFromEvent(previousEvent);
      const currentException = _getExceptionFromEvent(currentEvent);
      if (!previousException || !currentException) {
        return false;
      }
      if (previousException.type !== currentException.type || previousException.value !== currentException.value) {
        return false;
      }
      if (!_isSameFingerprint(currentEvent, previousEvent)) {
        return false;
      }
      if (!_isSameStacktrace(currentEvent, previousEvent)) {
        return false;
      }
      return true;
    }
    function _isSameStacktrace(currentEvent, previousEvent) {
      let currentFrames = _getFramesFromEvent(currentEvent);
      let previousFrames = _getFramesFromEvent(previousEvent);
      if (!currentFrames && !previousFrames) {
        return true;
      }
      if (currentFrames && !previousFrames || !currentFrames && previousFrames) {
        return false;
      }
      currentFrames = currentFrames;
      previousFrames = previousFrames;
      if (previousFrames.length !== currentFrames.length) {
        return false;
      }
      for (let i2 = 0; i2 < previousFrames.length; i2++) {
        const frameA = previousFrames[i2];
        const frameB = currentFrames[i2];
        if (frameA.filename !== frameB.filename || frameA.lineno !== frameB.lineno || frameA.colno !== frameB.colno || frameA.function !== frameB.function) {
          return false;
        }
      }
      return true;
    }
    function _isSameFingerprint(currentEvent, previousEvent) {
      let currentFingerprint = currentEvent.fingerprint;
      let previousFingerprint = previousEvent.fingerprint;
      if (!currentFingerprint && !previousFingerprint) {
        return true;
      }
      if (currentFingerprint && !previousFingerprint || !currentFingerprint && previousFingerprint) {
        return false;
      }
      currentFingerprint = currentFingerprint;
      previousFingerprint = previousFingerprint;
      try {
        return !!(currentFingerprint.join("") === previousFingerprint.join(""));
      } catch (_oO) {
        return false;
      }
    }
    function _getExceptionFromEvent(event) {
      return event.exception && event.exception.values && event.exception.values[0];
    }
    function _getFramesFromEvent(event) {
      const exception = event.exception;
      if (exception) {
        try {
          return exception.values[0].stacktrace.frames;
        } catch (_oO) {
          return void 0;
        }
      }
      return void 0;
    }
    exports.Dedupe = Dedupe;
    exports._shouldDropEvent = _shouldDropEvent;
    exports.dedupeIntegration = dedupeIntegration;
  }
});

// ../../../node_modules/.pnpm/@sentry+integrations@7.120.2/node_modules/@sentry/integrations/cjs/extraerrordata.js
var require_extraerrordata = __commonJS({
  "../../../node_modules/.pnpm/@sentry+integrations@7.120.2/node_modules/@sentry/integrations/cjs/extraerrordata.js"(exports) {
    init_define_ENV_DEFINED_IN_BUILD_STEP();
    Object.defineProperty(exports, "__esModule", { value: true });
    var core = require_cjs2();
    var utils = require_cjs();
    var debugBuild = require_debug_build5();
    var INTEGRATION_NAME = "ExtraErrorData";
    var _extraErrorDataIntegration = (options = {}) => {
      const depth = options.depth || 3;
      const captureErrorCause = options.captureErrorCause || false;
      return {
        name: INTEGRATION_NAME,
        // TODO v8: Remove this
        setupOnce() {
        },
        // eslint-disable-line @typescript-eslint/no-empty-function
        processEvent(event, hint) {
          return _enhanceEventWithErrorData(event, hint, depth, captureErrorCause);
        }
      };
    };
    var extraErrorDataIntegration = core.defineIntegration(_extraErrorDataIntegration);
    var ExtraErrorData = core.convertIntegrationFnToClass(
      INTEGRATION_NAME,
      extraErrorDataIntegration
    );
    function _enhanceEventWithErrorData(event, hint = {}, depth, captureErrorCause) {
      if (!hint.originalException || !utils.isError(hint.originalException)) {
        return event;
      }
      const exceptionName = hint.originalException.name || hint.originalException.constructor.name;
      const errorData = _extractErrorData(hint.originalException, captureErrorCause);
      if (errorData) {
        const contexts = {
          ...event.contexts
        };
        const normalizedErrorData = utils.normalize(errorData, depth);
        if (utils.isPlainObject(normalizedErrorData)) {
          utils.addNonEnumerableProperty(normalizedErrorData, "__sentry_skip_normalization__", true);
          contexts[exceptionName] = normalizedErrorData;
        }
        return {
          ...event,
          contexts
        };
      }
      return event;
    }
    function _extractErrorData(error, captureErrorCause) {
      try {
        const nativeKeys = [
          "name",
          "message",
          "stack",
          "line",
          "column",
          "fileName",
          "lineNumber",
          "columnNumber",
          "toJSON"
        ];
        const extraErrorInfo = {};
        for (const key of Object.keys(error)) {
          if (nativeKeys.indexOf(key) !== -1) {
            continue;
          }
          const value = error[key];
          extraErrorInfo[key] = utils.isError(value) ? value.toString() : value;
        }
        if (captureErrorCause && error.cause !== void 0) {
          extraErrorInfo.cause = utils.isError(error.cause) ? error.cause.toString() : error.cause;
        }
        if (typeof error.toJSON === "function") {
          const serializedError = error.toJSON();
          for (const key of Object.keys(serializedError)) {
            const value = serializedError[key];
            extraErrorInfo[key] = utils.isError(value) ? value.toString() : value;
          }
        }
        return extraErrorInfo;
      } catch (oO) {
        debugBuild.DEBUG_BUILD && utils.logger.error("Unable to extract extra data from the Error object:", oO);
      }
      return null;
    }
    exports.ExtraErrorData = ExtraErrorData;
    exports.extraErrorDataIntegration = extraErrorDataIntegration;
  }
});

// ../../../node_modules/.pnpm/localforage@1.10.0/node_modules/localforage/dist/localforage.js
var require_localforage = __commonJS({
  "../../../node_modules/.pnpm/localforage@1.10.0/node_modules/localforage/dist/localforage.js"(exports, module) {
    init_define_ENV_DEFINED_IN_BUILD_STEP();
    (function(f2) {
      if (typeof exports === "object" && typeof module !== "undefined") {
        module.exports = f2();
      } else if (typeof define === "function" && define.amd) {
        define([], f2);
      } else {
        var g;
        if (typeof window !== "undefined") {
          g = window;
        } else if (typeof global !== "undefined") {
          g = global;
        } else if (typeof self !== "undefined") {
          g = self;
        } else {
          g = this;
        }
        g.localforage = f2();
      }
    })(function() {
      var define2, module2, exports2;
      return function e2(t2, n2, r3) {
        function s2(o2, u3) {
          if (!n2[o2]) {
            if (!t2[o2]) {
              var a3 = typeof __require == "function" && __require;
              if (!u3 && a3)
                return a3(o2, true);
              if (i2)
                return i2(o2, true);
              var f2 = new Error("Cannot find module '" + o2 + "'");
              throw f2.code = "MODULE_NOT_FOUND", f2;
            }
            var l2 = n2[o2] = { exports: {} };
            t2[o2][0].call(l2.exports, function(e3) {
              var n3 = t2[o2][1][e3];
              return s2(n3 ? n3 : e3);
            }, l2, l2.exports, e2, t2, n2, r3);
          }
          return n2[o2].exports;
        }
        var i2 = typeof __require == "function" && __require;
        for (var o = 0; o < r3.length; o++)
          s2(r3[o]);
        return s2;
      }({ 1: [function(_dereq_, module3, exports3) {
        (function(global2) {
          "use strict";
          var Mutation = global2.MutationObserver || global2.WebKitMutationObserver;
          var scheduleDrain;
          {
            if (Mutation) {
              var called = 0;
              var observer = new Mutation(nextTick);
              var element = global2.document.createTextNode("");
              observer.observe(element, {
                characterData: true
              });
              scheduleDrain = function() {
                element.data = called = ++called % 2;
              };
            } else if (!global2.setImmediate && typeof global2.MessageChannel !== "undefined") {
              var channel = new global2.MessageChannel();
              channel.port1.onmessage = nextTick;
              scheduleDrain = function() {
                channel.port2.postMessage(0);
              };
            } else if ("document" in global2 && "onreadystatechange" in global2.document.createElement("script")) {
              scheduleDrain = function() {
                var scriptEl = global2.document.createElement("script");
                scriptEl.onreadystatechange = function() {
                  nextTick();
                  scriptEl.onreadystatechange = null;
                  scriptEl.parentNode.removeChild(scriptEl);
                  scriptEl = null;
                };
                global2.document.documentElement.appendChild(scriptEl);
              };
            } else {
              scheduleDrain = function() {
                setTimeout(nextTick, 0);
              };
            }
          }
          var draining;
          var queue2 = [];
          function nextTick() {
            draining = true;
            var i2, oldQueue;
            var len = queue2.length;
            while (len) {
              oldQueue = queue2;
              queue2 = [];
              i2 = -1;
              while (++i2 < len) {
                oldQueue[i2]();
              }
              len = queue2.length;
            }
            draining = false;
          }
          module3.exports = immediate;
          function immediate(task) {
            if (queue2.push(task) === 1 && !draining) {
              scheduleDrain();
            }
          }
        }).call(this, typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {});
      }, {}], 2: [function(_dereq_, module3, exports3) {
        "use strict";
        var immediate = _dereq_(1);
        function INTERNAL() {
        }
        var handlers = {};
        var REJECTED = ["REJECTED"];
        var FULFILLED = ["FULFILLED"];
        var PENDING = ["PENDING"];
        module3.exports = Promise3;
        function Promise3(resolver) {
          if (typeof resolver !== "function") {
            throw new TypeError("resolver must be a function");
          }
          this.state = PENDING;
          this.queue = [];
          this.outcome = void 0;
          if (resolver !== INTERNAL) {
            safelyResolveThenable(this, resolver);
          }
        }
        Promise3.prototype["catch"] = function(onRejected) {
          return this.then(null, onRejected);
        };
        Promise3.prototype.then = function(onFulfilled, onRejected) {
          if (typeof onFulfilled !== "function" && this.state === FULFILLED || typeof onRejected !== "function" && this.state === REJECTED) {
            return this;
          }
          var promise = new this.constructor(INTERNAL);
          if (this.state !== PENDING) {
            var resolver = this.state === FULFILLED ? onFulfilled : onRejected;
            unwrap(promise, resolver, this.outcome);
          } else {
            this.queue.push(new QueueItem(promise, onFulfilled, onRejected));
          }
          return promise;
        };
        function QueueItem(promise, onFulfilled, onRejected) {
          this.promise = promise;
          if (typeof onFulfilled === "function") {
            this.onFulfilled = onFulfilled;
            this.callFulfilled = this.otherCallFulfilled;
          }
          if (typeof onRejected === "function") {
            this.onRejected = onRejected;
            this.callRejected = this.otherCallRejected;
          }
        }
        QueueItem.prototype.callFulfilled = function(value) {
          handlers.resolve(this.promise, value);
        };
        QueueItem.prototype.otherCallFulfilled = function(value) {
          unwrap(this.promise, this.onFulfilled, value);
        };
        QueueItem.prototype.callRejected = function(value) {
          handlers.reject(this.promise, value);
        };
        QueueItem.prototype.otherCallRejected = function(value) {
          unwrap(this.promise, this.onRejected, value);
        };
        function unwrap(promise, func, value) {
          immediate(function() {
            var returnValue;
            try {
              returnValue = func(value);
            } catch (e2) {
              return handlers.reject(promise, e2);
            }
            if (returnValue === promise) {
              handlers.reject(promise, new TypeError("Cannot resolve promise with itself"));
            } else {
              handlers.resolve(promise, returnValue);
            }
          });
        }
        handlers.resolve = function(self2, value) {
          var result = tryCatch(getThen, value);
          if (result.status === "error") {
            return handlers.reject(self2, result.value);
          }
          var thenable = result.value;
          if (thenable) {
            safelyResolveThenable(self2, thenable);
          } else {
            self2.state = FULFILLED;
            self2.outcome = value;
            var i2 = -1;
            var len = self2.queue.length;
            while (++i2 < len) {
              self2.queue[i2].callFulfilled(value);
            }
          }
          return self2;
        };
        handlers.reject = function(self2, error) {
          self2.state = REJECTED;
          self2.outcome = error;
          var i2 = -1;
          var len = self2.queue.length;
          while (++i2 < len) {
            self2.queue[i2].callRejected(error);
          }
          return self2;
        };
        function getThen(obj) {
          var then = obj && obj.then;
          if (obj && (typeof obj === "object" || typeof obj === "function") && typeof then === "function") {
            return function appyThen() {
              then.apply(obj, arguments);
            };
          }
        }
        function safelyResolveThenable(self2, thenable) {
          var called = false;
          function onError(value) {
            if (called) {
              return;
            }
            called = true;
            handlers.reject(self2, value);
          }
          function onSuccess(value) {
            if (called) {
              return;
            }
            called = true;
            handlers.resolve(self2, value);
          }
          function tryToUnwrap() {
            thenable(onSuccess, onError);
          }
          var result = tryCatch(tryToUnwrap);
          if (result.status === "error") {
            onError(result.value);
          }
        }
        function tryCatch(func, value) {
          var out = {};
          try {
            out.value = func(value);
            out.status = "success";
          } catch (e2) {
            out.status = "error";
            out.value = e2;
          }
          return out;
        }
        Promise3.resolve = resolve2;
        function resolve2(value) {
          if (value instanceof this) {
            return value;
          }
          return handlers.resolve(new this(INTERNAL), value);
        }
        Promise3.reject = reject;
        function reject(reason) {
          var promise = new this(INTERNAL);
          return handlers.reject(promise, reason);
        }
        Promise3.all = all;
        function all(iterable) {
          var self2 = this;
          if (Object.prototype.toString.call(iterable) !== "[object Array]") {
            return this.reject(new TypeError("must be an array"));
          }
          var len = iterable.length;
          var called = false;
          if (!len) {
            return this.resolve([]);
          }
          var values = new Array(len);
          var resolved = 0;
          var i2 = -1;
          var promise = new this(INTERNAL);
          while (++i2 < len) {
            allResolver(iterable[i2], i2);
          }
          return promise;
          function allResolver(value, i3) {
            self2.resolve(value).then(resolveFromAll, function(error) {
              if (!called) {
                called = true;
                handlers.reject(promise, error);
              }
            });
            function resolveFromAll(outValue) {
              values[i3] = outValue;
              if (++resolved === len && !called) {
                called = true;
                handlers.resolve(promise, values);
              }
            }
          }
        }
        Promise3.race = race;
        function race(iterable) {
          var self2 = this;
          if (Object.prototype.toString.call(iterable) !== "[object Array]") {
            return this.reject(new TypeError("must be an array"));
          }
          var len = iterable.length;
          var called = false;
          if (!len) {
            return this.resolve([]);
          }
          var i2 = -1;
          var promise = new this(INTERNAL);
          while (++i2 < len) {
            resolver(iterable[i2]);
          }
          return promise;
          function resolver(value) {
            self2.resolve(value).then(function(response) {
              if (!called) {
                called = true;
                handlers.resolve(promise, response);
              }
            }, function(error) {
              if (!called) {
                called = true;
                handlers.reject(promise, error);
              }
            });
          }
        }
      }, { "1": 1 }], 3: [function(_dereq_, module3, exports3) {
        (function(global2) {
          "use strict";
          if (typeof global2.Promise !== "function") {
            global2.Promise = _dereq_(2);
          }
        }).call(this, typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {});
      }, { "2": 2 }], 4: [function(_dereq_, module3, exports3) {
        "use strict";
        var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function(obj) {
          return typeof obj;
        } : function(obj) {
          return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
        };
        function _classCallCheck(instance, Constructor2) {
          if (!(instance instanceof Constructor2)) {
            throw new TypeError("Cannot call a class as a function");
          }
        }
        function getIDB() {
          try {
            if (typeof indexedDB !== "undefined") {
              return indexedDB;
            }
            if (typeof webkitIndexedDB !== "undefined") {
              return webkitIndexedDB;
            }
            if (typeof mozIndexedDB !== "undefined") {
              return mozIndexedDB;
            }
            if (typeof OIndexedDB !== "undefined") {
              return OIndexedDB;
            }
            if (typeof msIndexedDB !== "undefined") {
              return msIndexedDB;
            }
          } catch (e2) {
            return;
          }
        }
        var idb = getIDB();
        function isIndexedDBValid() {
          try {
            if (!idb || !idb.open) {
              return false;
            }
            var isSafari = typeof openDatabase !== "undefined" && /(Safari|iPhone|iPad|iPod)/.test(navigator.userAgent) && !/Chrome/.test(navigator.userAgent) && !/BlackBerry/.test(navigator.platform);
            var hasFetch = typeof fetch === "function" && fetch.toString().indexOf("[native code") !== -1;
            return (!isSafari || hasFetch) && typeof indexedDB !== "undefined" && // some outdated implementations of IDB that appear on Samsung
            // and HTC Android devices <4.4 are missing IDBKeyRange
            // See: https://github.com/mozilla/localForage/issues/128
            // See: https://github.com/mozilla/localForage/issues/272
            typeof IDBKeyRange !== "undefined";
          } catch (e2) {
            return false;
          }
        }
        function createBlob(parts, properties) {
          parts = parts || [];
          properties = properties || {};
          try {
            return new Blob(parts, properties);
          } catch (e2) {
            if (e2.name !== "TypeError") {
              throw e2;
            }
            var Builder = typeof BlobBuilder !== "undefined" ? BlobBuilder : typeof MSBlobBuilder !== "undefined" ? MSBlobBuilder : typeof MozBlobBuilder !== "undefined" ? MozBlobBuilder : WebKitBlobBuilder;
            var builder = new Builder();
            for (var i2 = 0; i2 < parts.length; i2 += 1) {
              builder.append(parts[i2]);
            }
            return builder.getBlob(properties.type);
          }
        }
        if (typeof Promise === "undefined") {
          _dereq_(3);
        }
        var Promise$1 = Promise;
        function executeCallback(promise, callback) {
          if (callback) {
            promise.then(function(result) {
              callback(null, result);
            }, function(error) {
              callback(error);
            });
          }
        }
        function executeTwoCallbacks(promise, callback, errorCallback) {
          if (typeof callback === "function") {
            promise.then(callback);
          }
          if (typeof errorCallback === "function") {
            promise["catch"](errorCallback);
          }
        }
        function normalizeKey(key2) {
          if (typeof key2 !== "string") {
            console.warn(key2 + " used as a key, but it is not a string.");
            key2 = String(key2);
          }
          return key2;
        }
        function getCallback() {
          if (arguments.length && typeof arguments[arguments.length - 1] === "function") {
            return arguments[arguments.length - 1];
          }
        }
        var DETECT_BLOB_SUPPORT_STORE = "local-forage-detect-blob-support";
        var supportsBlobs = void 0;
        var dbContexts = {};
        var toString2 = Object.prototype.toString;
        var READ_ONLY = "readonly";
        var READ_WRITE = "readwrite";
        function _binStringToArrayBuffer(bin) {
          var length2 = bin.length;
          var buf = new ArrayBuffer(length2);
          var arr = new Uint8Array(buf);
          for (var i2 = 0; i2 < length2; i2++) {
            arr[i2] = bin.charCodeAt(i2);
          }
          return buf;
        }
        function _checkBlobSupportWithoutCaching(idb2) {
          return new Promise$1(function(resolve2) {
            var txn = idb2.transaction(DETECT_BLOB_SUPPORT_STORE, READ_WRITE);
            var blob = createBlob([""]);
            txn.objectStore(DETECT_BLOB_SUPPORT_STORE).put(blob, "key");
            txn.onabort = function(e2) {
              e2.preventDefault();
              e2.stopPropagation();
              resolve2(false);
            };
            txn.oncomplete = function() {
              var matchedChrome = navigator.userAgent.match(/Chrome\/(\d+)/);
              var matchedEdge = navigator.userAgent.match(/Edge\//);
              resolve2(matchedEdge || !matchedChrome || parseInt(matchedChrome[1], 10) >= 43);
            };
          })["catch"](function() {
            return false;
          });
        }
        function _checkBlobSupport(idb2) {
          if (typeof supportsBlobs === "boolean") {
            return Promise$1.resolve(supportsBlobs);
          }
          return _checkBlobSupportWithoutCaching(idb2).then(function(value) {
            supportsBlobs = value;
            return supportsBlobs;
          });
        }
        function _deferReadiness(dbInfo) {
          var dbContext = dbContexts[dbInfo.name];
          var deferredOperation = {};
          deferredOperation.promise = new Promise$1(function(resolve2, reject) {
            deferredOperation.resolve = resolve2;
            deferredOperation.reject = reject;
          });
          dbContext.deferredOperations.push(deferredOperation);
          if (!dbContext.dbReady) {
            dbContext.dbReady = deferredOperation.promise;
          } else {
            dbContext.dbReady = dbContext.dbReady.then(function() {
              return deferredOperation.promise;
            });
          }
        }
        function _advanceReadiness(dbInfo) {
          var dbContext = dbContexts[dbInfo.name];
          var deferredOperation = dbContext.deferredOperations.pop();
          if (deferredOperation) {
            deferredOperation.resolve();
            return deferredOperation.promise;
          }
        }
        function _rejectReadiness(dbInfo, err) {
          var dbContext = dbContexts[dbInfo.name];
          var deferredOperation = dbContext.deferredOperations.pop();
          if (deferredOperation) {
            deferredOperation.reject(err);
            return deferredOperation.promise;
          }
        }
        function _getConnection(dbInfo, upgradeNeeded) {
          return new Promise$1(function(resolve2, reject) {
            dbContexts[dbInfo.name] = dbContexts[dbInfo.name] || createDbContext();
            if (dbInfo.db) {
              if (upgradeNeeded) {
                _deferReadiness(dbInfo);
                dbInfo.db.close();
              } else {
                return resolve2(dbInfo.db);
              }
            }
            var dbArgs = [dbInfo.name];
            if (upgradeNeeded) {
              dbArgs.push(dbInfo.version);
            }
            var openreq = idb.open.apply(idb, dbArgs);
            if (upgradeNeeded) {
              openreq.onupgradeneeded = function(e2) {
                var db = openreq.result;
                try {
                  db.createObjectStore(dbInfo.storeName);
                  if (e2.oldVersion <= 1) {
                    db.createObjectStore(DETECT_BLOB_SUPPORT_STORE);
                  }
                } catch (ex) {
                  if (ex.name === "ConstraintError") {
                    console.warn('The database "' + dbInfo.name + '" has been upgraded from version ' + e2.oldVersion + " to version " + e2.newVersion + ', but the storage "' + dbInfo.storeName + '" already exists.');
                  } else {
                    throw ex;
                  }
                }
              };
            }
            openreq.onerror = function(e2) {
              e2.preventDefault();
              reject(openreq.error);
            };
            openreq.onsuccess = function() {
              var db = openreq.result;
              db.onversionchange = function(e2) {
                e2.target.close();
              };
              resolve2(db);
              _advanceReadiness(dbInfo);
            };
          });
        }
        function _getOriginalConnection(dbInfo) {
          return _getConnection(dbInfo, false);
        }
        function _getUpgradedConnection(dbInfo) {
          return _getConnection(dbInfo, true);
        }
        function _isUpgradeNeeded(dbInfo, defaultVersion) {
          if (!dbInfo.db) {
            return true;
          }
          var isNewStore = !dbInfo.db.objectStoreNames.contains(dbInfo.storeName);
          var isDowngrade = dbInfo.version < dbInfo.db.version;
          var isUpgrade = dbInfo.version > dbInfo.db.version;
          if (isDowngrade) {
            if (dbInfo.version !== defaultVersion) {
              console.warn('The database "' + dbInfo.name + `" can't be downgraded from version ` + dbInfo.db.version + " to version " + dbInfo.version + ".");
            }
            dbInfo.version = dbInfo.db.version;
          }
          if (isUpgrade || isNewStore) {
            if (isNewStore) {
              var incVersion = dbInfo.db.version + 1;
              if (incVersion > dbInfo.version) {
                dbInfo.version = incVersion;
              }
            }
            return true;
          }
          return false;
        }
        function _encodeBlob(blob) {
          return new Promise$1(function(resolve2, reject) {
            var reader = new FileReader();
            reader.onerror = reject;
            reader.onloadend = function(e2) {
              var base64 = btoa(e2.target.result || "");
              resolve2({
                __local_forage_encoded_blob: true,
                data: base64,
                type: blob.type
              });
            };
            reader.readAsBinaryString(blob);
          });
        }
        function _decodeBlob(encodedBlob) {
          var arrayBuff = _binStringToArrayBuffer(atob(encodedBlob.data));
          return createBlob([arrayBuff], { type: encodedBlob.type });
        }
        function _isEncodedBlob(value) {
          return value && value.__local_forage_encoded_blob;
        }
        function _fullyReady(callback) {
          var self2 = this;
          var promise = self2._initReady().then(function() {
            var dbContext = dbContexts[self2._dbInfo.name];
            if (dbContext && dbContext.dbReady) {
              return dbContext.dbReady;
            }
          });
          executeTwoCallbacks(promise, callback, callback);
          return promise;
        }
        function _tryReconnect(dbInfo) {
          _deferReadiness(dbInfo);
          var dbContext = dbContexts[dbInfo.name];
          var forages = dbContext.forages;
          for (var i2 = 0; i2 < forages.length; i2++) {
            var forage = forages[i2];
            if (forage._dbInfo.db) {
              forage._dbInfo.db.close();
              forage._dbInfo.db = null;
            }
          }
          dbInfo.db = null;
          return _getOriginalConnection(dbInfo).then(function(db) {
            dbInfo.db = db;
            if (_isUpgradeNeeded(dbInfo)) {
              return _getUpgradedConnection(dbInfo);
            }
            return db;
          }).then(function(db) {
            dbInfo.db = dbContext.db = db;
            for (var i3 = 0; i3 < forages.length; i3++) {
              forages[i3]._dbInfo.db = db;
            }
          })["catch"](function(err) {
            _rejectReadiness(dbInfo, err);
            throw err;
          });
        }
        function createTransaction(dbInfo, mode, callback, retries) {
          if (retries === void 0) {
            retries = 1;
          }
          try {
            var tx = dbInfo.db.transaction(dbInfo.storeName, mode);
            callback(null, tx);
          } catch (err) {
            if (retries > 0 && (!dbInfo.db || err.name === "InvalidStateError" || err.name === "NotFoundError")) {
              return Promise$1.resolve().then(function() {
                if (!dbInfo.db || err.name === "NotFoundError" && !dbInfo.db.objectStoreNames.contains(dbInfo.storeName) && dbInfo.version <= dbInfo.db.version) {
                  if (dbInfo.db) {
                    dbInfo.version = dbInfo.db.version + 1;
                  }
                  return _getUpgradedConnection(dbInfo);
                }
              }).then(function() {
                return _tryReconnect(dbInfo).then(function() {
                  createTransaction(dbInfo, mode, callback, retries - 1);
                });
              })["catch"](callback);
            }
            callback(err);
          }
        }
        function createDbContext() {
          return {
            // Running localForages sharing a database.
            forages: [],
            // Shared database.
            db: null,
            // Database readiness (promise).
            dbReady: null,
            // Deferred operations on the database.
            deferredOperations: []
          };
        }
        function _initStorage(options) {
          var self2 = this;
          var dbInfo = {
            db: null
          };
          if (options) {
            for (var i2 in options) {
              dbInfo[i2] = options[i2];
            }
          }
          var dbContext = dbContexts[dbInfo.name];
          if (!dbContext) {
            dbContext = createDbContext();
            dbContexts[dbInfo.name] = dbContext;
          }
          dbContext.forages.push(self2);
          if (!self2._initReady) {
            self2._initReady = self2.ready;
            self2.ready = _fullyReady;
          }
          var initPromises = [];
          function ignoreErrors() {
            return Promise$1.resolve();
          }
          for (var j2 = 0; j2 < dbContext.forages.length; j2++) {
            var forage = dbContext.forages[j2];
            if (forage !== self2) {
              initPromises.push(forage._initReady()["catch"](ignoreErrors));
            }
          }
          var forages = dbContext.forages.slice(0);
          return Promise$1.all(initPromises).then(function() {
            dbInfo.db = dbContext.db;
            return _getOriginalConnection(dbInfo);
          }).then(function(db) {
            dbInfo.db = db;
            if (_isUpgradeNeeded(dbInfo, self2._defaultConfig.version)) {
              return _getUpgradedConnection(dbInfo);
            }
            return db;
          }).then(function(db) {
            dbInfo.db = dbContext.db = db;
            self2._dbInfo = dbInfo;
            for (var k2 = 0; k2 < forages.length; k2++) {
              var forage2 = forages[k2];
              if (forage2 !== self2) {
                forage2._dbInfo.db = dbInfo.db;
                forage2._dbInfo.version = dbInfo.version;
              }
            }
          });
        }
        function getItem(key2, callback) {
          var self2 = this;
          key2 = normalizeKey(key2);
          var promise = new Promise$1(function(resolve2, reject) {
            self2.ready().then(function() {
              createTransaction(self2._dbInfo, READ_ONLY, function(err, transaction) {
                if (err) {
                  return reject(err);
                }
                try {
                  var store = transaction.objectStore(self2._dbInfo.storeName);
                  var req = store.get(key2);
                  req.onsuccess = function() {
                    var value = req.result;
                    if (value === void 0) {
                      value = null;
                    }
                    if (_isEncodedBlob(value)) {
                      value = _decodeBlob(value);
                    }
                    resolve2(value);
                  };
                  req.onerror = function() {
                    reject(req.error);
                  };
                } catch (e2) {
                  reject(e2);
                }
              });
            })["catch"](reject);
          });
          executeCallback(promise, callback);
          return promise;
        }
        function iterate(iterator, callback) {
          var self2 = this;
          var promise = new Promise$1(function(resolve2, reject) {
            self2.ready().then(function() {
              createTransaction(self2._dbInfo, READ_ONLY, function(err, transaction) {
                if (err) {
                  return reject(err);
                }
                try {
                  var store = transaction.objectStore(self2._dbInfo.storeName);
                  var req = store.openCursor();
                  var iterationNumber = 1;
                  req.onsuccess = function() {
                    var cursor = req.result;
                    if (cursor) {
                      var value = cursor.value;
                      if (_isEncodedBlob(value)) {
                        value = _decodeBlob(value);
                      }
                      var result = iterator(value, cursor.key, iterationNumber++);
                      if (result !== void 0) {
                        resolve2(result);
                      } else {
                        cursor["continue"]();
                      }
                    } else {
                      resolve2();
                    }
                  };
                  req.onerror = function() {
                    reject(req.error);
                  };
                } catch (e2) {
                  reject(e2);
                }
              });
            })["catch"](reject);
          });
          executeCallback(promise, callback);
          return promise;
        }
        function setItem(key2, value, callback) {
          var self2 = this;
          key2 = normalizeKey(key2);
          var promise = new Promise$1(function(resolve2, reject) {
            var dbInfo;
            self2.ready().then(function() {
              dbInfo = self2._dbInfo;
              if (toString2.call(value) === "[object Blob]") {
                return _checkBlobSupport(dbInfo.db).then(function(blobSupport) {
                  if (blobSupport) {
                    return value;
                  }
                  return _encodeBlob(value);
                });
              }
              return value;
            }).then(function(value2) {
              createTransaction(self2._dbInfo, READ_WRITE, function(err, transaction) {
                if (err) {
                  return reject(err);
                }
                try {
                  var store = transaction.objectStore(self2._dbInfo.storeName);
                  if (value2 === null) {
                    value2 = void 0;
                  }
                  var req = store.put(value2, key2);
                  transaction.oncomplete = function() {
                    if (value2 === void 0) {
                      value2 = null;
                    }
                    resolve2(value2);
                  };
                  transaction.onabort = transaction.onerror = function() {
                    var err2 = req.error ? req.error : req.transaction.error;
                    reject(err2);
                  };
                } catch (e2) {
                  reject(e2);
                }
              });
            })["catch"](reject);
          });
          executeCallback(promise, callback);
          return promise;
        }
        function removeItem(key2, callback) {
          var self2 = this;
          key2 = normalizeKey(key2);
          var promise = new Promise$1(function(resolve2, reject) {
            self2.ready().then(function() {
              createTransaction(self2._dbInfo, READ_WRITE, function(err, transaction) {
                if (err) {
                  return reject(err);
                }
                try {
                  var store = transaction.objectStore(self2._dbInfo.storeName);
                  var req = store["delete"](key2);
                  transaction.oncomplete = function() {
                    resolve2();
                  };
                  transaction.onerror = function() {
                    reject(req.error);
                  };
                  transaction.onabort = function() {
                    var err2 = req.error ? req.error : req.transaction.error;
                    reject(err2);
                  };
                } catch (e2) {
                  reject(e2);
                }
              });
            })["catch"](reject);
          });
          executeCallback(promise, callback);
          return promise;
        }
        function clear(callback) {
          var self2 = this;
          var promise = new Promise$1(function(resolve2, reject) {
            self2.ready().then(function() {
              createTransaction(self2._dbInfo, READ_WRITE, function(err, transaction) {
                if (err) {
                  return reject(err);
                }
                try {
                  var store = transaction.objectStore(self2._dbInfo.storeName);
                  var req = store.clear();
                  transaction.oncomplete = function() {
                    resolve2();
                  };
                  transaction.onabort = transaction.onerror = function() {
                    var err2 = req.error ? req.error : req.transaction.error;
                    reject(err2);
                  };
                } catch (e2) {
                  reject(e2);
                }
              });
            })["catch"](reject);
          });
          executeCallback(promise, callback);
          return promise;
        }
        function length(callback) {
          var self2 = this;
          var promise = new Promise$1(function(resolve2, reject) {
            self2.ready().then(function() {
              createTransaction(self2._dbInfo, READ_ONLY, function(err, transaction) {
                if (err) {
                  return reject(err);
                }
                try {
                  var store = transaction.objectStore(self2._dbInfo.storeName);
                  var req = store.count();
                  req.onsuccess = function() {
                    resolve2(req.result);
                  };
                  req.onerror = function() {
                    reject(req.error);
                  };
                } catch (e2) {
                  reject(e2);
                }
              });
            })["catch"](reject);
          });
          executeCallback(promise, callback);
          return promise;
        }
        function key(n2, callback) {
          var self2 = this;
          var promise = new Promise$1(function(resolve2, reject) {
            if (n2 < 0) {
              resolve2(null);
              return;
            }
            self2.ready().then(function() {
              createTransaction(self2._dbInfo, READ_ONLY, function(err, transaction) {
                if (err) {
                  return reject(err);
                }
                try {
                  var store = transaction.objectStore(self2._dbInfo.storeName);
                  var advanced = false;
                  var req = store.openKeyCursor();
                  req.onsuccess = function() {
                    var cursor = req.result;
                    if (!cursor) {
                      resolve2(null);
                      return;
                    }
                    if (n2 === 0) {
                      resolve2(cursor.key);
                    } else {
                      if (!advanced) {
                        advanced = true;
                        cursor.advance(n2);
                      } else {
                        resolve2(cursor.key);
                      }
                    }
                  };
                  req.onerror = function() {
                    reject(req.error);
                  };
                } catch (e2) {
                  reject(e2);
                }
              });
            })["catch"](reject);
          });
          executeCallback(promise, callback);
          return promise;
        }
        function keys(callback) {
          var self2 = this;
          var promise = new Promise$1(function(resolve2, reject) {
            self2.ready().then(function() {
              createTransaction(self2._dbInfo, READ_ONLY, function(err, transaction) {
                if (err) {
                  return reject(err);
                }
                try {
                  var store = transaction.objectStore(self2._dbInfo.storeName);
                  var req = store.openKeyCursor();
                  var keys2 = [];
                  req.onsuccess = function() {
                    var cursor = req.result;
                    if (!cursor) {
                      resolve2(keys2);
                      return;
                    }
                    keys2.push(cursor.key);
                    cursor["continue"]();
                  };
                  req.onerror = function() {
                    reject(req.error);
                  };
                } catch (e2) {
                  reject(e2);
                }
              });
            })["catch"](reject);
          });
          executeCallback(promise, callback);
          return promise;
        }
        function dropInstance(options, callback) {
          callback = getCallback.apply(this, arguments);
          var currentConfig = this.config();
          options = typeof options !== "function" && options || {};
          if (!options.name) {
            options.name = options.name || currentConfig.name;
            options.storeName = options.storeName || currentConfig.storeName;
          }
          var self2 = this;
          var promise;
          if (!options.name) {
            promise = Promise$1.reject("Invalid arguments");
          } else {
            var isCurrentDb = options.name === currentConfig.name && self2._dbInfo.db;
            var dbPromise = isCurrentDb ? Promise$1.resolve(self2._dbInfo.db) : _getOriginalConnection(options).then(function(db) {
              var dbContext = dbContexts[options.name];
              var forages = dbContext.forages;
              dbContext.db = db;
              for (var i2 = 0; i2 < forages.length; i2++) {
                forages[i2]._dbInfo.db = db;
              }
              return db;
            });
            if (!options.storeName) {
              promise = dbPromise.then(function(db) {
                _deferReadiness(options);
                var dbContext = dbContexts[options.name];
                var forages = dbContext.forages;
                db.close();
                for (var i2 = 0; i2 < forages.length; i2++) {
                  var forage = forages[i2];
                  forage._dbInfo.db = null;
                }
                var dropDBPromise = new Promise$1(function(resolve2, reject) {
                  var req = idb.deleteDatabase(options.name);
                  req.onerror = function() {
                    var db2 = req.result;
                    if (db2) {
                      db2.close();
                    }
                    reject(req.error);
                  };
                  req.onblocked = function() {
                    console.warn('dropInstance blocked for database "' + options.name + '" until all open connections are closed');
                  };
                  req.onsuccess = function() {
                    var db2 = req.result;
                    if (db2) {
                      db2.close();
                    }
                    resolve2(db2);
                  };
                });
                return dropDBPromise.then(function(db2) {
                  dbContext.db = db2;
                  for (var i3 = 0; i3 < forages.length; i3++) {
                    var _forage = forages[i3];
                    _advanceReadiness(_forage._dbInfo);
                  }
                })["catch"](function(err) {
                  (_rejectReadiness(options, err) || Promise$1.resolve())["catch"](function() {
                  });
                  throw err;
                });
              });
            } else {
              promise = dbPromise.then(function(db) {
                if (!db.objectStoreNames.contains(options.storeName)) {
                  return;
                }
                var newVersion = db.version + 1;
                _deferReadiness(options);
                var dbContext = dbContexts[options.name];
                var forages = dbContext.forages;
                db.close();
                for (var i2 = 0; i2 < forages.length; i2++) {
                  var forage = forages[i2];
                  forage._dbInfo.db = null;
                  forage._dbInfo.version = newVersion;
                }
                var dropObjectPromise = new Promise$1(function(resolve2, reject) {
                  var req = idb.open(options.name, newVersion);
                  req.onerror = function(err) {
                    var db2 = req.result;
                    db2.close();
                    reject(err);
                  };
                  req.onupgradeneeded = function() {
                    var db2 = req.result;
                    db2.deleteObjectStore(options.storeName);
                  };
                  req.onsuccess = function() {
                    var db2 = req.result;
                    db2.close();
                    resolve2(db2);
                  };
                });
                return dropObjectPromise.then(function(db2) {
                  dbContext.db = db2;
                  for (var j2 = 0; j2 < forages.length; j2++) {
                    var _forage2 = forages[j2];
                    _forage2._dbInfo.db = db2;
                    _advanceReadiness(_forage2._dbInfo);
                  }
                })["catch"](function(err) {
                  (_rejectReadiness(options, err) || Promise$1.resolve())["catch"](function() {
                  });
                  throw err;
                });
              });
            }
          }
          executeCallback(promise, callback);
          return promise;
        }
        var asyncStorage = {
          _driver: "asyncStorage",
          _initStorage,
          _support: isIndexedDBValid(),
          iterate,
          getItem,
          setItem,
          removeItem,
          clear,
          length,
          key,
          keys,
          dropInstance
        };
        function isWebSQLValid() {
          return typeof openDatabase === "function";
        }
        var BASE_CHARS = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
        var BLOB_TYPE_PREFIX = "~~local_forage_type~";
        var BLOB_TYPE_PREFIX_REGEX = /^~~local_forage_type~([^~]+)~/;
        var SERIALIZED_MARKER = "__lfsc__:";
        var SERIALIZED_MARKER_LENGTH = SERIALIZED_MARKER.length;
        var TYPE_ARRAYBUFFER = "arbf";
        var TYPE_BLOB = "blob";
        var TYPE_INT8ARRAY = "si08";
        var TYPE_UINT8ARRAY = "ui08";
        var TYPE_UINT8CLAMPEDARRAY = "uic8";
        var TYPE_INT16ARRAY = "si16";
        var TYPE_INT32ARRAY = "si32";
        var TYPE_UINT16ARRAY = "ur16";
        var TYPE_UINT32ARRAY = "ui32";
        var TYPE_FLOAT32ARRAY = "fl32";
        var TYPE_FLOAT64ARRAY = "fl64";
        var TYPE_SERIALIZED_MARKER_LENGTH = SERIALIZED_MARKER_LENGTH + TYPE_ARRAYBUFFER.length;
        var toString$1 = Object.prototype.toString;
        function stringToBuffer(serializedString) {
          var bufferLength = serializedString.length * 0.75;
          var len = serializedString.length;
          var i2;
          var p3 = 0;
          var encoded1, encoded2, encoded3, encoded4;
          if (serializedString[serializedString.length - 1] === "=") {
            bufferLength--;
            if (serializedString[serializedString.length - 2] === "=") {
              bufferLength--;
            }
          }
          var buffer = new ArrayBuffer(bufferLength);
          var bytes = new Uint8Array(buffer);
          for (i2 = 0; i2 < len; i2 += 4) {
            encoded1 = BASE_CHARS.indexOf(serializedString[i2]);
            encoded2 = BASE_CHARS.indexOf(serializedString[i2 + 1]);
            encoded3 = BASE_CHARS.indexOf(serializedString[i2 + 2]);
            encoded4 = BASE_CHARS.indexOf(serializedString[i2 + 3]);
            bytes[p3++] = encoded1 << 2 | encoded2 >> 4;
            bytes[p3++] = (encoded2 & 15) << 4 | encoded3 >> 2;
            bytes[p3++] = (encoded3 & 3) << 6 | encoded4 & 63;
          }
          return buffer;
        }
        function bufferToString(buffer) {
          var bytes = new Uint8Array(buffer);
          var base64String = "";
          var i2;
          for (i2 = 0; i2 < bytes.length; i2 += 3) {
            base64String += BASE_CHARS[bytes[i2] >> 2];
            base64String += BASE_CHARS[(bytes[i2] & 3) << 4 | bytes[i2 + 1] >> 4];
            base64String += BASE_CHARS[(bytes[i2 + 1] & 15) << 2 | bytes[i2 + 2] >> 6];
            base64String += BASE_CHARS[bytes[i2 + 2] & 63];
          }
          if (bytes.length % 3 === 2) {
            base64String = base64String.substring(0, base64String.length - 1) + "=";
          } else if (bytes.length % 3 === 1) {
            base64String = base64String.substring(0, base64String.length - 2) + "==";
          }
          return base64String;
        }
        function serialize(value, callback) {
          var valueType = "";
          if (value) {
            valueType = toString$1.call(value);
          }
          if (value && (valueType === "[object ArrayBuffer]" || value.buffer && toString$1.call(value.buffer) === "[object ArrayBuffer]")) {
            var buffer;
            var marker = SERIALIZED_MARKER;
            if (value instanceof ArrayBuffer) {
              buffer = value;
              marker += TYPE_ARRAYBUFFER;
            } else {
              buffer = value.buffer;
              if (valueType === "[object Int8Array]") {
                marker += TYPE_INT8ARRAY;
              } else if (valueType === "[object Uint8Array]") {
                marker += TYPE_UINT8ARRAY;
              } else if (valueType === "[object Uint8ClampedArray]") {
                marker += TYPE_UINT8CLAMPEDARRAY;
              } else if (valueType === "[object Int16Array]") {
                marker += TYPE_INT16ARRAY;
              } else if (valueType === "[object Uint16Array]") {
                marker += TYPE_UINT16ARRAY;
              } else if (valueType === "[object Int32Array]") {
                marker += TYPE_INT32ARRAY;
              } else if (valueType === "[object Uint32Array]") {
                marker += TYPE_UINT32ARRAY;
              } else if (valueType === "[object Float32Array]") {
                marker += TYPE_FLOAT32ARRAY;
              } else if (valueType === "[object Float64Array]") {
                marker += TYPE_FLOAT64ARRAY;
              } else {
                callback(new Error("Failed to get type for BinaryArray"));
              }
            }
            callback(marker + bufferToString(buffer));
          } else if (valueType === "[object Blob]") {
            var fileReader = new FileReader();
            fileReader.onload = function() {
              var str = BLOB_TYPE_PREFIX + value.type + "~" + bufferToString(this.result);
              callback(SERIALIZED_MARKER + TYPE_BLOB + str);
            };
            fileReader.readAsArrayBuffer(value);
          } else {
            try {
              callback(JSON.stringify(value));
            } catch (e2) {
              console.error("Couldn't convert value into a JSON string: ", value);
              callback(null, e2);
            }
          }
        }
        function deserialize(value) {
          if (value.substring(0, SERIALIZED_MARKER_LENGTH) !== SERIALIZED_MARKER) {
            return JSON.parse(value);
          }
          var serializedString = value.substring(TYPE_SERIALIZED_MARKER_LENGTH);
          var type = value.substring(SERIALIZED_MARKER_LENGTH, TYPE_SERIALIZED_MARKER_LENGTH);
          var blobType;
          if (type === TYPE_BLOB && BLOB_TYPE_PREFIX_REGEX.test(serializedString)) {
            var matcher = serializedString.match(BLOB_TYPE_PREFIX_REGEX);
            blobType = matcher[1];
            serializedString = serializedString.substring(matcher[0].length);
          }
          var buffer = stringToBuffer(serializedString);
          switch (type) {
            case TYPE_ARRAYBUFFER:
              return buffer;
            case TYPE_BLOB:
              return createBlob([buffer], { type: blobType });
            case TYPE_INT8ARRAY:
              return new Int8Array(buffer);
            case TYPE_UINT8ARRAY:
              return new Uint8Array(buffer);
            case TYPE_UINT8CLAMPEDARRAY:
              return new Uint8ClampedArray(buffer);
            case TYPE_INT16ARRAY:
              return new Int16Array(buffer);
            case TYPE_UINT16ARRAY:
              return new Uint16Array(buffer);
            case TYPE_INT32ARRAY:
              return new Int32Array(buffer);
            case TYPE_UINT32ARRAY:
              return new Uint32Array(buffer);
            case TYPE_FLOAT32ARRAY:
              return new Float32Array(buffer);
            case TYPE_FLOAT64ARRAY:
              return new Float64Array(buffer);
            default:
              throw new Error("Unkown type: " + type);
          }
        }
        var localforageSerializer = {
          serialize,
          deserialize,
          stringToBuffer,
          bufferToString
        };
        function createDbTable(t2, dbInfo, callback, errorCallback) {
          t2.executeSql("CREATE TABLE IF NOT EXISTS " + dbInfo.storeName + " (id INTEGER PRIMARY KEY, key unique, value)", [], callback, errorCallback);
        }
        function _initStorage$1(options) {
          var self2 = this;
          var dbInfo = {
            db: null
          };
          if (options) {
            for (var i2 in options) {
              dbInfo[i2] = typeof options[i2] !== "string" ? options[i2].toString() : options[i2];
            }
          }
          var dbInfoPromise = new Promise$1(function(resolve2, reject) {
            try {
              dbInfo.db = openDatabase(dbInfo.name, String(dbInfo.version), dbInfo.description, dbInfo.size);
            } catch (e2) {
              return reject(e2);
            }
            dbInfo.db.transaction(function(t2) {
              createDbTable(t2, dbInfo, function() {
                self2._dbInfo = dbInfo;
                resolve2();
              }, function(t3, error) {
                reject(error);
              });
            }, reject);
          });
          dbInfo.serializer = localforageSerializer;
          return dbInfoPromise;
        }
        function tryExecuteSql(t2, dbInfo, sqlStatement, args, callback, errorCallback) {
          t2.executeSql(sqlStatement, args, callback, function(t3, error) {
            if (error.code === error.SYNTAX_ERR) {
              t3.executeSql("SELECT name FROM sqlite_master WHERE type='table' AND name = ?", [dbInfo.storeName], function(t4, results) {
                if (!results.rows.length) {
                  createDbTable(t4, dbInfo, function() {
                    t4.executeSql(sqlStatement, args, callback, errorCallback);
                  }, errorCallback);
                } else {
                  errorCallback(t4, error);
                }
              }, errorCallback);
            } else {
              errorCallback(t3, error);
            }
          }, errorCallback);
        }
        function getItem$1(key2, callback) {
          var self2 = this;
          key2 = normalizeKey(key2);
          var promise = new Promise$1(function(resolve2, reject) {
            self2.ready().then(function() {
              var dbInfo = self2._dbInfo;
              dbInfo.db.transaction(function(t2) {
                tryExecuteSql(t2, dbInfo, "SELECT * FROM " + dbInfo.storeName + " WHERE key = ? LIMIT 1", [key2], function(t3, results) {
                  var result = results.rows.length ? results.rows.item(0).value : null;
                  if (result) {
                    result = dbInfo.serializer.deserialize(result);
                  }
                  resolve2(result);
                }, function(t3, error) {
                  reject(error);
                });
              });
            })["catch"](reject);
          });
          executeCallback(promise, callback);
          return promise;
        }
        function iterate$1(iterator, callback) {
          var self2 = this;
          var promise = new Promise$1(function(resolve2, reject) {
            self2.ready().then(function() {
              var dbInfo = self2._dbInfo;
              dbInfo.db.transaction(function(t2) {
                tryExecuteSql(t2, dbInfo, "SELECT * FROM " + dbInfo.storeName, [], function(t3, results) {
                  var rows = results.rows;
                  var length2 = rows.length;
                  for (var i2 = 0; i2 < length2; i2++) {
                    var item = rows.item(i2);
                    var result = item.value;
                    if (result) {
                      result = dbInfo.serializer.deserialize(result);
                    }
                    result = iterator(result, item.key, i2 + 1);
                    if (result !== void 0) {
                      resolve2(result);
                      return;
                    }
                  }
                  resolve2();
                }, function(t3, error) {
                  reject(error);
                });
              });
            })["catch"](reject);
          });
          executeCallback(promise, callback);
          return promise;
        }
        function _setItem(key2, value, callback, retriesLeft) {
          var self2 = this;
          key2 = normalizeKey(key2);
          var promise = new Promise$1(function(resolve2, reject) {
            self2.ready().then(function() {
              if (value === void 0) {
                value = null;
              }
              var originalValue = value;
              var dbInfo = self2._dbInfo;
              dbInfo.serializer.serialize(value, function(value2, error) {
                if (error) {
                  reject(error);
                } else {
                  dbInfo.db.transaction(function(t2) {
                    tryExecuteSql(t2, dbInfo, "INSERT OR REPLACE INTO " + dbInfo.storeName + " (key, value) VALUES (?, ?)", [key2, value2], function() {
                      resolve2(originalValue);
                    }, function(t3, error2) {
                      reject(error2);
                    });
                  }, function(sqlError) {
                    if (sqlError.code === sqlError.QUOTA_ERR) {
                      if (retriesLeft > 0) {
                        resolve2(_setItem.apply(self2, [key2, originalValue, callback, retriesLeft - 1]));
                        return;
                      }
                      reject(sqlError);
                    }
                  });
                }
              });
            })["catch"](reject);
          });
          executeCallback(promise, callback);
          return promise;
        }
        function setItem$1(key2, value, callback) {
          return _setItem.apply(this, [key2, value, callback, 1]);
        }
        function removeItem$1(key2, callback) {
          var self2 = this;
          key2 = normalizeKey(key2);
          var promise = new Promise$1(function(resolve2, reject) {
            self2.ready().then(function() {
              var dbInfo = self2._dbInfo;
              dbInfo.db.transaction(function(t2) {
                tryExecuteSql(t2, dbInfo, "DELETE FROM " + dbInfo.storeName + " WHERE key = ?", [key2], function() {
                  resolve2();
                }, function(t3, error) {
                  reject(error);
                });
              });
            })["catch"](reject);
          });
          executeCallback(promise, callback);
          return promise;
        }
        function clear$1(callback) {
          var self2 = this;
          var promise = new Promise$1(function(resolve2, reject) {
            self2.ready().then(function() {
              var dbInfo = self2._dbInfo;
              dbInfo.db.transaction(function(t2) {
                tryExecuteSql(t2, dbInfo, "DELETE FROM " + dbInfo.storeName, [], function() {
                  resolve2();
                }, function(t3, error) {
                  reject(error);
                });
              });
            })["catch"](reject);
          });
          executeCallback(promise, callback);
          return promise;
        }
        function length$1(callback) {
          var self2 = this;
          var promise = new Promise$1(function(resolve2, reject) {
            self2.ready().then(function() {
              var dbInfo = self2._dbInfo;
              dbInfo.db.transaction(function(t2) {
                tryExecuteSql(t2, dbInfo, "SELECT COUNT(key) as c FROM " + dbInfo.storeName, [], function(t3, results) {
                  var result = results.rows.item(0).c;
                  resolve2(result);
                }, function(t3, error) {
                  reject(error);
                });
              });
            })["catch"](reject);
          });
          executeCallback(promise, callback);
          return promise;
        }
        function key$1(n2, callback) {
          var self2 = this;
          var promise = new Promise$1(function(resolve2, reject) {
            self2.ready().then(function() {
              var dbInfo = self2._dbInfo;
              dbInfo.db.transaction(function(t2) {
                tryExecuteSql(t2, dbInfo, "SELECT key FROM " + dbInfo.storeName + " WHERE id = ? LIMIT 1", [n2 + 1], function(t3, results) {
                  var result = results.rows.length ? results.rows.item(0).key : null;
                  resolve2(result);
                }, function(t3, error) {
                  reject(error);
                });
              });
            })["catch"](reject);
          });
          executeCallback(promise, callback);
          return promise;
        }
        function keys$1(callback) {
          var self2 = this;
          var promise = new Promise$1(function(resolve2, reject) {
            self2.ready().then(function() {
              var dbInfo = self2._dbInfo;
              dbInfo.db.transaction(function(t2) {
                tryExecuteSql(t2, dbInfo, "SELECT key FROM " + dbInfo.storeName, [], function(t3, results) {
                  var keys2 = [];
                  for (var i2 = 0; i2 < results.rows.length; i2++) {
                    keys2.push(results.rows.item(i2).key);
                  }
                  resolve2(keys2);
                }, function(t3, error) {
                  reject(error);
                });
              });
            })["catch"](reject);
          });
          executeCallback(promise, callback);
          return promise;
        }
        function getAllStoreNames(db) {
          return new Promise$1(function(resolve2, reject) {
            db.transaction(function(t2) {
              t2.executeSql("SELECT name FROM sqlite_master WHERE type='table' AND name <> '__WebKitDatabaseInfoTable__'", [], function(t3, results) {
                var storeNames = [];
                for (var i2 = 0; i2 < results.rows.length; i2++) {
                  storeNames.push(results.rows.item(i2).name);
                }
                resolve2({
                  db,
                  storeNames
                });
              }, function(t3, error) {
                reject(error);
              });
            }, function(sqlError) {
              reject(sqlError);
            });
          });
        }
        function dropInstance$1(options, callback) {
          callback = getCallback.apply(this, arguments);
          var currentConfig = this.config();
          options = typeof options !== "function" && options || {};
          if (!options.name) {
            options.name = options.name || currentConfig.name;
            options.storeName = options.storeName || currentConfig.storeName;
          }
          var self2 = this;
          var promise;
          if (!options.name) {
            promise = Promise$1.reject("Invalid arguments");
          } else {
            promise = new Promise$1(function(resolve2) {
              var db;
              if (options.name === currentConfig.name) {
                db = self2._dbInfo.db;
              } else {
                db = openDatabase(options.name, "", "", 0);
              }
              if (!options.storeName) {
                resolve2(getAllStoreNames(db));
              } else {
                resolve2({
                  db,
                  storeNames: [options.storeName]
                });
              }
            }).then(function(operationInfo) {
              return new Promise$1(function(resolve2, reject) {
                operationInfo.db.transaction(function(t2) {
                  function dropTable(storeName) {
                    return new Promise$1(function(resolve3, reject2) {
                      t2.executeSql("DROP TABLE IF EXISTS " + storeName, [], function() {
                        resolve3();
                      }, function(t3, error) {
                        reject2(error);
                      });
                    });
                  }
                  var operations = [];
                  for (var i2 = 0, len = operationInfo.storeNames.length; i2 < len; i2++) {
                    operations.push(dropTable(operationInfo.storeNames[i2]));
                  }
                  Promise$1.all(operations).then(function() {
                    resolve2();
                  })["catch"](function(e2) {
                    reject(e2);
                  });
                }, function(sqlError) {
                  reject(sqlError);
                });
              });
            });
          }
          executeCallback(promise, callback);
          return promise;
        }
        var webSQLStorage = {
          _driver: "webSQLStorage",
          _initStorage: _initStorage$1,
          _support: isWebSQLValid(),
          iterate: iterate$1,
          getItem: getItem$1,
          setItem: setItem$1,
          removeItem: removeItem$1,
          clear: clear$1,
          length: length$1,
          key: key$1,
          keys: keys$1,
          dropInstance: dropInstance$1
        };
        function isLocalStorageValid() {
          try {
            return typeof localStorage !== "undefined" && "setItem" in localStorage && // in IE8 typeof localStorage.setItem === 'object'
            !!localStorage.setItem;
          } catch (e2) {
            return false;
          }
        }
        function _getKeyPrefix(options, defaultConfig) {
          var keyPrefix = options.name + "/";
          if (options.storeName !== defaultConfig.storeName) {
            keyPrefix += options.storeName + "/";
          }
          return keyPrefix;
        }
        function checkIfLocalStorageThrows() {
          var localStorageTestKey = "_localforage_support_test";
          try {
            localStorage.setItem(localStorageTestKey, true);
            localStorage.removeItem(localStorageTestKey);
            return false;
          } catch (e2) {
            return true;
          }
        }
        function _isLocalStorageUsable() {
          return !checkIfLocalStorageThrows() || localStorage.length > 0;
        }
        function _initStorage$2(options) {
          var self2 = this;
          var dbInfo = {};
          if (options) {
            for (var i2 in options) {
              dbInfo[i2] = options[i2];
            }
          }
          dbInfo.keyPrefix = _getKeyPrefix(options, self2._defaultConfig);
          if (!_isLocalStorageUsable()) {
            return Promise$1.reject();
          }
          self2._dbInfo = dbInfo;
          dbInfo.serializer = localforageSerializer;
          return Promise$1.resolve();
        }
        function clear$2(callback) {
          var self2 = this;
          var promise = self2.ready().then(function() {
            var keyPrefix = self2._dbInfo.keyPrefix;
            for (var i2 = localStorage.length - 1; i2 >= 0; i2--) {
              var key2 = localStorage.key(i2);
              if (key2.indexOf(keyPrefix) === 0) {
                localStorage.removeItem(key2);
              }
            }
          });
          executeCallback(promise, callback);
          return promise;
        }
        function getItem$2(key2, callback) {
          var self2 = this;
          key2 = normalizeKey(key2);
          var promise = self2.ready().then(function() {
            var dbInfo = self2._dbInfo;
            var result = localStorage.getItem(dbInfo.keyPrefix + key2);
            if (result) {
              result = dbInfo.serializer.deserialize(result);
            }
            return result;
          });
          executeCallback(promise, callback);
          return promise;
        }
        function iterate$2(iterator, callback) {
          var self2 = this;
          var promise = self2.ready().then(function() {
            var dbInfo = self2._dbInfo;
            var keyPrefix = dbInfo.keyPrefix;
            var keyPrefixLength = keyPrefix.length;
            var length2 = localStorage.length;
            var iterationNumber = 1;
            for (var i2 = 0; i2 < length2; i2++) {
              var key2 = localStorage.key(i2);
              if (key2.indexOf(keyPrefix) !== 0) {
                continue;
              }
              var value = localStorage.getItem(key2);
              if (value) {
                value = dbInfo.serializer.deserialize(value);
              }
              value = iterator(value, key2.substring(keyPrefixLength), iterationNumber++);
              if (value !== void 0) {
                return value;
              }
            }
          });
          executeCallback(promise, callback);
          return promise;
        }
        function key$2(n2, callback) {
          var self2 = this;
          var promise = self2.ready().then(function() {
            var dbInfo = self2._dbInfo;
            var result;
            try {
              result = localStorage.key(n2);
            } catch (error) {
              result = null;
            }
            if (result) {
              result = result.substring(dbInfo.keyPrefix.length);
            }
            return result;
          });
          executeCallback(promise, callback);
          return promise;
        }
        function keys$2(callback) {
          var self2 = this;
          var promise = self2.ready().then(function() {
            var dbInfo = self2._dbInfo;
            var length2 = localStorage.length;
            var keys2 = [];
            for (var i2 = 0; i2 < length2; i2++) {
              var itemKey = localStorage.key(i2);
              if (itemKey.indexOf(dbInfo.keyPrefix) === 0) {
                keys2.push(itemKey.substring(dbInfo.keyPrefix.length));
              }
            }
            return keys2;
          });
          executeCallback(promise, callback);
          return promise;
        }
        function length$2(callback) {
          var self2 = this;
          var promise = self2.keys().then(function(keys2) {
            return keys2.length;
          });
          executeCallback(promise, callback);
          return promise;
        }
        function removeItem$2(key2, callback) {
          var self2 = this;
          key2 = normalizeKey(key2);
          var promise = self2.ready().then(function() {
            var dbInfo = self2._dbInfo;
            localStorage.removeItem(dbInfo.keyPrefix + key2);
          });
          executeCallback(promise, callback);
          return promise;
        }
        function setItem$2(key2, value, callback) {
          var self2 = this;
          key2 = normalizeKey(key2);
          var promise = self2.ready().then(function() {
            if (value === void 0) {
              value = null;
            }
            var originalValue = value;
            return new Promise$1(function(resolve2, reject) {
              var dbInfo = self2._dbInfo;
              dbInfo.serializer.serialize(value, function(value2, error) {
                if (error) {
                  reject(error);
                } else {
                  try {
                    localStorage.setItem(dbInfo.keyPrefix + key2, value2);
                    resolve2(originalValue);
                  } catch (e2) {
                    if (e2.name === "QuotaExceededError" || e2.name === "NS_ERROR_DOM_QUOTA_REACHED") {
                      reject(e2);
                    }
                    reject(e2);
                  }
                }
              });
            });
          });
          executeCallback(promise, callback);
          return promise;
        }
        function dropInstance$2(options, callback) {
          callback = getCallback.apply(this, arguments);
          options = typeof options !== "function" && options || {};
          if (!options.name) {
            var currentConfig = this.config();
            options.name = options.name || currentConfig.name;
            options.storeName = options.storeName || currentConfig.storeName;
          }
          var self2 = this;
          var promise;
          if (!options.name) {
            promise = Promise$1.reject("Invalid arguments");
          } else {
            promise = new Promise$1(function(resolve2) {
              if (!options.storeName) {
                resolve2(options.name + "/");
              } else {
                resolve2(_getKeyPrefix(options, self2._defaultConfig));
              }
            }).then(function(keyPrefix) {
              for (var i2 = localStorage.length - 1; i2 >= 0; i2--) {
                var key2 = localStorage.key(i2);
                if (key2.indexOf(keyPrefix) === 0) {
                  localStorage.removeItem(key2);
                }
              }
            });
          }
          executeCallback(promise, callback);
          return promise;
        }
        var localStorageWrapper = {
          _driver: "localStorageWrapper",
          _initStorage: _initStorage$2,
          _support: isLocalStorageValid(),
          iterate: iterate$2,
          getItem: getItem$2,
          setItem: setItem$2,
          removeItem: removeItem$2,
          clear: clear$2,
          length: length$2,
          key: key$2,
          keys: keys$2,
          dropInstance: dropInstance$2
        };
        var sameValue = function sameValue2(x2, y3) {
          return x2 === y3 || typeof x2 === "number" && typeof y3 === "number" && isNaN(x2) && isNaN(y3);
        };
        var includes = function includes2(array, searchElement) {
          var len = array.length;
          var i2 = 0;
          while (i2 < len) {
            if (sameValue(array[i2], searchElement)) {
              return true;
            }
            i2++;
          }
          return false;
        };
        var isArray = Array.isArray || function(arg) {
          return Object.prototype.toString.call(arg) === "[object Array]";
        };
        var DefinedDrivers = {};
        var DriverSupport = {};
        var DefaultDrivers = {
          INDEXEDDB: asyncStorage,
          WEBSQL: webSQLStorage,
          LOCALSTORAGE: localStorageWrapper
        };
        var DefaultDriverOrder = [DefaultDrivers.INDEXEDDB._driver, DefaultDrivers.WEBSQL._driver, DefaultDrivers.LOCALSTORAGE._driver];
        var OptionalDriverMethods = ["dropInstance"];
        var LibraryMethods = ["clear", "getItem", "iterate", "key", "keys", "length", "removeItem", "setItem"].concat(OptionalDriverMethods);
        var DefaultConfig = {
          description: "",
          driver: DefaultDriverOrder.slice(),
          name: "localforage",
          // Default DB size is _JUST UNDER_ 5MB, as it's the highest size
          // we can use without a prompt.
          size: 4980736,
          storeName: "keyvaluepairs",
          version: 1
        };
        function callWhenReady(localForageInstance, libraryMethod) {
          localForageInstance[libraryMethod] = function() {
            var _args = arguments;
            return localForageInstance.ready().then(function() {
              return localForageInstance[libraryMethod].apply(localForageInstance, _args);
            });
          };
        }
        function extend() {
          for (var i2 = 1; i2 < arguments.length; i2++) {
            var arg = arguments[i2];
            if (arg) {
              for (var _key in arg) {
                if (arg.hasOwnProperty(_key)) {
                  if (isArray(arg[_key])) {
                    arguments[0][_key] = arg[_key].slice();
                  } else {
                    arguments[0][_key] = arg[_key];
                  }
                }
              }
            }
          }
          return arguments[0];
        }
        var LocalForage = function() {
          function LocalForage2(options) {
            _classCallCheck(this, LocalForage2);
            for (var driverTypeKey in DefaultDrivers) {
              if (DefaultDrivers.hasOwnProperty(driverTypeKey)) {
                var driver = DefaultDrivers[driverTypeKey];
                var driverName = driver._driver;
                this[driverTypeKey] = driverName;
                if (!DefinedDrivers[driverName]) {
                  this.defineDriver(driver);
                }
              }
            }
            this._defaultConfig = extend({}, DefaultConfig);
            this._config = extend({}, this._defaultConfig, options);
            this._driverSet = null;
            this._initDriver = null;
            this._ready = false;
            this._dbInfo = null;
            this._wrapLibraryMethodsWithReady();
            this.setDriver(this._config.driver)["catch"](function() {
            });
          }
          LocalForage2.prototype.config = function config(options) {
            if ((typeof options === "undefined" ? "undefined" : _typeof(options)) === "object") {
              if (this._ready) {
                return new Error("Can't call config() after localforage has been used.");
              }
              for (var i2 in options) {
                if (i2 === "storeName") {
                  options[i2] = options[i2].replace(/\W/g, "_");
                }
                if (i2 === "version" && typeof options[i2] !== "number") {
                  return new Error("Database version must be a number.");
                }
                this._config[i2] = options[i2];
              }
              if ("driver" in options && options.driver) {
                return this.setDriver(this._config.driver);
              }
              return true;
            } else if (typeof options === "string") {
              return this._config[options];
            } else {
              return this._config;
            }
          };
          LocalForage2.prototype.defineDriver = function defineDriver(driverObject, callback, errorCallback) {
            var promise = new Promise$1(function(resolve2, reject) {
              try {
                var driverName = driverObject._driver;
                var complianceError = new Error("Custom driver not compliant; see https://mozilla.github.io/localForage/#definedriver");
                if (!driverObject._driver) {
                  reject(complianceError);
                  return;
                }
                var driverMethods = LibraryMethods.concat("_initStorage");
                for (var i2 = 0, len = driverMethods.length; i2 < len; i2++) {
                  var driverMethodName = driverMethods[i2];
                  var isRequired = !includes(OptionalDriverMethods, driverMethodName);
                  if ((isRequired || driverObject[driverMethodName]) && typeof driverObject[driverMethodName] !== "function") {
                    reject(complianceError);
                    return;
                  }
                }
                var configureMissingMethods = function configureMissingMethods2() {
                  var methodNotImplementedFactory = function methodNotImplementedFactory2(methodName) {
                    return function() {
                      var error = new Error("Method " + methodName + " is not implemented by the current driver");
                      var promise2 = Promise$1.reject(error);
                      executeCallback(promise2, arguments[arguments.length - 1]);
                      return promise2;
                    };
                  };
                  for (var _i = 0, _len = OptionalDriverMethods.length; _i < _len; _i++) {
                    var optionalDriverMethod = OptionalDriverMethods[_i];
                    if (!driverObject[optionalDriverMethod]) {
                      driverObject[optionalDriverMethod] = methodNotImplementedFactory(optionalDriverMethod);
                    }
                  }
                };
                configureMissingMethods();
                var setDriverSupport = function setDriverSupport2(support) {
                  if (DefinedDrivers[driverName]) {
                    console.info("Redefining LocalForage driver: " + driverName);
                  }
                  DefinedDrivers[driverName] = driverObject;
                  DriverSupport[driverName] = support;
                  resolve2();
                };
                if ("_support" in driverObject) {
                  if (driverObject._support && typeof driverObject._support === "function") {
                    driverObject._support().then(setDriverSupport, reject);
                  } else {
                    setDriverSupport(!!driverObject._support);
                  }
                } else {
                  setDriverSupport(true);
                }
              } catch (e2) {
                reject(e2);
              }
            });
            executeTwoCallbacks(promise, callback, errorCallback);
            return promise;
          };
          LocalForage2.prototype.driver = function driver() {
            return this._driver || null;
          };
          LocalForage2.prototype.getDriver = function getDriver(driverName, callback, errorCallback) {
            var getDriverPromise = DefinedDrivers[driverName] ? Promise$1.resolve(DefinedDrivers[driverName]) : Promise$1.reject(new Error("Driver not found."));
            executeTwoCallbacks(getDriverPromise, callback, errorCallback);
            return getDriverPromise;
          };
          LocalForage2.prototype.getSerializer = function getSerializer(callback) {
            var serializerPromise = Promise$1.resolve(localforageSerializer);
            executeTwoCallbacks(serializerPromise, callback);
            return serializerPromise;
          };
          LocalForage2.prototype.ready = function ready(callback) {
            var self2 = this;
            var promise = self2._driverSet.then(function() {
              if (self2._ready === null) {
                self2._ready = self2._initDriver();
              }
              return self2._ready;
            });
            executeTwoCallbacks(promise, callback, callback);
            return promise;
          };
          LocalForage2.prototype.setDriver = function setDriver(drivers, callback, errorCallback) {
            var self2 = this;
            if (!isArray(drivers)) {
              drivers = [drivers];
            }
            var supportedDrivers = this._getSupportedDrivers(drivers);
            function setDriverToConfig() {
              self2._config.driver = self2.driver();
            }
            function extendSelfWithDriver(driver) {
              self2._extend(driver);
              setDriverToConfig();
              self2._ready = self2._initStorage(self2._config);
              return self2._ready;
            }
            function initDriver(supportedDrivers2) {
              return function() {
                var currentDriverIndex = 0;
                function driverPromiseLoop() {
                  while (currentDriverIndex < supportedDrivers2.length) {
                    var driverName = supportedDrivers2[currentDriverIndex];
                    currentDriverIndex++;
                    self2._dbInfo = null;
                    self2._ready = null;
                    return self2.getDriver(driverName).then(extendSelfWithDriver)["catch"](driverPromiseLoop);
                  }
                  setDriverToConfig();
                  var error = new Error("No available storage method found.");
                  self2._driverSet = Promise$1.reject(error);
                  return self2._driverSet;
                }
                return driverPromiseLoop();
              };
            }
            var oldDriverSetDone = this._driverSet !== null ? this._driverSet["catch"](function() {
              return Promise$1.resolve();
            }) : Promise$1.resolve();
            this._driverSet = oldDriverSetDone.then(function() {
              var driverName = supportedDrivers[0];
              self2._dbInfo = null;
              self2._ready = null;
              return self2.getDriver(driverName).then(function(driver) {
                self2._driver = driver._driver;
                setDriverToConfig();
                self2._wrapLibraryMethodsWithReady();
                self2._initDriver = initDriver(supportedDrivers);
              });
            })["catch"](function() {
              setDriverToConfig();
              var error = new Error("No available storage method found.");
              self2._driverSet = Promise$1.reject(error);
              return self2._driverSet;
            });
            executeTwoCallbacks(this._driverSet, callback, errorCallback);
            return this._driverSet;
          };
          LocalForage2.prototype.supports = function supports(driverName) {
            return !!DriverSupport[driverName];
          };
          LocalForage2.prototype._extend = function _extend(libraryMethodsAndProperties) {
            extend(this, libraryMethodsAndProperties);
          };
          LocalForage2.prototype._getSupportedDrivers = function _getSupportedDrivers(drivers) {
            var supportedDrivers = [];
            for (var i2 = 0, len = drivers.length; i2 < len; i2++) {
              var driverName = drivers[i2];
              if (this.supports(driverName)) {
                supportedDrivers.push(driverName);
              }
            }
            return supportedDrivers;
          };
          LocalForage2.prototype._wrapLibraryMethodsWithReady = function _wrapLibraryMethodsWithReady() {
            for (var i2 = 0, len = LibraryMethods.length; i2 < len; i2++) {
              callWhenReady(this, LibraryMethods[i2]);
            }
          };
          LocalForage2.prototype.createInstance = function createInstance(options) {
            return new LocalForage2(options);
          };
          return LocalForage2;
        }();
        var localforage_js = new LocalForage();
        module3.exports = localforage_js;
      }, { "3": 3 }] }, {}, [4])(4);
    });
  }
});

// ../../../node_modules/.pnpm/@sentry+integrations@7.120.2/node_modules/@sentry/integrations/cjs/offline.js
var require_offline2 = __commonJS({
  "../../../node_modules/.pnpm/@sentry+integrations@7.120.2/node_modules/@sentry/integrations/cjs/offline.js"(exports) {
    init_define_ENV_DEFINED_IN_BUILD_STEP();
    Object.defineProperty(exports, "__esModule", { value: true });
    var utils = require_cjs();
    var localForage = require_localforage();
    var debugBuild = require_debug_build5();
    var WINDOW = utils.GLOBAL_OBJ;
    var Offline = class _Offline {
      /**
       * @inheritDoc
       */
      static __initStatic() {
        this.id = "Offline";
      }
      /**
       * @inheritDoc
       */
      /**
       * the current hub instance
       */
      /**
       * maximum number of events to store while offline
       */
      /**
       * event cache
       */
      /**
       * @inheritDoc
       */
      constructor(options = {}) {
        this.name = _Offline.id;
        this.maxStoredEvents = options.maxStoredEvents || 30;
        this.offlineEventStore = localForage.createInstance({
          name: "sentry/offlineEventStore"
        });
      }
      /**
       * @inheritDoc
       */
      setupOnce(addGlobalEventProcessor, getCurrentHub) {
        this.hub = getCurrentHub();
        if ("addEventListener" in WINDOW) {
          WINDOW.addEventListener("online", () => {
            void this._sendEvents().catch(() => {
              debugBuild.DEBUG_BUILD && utils.logger.warn("could not send cached events");
            });
          });
        }
        const eventProcessor = (event) => {
          if (this.hub && this.hub.getIntegration(_Offline)) {
            if ("navigator" in WINDOW && "onLine" in WINDOW.navigator && !WINDOW.navigator.onLine) {
              debugBuild.DEBUG_BUILD && utils.logger.log("Event dropped due to being a offline - caching instead");
              void this._cacheEvent(event).then((_event) => this._enforceMaxEvents()).catch((_error) => {
                debugBuild.DEBUG_BUILD && utils.logger.warn("could not cache event while offline");
              });
              return null;
            }
          }
          return event;
        };
        eventProcessor.id = this.name;
        addGlobalEventProcessor(eventProcessor);
        if ("navigator" in WINDOW && "onLine" in WINDOW.navigator && WINDOW.navigator.onLine) {
          void this._sendEvents().catch(() => {
            debugBuild.DEBUG_BUILD && utils.logger.warn("could not send cached events");
          });
        }
      }
      /**
       * cache an event to send later
       * @param event an event
       */
      async _cacheEvent(event) {
        return this.offlineEventStore.setItem(utils.uuid4(), utils.normalize(event));
      }
      /**
       * purge excess events if necessary
       */
      async _enforceMaxEvents() {
        const events = [];
        return this.offlineEventStore.iterate((event, cacheKey, _index) => {
          events.push({ cacheKey, event });
        }).then(
          () => (
            // this promise resolves when the iteration is finished
            this._purgeEvents(
              // purge all events past maxStoredEvents in reverse chronological order
              events.sort((a3, b) => (b.event.timestamp || 0) - (a3.event.timestamp || 0)).slice(this.maxStoredEvents < events.length ? this.maxStoredEvents : events.length).map((event) => event.cacheKey)
            )
          )
        ).catch((_error) => {
          debugBuild.DEBUG_BUILD && utils.logger.warn("could not enforce max events");
        });
      }
      /**
       * purge event from cache
       */
      async _purgeEvent(cacheKey) {
        return this.offlineEventStore.removeItem(cacheKey);
      }
      /**
       * purge events from cache
       */
      async _purgeEvents(cacheKeys) {
        return Promise.all(cacheKeys.map((cacheKey) => this._purgeEvent(cacheKey))).then();
      }
      /**
       * send all events
       */
      async _sendEvents() {
        return this.offlineEventStore.iterate((event, cacheKey, _index) => {
          if (this.hub) {
            this.hub.captureEvent(event);
            void this._purgeEvent(cacheKey).catch((_error) => {
              debugBuild.DEBUG_BUILD && utils.logger.warn("could not purge event from cache");
            });
          } else {
            debugBuild.DEBUG_BUILD && utils.logger.warn("no hub found - could not send cached event");
          }
        });
      }
    };
    Offline.__initStatic();
    exports.Offline = Offline;
  }
});

// ../../../node_modules/.pnpm/@sentry+integrations@7.120.2/node_modules/@sentry/integrations/cjs/reportingobserver.js
var require_reportingobserver = __commonJS({
  "../../../node_modules/.pnpm/@sentry+integrations@7.120.2/node_modules/@sentry/integrations/cjs/reportingobserver.js"(exports) {
    init_define_ENV_DEFINED_IN_BUILD_STEP();
    Object.defineProperty(exports, "__esModule", { value: true });
    var core = require_cjs2();
    var utils = require_cjs();
    var WINDOW = utils.GLOBAL_OBJ;
    var INTEGRATION_NAME = "ReportingObserver";
    var SETUP_CLIENTS = /* @__PURE__ */ new WeakMap();
    var _reportingObserverIntegration = (options = {}) => {
      const types = options.types || ["crash", "deprecation", "intervention"];
      function handler(reports) {
        if (!SETUP_CLIENTS.has(core.getClient())) {
          return;
        }
        for (const report of reports) {
          core.withScope((scope) => {
            scope.setExtra("url", report.url);
            const label = `ReportingObserver [${report.type}]`;
            let details = "No details available";
            if (report.body) {
              const plainBody = {};
              for (const prop in report.body) {
                plainBody[prop] = report.body[prop];
              }
              scope.setExtra("body", plainBody);
              if (report.type === "crash") {
                const body = report.body;
                details = [body.crashId || "", body.reason || ""].join(" ").trim() || details;
              } else {
                const body = report.body;
                details = body.message || details;
              }
            }
            core.captureMessage(`${label}: ${details}`);
          });
        }
      }
      return {
        name: INTEGRATION_NAME,
        setupOnce() {
          if (!utils.supportsReportingObserver()) {
            return;
          }
          const observer = new WINDOW.ReportingObserver(handler, {
            buffered: true,
            types
          });
          observer.observe();
        },
        setup(client) {
          SETUP_CLIENTS.set(client, true);
        }
      };
    };
    var reportingObserverIntegration = core.defineIntegration(_reportingObserverIntegration);
    var ReportingObserver = core.convertIntegrationFnToClass(
      INTEGRATION_NAME,
      reportingObserverIntegration
    );
    exports.ReportingObserver = ReportingObserver;
    exports.reportingObserverIntegration = reportingObserverIntegration;
  }
});

// ../../../node_modules/.pnpm/@sentry+integrations@7.120.2/node_modules/@sentry/integrations/cjs/rewriteframes.js
var require_rewriteframes = __commonJS({
  "../../../node_modules/.pnpm/@sentry+integrations@7.120.2/node_modules/@sentry/integrations/cjs/rewriteframes.js"(exports) {
    init_define_ENV_DEFINED_IN_BUILD_STEP();
    Object.defineProperty(exports, "__esModule", { value: true });
    var core = require_cjs2();
    var utils = require_cjs();
    var INTEGRATION_NAME = "RewriteFrames";
    var _rewriteFramesIntegration = (options = {}) => {
      const root = options.root;
      const prefix = options.prefix || "app:///";
      const iteratee = options.iteratee || ((frame) => {
        if (!frame.filename) {
          return frame;
        }
        const isWindowsFrame = /^[a-zA-Z]:\\/.test(frame.filename) || // or the presence of a backslash without a forward slash (which are not allowed on Windows)
        frame.filename.includes("\\") && !frame.filename.includes("/");
        const startsWithSlash = /^\//.test(frame.filename);
        if (isWindowsFrame || startsWithSlash) {
          const filename = isWindowsFrame ? frame.filename.replace(/^[a-zA-Z]:/, "").replace(/\\/g, "/") : frame.filename;
          const base = root ? utils.relative(root, filename) : utils.basename(filename);
          frame.filename = `${prefix}${base}`;
        }
        return frame;
      });
      function _processExceptionsEvent(event) {
        try {
          return {
            ...event,
            exception: {
              ...event.exception,
              // The check for this is performed inside `process` call itself, safe to skip here
              // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
              values: event.exception.values.map((value) => ({
                ...value,
                ...value.stacktrace && { stacktrace: _processStacktrace(value.stacktrace) }
              }))
            }
          };
        } catch (_oO) {
          return event;
        }
      }
      function _processStacktrace(stacktrace) {
        return {
          ...stacktrace,
          frames: stacktrace && stacktrace.frames && stacktrace.frames.map((f2) => iteratee(f2))
        };
      }
      return {
        name: INTEGRATION_NAME,
        // TODO v8: Remove this
        setupOnce() {
        },
        // eslint-disable-line @typescript-eslint/no-empty-function
        processEvent(originalEvent) {
          let processedEvent = originalEvent;
          if (originalEvent.exception && Array.isArray(originalEvent.exception.values)) {
            processedEvent = _processExceptionsEvent(processedEvent);
          }
          return processedEvent;
        }
      };
    };
    var rewriteFramesIntegration = core.defineIntegration(_rewriteFramesIntegration);
    var RewriteFrames = core.convertIntegrationFnToClass(
      INTEGRATION_NAME,
      rewriteFramesIntegration
    );
    exports.RewriteFrames = RewriteFrames;
    exports.rewriteFramesIntegration = rewriteFramesIntegration;
  }
});

// ../../../node_modules/.pnpm/@sentry+integrations@7.120.2/node_modules/@sentry/integrations/cjs/sessiontiming.js
var require_sessiontiming = __commonJS({
  "../../../node_modules/.pnpm/@sentry+integrations@7.120.2/node_modules/@sentry/integrations/cjs/sessiontiming.js"(exports) {
    init_define_ENV_DEFINED_IN_BUILD_STEP();
    Object.defineProperty(exports, "__esModule", { value: true });
    var core = require_cjs2();
    var INTEGRATION_NAME = "SessionTiming";
    var _sessionTimingIntegration = () => {
      const startTime = Date.now();
      return {
        name: INTEGRATION_NAME,
        // TODO v8: Remove this
        setupOnce() {
        },
        // eslint-disable-line @typescript-eslint/no-empty-function
        processEvent(event) {
          const now = Date.now();
          return {
            ...event,
            extra: {
              ...event.extra,
              ["session:start"]: startTime,
              ["session:duration"]: now - startTime,
              ["session:end"]: now
            }
          };
        }
      };
    };
    var sessionTimingIntegration = core.defineIntegration(_sessionTimingIntegration);
    var SessionTiming = core.convertIntegrationFnToClass(
      INTEGRATION_NAME,
      sessionTimingIntegration
    );
    exports.SessionTiming = SessionTiming;
    exports.sessionTimingIntegration = sessionTimingIntegration;
  }
});

// ../../../node_modules/.pnpm/@sentry+integrations@7.120.2/node_modules/@sentry/integrations/cjs/transaction.js
var require_transaction2 = __commonJS({
  "../../../node_modules/.pnpm/@sentry+integrations@7.120.2/node_modules/@sentry/integrations/cjs/transaction.js"(exports) {
    init_define_ENV_DEFINED_IN_BUILD_STEP();
    Object.defineProperty(exports, "__esModule", { value: true });
    var core = require_cjs2();
    var INTEGRATION_NAME = "Transaction";
    var transactionIntegration = () => {
      return {
        name: INTEGRATION_NAME,
        // TODO v8: Remove this
        setupOnce() {
        },
        // eslint-disable-line @typescript-eslint/no-empty-function
        processEvent(event) {
          const frames = _getFramesFromEvent(event);
          for (let i2 = frames.length - 1; i2 >= 0; i2--) {
            const frame = frames[i2];
            if (frame.in_app === true) {
              event.transaction = _getTransaction(frame);
              break;
            }
          }
          return event;
        }
      };
    };
    var Transaction2 = core.convertIntegrationFnToClass(INTEGRATION_NAME, transactionIntegration);
    function _getFramesFromEvent(event) {
      const exception = event.exception && event.exception.values && event.exception.values[0];
      return exception && exception.stacktrace && exception.stacktrace.frames || [];
    }
    function _getTransaction(frame) {
      return frame.module || frame.function ? `${frame.module || "?"}/${frame.function || "?"}` : "<unknown>";
    }
    exports.Transaction = Transaction2;
  }
});

// ../../../node_modules/.pnpm/@sentry+integrations@7.120.2/node_modules/@sentry/integrations/cjs/httpclient.js
var require_httpclient = __commonJS({
  "../../../node_modules/.pnpm/@sentry+integrations@7.120.2/node_modules/@sentry/integrations/cjs/httpclient.js"(exports) {
    init_define_ENV_DEFINED_IN_BUILD_STEP();
    Object.defineProperty(exports, "__esModule", { value: true });
    var core = require_cjs2();
    var utils = require_cjs();
    var debugBuild = require_debug_build5();
    var INTEGRATION_NAME = "HttpClient";
    var _httpClientIntegration = (options = {}) => {
      const _options = {
        failedRequestStatusCodes: [[500, 599]],
        failedRequestTargets: [/.*/],
        ...options
      };
      return {
        name: INTEGRATION_NAME,
        // TODO v8: Remove this
        setupOnce() {
        },
        // eslint-disable-line @typescript-eslint/no-empty-function
        setup(client) {
          _wrapFetch(client, _options);
          _wrapXHR(client, _options);
        }
      };
    };
    var httpClientIntegration = core.defineIntegration(_httpClientIntegration);
    var HttpClient = core.convertIntegrationFnToClass(INTEGRATION_NAME, httpClientIntegration);
    function _fetchResponseHandler(options, requestInfo, response, requestInit) {
      if (_shouldCaptureResponse(options, response.status, response.url)) {
        const request = _getRequest(requestInfo, requestInit);
        let requestHeaders, responseHeaders, requestCookies, responseCookies;
        if (_shouldSendDefaultPii()) {
          [{ headers: requestHeaders, cookies: requestCookies }, { headers: responseHeaders, cookies: responseCookies }] = [
            { cookieHeader: "Cookie", obj: request },
            { cookieHeader: "Set-Cookie", obj: response }
          ].map(({ cookieHeader, obj }) => {
            const headers = _extractFetchHeaders(obj.headers);
            let cookies;
            try {
              const cookieString = headers[cookieHeader] || headers[cookieHeader.toLowerCase()] || void 0;
              if (cookieString) {
                cookies = _parseCookieString(cookieString);
              }
            } catch (e2) {
              debugBuild.DEBUG_BUILD && utils.logger.log(`Could not extract cookies from header ${cookieHeader}`);
            }
            return {
              headers,
              cookies
            };
          });
        }
        const event = _createEvent({
          url: request.url,
          method: request.method,
          status: response.status,
          requestHeaders,
          responseHeaders,
          requestCookies,
          responseCookies
        });
        core.captureEvent(event);
      }
    }
    function _xhrResponseHandler(options, xhr, method, headers) {
      if (_shouldCaptureResponse(options, xhr.status, xhr.responseURL)) {
        let requestHeaders, responseCookies, responseHeaders;
        if (_shouldSendDefaultPii()) {
          try {
            const cookieString = xhr.getResponseHeader("Set-Cookie") || xhr.getResponseHeader("set-cookie") || void 0;
            if (cookieString) {
              responseCookies = _parseCookieString(cookieString);
            }
          } catch (e2) {
            debugBuild.DEBUG_BUILD && utils.logger.log("Could not extract cookies from response headers");
          }
          try {
            responseHeaders = _getXHRResponseHeaders(xhr);
          } catch (e2) {
            debugBuild.DEBUG_BUILD && utils.logger.log("Could not extract headers from response");
          }
          requestHeaders = headers;
        }
        const event = _createEvent({
          url: xhr.responseURL,
          method,
          status: xhr.status,
          requestHeaders,
          // Can't access request cookies from XHR
          responseHeaders,
          responseCookies
        });
        core.captureEvent(event);
      }
    }
    function _getResponseSizeFromHeaders(headers) {
      if (headers) {
        const contentLength = headers["Content-Length"] || headers["content-length"];
        if (contentLength) {
          return parseInt(contentLength, 10);
        }
      }
      return void 0;
    }
    function _parseCookieString(cookieString) {
      return cookieString.split("; ").reduce((acc, cookie) => {
        const [key, value] = cookie.split("=");
        acc[key] = value;
        return acc;
      }, {});
    }
    function _extractFetchHeaders(headers) {
      const result = {};
      headers.forEach((value, key) => {
        result[key] = value;
      });
      return result;
    }
    function _getXHRResponseHeaders(xhr) {
      const headers = xhr.getAllResponseHeaders();
      if (!headers) {
        return {};
      }
      return headers.split("\r\n").reduce((acc, line) => {
        const [key, value] = line.split(": ");
        acc[key] = value;
        return acc;
      }, {});
    }
    function _isInGivenRequestTargets(failedRequestTargets, target) {
      return failedRequestTargets.some((givenRequestTarget) => {
        if (typeof givenRequestTarget === "string") {
          return target.includes(givenRequestTarget);
        }
        return givenRequestTarget.test(target);
      });
    }
    function _isInGivenStatusRanges(failedRequestStatusCodes, status) {
      return failedRequestStatusCodes.some((range) => {
        if (typeof range === "number") {
          return range === status;
        }
        return status >= range[0] && status <= range[1];
      });
    }
    function _wrapFetch(client, options) {
      if (!utils.supportsNativeFetch()) {
        return;
      }
      utils.addFetchInstrumentationHandler((handlerData) => {
        if (core.getClient() !== client) {
          return;
        }
        const { response, args } = handlerData;
        const [requestInfo, requestInit] = args;
        if (!response) {
          return;
        }
        _fetchResponseHandler(options, requestInfo, response, requestInit);
      });
    }
    function _wrapXHR(client, options) {
      if (!("XMLHttpRequest" in utils.GLOBAL_OBJ)) {
        return;
      }
      utils.addXhrInstrumentationHandler((handlerData) => {
        if (core.getClient() !== client) {
          return;
        }
        const xhr = handlerData.xhr;
        const sentryXhrData = xhr[utils.SENTRY_XHR_DATA_KEY];
        if (!sentryXhrData) {
          return;
        }
        const { method, request_headers: headers } = sentryXhrData;
        try {
          _xhrResponseHandler(options, xhr, method, headers);
        } catch (e2) {
          debugBuild.DEBUG_BUILD && utils.logger.warn("Error while extracting response event form XHR response", e2);
        }
      });
    }
    function _shouldCaptureResponse(options, status, url) {
      return _isInGivenStatusRanges(options.failedRequestStatusCodes, status) && _isInGivenRequestTargets(options.failedRequestTargets, url) && !core.isSentryRequestUrl(url, core.getClient());
    }
    function _createEvent(data) {
      const message = `HTTP Client Error with status code: ${data.status}`;
      const event = {
        message,
        exception: {
          values: [
            {
              type: "Error",
              value: message
            }
          ]
        },
        request: {
          url: data.url,
          method: data.method,
          headers: data.requestHeaders,
          cookies: data.requestCookies
        },
        contexts: {
          response: {
            status_code: data.status,
            headers: data.responseHeaders,
            cookies: data.responseCookies,
            body_size: _getResponseSizeFromHeaders(data.responseHeaders)
          }
        }
      };
      utils.addExceptionMechanism(event, {
        type: "http.client",
        handled: false
      });
      return event;
    }
    function _getRequest(requestInfo, requestInit) {
      if (!requestInit && requestInfo instanceof Request) {
        return requestInfo;
      }
      if (requestInfo instanceof Request && requestInfo.bodyUsed) {
        return requestInfo;
      }
      return new Request(requestInfo, requestInit);
    }
    function _shouldSendDefaultPii() {
      const client = core.getClient();
      return client ? Boolean(client.getOptions().sendDefaultPii) : false;
    }
    exports.HttpClient = HttpClient;
    exports.httpClientIntegration = httpClientIntegration;
  }
});

// ../../../node_modules/.pnpm/@sentry+integrations@7.120.2/node_modules/@sentry/integrations/cjs/contextlines.js
var require_contextlines2 = __commonJS({
  "../../../node_modules/.pnpm/@sentry+integrations@7.120.2/node_modules/@sentry/integrations/cjs/contextlines.js"(exports) {
    init_define_ENV_DEFINED_IN_BUILD_STEP();
    Object.defineProperty(exports, "__esModule", { value: true });
    var core = require_cjs2();
    var utils = require_cjs();
    var WINDOW = utils.GLOBAL_OBJ;
    var DEFAULT_LINES_OF_CONTEXT = 7;
    var INTEGRATION_NAME = "ContextLines";
    var _contextLinesIntegration = (options = {}) => {
      const contextLines = options.frameContextLines != null ? options.frameContextLines : DEFAULT_LINES_OF_CONTEXT;
      return {
        name: INTEGRATION_NAME,
        // TODO v8: Remove this
        setupOnce() {
        },
        // eslint-disable-line @typescript-eslint/no-empty-function
        processEvent(event) {
          return addSourceContext(event, contextLines);
        }
      };
    };
    var contextLinesIntegration = core.defineIntegration(_contextLinesIntegration);
    var ContextLines = core.convertIntegrationFnToClass(INTEGRATION_NAME, contextLinesIntegration);
    function addSourceContext(event, contextLines) {
      const doc = WINDOW.document;
      const htmlFilename = WINDOW.location && utils.stripUrlQueryAndFragment(WINDOW.location.href);
      if (!doc || !htmlFilename) {
        return event;
      }
      const exceptions = event.exception && event.exception.values;
      if (!exceptions || !exceptions.length) {
        return event;
      }
      const html = doc.documentElement.innerHTML;
      if (!html) {
        return event;
      }
      const htmlLines = ["<!DOCTYPE html>", "<html>", ...html.split("\n"), "</html>"];
      exceptions.forEach((exception) => {
        const stacktrace = exception.stacktrace;
        if (stacktrace && stacktrace.frames) {
          stacktrace.frames = stacktrace.frames.map(
            (frame) => applySourceContextToFrame(frame, htmlLines, htmlFilename, contextLines)
          );
        }
      });
      return event;
    }
    function applySourceContextToFrame(frame, htmlLines, htmlFilename, linesOfContext) {
      if (frame.filename !== htmlFilename || !frame.lineno || !htmlLines.length) {
        return frame;
      }
      utils.addContextToFrame(htmlLines, frame, linesOfContext);
      return frame;
    }
    exports.ContextLines = ContextLines;
    exports.applySourceContextToFrame = applySourceContextToFrame;
    exports.contextLinesIntegration = contextLinesIntegration;
  }
});

// ../../../node_modules/.pnpm/@sentry+integrations@7.120.2/node_modules/@sentry/integrations/cjs/index.js
var require_cjs4 = __commonJS({
  "../../../node_modules/.pnpm/@sentry+integrations@7.120.2/node_modules/@sentry/integrations/cjs/index.js"(exports) {
    init_define_ENV_DEFINED_IN_BUILD_STEP();
    Object.defineProperty(exports, "__esModule", { value: true });
    var captureconsole = require_captureconsole();
    var debug = require_debug();
    var dedupe = require_dedupe();
    var extraerrordata = require_extraerrordata();
    var offline = require_offline2();
    var reportingobserver = require_reportingobserver();
    var rewriteframes = require_rewriteframes();
    var sessiontiming = require_sessiontiming();
    var transaction = require_transaction2();
    var httpclient = require_httpclient();
    var contextlines = require_contextlines2();
    exports.CaptureConsole = captureconsole.CaptureConsole;
    exports.captureConsoleIntegration = captureconsole.captureConsoleIntegration;
    exports.Debug = debug.Debug;
    exports.debugIntegration = debug.debugIntegration;
    exports.Dedupe = dedupe.Dedupe;
    exports.dedupeIntegration = dedupe.dedupeIntegration;
    exports.ExtraErrorData = extraerrordata.ExtraErrorData;
    exports.extraErrorDataIntegration = extraerrordata.extraErrorDataIntegration;
    exports.Offline = offline.Offline;
    exports.ReportingObserver = reportingobserver.ReportingObserver;
    exports.reportingObserverIntegration = reportingobserver.reportingObserverIntegration;
    exports.RewriteFrames = rewriteframes.RewriteFrames;
    exports.rewriteFramesIntegration = rewriteframes.rewriteFramesIntegration;
    exports.SessionTiming = sessiontiming.SessionTiming;
    exports.sessionTimingIntegration = sessiontiming.sessionTimingIntegration;
    exports.Transaction = transaction.Transaction;
    exports.HttpClient = httpclient.HttpClient;
    exports.httpClientIntegration = httpclient.httpClientIntegration;
    exports.ContextLines = contextlines.ContextLines;
    exports.contextLinesIntegration = contextlines.contextLinesIntegration;
  }
});

// ../../../node_modules/.pnpm/@sentry+node@7.120.2/node_modules/@sentry/node/cjs/cron/common.js
var require_common2 = __commonJS({
  "../../../node_modules/.pnpm/@sentry+node@7.120.2/node_modules/@sentry/node/cjs/cron/common.js"(exports) {
    init_define_ENV_DEFINED_IN_BUILD_STEP();
    Object.defineProperty(exports, "__esModule", { value: true });
    var replacements = [
      ["january", "1"],
      ["february", "2"],
      ["march", "3"],
      ["april", "4"],
      ["may", "5"],
      ["june", "6"],
      ["july", "7"],
      ["august", "8"],
      ["september", "9"],
      ["october", "10"],
      ["november", "11"],
      ["december", "12"],
      ["jan", "1"],
      ["feb", "2"],
      ["mar", "3"],
      ["apr", "4"],
      ["may", "5"],
      ["jun", "6"],
      ["jul", "7"],
      ["aug", "8"],
      ["sep", "9"],
      ["oct", "10"],
      ["nov", "11"],
      ["dec", "12"],
      ["sunday", "0"],
      ["monday", "1"],
      ["tuesday", "2"],
      ["wednesday", "3"],
      ["thursday", "4"],
      ["friday", "5"],
      ["saturday", "6"],
      ["sun", "0"],
      ["mon", "1"],
      ["tue", "2"],
      ["wed", "3"],
      ["thu", "4"],
      ["fri", "5"],
      ["sat", "6"]
    ];
    function replaceCronNames(cronExpression) {
      return replacements.reduce(
        // eslint-disable-next-line @sentry-internal/sdk/no-regexp-constructor
        (acc, [name, replacement]) => acc.replace(new RegExp(name, "gi"), replacement),
        cronExpression
      );
    }
    exports.replaceCronNames = replaceCronNames;
  }
});

// ../../../node_modules/.pnpm/@sentry+node@7.120.2/node_modules/@sentry/node/cjs/cron/cron.js
var require_cron = __commonJS({
  "../../../node_modules/.pnpm/@sentry+node@7.120.2/node_modules/@sentry/node/cjs/cron/cron.js"(exports) {
    init_define_ENV_DEFINED_IN_BUILD_STEP();
    Object.defineProperty(exports, "__esModule", { value: true });
    var core = require_cjs2();
    var common = require_common2();
    var ERROR_TEXT = "Automatic instrumentation of CronJob only supports crontab string";
    function instrumentCron(lib, monitorSlug) {
      let jobScheduled = false;
      return new Proxy(lib, {
        construct(target, args) {
          const [cronTime, onTick, onComplete, start, timeZone, ...rest] = args;
          if (typeof cronTime !== "string") {
            throw new Error(ERROR_TEXT);
          }
          if (jobScheduled) {
            throw new Error(`A job named '${monitorSlug}' has already been scheduled`);
          }
          jobScheduled = true;
          const cronString = common.replaceCronNames(cronTime);
          function monitoredTick(context2, onComplete2) {
            return core.withMonitor(
              monitorSlug,
              () => {
                return onTick(context2, onComplete2);
              },
              {
                schedule: { type: "crontab", value: cronString },
                timezone: timeZone || void 0
              }
            );
          }
          return new target(cronTime, monitoredTick, onComplete, start, timeZone, ...rest);
        },
        get(target, prop) {
          if (prop === "from") {
            return (param) => {
              const { cronTime, onTick, timeZone } = param;
              if (typeof cronTime !== "string") {
                throw new Error(ERROR_TEXT);
              }
              if (jobScheduled) {
                throw new Error(`A job named '${monitorSlug}' has already been scheduled`);
              }
              jobScheduled = true;
              const cronString = common.replaceCronNames(cronTime);
              param.onTick = (context2, onComplete) => {
                return core.withMonitor(
                  monitorSlug,
                  () => {
                    return onTick(context2, onComplete);
                  },
                  {
                    schedule: { type: "crontab", value: cronString },
                    timezone: timeZone || void 0
                  }
                );
              };
              return target.from(param);
            };
          } else {
            return target[prop];
          }
        }
      });
    }
    exports.instrumentCron = instrumentCron;
  }
});

// ../../../node_modules/.pnpm/@sentry+node@7.120.2/node_modules/@sentry/node/cjs/cron/node-cron.js
var require_node_cron = __commonJS({
  "../../../node_modules/.pnpm/@sentry+node@7.120.2/node_modules/@sentry/node/cjs/cron/node-cron.js"(exports) {
    init_define_ENV_DEFINED_IN_BUILD_STEP();
    var {
      _optionalChain
    } = require_cjs();
    Object.defineProperty(exports, "__esModule", { value: true });
    var core = require_cjs2();
    var common = require_common2();
    function instrumentNodeCron(lib) {
      return new Proxy(lib, {
        get(target, prop) {
          if (prop === "schedule" && target.schedule) {
            return new Proxy(target.schedule, {
              apply(target2, thisArg, argArray) {
                const [expression, , options] = argArray;
                if (!_optionalChain([options, "optionalAccess", (_3) => _3.name])) {
                  throw new Error('Missing "name" for scheduled job. A name is required for Sentry check-in monitoring.');
                }
                return core.withMonitor(
                  options.name,
                  () => {
                    return target2.apply(thisArg, argArray);
                  },
                  {
                    schedule: { type: "crontab", value: common.replaceCronNames(expression) },
                    timezone: _optionalChain([options, "optionalAccess", (_22) => _22.timezone])
                  }
                );
              }
            });
          } else {
            return target[prop];
          }
        }
      });
    }
    exports.instrumentNodeCron = instrumentNodeCron;
  }
});

// ../../../node_modules/.pnpm/@sentry+node@7.120.2/node_modules/@sentry/node/cjs/cron/node-schedule.js
var require_node_schedule = __commonJS({
  "../../../node_modules/.pnpm/@sentry+node@7.120.2/node_modules/@sentry/node/cjs/cron/node-schedule.js"(exports) {
    init_define_ENV_DEFINED_IN_BUILD_STEP();
    Object.defineProperty(exports, "__esModule", { value: true });
    var core = require_cjs2();
    var common = require_common2();
    function instrumentNodeSchedule(lib) {
      return new Proxy(lib, {
        get(target, prop) {
          if (prop === "scheduleJob") {
            return new Proxy(target.scheduleJob, {
              apply(target2, thisArg, argArray) {
                const [nameOrExpression, expressionOrCallback] = argArray;
                if (typeof nameOrExpression !== "string" || typeof expressionOrCallback !== "string") {
                  throw new Error(
                    "Automatic instrumentation of 'node-schedule' requires the first parameter of 'scheduleJob' to be a job name string and the second parameter to be a crontab string"
                  );
                }
                const monitorSlug = nameOrExpression;
                const expression = expressionOrCallback;
                return core.withMonitor(
                  monitorSlug,
                  () => {
                    return target2.apply(thisArg, argArray);
                  },
                  {
                    schedule: { type: "crontab", value: common.replaceCronNames(expression) }
                  }
                );
              }
            });
          }
          return target[prop];
        }
      });
    }
    exports.instrumentNodeSchedule = instrumentNodeSchedule;
  }
});

// ../../../node_modules/.pnpm/@sentry+node@7.120.2/node_modules/@sentry/node/cjs/index.js
var require_cjs5 = __commonJS({
  "../../../node_modules/.pnpm/@sentry+node@7.120.2/node_modules/@sentry/node/cjs/index.js"(exports) {
    init_define_ENV_DEFINED_IN_BUILD_STEP();
    Object.defineProperty(exports, "__esModule", { value: true });
    var core = require_cjs2();
    var index = require_tracing2();
    var client = require_client2();
    var http = require_http();
    var sdk = require_sdk2();
    var utils = require_cjs();
    var utils$1 = require_utils4();
    var module$1 = require_module();
    var legacy = require_legacy2();
    var handlers = require_handlers2();
    var index$5 = require_integrations2();
    var integrations$1 = require_integrations3();
    var integrations = require_cjs4();
    var console2 = require_console2();
    var onuncaughtexception = require_onuncaughtexception();
    var onunhandledrejection = require_onunhandledrejection();
    var modules = require_modules();
    var contextlines = require_contextlines();
    var context2 = require_context();
    var index$1 = require_local_variables();
    var spotlight = require_spotlight();
    var index$2 = require_anr2();
    var index$3 = require_hapi();
    var index$4 = require_undici();
    var http$1 = require_http3();
    var trpc = require_trpc();
    var cron$1 = require_cron();
    var nodeCron = require_node_cron();
    var nodeSchedule = require_node_schedule();
    var getModuleFromFilename = module$1.createGetModuleFromFilename();
    var Integrations = {
      // eslint-disable-next-line deprecation/deprecation
      ...core.Integrations,
      ...index$5,
      ...integrations$1
    };
    var cron = {
      instrumentCron: cron$1.instrumentCron,
      instrumentNodeCron: nodeCron.instrumentNodeCron,
      instrumentNodeSchedule: nodeSchedule.instrumentNodeSchedule
    };
    exports.Hub = core.Hub;
    exports.SDK_VERSION = core.SDK_VERSION;
    exports.SEMANTIC_ATTRIBUTE_SENTRY_OP = core.SEMANTIC_ATTRIBUTE_SENTRY_OP;
    exports.SEMANTIC_ATTRIBUTE_SENTRY_ORIGIN = core.SEMANTIC_ATTRIBUTE_SENTRY_ORIGIN;
    exports.SEMANTIC_ATTRIBUTE_SENTRY_SAMPLE_RATE = core.SEMANTIC_ATTRIBUTE_SENTRY_SAMPLE_RATE;
    exports.SEMANTIC_ATTRIBUTE_SENTRY_SOURCE = core.SEMANTIC_ATTRIBUTE_SENTRY_SOURCE;
    exports.Scope = core.Scope;
    exports.addBreadcrumb = core.addBreadcrumb;
    exports.addEventProcessor = core.addEventProcessor;
    exports.addGlobalEventProcessor = core.addGlobalEventProcessor;
    exports.addIntegration = core.addIntegration;
    exports.captureCheckIn = core.captureCheckIn;
    exports.captureEvent = core.captureEvent;
    exports.captureException = core.captureException;
    exports.captureMessage = core.captureMessage;
    exports.captureSession = core.captureSession;
    exports.close = core.close;
    exports.configureScope = core.configureScope;
    exports.continueTrace = core.continueTrace;
    exports.createTransport = core.createTransport;
    exports.endSession = core.endSession;
    exports.extractTraceparentData = core.extractTraceparentData;
    exports.flush = core.flush;
    exports.functionToStringIntegration = core.functionToStringIntegration;
    exports.getActiveSpan = core.getActiveSpan;
    exports.getActiveTransaction = core.getActiveTransaction;
    exports.getClient = core.getClient;
    exports.getCurrentHub = core.getCurrentHub;
    exports.getCurrentScope = core.getCurrentScope;
    exports.getGlobalScope = core.getGlobalScope;
    exports.getHubFromCarrier = core.getHubFromCarrier;
    exports.getIsolationScope = core.getIsolationScope;
    exports.getSpanStatusFromHttpCode = core.getSpanStatusFromHttpCode;
    exports.inboundFiltersIntegration = core.inboundFiltersIntegration;
    exports.isInitialized = core.isInitialized;
    exports.lastEventId = core.lastEventId;
    exports.linkedErrorsIntegration = core.linkedErrorsIntegration;
    exports.makeMain = core.makeMain;
    exports.metrics = core.metrics;
    exports.parameterize = core.parameterize;
    exports.requestDataIntegration = core.requestDataIntegration;
    exports.runWithAsyncContext = core.runWithAsyncContext;
    exports.setContext = core.setContext;
    exports.setCurrentClient = core.setCurrentClient;
    exports.setExtra = core.setExtra;
    exports.setExtras = core.setExtras;
    exports.setHttpStatus = core.setHttpStatus;
    exports.setMeasurement = core.setMeasurement;
    exports.setTag = core.setTag;
    exports.setTags = core.setTags;
    exports.setUser = core.setUser;
    exports.spanStatusfromHttpCode = core.spanStatusfromHttpCode;
    exports.startActiveSpan = core.startActiveSpan;
    exports.startInactiveSpan = core.startInactiveSpan;
    exports.startSession = core.startSession;
    exports.startSpan = core.startSpan;
    exports.startSpanManual = core.startSpanManual;
    exports.startTransaction = core.startTransaction;
    exports.trace = core.trace;
    exports.withActiveSpan = core.withActiveSpan;
    exports.withIsolationScope = core.withIsolationScope;
    exports.withMonitor = core.withMonitor;
    exports.withScope = core.withScope;
    exports.autoDiscoverNodePerformanceMonitoringIntegrations = index.autoDiscoverNodePerformanceMonitoringIntegrations;
    exports.NodeClient = client.NodeClient;
    exports.makeNodeTransport = http.makeNodeTransport;
    exports.defaultIntegrations = sdk.defaultIntegrations;
    exports.defaultStackParser = sdk.defaultStackParser;
    exports.getDefaultIntegrations = sdk.getDefaultIntegrations;
    exports.getSentryRelease = sdk.getSentryRelease;
    exports.init = sdk.init;
    exports.DEFAULT_USER_INCLUDES = utils.DEFAULT_USER_INCLUDES;
    exports.addRequestDataToEvent = utils.addRequestDataToEvent;
    exports.extractRequestData = utils.extractRequestData;
    exports.deepReadDirSync = utils$1.deepReadDirSync;
    exports.createGetModuleFromFilename = module$1.createGetModuleFromFilename;
    exports.enableAnrDetection = legacy.enableAnrDetection;
    exports.Handlers = handlers;
    exports.captureConsoleIntegration = integrations.captureConsoleIntegration;
    exports.debugIntegration = integrations.debugIntegration;
    exports.dedupeIntegration = integrations.dedupeIntegration;
    exports.extraErrorDataIntegration = integrations.extraErrorDataIntegration;
    exports.httpClientIntegration = integrations.httpClientIntegration;
    exports.reportingObserverIntegration = integrations.reportingObserverIntegration;
    exports.rewriteFramesIntegration = integrations.rewriteFramesIntegration;
    exports.sessionTimingIntegration = integrations.sessionTimingIntegration;
    exports.consoleIntegration = console2.consoleIntegration;
    exports.onUncaughtExceptionIntegration = onuncaughtexception.onUncaughtExceptionIntegration;
    exports.onUnhandledRejectionIntegration = onunhandledrejection.onUnhandledRejectionIntegration;
    exports.modulesIntegration = modules.modulesIntegration;
    exports.contextLinesIntegration = contextlines.contextLinesIntegration;
    exports.nodeContextIntegration = context2.nodeContextIntegration;
    exports.localVariablesIntegration = index$1.localVariablesIntegration;
    exports.spotlightIntegration = spotlight.spotlightIntegration;
    exports.anrIntegration = index$2.anrIntegration;
    exports.hapiErrorPlugin = index$3.hapiErrorPlugin;
    exports.hapiIntegration = index$3.hapiIntegration;
    exports.Undici = index$4.Undici;
    exports.nativeNodeFetchintegration = index$4.nativeNodeFetchintegration;
    exports.Http = http$1.Http;
    exports.httpIntegration = http$1.httpIntegration;
    exports.trpcMiddleware = trpc.trpcMiddleware;
    exports.Integrations = Integrations;
    exports.cron = cron;
    exports.getModuleFromFilename = getModuleFromFilename;
  }
});

// src/main.ts
init_define_ENV_DEFINED_IN_BUILD_STEP();

// ../../../node_modules/.pnpm/commander@11.1.0/node_modules/commander/esm.mjs
init_define_ENV_DEFINED_IN_BUILD_STEP();
var import_index = __toESM(require_commander(), 1);
var {
  program,
  createCommand,
  createArgument,
  createOption,
  CommanderError,
  InvalidArgumentError,
  InvalidOptionArgumentError,
  // deprecated old name
  Command,
  Argument,
  Option,
  Help
} = import_index.default;

// src/commands/machine/index.ts
init_define_ENV_DEFINED_IN_BUILD_STEP();

// src/commands/machine/translate.ts
init_define_ENV_DEFINED_IN_BUILD_STEP();

// ../rpc/dist/index.js
init_define_ENV_DEFINED_IN_BUILD_STEP();

// ../rpc/dist/client.js
init_define_ENV_DEFINED_IN_BUILD_STEP();
var import_typed_rpc = __toESM(require_client(), 1);

// ../rpc/dist/services/env-variables/index.js
init_define_ENV_DEFINED_IN_BUILD_STEP();
var PUBLIC_ENV_VARIABLES = {
  PUBLIC_SERVER_BASE_URL: "https://inlang.com",
  PUBLIC_ALLOWED_AUTH_URLS: "https://inlang.com,https://manage.inlang.com,https://fink.inlang.com"
};

// ../rpc/dist/client.js
var route = "/_rpc";
var rpc = (0, import_typed_rpc.rpcClient)(PUBLIC_ENV_VARIABLES.PUBLIC_SERVER_BASE_URL + route);

// src/utilities/getInlangProject.ts
init_define_ENV_DEFINED_IN_BUILD_STEP();
import fs from "node:fs";

// ../sdk/dist/index.js
init_define_ENV_DEFINED_IN_BUILD_STEP();

// ../sdk/dist/project/newProject.js
init_define_ENV_DEFINED_IN_BUILD_STEP();

// ../../../packages/lix-sdk/dist/account/database-schema.js
init_define_ENV_DEFINED_IN_BUILD_STEP();
var import_human_id = __toESM(require_dist(), 1);
function applyAccountDatabaseSchema(sqlite2) {
  const anonymousAccountName = `Anonymous ${(0, import_human_id.humanId)({
    capitalize: true,
    adjectiveCount: 0,
    separator: "_"
  }).split("_")[0].slice(0, -1)}`;
  const sql2 = `
  CREATE TABLE IF NOT EXISTS account (
    id TEXT PRIMARY KEY DEFAULT (uuid_v7()),
    name TEXT NOT NULL
  ) STRICT;

  -- current account(s)
  -- temp table because current accounts are session
  -- specific and should not be persisted
  CREATE TEMP TABLE IF NOT EXISTS active_account (
    id TEXT PRIMARY KEY,
    name TEXT NOT NULL
    -- can't use foreign keys in temp tables... :(
  ) STRICT;

  -- default to a new account
  INSERT INTO active_account (id, name) values (uuid_v7(), '${anonymousAccountName}');
`;
  return sqlite2.exec(sql2);
}

// ../../../packages/lix-sdk/dist/change/create-change.js
init_define_ENV_DEFINED_IN_BUILD_STEP();

// ../../../packages/lix-sdk/dist/database/execute-sync.js
init_define_ENV_DEFINED_IN_BUILD_STEP();
function executeSync(args) {
  const compiledQuery = args.query.compile();
  const columnNames = [];
  const result = args.lix.sqlite.exec({
    sql: compiledQuery.sql,
    bind: compiledQuery.parameters,
    returnValue: "resultRows",
    columnNames
  });
  return result.map((row) => {
    const obj = {};
    columnNames.forEach((columnName, index) => {
      obj[columnName] = row[index];
    });
    for (const col of Object.keys(obj)) {
      const raw = obj[col];
      if (!(raw instanceof Uint8Array)) {
        continue;
      }
      try {
        const json = args.lix.sqlite.exec("SELECT json(?)", {
          bind: [raw],
          returnValue: "resultRows"
        })[0][0];
        obj[col] = JSON.parse(json);
      } catch {
        continue;
      }
    }
    return obj;
  });
}

// ../../../packages/lix-sdk/dist/change/create-change.js
function createChange(args) {
  const snapshot = executeSync({
    lix: args.lix,
    query: args.lix.db.insertInto("snapshot").values({
      content: args.snapshotContent ?? null
    }).onConflict((oc) => oc.doUpdateSet((eb) => ({
      content: eb.ref("excluded.content")
    }))).returning("id")
  })[0];
  const change = executeSync({
    lix: args.lix,
    query: args.lix.db.insertInto("change").values({
      entity_id: args.entityId,
      plugin_key: args.pluginKey,
      file_id: args.fileId,
      schema_key: args.schemaKey,
      snapshot_id: snapshot.id
    }).returningAll()
  })[0];
  if (args.authors.length > 0) {
    for (const author of args.authors) {
      executeSync({
        lix: args.lix,
        query: args.lix.db.insertInto("change_author").values({
          change_id: change.id,
          account_id: author.id
        })
      });
    }
  }
  return change;
}

// ../../../packages/lix-sdk/dist/change-set/create-change-set.js
init_define_ENV_DEFINED_IN_BUILD_STEP();
async function createChangeSet(args) {
  const executeInTransaction = async (trx) => {
    const changeSet = await trx.insertInto("change_set").values({
      id: args.id,
      // needs to be false when creating the change set to insert elements
      immutable_elements: false
    }).returningAll().executeTakeFirstOrThrow();
    if (args.elements && args.elements.length > 0) {
      await trx.insertInto("change_set_element").values(args.elements.map((element) => ({
        change_set_id: changeSet.id,
        ...element
      }))).execute();
    }
    if (args.labels && args.labels.length > 0) {
      await trx.insertInto("change_set_label").values(args.labels.map((label) => ({
        label_id: label.id,
        change_set_id: changeSet.id
      }))).execute();
    }
    const updatedCs = await trx.updateTable("change_set").set({ immutable_elements: args.immutableElements ?? true }).where("id", "=", changeSet.id).returningAll().executeTakeFirstOrThrow();
    for (const parent of args.parents ?? []) {
      await trx.insertInto("change_set_edge").values({
        parent_id: parent.id,
        child_id: changeSet.id
      }).onConflict((oc) => oc.doNothing()).execute();
    }
    return updatedCs;
  };
  if (args.lix.db.isTransaction) {
    return executeInTransaction(args.lix.db);
  } else {
    return args.lix.db.transaction().execute(executeInTransaction);
  }
}

// ../../../packages/lix-sdk/dist/change-set/database-schema.js
init_define_ENV_DEFINED_IN_BUILD_STEP();
function applyChangeSetDatabaseSchema(sqlite2) {
  const sql2 = `
  CREATE TABLE IF NOT EXISTS change_set (
    id TEXT PRIMARY KEY DEFAULT (uuid_v7()),
    
    -- needs to default to 0 to allow inserting elements 
    -- after creating the change set. SQLite does not 
    -- support statement or on commit triggers (yet).
    immutable_elements INTEGER NOT NULL DEFAULT 0
  ) STRICT;

  CREATE TABLE IF NOT EXISTS change_set_element (
    
    change_set_id TEXT NOT NULL,
    change_id TEXT NOT NULL,

    -- entity changes must be unique per change set
    -- otherwise, a change (not set) graph is required
    -- https://github.com/opral/lix-sdk/issues/290

    entity_id TEXT NOT NULL,
    schema_key TEXT NOT NULL,
    file_id TEXT NOT NULL,
    UNIQUE (change_set_id, entity_id, schema_key, file_id),

    PRIMARY KEY(change_set_id, change_id),
    FOREIGN KEY(change_set_id) REFERENCES change_set(id) ON DELETE CASCADE,    
    FOREIGN KEY (change_id, entity_id, schema_key, file_id) REFERENCES change(id, entity_id, schema_key, file_id) ON DELETE CASCADE
  ) STRICT;

  -- Trigger to prevent INSERTING elements into an immutable change set
  CREATE TRIGGER IF NOT EXISTS prevent_immutable_element_insert
  BEFORE INSERT ON change_set_element
  FOR EACH ROW
  WHEN (SELECT immutable_elements FROM change_set WHERE id = NEW.change_set_id) = 1
  BEGIN
    SELECT RAISE(ABORT, 'Attempted to insert elements into a change set with immutable elements');
  END;

  -- Trigger to prevent UPDATING elements in an immutable change set
  CREATE TRIGGER IF NOT EXISTS prevent_immutable_element_update
  BEFORE UPDATE ON change_set_element
  FOR EACH ROW
  WHEN (SELECT immutable_elements FROM change_set WHERE id = OLD.change_set_id) = 1
  BEGIN
    SELECT RAISE(ABORT, 'Attempted to update elements of a change set with immutable elements');
  END;

  -- Trigger to prevent DELETING elements from an immutable change set
  CREATE TRIGGER IF NOT EXISTS prevent_immutable_element_delete
  BEFORE DELETE ON change_set_element
  FOR EACH ROW
  WHEN (SELECT immutable_elements FROM change_set WHERE id = OLD.change_set_id) = 1
  BEGIN
    SELECT RAISE(ABORT, 'Attempted to delete elements from a change set with immutable elements');
  END;

  -- Trigger to prevent changing the immutable flag once set
  -- CREATE TRIGGER IF NOT EXISTS prevent_immutable_flag_change
  -- BEFORE UPDATE OF immutable_elements ON change_set
  -- FOR EACH ROW
  -- WHEN OLD.immutable_elements = 1 AND NEW.immutable_elements = 0
  -- BEGIN
  --     SELECT RAISE(ABORT, 'Cannot set immutable_elements to false once it was set to true');
  -- END;

  CREATE TABLE IF NOT EXISTS change_set_label (
    change_set_id TEXT NOT NULL,
    label_id TEXT NOT NULL,
    PRIMARY KEY(change_set_id, label_id),
    FOREIGN KEY(label_id) REFERENCES label(id),
    FOREIGN KEY(change_set_id) REFERENCES change_set(id)
  ) STRICT;

  CREATE TABLE IF NOT EXISTS change_set_thread (
    change_set_id TEXT NOT NULL,
    thread_id TEXT NOT NULL,
  
    PRIMARY KEY(change_set_id, thread_id),
    FOREIGN KEY(thread_id) REFERENCES thread(id),
    FOREIGN KEY(change_set_id) REFERENCES change_set(id)
  ) STRICT;
`;
  return sqlite2.exec(sql2);
}

// ../../../node_modules/.pnpm/kysely@0.27.4/node_modules/kysely/dist/esm/kysely.js
init_define_ENV_DEFINED_IN_BUILD_STEP();

// ../../../node_modules/.pnpm/kysely@0.27.4/node_modules/kysely/dist/esm/schema/schema.js
init_define_ENV_DEFINED_IN_BUILD_STEP();

// ../../../node_modules/.pnpm/kysely@0.27.4/node_modules/kysely/dist/esm/operation-node/alter-table-node.js
init_define_ENV_DEFINED_IN_BUILD_STEP();

// ../../../node_modules/.pnpm/kysely@0.27.4/node_modules/kysely/dist/esm/util/object-utils.js
init_define_ENV_DEFINED_IN_BUILD_STEP();
function isUndefined(obj) {
  return typeof obj === "undefined" || obj === void 0;
}
function isString(obj) {
  return typeof obj === "string";
}
function isNumber(obj) {
  return typeof obj === "number";
}
function isBoolean(obj) {
  return typeof obj === "boolean";
}
function isNull(obj) {
  return obj === null;
}
function isDate(obj) {
  return obj instanceof Date;
}
function isBigInt(obj) {
  return typeof obj === "bigint";
}
function isFunction(obj) {
  return typeof obj === "function";
}
function isObject(obj) {
  return typeof obj === "object" && obj !== null;
}
function isPlainObject(obj) {
  if (!isObject(obj) || getTag(obj) !== "[object Object]") {
    return false;
  }
  if (Object.getPrototypeOf(obj) === null) {
    return true;
  }
  let proto = obj;
  while (Object.getPrototypeOf(proto) !== null) {
    proto = Object.getPrototypeOf(proto);
  }
  return Object.getPrototypeOf(obj) === proto;
}
function freeze(obj) {
  return Object.freeze(obj);
}
function asArray(arg) {
  if (isReadonlyArray(arg)) {
    return arg;
  } else {
    return [arg];
  }
}
function isReadonlyArray(arg) {
  return Array.isArray(arg);
}
function noop(obj) {
  return obj;
}
var toString = Object.prototype.toString;
function getTag(value) {
  if (value == null) {
    return value === void 0 ? "[object Undefined]" : "[object Null]";
  }
  return toString.call(value);
}

// ../../../node_modules/.pnpm/kysely@0.27.4/node_modules/kysely/dist/esm/operation-node/alter-table-node.js
var AlterTableNode = freeze({
  is(node) {
    return node.kind === "AlterTableNode";
  },
  create(table) {
    return freeze({
      kind: "AlterTableNode",
      table
    });
  },
  cloneWithTableProps(node, props) {
    return freeze({
      ...node,
      ...props
    });
  },
  cloneWithColumnAlteration(node, columnAlteration) {
    return freeze({
      ...node,
      columnAlterations: node.columnAlterations ? [...node.columnAlterations, columnAlteration] : [columnAlteration]
    });
  }
});

// ../../../node_modules/.pnpm/kysely@0.27.4/node_modules/kysely/dist/esm/operation-node/create-index-node.js
init_define_ENV_DEFINED_IN_BUILD_STEP();

// ../../../node_modules/.pnpm/kysely@0.27.4/node_modules/kysely/dist/esm/operation-node/identifier-node.js
init_define_ENV_DEFINED_IN_BUILD_STEP();
var IdentifierNode = freeze({
  is(node) {
    return node.kind === "IdentifierNode";
  },
  create(name) {
    return freeze({
      kind: "IdentifierNode",
      name
    });
  }
});

// ../../../node_modules/.pnpm/kysely@0.27.4/node_modules/kysely/dist/esm/operation-node/create-index-node.js
var CreateIndexNode = freeze({
  is(node) {
    return node.kind === "CreateIndexNode";
  },
  create(name) {
    return freeze({
      kind: "CreateIndexNode",
      name: IdentifierNode.create(name)
    });
  },
  cloneWith(node, props) {
    return freeze({
      ...node,
      ...props
    });
  },
  cloneWithColumns(node, columns) {
    return freeze({
      ...node,
      columns: [...node.columns || [], ...columns]
    });
  }
});

// ../../../node_modules/.pnpm/kysely@0.27.4/node_modules/kysely/dist/esm/operation-node/create-schema-node.js
init_define_ENV_DEFINED_IN_BUILD_STEP();
var CreateSchemaNode = freeze({
  is(node) {
    return node.kind === "CreateSchemaNode";
  },
  create(schema, params) {
    return freeze({
      kind: "CreateSchemaNode",
      schema: IdentifierNode.create(schema),
      ...params
    });
  },
  cloneWith(createSchema, params) {
    return freeze({
      ...createSchema,
      ...params
    });
  }
});

// ../../../node_modules/.pnpm/kysely@0.27.4/node_modules/kysely/dist/esm/operation-node/create-table-node.js
init_define_ENV_DEFINED_IN_BUILD_STEP();
var ON_COMMIT_ACTIONS = ["preserve rows", "delete rows", "drop"];
var CreateTableNode = freeze({
  is(node) {
    return node.kind === "CreateTableNode";
  },
  create(table) {
    return freeze({
      kind: "CreateTableNode",
      table,
      columns: freeze([])
    });
  },
  cloneWithColumn(createTable, column) {
    return freeze({
      ...createTable,
      columns: freeze([...createTable.columns, column])
    });
  },
  cloneWithConstraint(createTable, constraint) {
    return freeze({
      ...createTable,
      constraints: createTable.constraints ? freeze([...createTable.constraints, constraint]) : freeze([constraint])
    });
  },
  cloneWithFrontModifier(createTable, modifier) {
    return freeze({
      ...createTable,
      frontModifiers: createTable.frontModifiers ? freeze([...createTable.frontModifiers, modifier]) : freeze([modifier])
    });
  },
  cloneWithEndModifier(createTable, modifier) {
    return freeze({
      ...createTable,
      endModifiers: createTable.endModifiers ? freeze([...createTable.endModifiers, modifier]) : freeze([modifier])
    });
  },
  cloneWith(createTable, params) {
    return freeze({
      ...createTable,
      ...params
    });
  }
});

// ../../../node_modules/.pnpm/kysely@0.27.4/node_modules/kysely/dist/esm/operation-node/drop-index-node.js
init_define_ENV_DEFINED_IN_BUILD_STEP();

// ../../../node_modules/.pnpm/kysely@0.27.4/node_modules/kysely/dist/esm/operation-node/schemable-identifier-node.js
init_define_ENV_DEFINED_IN_BUILD_STEP();
var SchemableIdentifierNode = freeze({
  is(node) {
    return node.kind === "SchemableIdentifierNode";
  },
  create(identifier) {
    return freeze({
      kind: "SchemableIdentifierNode",
      identifier: IdentifierNode.create(identifier)
    });
  },
  createWithSchema(schema, identifier) {
    return freeze({
      kind: "SchemableIdentifierNode",
      schema: IdentifierNode.create(schema),
      identifier: IdentifierNode.create(identifier)
    });
  }
});

// ../../../node_modules/.pnpm/kysely@0.27.4/node_modules/kysely/dist/esm/operation-node/drop-index-node.js
var DropIndexNode = freeze({
  is(node) {
    return node.kind === "DropIndexNode";
  },
  create(name, params) {
    return freeze({
      kind: "DropIndexNode",
      name: SchemableIdentifierNode.create(name),
      ...params
    });
  },
  cloneWith(dropIndex, props) {
    return freeze({
      ...dropIndex,
      ...props
    });
  }
});

// ../../../node_modules/.pnpm/kysely@0.27.4/node_modules/kysely/dist/esm/operation-node/drop-schema-node.js
init_define_ENV_DEFINED_IN_BUILD_STEP();
var DropSchemaNode = freeze({
  is(node) {
    return node.kind === "DropSchemaNode";
  },
  create(schema, params) {
    return freeze({
      kind: "DropSchemaNode",
      schema: IdentifierNode.create(schema),
      ...params
    });
  },
  cloneWith(dropSchema, params) {
    return freeze({
      ...dropSchema,
      ...params
    });
  }
});

// ../../../node_modules/.pnpm/kysely@0.27.4/node_modules/kysely/dist/esm/operation-node/drop-table-node.js
init_define_ENV_DEFINED_IN_BUILD_STEP();
var DropTableNode = freeze({
  is(node) {
    return node.kind === "DropTableNode";
  },
  create(table, params) {
    return freeze({
      kind: "DropTableNode",
      table,
      ...params
    });
  },
  cloneWith(dropIndex, params) {
    return freeze({
      ...dropIndex,
      ...params
    });
  }
});

// ../../../node_modules/.pnpm/kysely@0.27.4/node_modules/kysely/dist/esm/parser/table-parser.js
init_define_ENV_DEFINED_IN_BUILD_STEP();

// ../../../node_modules/.pnpm/kysely@0.27.4/node_modules/kysely/dist/esm/operation-node/alias-node.js
init_define_ENV_DEFINED_IN_BUILD_STEP();
var AliasNode = freeze({
  is(node) {
    return node.kind === "AliasNode";
  },
  create(node, alias) {
    return freeze({
      kind: "AliasNode",
      node,
      alias
    });
  }
});

// ../../../node_modules/.pnpm/kysely@0.27.4/node_modules/kysely/dist/esm/operation-node/table-node.js
init_define_ENV_DEFINED_IN_BUILD_STEP();
var TableNode = freeze({
  is(node) {
    return node.kind === "TableNode";
  },
  create(table) {
    return freeze({
      kind: "TableNode",
      table: SchemableIdentifierNode.create(table)
    });
  },
  createWithSchema(schema, table) {
    return freeze({
      kind: "TableNode",
      table: SchemableIdentifierNode.createWithSchema(schema, table)
    });
  }
});

// ../../../node_modules/.pnpm/kysely@0.27.4/node_modules/kysely/dist/esm/parser/expression-parser.js
init_define_ENV_DEFINED_IN_BUILD_STEP();

// ../../../node_modules/.pnpm/kysely@0.27.4/node_modules/kysely/dist/esm/expression/expression.js
init_define_ENV_DEFINED_IN_BUILD_STEP();

// ../../../node_modules/.pnpm/kysely@0.27.4/node_modules/kysely/dist/esm/operation-node/operation-node-source.js
init_define_ENV_DEFINED_IN_BUILD_STEP();
function isOperationNodeSource(obj) {
  return isObject(obj) && isFunction(obj.toOperationNode);
}

// ../../../node_modules/.pnpm/kysely@0.27.4/node_modules/kysely/dist/esm/expression/expression.js
function isExpression(obj) {
  return isObject(obj) && "expressionType" in obj && isOperationNodeSource(obj);
}
function isAliasedExpression(obj) {
  return isObject(obj) && "expression" in obj && isString(obj.alias) && isOperationNodeSource(obj);
}

// ../../../node_modules/.pnpm/kysely@0.27.4/node_modules/kysely/dist/esm/expression/expression-builder.js
init_define_ENV_DEFINED_IN_BUILD_STEP();

// ../../../node_modules/.pnpm/kysely@0.27.4/node_modules/kysely/dist/esm/query-builder/select-query-builder.js
init_define_ENV_DEFINED_IN_BUILD_STEP();

// ../../../node_modules/.pnpm/kysely@0.27.4/node_modules/kysely/dist/esm/operation-node/select-modifier-node.js
init_define_ENV_DEFINED_IN_BUILD_STEP();
var SelectModifierNode = freeze({
  is(node) {
    return node.kind === "SelectModifierNode";
  },
  create(modifier, of) {
    return freeze({
      kind: "SelectModifierNode",
      modifier,
      of
    });
  },
  createWithExpression(modifier) {
    return freeze({
      kind: "SelectModifierNode",
      rawModifier: modifier
    });
  }
});

// ../../../node_modules/.pnpm/kysely@0.27.4/node_modules/kysely/dist/esm/parser/join-parser.js
init_define_ENV_DEFINED_IN_BUILD_STEP();

// ../../../node_modules/.pnpm/kysely@0.27.4/node_modules/kysely/dist/esm/operation-node/join-node.js
init_define_ENV_DEFINED_IN_BUILD_STEP();

// ../../../node_modules/.pnpm/kysely@0.27.4/node_modules/kysely/dist/esm/operation-node/on-node.js
init_define_ENV_DEFINED_IN_BUILD_STEP();

// ../../../node_modules/.pnpm/kysely@0.27.4/node_modules/kysely/dist/esm/operation-node/and-node.js
init_define_ENV_DEFINED_IN_BUILD_STEP();
var AndNode = freeze({
  is(node) {
    return node.kind === "AndNode";
  },
  create(left, right) {
    return freeze({
      kind: "AndNode",
      left,
      right
    });
  }
});

// ../../../node_modules/.pnpm/kysely@0.27.4/node_modules/kysely/dist/esm/operation-node/or-node.js
init_define_ENV_DEFINED_IN_BUILD_STEP();
var OrNode = freeze({
  is(node) {
    return node.kind === "OrNode";
  },
  create(left, right) {
    return freeze({
      kind: "OrNode",
      left,
      right
    });
  }
});

// ../../../node_modules/.pnpm/kysely@0.27.4/node_modules/kysely/dist/esm/operation-node/on-node.js
var OnNode = freeze({
  is(node) {
    return node.kind === "OnNode";
  },
  create(filter) {
    return freeze({
      kind: "OnNode",
      on: filter
    });
  },
  cloneWithOperation(onNode, operator, operation) {
    return freeze({
      ...onNode,
      on: operator === "And" ? AndNode.create(onNode.on, operation) : OrNode.create(onNode.on, operation)
    });
  }
});

// ../../../node_modules/.pnpm/kysely@0.27.4/node_modules/kysely/dist/esm/operation-node/join-node.js
var JoinNode = freeze({
  is(node) {
    return node.kind === "JoinNode";
  },
  create(joinType, table) {
    return freeze({
      kind: "JoinNode",
      joinType,
      table,
      on: void 0
    });
  },
  createWithOn(joinType, table, on) {
    return freeze({
      kind: "JoinNode",
      joinType,
      table,
      on: OnNode.create(on)
    });
  },
  cloneWithOn(joinNode, operation) {
    return freeze({
      ...joinNode,
      on: joinNode.on ? OnNode.cloneWithOperation(joinNode.on, "And", operation) : OnNode.create(operation)
    });
  }
});

// ../../../node_modules/.pnpm/kysely@0.27.4/node_modules/kysely/dist/esm/parser/binary-operation-parser.js
init_define_ENV_DEFINED_IN_BUILD_STEP();

// ../../../node_modules/.pnpm/kysely@0.27.4/node_modules/kysely/dist/esm/operation-node/binary-operation-node.js
init_define_ENV_DEFINED_IN_BUILD_STEP();
var BinaryOperationNode = freeze({
  is(node) {
    return node.kind === "BinaryOperationNode";
  },
  create(leftOperand, operator, rightOperand) {
    return freeze({
      kind: "BinaryOperationNode",
      leftOperand,
      operator,
      rightOperand
    });
  }
});

// ../../../node_modules/.pnpm/kysely@0.27.4/node_modules/kysely/dist/esm/operation-node/operator-node.js
init_define_ENV_DEFINED_IN_BUILD_STEP();
var COMPARISON_OPERATORS = [
  "=",
  "==",
  "!=",
  "<>",
  ">",
  ">=",
  "<",
  "<=",
  "in",
  "not in",
  "is",
  "is not",
  "like",
  "not like",
  "match",
  "ilike",
  "not ilike",
  "@>",
  "<@",
  "^@",
  "&&",
  "?",
  "?&",
  "?|",
  "!<",
  "!>",
  "<=>",
  "!~",
  "~",
  "~*",
  "!~*",
  "@@",
  "@@@",
  "!!",
  "<->",
  "regexp",
  "is distinct from",
  "is not distinct from"
];
var ARITHMETIC_OPERATORS = [
  "+",
  "-",
  "*",
  "/",
  "%",
  "^",
  "&",
  "|",
  "#",
  "<<",
  ">>"
];
var JSON_OPERATORS = ["->", "->>"];
var BINARY_OPERATORS = [
  ...COMPARISON_OPERATORS,
  ...ARITHMETIC_OPERATORS,
  "&&",
  "||"
];
var UNARY_FILTER_OPERATORS = ["exists", "not exists"];
var UNARY_OPERATORS = ["not", "-", ...UNARY_FILTER_OPERATORS];
var OPERATORS = [
  ...BINARY_OPERATORS,
  ...JSON_OPERATORS,
  ...UNARY_OPERATORS,
  "between",
  "between symmetric"
];
var OperatorNode = freeze({
  is(node) {
    return node.kind === "OperatorNode";
  },
  create(operator) {
    return freeze({
      kind: "OperatorNode",
      operator
    });
  }
});
function isJSONOperator(op) {
  return isString(op) && JSON_OPERATORS.includes(op);
}

// ../../../node_modules/.pnpm/kysely@0.27.4/node_modules/kysely/dist/esm/parser/reference-parser.js
init_define_ENV_DEFINED_IN_BUILD_STEP();

// ../../../node_modules/.pnpm/kysely@0.27.4/node_modules/kysely/dist/esm/operation-node/column-node.js
init_define_ENV_DEFINED_IN_BUILD_STEP();
var ColumnNode = freeze({
  is(node) {
    return node.kind === "ColumnNode";
  },
  create(column) {
    return freeze({
      kind: "ColumnNode",
      column: IdentifierNode.create(column)
    });
  }
});

// ../../../node_modules/.pnpm/kysely@0.27.4/node_modules/kysely/dist/esm/operation-node/reference-node.js
init_define_ENV_DEFINED_IN_BUILD_STEP();

// ../../../node_modules/.pnpm/kysely@0.27.4/node_modules/kysely/dist/esm/operation-node/select-all-node.js
init_define_ENV_DEFINED_IN_BUILD_STEP();
var SelectAllNode = freeze({
  is(node) {
    return node.kind === "SelectAllNode";
  },
  create() {
    return freeze({
      kind: "SelectAllNode"
    });
  }
});

// ../../../node_modules/.pnpm/kysely@0.27.4/node_modules/kysely/dist/esm/operation-node/reference-node.js
var ReferenceNode = freeze({
  is(node) {
    return node.kind === "ReferenceNode";
  },
  create(column, table) {
    return freeze({
      kind: "ReferenceNode",
      table,
      column
    });
  },
  createSelectAll(table) {
    return freeze({
      kind: "ReferenceNode",
      table,
      column: SelectAllNode.create()
    });
  }
});

// ../../../node_modules/.pnpm/kysely@0.27.4/node_modules/kysely/dist/esm/parser/order-by-parser.js
init_define_ENV_DEFINED_IN_BUILD_STEP();

// ../../../node_modules/.pnpm/kysely@0.27.4/node_modules/kysely/dist/esm/dynamic/dynamic-reference-builder.js
init_define_ENV_DEFINED_IN_BUILD_STEP();
var DynamicReferenceBuilder = class {
  #dynamicReference;
  get dynamicReference() {
    return this.#dynamicReference;
  }
  /**
   * @private
   *
   * This needs to be here just so that the typings work. Without this
   * the generated .d.ts file contains no reference to the type param R
   * which causes this type to be equal to DynamicReferenceBuilder with
   * any R.
   */
  get refType() {
    return void 0;
  }
  constructor(reference) {
    this.#dynamicReference = reference;
  }
  toOperationNode() {
    return parseSimpleReferenceExpression(this.#dynamicReference);
  }
};
function isDynamicReferenceBuilder(obj) {
  return isObject(obj) && isOperationNodeSource(obj) && isString(obj.dynamicReference);
}

// ../../../node_modules/.pnpm/kysely@0.27.4/node_modules/kysely/dist/esm/operation-node/order-by-item-node.js
init_define_ENV_DEFINED_IN_BUILD_STEP();
var OrderByItemNode = freeze({
  is(node) {
    return node.kind === "OrderByItemNode";
  },
  create(orderBy, direction) {
    return freeze({
      kind: "OrderByItemNode",
      orderBy,
      direction
    });
  }
});

// ../../../node_modules/.pnpm/kysely@0.27.4/node_modules/kysely/dist/esm/operation-node/raw-node.js
init_define_ENV_DEFINED_IN_BUILD_STEP();
var RawNode = freeze({
  is(node) {
    return node.kind === "RawNode";
  },
  create(sqlFragments, parameters) {
    return freeze({
      kind: "RawNode",
      sqlFragments: freeze(sqlFragments),
      parameters: freeze(parameters)
    });
  },
  createWithSql(sql2) {
    return RawNode.create([sql2], []);
  },
  createWithChild(child) {
    return RawNode.create(["", ""], [child]);
  },
  createWithChildren(children) {
    return RawNode.create(new Array(children.length + 1).fill(""), children);
  }
});

// ../../../node_modules/.pnpm/kysely@0.27.4/node_modules/kysely/dist/esm/parser/order-by-parser.js
function isOrderByDirection(thing) {
  return thing === "asc" || thing === "desc";
}
function parseOrderBy(args) {
  if (args.length === 2) {
    return [parseOrderByItem(args[0], args[1])];
  }
  if (args.length === 1) {
    const [orderBy] = args;
    if (Array.isArray(orderBy)) {
      return orderBy.map((item) => parseOrderByItem(item));
    }
    return [parseOrderByItem(orderBy)];
  }
  throw new Error(`Invalid number of arguments at order by! expected 1-2, received ${args.length}`);
}
function parseOrderByItem(ref, direction) {
  const parsedRef = parseOrderByExpression(ref);
  if (OrderByItemNode.is(parsedRef)) {
    if (direction) {
      throw new Error("Cannot specify direction twice!");
    }
    return parsedRef;
  }
  return OrderByItemNode.create(parsedRef, parseOrderByDirectionExpression(direction));
}
function parseOrderByExpression(expr) {
  if (isExpressionOrFactory(expr)) {
    return parseExpression(expr);
  }
  if (isDynamicReferenceBuilder(expr)) {
    return expr.toOperationNode();
  }
  const [ref, direction] = expr.split(" ");
  if (direction) {
    if (!isOrderByDirection(direction)) {
      throw new Error(`Invalid order by direction: ${direction}`);
    }
    return OrderByItemNode.create(parseStringReference(ref), parseOrderByDirectionExpression(direction));
  }
  return parseStringReference(expr);
}
function parseOrderByDirectionExpression(expr) {
  if (!expr) {
    return void 0;
  }
  if (expr === "asc" || expr === "desc") {
    return RawNode.createWithSql(expr);
  }
  return expr.toOperationNode();
}

// ../../../node_modules/.pnpm/kysely@0.27.4/node_modules/kysely/dist/esm/operation-node/json-reference-node.js
init_define_ENV_DEFINED_IN_BUILD_STEP();
var JSONReferenceNode = freeze({
  is(node) {
    return node.kind === "JSONReferenceNode";
  },
  create(reference, traversal) {
    return freeze({
      kind: "JSONReferenceNode",
      reference,
      traversal
    });
  },
  cloneWithTraversal(node, traversal) {
    return freeze({
      ...node,
      traversal
    });
  }
});

// ../../../node_modules/.pnpm/kysely@0.27.4/node_modules/kysely/dist/esm/operation-node/json-operator-chain-node.js
init_define_ENV_DEFINED_IN_BUILD_STEP();
var JSONOperatorChainNode = freeze({
  is(node) {
    return node.kind === "JSONOperatorChainNode";
  },
  create(operator) {
    return freeze({
      kind: "JSONOperatorChainNode",
      operator,
      values: freeze([])
    });
  },
  cloneWithValue(node, value) {
    return freeze({
      ...node,
      values: freeze([...node.values, value])
    });
  }
});

// ../../../node_modules/.pnpm/kysely@0.27.4/node_modules/kysely/dist/esm/operation-node/json-path-node.js
init_define_ENV_DEFINED_IN_BUILD_STEP();
var JSONPathNode = freeze({
  is(node) {
    return node.kind === "JSONPathNode";
  },
  create(inOperator) {
    return freeze({
      kind: "JSONPathNode",
      inOperator,
      pathLegs: freeze([])
    });
  },
  cloneWithLeg(jsonPathNode, pathLeg) {
    return freeze({
      ...jsonPathNode,
      pathLegs: freeze([...jsonPathNode.pathLegs, pathLeg])
    });
  }
});

// ../../../node_modules/.pnpm/kysely@0.27.4/node_modules/kysely/dist/esm/parser/reference-parser.js
function parseSimpleReferenceExpression(exp) {
  if (isString(exp)) {
    return parseStringReference(exp);
  }
  return exp.toOperationNode();
}
function parseReferenceExpressionOrList(arg) {
  if (isReadonlyArray(arg)) {
    return arg.map((it) => parseReferenceExpression(it));
  } else {
    return [parseReferenceExpression(arg)];
  }
}
function parseReferenceExpression(exp) {
  if (isExpressionOrFactory(exp)) {
    return parseExpression(exp);
  }
  return parseSimpleReferenceExpression(exp);
}
function parseJSONReference(ref, op) {
  const referenceNode = parseStringReference(ref);
  if (isJSONOperator(op)) {
    return JSONReferenceNode.create(referenceNode, JSONOperatorChainNode.create(OperatorNode.create(op)));
  }
  const opWithoutLastChar = op.slice(0, -1);
  if (isJSONOperator(opWithoutLastChar)) {
    return JSONReferenceNode.create(referenceNode, JSONPathNode.create(OperatorNode.create(opWithoutLastChar)));
  }
  throw new Error(`Invalid JSON operator: ${op}`);
}
function parseStringReference(ref) {
  const COLUMN_SEPARATOR = ".";
  if (!ref.includes(COLUMN_SEPARATOR)) {
    return ReferenceNode.create(ColumnNode.create(ref));
  }
  const parts = ref.split(COLUMN_SEPARATOR).map(trim);
  if (parts.length === 3) {
    return parseStringReferenceWithTableAndSchema(parts);
  }
  if (parts.length === 2) {
    return parseStringReferenceWithTable(parts);
  }
  throw new Error(`invalid column reference ${ref}`);
}
function parseAliasedStringReference(ref) {
  const ALIAS_SEPARATOR = " as ";
  if (ref.includes(ALIAS_SEPARATOR)) {
    const [columnRef, alias] = ref.split(ALIAS_SEPARATOR).map(trim);
    return AliasNode.create(parseStringReference(columnRef), IdentifierNode.create(alias));
  } else {
    return parseStringReference(ref);
  }
}
function parseColumnName(column) {
  return ColumnNode.create(column);
}
function parseOrderedColumnName(column) {
  const ORDER_SEPARATOR = " ";
  if (column.includes(ORDER_SEPARATOR)) {
    const [columnName, order] = column.split(ORDER_SEPARATOR).map(trim);
    if (!isOrderByDirection(order)) {
      throw new Error(`invalid order direction "${order}" next to "${columnName}"`);
    }
    return parseOrderBy([columnName, order])[0];
  } else {
    return parseColumnName(column);
  }
}
function parseStringReferenceWithTableAndSchema(parts) {
  const [schema, table, column] = parts;
  return ReferenceNode.create(ColumnNode.create(column), TableNode.createWithSchema(schema, table));
}
function parseStringReferenceWithTable(parts) {
  const [table, column] = parts;
  return ReferenceNode.create(ColumnNode.create(column), TableNode.create(table));
}
function trim(str) {
  return str.trim();
}

// ../../../node_modules/.pnpm/kysely@0.27.4/node_modules/kysely/dist/esm/parser/value-parser.js
init_define_ENV_DEFINED_IN_BUILD_STEP();

// ../../../node_modules/.pnpm/kysely@0.27.4/node_modules/kysely/dist/esm/operation-node/primitive-value-list-node.js
init_define_ENV_DEFINED_IN_BUILD_STEP();
var PrimitiveValueListNode = freeze({
  is(node) {
    return node.kind === "PrimitiveValueListNode";
  },
  create(values) {
    return freeze({
      kind: "PrimitiveValueListNode",
      values: freeze([...values])
    });
  }
});

// ../../../node_modules/.pnpm/kysely@0.27.4/node_modules/kysely/dist/esm/operation-node/value-list-node.js
init_define_ENV_DEFINED_IN_BUILD_STEP();
var ValueListNode = freeze({
  is(node) {
    return node.kind === "ValueListNode";
  },
  create(values) {
    return freeze({
      kind: "ValueListNode",
      values: freeze(values)
    });
  }
});

// ../../../node_modules/.pnpm/kysely@0.27.4/node_modules/kysely/dist/esm/operation-node/value-node.js
init_define_ENV_DEFINED_IN_BUILD_STEP();
var ValueNode = freeze({
  is(node) {
    return node.kind === "ValueNode";
  },
  create(value) {
    return freeze({
      kind: "ValueNode",
      value
    });
  },
  createImmediate(value) {
    return freeze({
      kind: "ValueNode",
      value,
      immediate: true
    });
  }
});

// ../../../node_modules/.pnpm/kysely@0.27.4/node_modules/kysely/dist/esm/parser/value-parser.js
function parseValueExpressionOrList(arg) {
  if (isReadonlyArray(arg)) {
    return parseValueExpressionList(arg);
  }
  return parseValueExpression(arg);
}
function parseValueExpression(exp) {
  if (isExpressionOrFactory(exp)) {
    return parseExpression(exp);
  }
  return ValueNode.create(exp);
}
function isSafeImmediateValue(value) {
  return isNumber(value) || isBoolean(value) || isNull(value);
}
function parseSafeImmediateValue(value) {
  if (!isSafeImmediateValue(value)) {
    throw new Error(`unsafe immediate value ${JSON.stringify(value)}`);
  }
  return ValueNode.createImmediate(value);
}
function parseValueExpressionList(arg) {
  if (arg.some(isExpressionOrFactory)) {
    return ValueListNode.create(arg.map((it) => parseValueExpression(it)));
  }
  return PrimitiveValueListNode.create(arg);
}

// ../../../node_modules/.pnpm/kysely@0.27.4/node_modules/kysely/dist/esm/operation-node/parens-node.js
init_define_ENV_DEFINED_IN_BUILD_STEP();
var ParensNode = freeze({
  is(node) {
    return node.kind === "ParensNode";
  },
  create(node) {
    return freeze({
      kind: "ParensNode",
      node
    });
  }
});

// ../../../node_modules/.pnpm/kysely@0.27.4/node_modules/kysely/dist/esm/parser/binary-operation-parser.js
function parseValueBinaryOperationOrExpression(args) {
  if (args.length === 3) {
    return parseValueBinaryOperation(args[0], args[1], args[2]);
  } else if (args.length === 1) {
    return parseValueExpression(args[0]);
  }
  throw new Error(`invalid arguments: ${JSON.stringify(args)}`);
}
function parseValueBinaryOperation(left, operator, right) {
  if (isIsOperator(operator) && needsIsOperator(right)) {
    return BinaryOperationNode.create(parseReferenceExpression(left), parseOperator(operator), ValueNode.createImmediate(right));
  }
  return BinaryOperationNode.create(parseReferenceExpression(left), parseOperator(operator), parseValueExpressionOrList(right));
}
function parseReferentialBinaryOperation(left, operator, right) {
  return BinaryOperationNode.create(parseReferenceExpression(left), parseOperator(operator), parseReferenceExpression(right));
}
function parseFilterObject(obj, combinator) {
  return parseFilterList(Object.entries(obj).filter(([, v3]) => !isUndefined(v3)).map(([k2, v3]) => parseValueBinaryOperation(k2, needsIsOperator(v3) ? "is" : "=", v3)), combinator);
}
function parseFilterList(list, combinator, withParens = true) {
  const combine = combinator === "and" ? AndNode.create : OrNode.create;
  if (list.length === 0) {
    return BinaryOperationNode.create(ValueNode.createImmediate(1), OperatorNode.create("="), ValueNode.createImmediate(combinator === "and" ? 1 : 0));
  }
  let node = toOperationNode(list[0]);
  for (let i2 = 1; i2 < list.length; ++i2) {
    node = combine(node, toOperationNode(list[i2]));
  }
  if (list.length > 1 && withParens) {
    return ParensNode.create(node);
  }
  return node;
}
function isIsOperator(operator) {
  return operator === "is" || operator === "is not";
}
function needsIsOperator(value) {
  return isNull(value) || isBoolean(value);
}
function parseOperator(operator) {
  if (isString(operator) && OPERATORS.includes(operator)) {
    return OperatorNode.create(operator);
  }
  if (isOperationNodeSource(operator)) {
    return operator.toOperationNode();
  }
  throw new Error(`invalid operator ${JSON.stringify(operator)}`);
}
function toOperationNode(nodeOrSource) {
  return isOperationNodeSource(nodeOrSource) ? nodeOrSource.toOperationNode() : nodeOrSource;
}

// ../../../node_modules/.pnpm/kysely@0.27.4/node_modules/kysely/dist/esm/parser/parse-utils.js
init_define_ENV_DEFINED_IN_BUILD_STEP();

// ../../../node_modules/.pnpm/kysely@0.27.4/node_modules/kysely/dist/esm/operation-node/over-node.js
init_define_ENV_DEFINED_IN_BUILD_STEP();

// ../../../node_modules/.pnpm/kysely@0.27.4/node_modules/kysely/dist/esm/operation-node/order-by-node.js
init_define_ENV_DEFINED_IN_BUILD_STEP();
var OrderByNode = freeze({
  is(node) {
    return node.kind === "OrderByNode";
  },
  create(items) {
    return freeze({
      kind: "OrderByNode",
      items: freeze([...items])
    });
  },
  cloneWithItems(orderBy, items) {
    return freeze({
      ...orderBy,
      items: freeze([...orderBy.items, ...items])
    });
  }
});

// ../../../node_modules/.pnpm/kysely@0.27.4/node_modules/kysely/dist/esm/operation-node/partition-by-node.js
init_define_ENV_DEFINED_IN_BUILD_STEP();
var PartitionByNode = freeze({
  is(node) {
    return node.kind === "PartitionByNode";
  },
  create(items) {
    return freeze({
      kind: "PartitionByNode",
      items: freeze(items)
    });
  },
  cloneWithItems(partitionBy, items) {
    return freeze({
      ...partitionBy,
      items: freeze([...partitionBy.items, ...items])
    });
  }
});

// ../../../node_modules/.pnpm/kysely@0.27.4/node_modules/kysely/dist/esm/operation-node/over-node.js
var OverNode = freeze({
  is(node) {
    return node.kind === "OverNode";
  },
  create() {
    return freeze({
      kind: "OverNode"
    });
  },
  cloneWithOrderByItems(overNode, items) {
    return freeze({
      ...overNode,
      orderBy: overNode.orderBy ? OrderByNode.cloneWithItems(overNode.orderBy, items) : OrderByNode.create(items)
    });
  },
  cloneWithPartitionByItems(overNode, items) {
    return freeze({
      ...overNode,
      partitionBy: overNode.partitionBy ? PartitionByNode.cloneWithItems(overNode.partitionBy, items) : PartitionByNode.create(items)
    });
  }
});

// ../../../node_modules/.pnpm/kysely@0.27.4/node_modules/kysely/dist/esm/operation-node/select-query-node.js
init_define_ENV_DEFINED_IN_BUILD_STEP();

// ../../../node_modules/.pnpm/kysely@0.27.4/node_modules/kysely/dist/esm/operation-node/from-node.js
init_define_ENV_DEFINED_IN_BUILD_STEP();
var FromNode = freeze({
  is(node) {
    return node.kind === "FromNode";
  },
  create(froms) {
    return freeze({
      kind: "FromNode",
      froms: freeze(froms)
    });
  },
  cloneWithFroms(from, froms) {
    return freeze({
      ...from,
      froms: freeze([...from.froms, ...froms])
    });
  }
});

// ../../../node_modules/.pnpm/kysely@0.27.4/node_modules/kysely/dist/esm/operation-node/group-by-node.js
init_define_ENV_DEFINED_IN_BUILD_STEP();
var GroupByNode = freeze({
  is(node) {
    return node.kind === "GroupByNode";
  },
  create(items) {
    return freeze({
      kind: "GroupByNode",
      items: freeze(items)
    });
  },
  cloneWithItems(groupBy, items) {
    return freeze({
      ...groupBy,
      items: freeze([...groupBy.items, ...items])
    });
  }
});

// ../../../node_modules/.pnpm/kysely@0.27.4/node_modules/kysely/dist/esm/operation-node/having-node.js
init_define_ENV_DEFINED_IN_BUILD_STEP();
var HavingNode = freeze({
  is(node) {
    return node.kind === "HavingNode";
  },
  create(filter) {
    return freeze({
      kind: "HavingNode",
      having: filter
    });
  },
  cloneWithOperation(havingNode, operator, operation) {
    return freeze({
      ...havingNode,
      having: operator === "And" ? AndNode.create(havingNode.having, operation) : OrNode.create(havingNode.having, operation)
    });
  }
});

// ../../../node_modules/.pnpm/kysely@0.27.4/node_modules/kysely/dist/esm/operation-node/select-query-node.js
var SelectQueryNode = freeze({
  is(node) {
    return node.kind === "SelectQueryNode";
  },
  create(withNode) {
    return freeze({
      kind: "SelectQueryNode",
      ...withNode && { with: withNode }
    });
  },
  createFrom(fromItems, withNode) {
    return freeze({
      kind: "SelectQueryNode",
      from: FromNode.create(fromItems),
      ...withNode && { with: withNode }
    });
  },
  cloneWithSelections(select, selections) {
    return freeze({
      ...select,
      selections: select.selections ? freeze([...select.selections, ...selections]) : freeze(selections)
    });
  },
  cloneWithDistinctOn(select, expressions) {
    return freeze({
      ...select,
      distinctOn: select.distinctOn ? freeze([...select.distinctOn, ...expressions]) : freeze(expressions)
    });
  },
  cloneWithFrontModifier(select, modifier) {
    return freeze({
      ...select,
      frontModifiers: select.frontModifiers ? freeze([...select.frontModifiers, modifier]) : freeze([modifier])
    });
  },
  cloneWithEndModifier(select, modifier) {
    return freeze({
      ...select,
      endModifiers: select.endModifiers ? freeze([...select.endModifiers, modifier]) : freeze([modifier])
    });
  },
  cloneWithOrderByItems(selectNode, items) {
    return freeze({
      ...selectNode,
      orderBy: selectNode.orderBy ? OrderByNode.cloneWithItems(selectNode.orderBy, items) : OrderByNode.create(items)
    });
  },
  cloneWithGroupByItems(selectNode, items) {
    return freeze({
      ...selectNode,
      groupBy: selectNode.groupBy ? GroupByNode.cloneWithItems(selectNode.groupBy, items) : GroupByNode.create(items)
    });
  },
  cloneWithLimit(selectNode, limit) {
    return freeze({
      ...selectNode,
      limit
    });
  },
  cloneWithOffset(selectNode, offset) {
    return freeze({
      ...selectNode,
      offset
    });
  },
  cloneWithFetch(selectNode, fetch2) {
    return freeze({
      ...selectNode,
      fetch: fetch2
    });
  },
  cloneWithHaving(selectNode, operation) {
    return freeze({
      ...selectNode,
      having: selectNode.having ? HavingNode.cloneWithOperation(selectNode.having, "And", operation) : HavingNode.create(operation)
    });
  },
  cloneWithSetOperations(selectNode, setOperations) {
    return freeze({
      ...selectNode,
      setOperations: selectNode.setOperations ? freeze([...selectNode.setOperations, ...setOperations]) : freeze([...setOperations])
    });
  },
  cloneWithoutSelections(select) {
    return freeze({
      ...select,
      selections: []
    });
  },
  cloneWithoutLimit(select) {
    return freeze({
      ...select,
      limit: void 0
    });
  },
  cloneWithoutOffset(select) {
    return freeze({
      ...select,
      offset: void 0
    });
  },
  cloneWithoutOrderBy(select) {
    return freeze({
      ...select,
      orderBy: void 0
    });
  },
  cloneWithoutGroupBy(select) {
    return freeze({
      ...select,
      groupBy: void 0
    });
  }
});

// ../../../node_modules/.pnpm/kysely@0.27.4/node_modules/kysely/dist/esm/query-builder/join-builder.js
init_define_ENV_DEFINED_IN_BUILD_STEP();

// ../../../node_modules/.pnpm/kysely@0.27.4/node_modules/kysely/dist/esm/util/prevent-await.js
init_define_ENV_DEFINED_IN_BUILD_STEP();
function preventAwait(clazz, message) {
  Object.defineProperties(clazz.prototype, {
    then: {
      enumerable: false,
      value: () => {
        throw new Error(message);
      }
    }
  });
}

// ../../../node_modules/.pnpm/kysely@0.27.4/node_modules/kysely/dist/esm/query-builder/join-builder.js
var JoinBuilder = class _JoinBuilder {
  #props;
  constructor(props) {
    this.#props = freeze(props);
  }
  on(...args) {
    return new _JoinBuilder({
      ...this.#props,
      joinNode: JoinNode.cloneWithOn(this.#props.joinNode, parseValueBinaryOperationOrExpression(args))
    });
  }
  /**
   * Just like {@link WhereInterface.whereRef} but adds an item to the join's
   * `on` clause instead.
   *
   * See {@link WhereInterface.whereRef} for documentation and examples.
   */
  onRef(lhs, op, rhs) {
    return new _JoinBuilder({
      ...this.#props,
      joinNode: JoinNode.cloneWithOn(this.#props.joinNode, parseReferentialBinaryOperation(lhs, op, rhs))
    });
  }
  /**
   * Adds `on true`.
   */
  onTrue() {
    return new _JoinBuilder({
      ...this.#props,
      joinNode: JoinNode.cloneWithOn(this.#props.joinNode, RawNode.createWithSql("true"))
    });
  }
  /**
   * Simply calls the provided function passing `this` as the only argument. `$call` returns
   * what the provided function returns.
   */
  $call(func) {
    return func(this);
  }
  toOperationNode() {
    return this.#props.joinNode;
  }
};
preventAwait(JoinBuilder, "don't await JoinBuilder instances. They are never executed directly and are always just a part of a query.");

// ../../../node_modules/.pnpm/kysely@0.27.4/node_modules/kysely/dist/esm/query-builder/over-builder.js
init_define_ENV_DEFINED_IN_BUILD_STEP();

// ../../../node_modules/.pnpm/kysely@0.27.4/node_modules/kysely/dist/esm/parser/partition-by-parser.js
init_define_ENV_DEFINED_IN_BUILD_STEP();

// ../../../node_modules/.pnpm/kysely@0.27.4/node_modules/kysely/dist/esm/operation-node/partition-by-item-node.js
init_define_ENV_DEFINED_IN_BUILD_STEP();
var PartitionByItemNode = freeze({
  is(node) {
    return node.kind === "PartitionByItemNode";
  },
  create(partitionBy) {
    return freeze({
      kind: "PartitionByItemNode",
      partitionBy
    });
  }
});

// ../../../node_modules/.pnpm/kysely@0.27.4/node_modules/kysely/dist/esm/parser/partition-by-parser.js
function parsePartitionBy(partitionBy) {
  return parseReferenceExpressionOrList(partitionBy).map(PartitionByItemNode.create);
}

// ../../../node_modules/.pnpm/kysely@0.27.4/node_modules/kysely/dist/esm/query-builder/over-builder.js
var OverBuilder = class _OverBuilder {
  #props;
  constructor(props) {
    this.#props = freeze(props);
  }
  /**
   * Adds an order by clause item inside the over function.
   *
   * ```ts
   * const result = await db
   *   .selectFrom('person')
   *   .select(
   *     (eb) => eb.fn.avg<number>('age').over(
   *       ob => ob.orderBy('first_name', 'asc').orderBy('last_name', 'asc')
   *     ).as('average_age')
   *   )
   *   .execute()
   * ```
   *
   * The generated SQL (PostgreSQL):
   *
   * ```sql
   * select avg("age") over(order by "first_name" asc, "last_name" asc) as "average_age"
   * from "person"
   * ```
   */
  orderBy(orderBy, direction) {
    return new _OverBuilder({
      overNode: OverNode.cloneWithOrderByItems(this.#props.overNode, parseOrderBy([orderBy, direction]))
    });
  }
  partitionBy(partitionBy) {
    return new _OverBuilder({
      overNode: OverNode.cloneWithPartitionByItems(this.#props.overNode, parsePartitionBy(partitionBy))
    });
  }
  /**
   * Simply calls the provided function passing `this` as the only argument. `$call` returns
   * what the provided function returns.
   */
  $call(func) {
    return func(this);
  }
  toOperationNode() {
    return this.#props.overNode;
  }
};
preventAwait(OverBuilder, "don't await OverBuilder instances. They are never executed directly and are always just a part of a query.");

// ../../../node_modules/.pnpm/kysely@0.27.4/node_modules/kysely/dist/esm/query-creator.js
init_define_ENV_DEFINED_IN_BUILD_STEP();

// ../../../node_modules/.pnpm/kysely@0.27.4/node_modules/kysely/dist/esm/query-builder/insert-query-builder.js
init_define_ENV_DEFINED_IN_BUILD_STEP();

// ../../../node_modules/.pnpm/kysely@0.27.4/node_modules/kysely/dist/esm/parser/select-parser.js
init_define_ENV_DEFINED_IN_BUILD_STEP();

// ../../../node_modules/.pnpm/kysely@0.27.4/node_modules/kysely/dist/esm/operation-node/selection-node.js
init_define_ENV_DEFINED_IN_BUILD_STEP();
var SelectionNode = freeze({
  is(node) {
    return node.kind === "SelectionNode";
  },
  create(selection) {
    return freeze({
      kind: "SelectionNode",
      selection
    });
  },
  createSelectAll() {
    return freeze({
      kind: "SelectionNode",
      selection: SelectAllNode.create()
    });
  },
  createSelectAllFromTable(table) {
    return freeze({
      kind: "SelectionNode",
      selection: ReferenceNode.createSelectAll(table)
    });
  }
});

// ../../../node_modules/.pnpm/kysely@0.27.4/node_modules/kysely/dist/esm/parser/select-parser.js
function parseSelectArg(selection) {
  if (isFunction(selection)) {
    return parseSelectArg(selection(expressionBuilder()));
  } else if (isReadonlyArray(selection)) {
    return selection.map((it) => parseSelectExpression(it));
  } else {
    return [parseSelectExpression(selection)];
  }
}
function parseSelectExpression(selection) {
  if (isString(selection)) {
    return SelectionNode.create(parseAliasedStringReference(selection));
  } else if (isDynamicReferenceBuilder(selection)) {
    return SelectionNode.create(selection.toOperationNode());
  } else {
    return SelectionNode.create(parseAliasedExpression(selection));
  }
}
function parseSelectAll(table) {
  if (!table) {
    return [SelectionNode.createSelectAll()];
  } else if (Array.isArray(table)) {
    return table.map(parseSelectAllArg);
  } else {
    return [parseSelectAllArg(table)];
  }
}
function parseSelectAllArg(table) {
  if (isString(table)) {
    return SelectionNode.createSelectAllFromTable(parseTable(table));
  }
  throw new Error(`invalid value selectAll expression: ${JSON.stringify(table)}`);
}

// ../../../node_modules/.pnpm/kysely@0.27.4/node_modules/kysely/dist/esm/parser/insert-values-parser.js
init_define_ENV_DEFINED_IN_BUILD_STEP();

// ../../../node_modules/.pnpm/kysely@0.27.4/node_modules/kysely/dist/esm/operation-node/values-node.js
init_define_ENV_DEFINED_IN_BUILD_STEP();
var ValuesNode = freeze({
  is(node) {
    return node.kind === "ValuesNode";
  },
  create(values) {
    return freeze({
      kind: "ValuesNode",
      values: freeze(values)
    });
  }
});

// ../../../node_modules/.pnpm/kysely@0.27.4/node_modules/kysely/dist/esm/operation-node/default-insert-value-node.js
init_define_ENV_DEFINED_IN_BUILD_STEP();
var DefaultInsertValueNode = freeze({
  is(node) {
    return node.kind === "DefaultInsertValueNode";
  },
  create() {
    return freeze({
      kind: "DefaultInsertValueNode"
    });
  }
});

// ../../../node_modules/.pnpm/kysely@0.27.4/node_modules/kysely/dist/esm/parser/insert-values-parser.js
function parseInsertExpression(arg) {
  const objectOrList = isFunction(arg) ? arg(expressionBuilder()) : arg;
  const list = isReadonlyArray(objectOrList) ? objectOrList : freeze([objectOrList]);
  return parseInsertColumnsAndValues(list);
}
function parseInsertColumnsAndValues(rows) {
  const columns = parseColumnNamesAndIndexes(rows);
  return [
    freeze([...columns.keys()].map(ColumnNode.create)),
    ValuesNode.create(rows.map((row) => parseRowValues(row, columns)))
  ];
}
function parseColumnNamesAndIndexes(rows) {
  const columns = /* @__PURE__ */ new Map();
  for (const row of rows) {
    const cols = Object.keys(row);
    for (const col of cols) {
      if (!columns.has(col) && row[col] !== void 0) {
        columns.set(col, columns.size);
      }
    }
  }
  return columns;
}
function parseRowValues(row, columns) {
  const rowColumns = Object.keys(row);
  const rowValues = Array.from({
    length: columns.size
  });
  let hasUndefinedOrComplexColumns = false;
  for (const col of rowColumns) {
    const columnIdx = columns.get(col);
    if (isUndefined(columnIdx)) {
      continue;
    }
    const value = row[col];
    if (isUndefined(value) || isExpressionOrFactory(value)) {
      hasUndefinedOrComplexColumns = true;
    }
    rowValues[columnIdx] = value;
  }
  const hasMissingColumns = rowColumns.length < columns.size;
  if (hasMissingColumns || hasUndefinedOrComplexColumns) {
    const defaultValue = DefaultInsertValueNode.create();
    return ValueListNode.create(rowValues.map((it) => isUndefined(it) ? defaultValue : parseValueExpression(it)));
  }
  return PrimitiveValueListNode.create(rowValues);
}

// ../../../node_modules/.pnpm/kysely@0.27.4/node_modules/kysely/dist/esm/operation-node/insert-query-node.js
init_define_ENV_DEFINED_IN_BUILD_STEP();
var InsertQueryNode = freeze({
  is(node) {
    return node.kind === "InsertQueryNode";
  },
  create(into, withNode, replace) {
    return freeze({
      kind: "InsertQueryNode",
      into,
      ...withNode && { with: withNode },
      replace
    });
  },
  createWithoutInto() {
    return freeze({
      kind: "InsertQueryNode"
    });
  },
  cloneWith(insertQuery, props) {
    return freeze({
      ...insertQuery,
      ...props
    });
  }
});

// ../../../node_modules/.pnpm/kysely@0.27.4/node_modules/kysely/dist/esm/operation-node/query-node.js
init_define_ENV_DEFINED_IN_BUILD_STEP();

// ../../../node_modules/.pnpm/kysely@0.27.4/node_modules/kysely/dist/esm/operation-node/update-query-node.js
init_define_ENV_DEFINED_IN_BUILD_STEP();
var UpdateQueryNode = freeze({
  is(node) {
    return node.kind === "UpdateQueryNode";
  },
  create(table, withNode) {
    return freeze({
      kind: "UpdateQueryNode",
      table,
      ...withNode && { with: withNode }
    });
  },
  createWithoutTable() {
    return freeze({
      kind: "UpdateQueryNode"
    });
  },
  cloneWithFromItems(updateQuery, fromItems) {
    return freeze({
      ...updateQuery,
      from: updateQuery.from ? FromNode.cloneWithFroms(updateQuery.from, fromItems) : FromNode.create(fromItems)
    });
  },
  cloneWithUpdates(updateQuery, updates) {
    return freeze({
      ...updateQuery,
      updates: updateQuery.updates ? freeze([...updateQuery.updates, ...updates]) : updates
    });
  },
  cloneWithLimit(updateQuery, limit) {
    return freeze({
      ...updateQuery,
      limit
    });
  }
});

// ../../../node_modules/.pnpm/kysely@0.27.4/node_modules/kysely/dist/esm/operation-node/delete-query-node.js
init_define_ENV_DEFINED_IN_BUILD_STEP();

// ../../../node_modules/.pnpm/kysely@0.27.4/node_modules/kysely/dist/esm/operation-node/using-node.js
init_define_ENV_DEFINED_IN_BUILD_STEP();
var UsingNode = freeze({
  is(node) {
    return node.kind === "UsingNode";
  },
  create(tables) {
    return freeze({
      kind: "UsingNode",
      tables: freeze(tables)
    });
  },
  cloneWithTables(using, tables) {
    return freeze({
      ...using,
      tables: freeze([...using.tables, ...tables])
    });
  }
});

// ../../../node_modules/.pnpm/kysely@0.27.4/node_modules/kysely/dist/esm/operation-node/delete-query-node.js
var DeleteQueryNode = freeze({
  is(node) {
    return node.kind === "DeleteQueryNode";
  },
  create(fromItems, withNode) {
    return freeze({
      kind: "DeleteQueryNode",
      from: FromNode.create(fromItems),
      ...withNode && { with: withNode }
    });
  },
  cloneWithOrderByItems(deleteNode, items) {
    return freeze({
      ...deleteNode,
      orderBy: deleteNode.orderBy ? OrderByNode.cloneWithItems(deleteNode.orderBy, items) : OrderByNode.create(items)
    });
  },
  cloneWithoutOrderBy(deleteNode) {
    return freeze({
      ...deleteNode,
      orderBy: void 0
    });
  },
  cloneWithLimit(deleteNode, limit) {
    return freeze({
      ...deleteNode,
      limit
    });
  },
  cloneWithoutLimit(deleteNode) {
    return freeze({
      ...deleteNode,
      limit: void 0
    });
  },
  cloneWithUsing(deleteNode, tables) {
    return freeze({
      ...deleteNode,
      using: deleteNode.using !== void 0 ? UsingNode.cloneWithTables(deleteNode.using, tables) : UsingNode.create(tables)
    });
  }
});

// ../../../node_modules/.pnpm/kysely@0.27.4/node_modules/kysely/dist/esm/operation-node/where-node.js
init_define_ENV_DEFINED_IN_BUILD_STEP();
var WhereNode = freeze({
  is(node) {
    return node.kind === "WhereNode";
  },
  create(filter) {
    return freeze({
      kind: "WhereNode",
      where: filter
    });
  },
  cloneWithOperation(whereNode, operator, operation) {
    return freeze({
      ...whereNode,
      where: operator === "And" ? AndNode.create(whereNode.where, operation) : OrNode.create(whereNode.where, operation)
    });
  }
});

// ../../../node_modules/.pnpm/kysely@0.27.4/node_modules/kysely/dist/esm/operation-node/returning-node.js
init_define_ENV_DEFINED_IN_BUILD_STEP();
var ReturningNode = freeze({
  is(node) {
    return node.kind === "ReturningNode";
  },
  create(selections) {
    return freeze({
      kind: "ReturningNode",
      selections: freeze(selections)
    });
  },
  cloneWithSelections(returning, selections) {
    return freeze({
      ...returning,
      selections: returning.selections ? freeze([...returning.selections, ...selections]) : freeze(selections)
    });
  }
});

// ../../../node_modules/.pnpm/kysely@0.27.4/node_modules/kysely/dist/esm/operation-node/explain-node.js
init_define_ENV_DEFINED_IN_BUILD_STEP();
var ExplainNode = freeze({
  is(node) {
    return node.kind === "ExplainNode";
  },
  create(format, options) {
    return freeze({
      kind: "ExplainNode",
      format,
      options
    });
  }
});

// ../../../node_modules/.pnpm/kysely@0.27.4/node_modules/kysely/dist/esm/operation-node/merge-query-node.js
init_define_ENV_DEFINED_IN_BUILD_STEP();

// ../../../node_modules/.pnpm/kysely@0.27.4/node_modules/kysely/dist/esm/operation-node/when-node.js
init_define_ENV_DEFINED_IN_BUILD_STEP();
var WhenNode = freeze({
  is(node) {
    return node.kind === "WhenNode";
  },
  create(condition) {
    return freeze({
      kind: "WhenNode",
      condition
    });
  },
  cloneWithResult(whenNode, result) {
    return freeze({
      ...whenNode,
      result
    });
  }
});

// ../../../node_modules/.pnpm/kysely@0.27.4/node_modules/kysely/dist/esm/operation-node/merge-query-node.js
var MergeQueryNode = freeze({
  is(node) {
    return node.kind === "MergeQueryNode";
  },
  create(into, withNode) {
    return freeze({
      kind: "MergeQueryNode",
      into,
      ...withNode && { with: withNode }
    });
  },
  cloneWithUsing(mergeNode, using) {
    return freeze({
      ...mergeNode,
      using
    });
  },
  cloneWithWhen(mergeNode, when) {
    return freeze({
      ...mergeNode,
      whens: mergeNode.whens ? freeze([...mergeNode.whens, when]) : freeze([when])
    });
  },
  cloneWithThen(mergeNode, then) {
    return freeze({
      ...mergeNode,
      whens: mergeNode.whens ? freeze([
        ...mergeNode.whens.slice(0, -1),
        WhenNode.cloneWithResult(mergeNode.whens[mergeNode.whens.length - 1], then)
      ]) : void 0
    });
  }
});

// ../../../node_modules/.pnpm/kysely@0.27.4/node_modules/kysely/dist/esm/operation-node/output-node.js
init_define_ENV_DEFINED_IN_BUILD_STEP();
var OutputNode = freeze({
  is(node) {
    return node.kind === "OutputNode";
  },
  create(selections) {
    return freeze({
      kind: "OutputNode",
      selections: freeze(selections)
    });
  },
  cloneWithSelections(output, selections) {
    return freeze({
      ...output,
      selections: output.selections ? freeze([...output.selections, ...selections]) : freeze(selections)
    });
  }
});

// ../../../node_modules/.pnpm/kysely@0.27.4/node_modules/kysely/dist/esm/operation-node/query-node.js
var QueryNode = freeze({
  is(node) {
    return SelectQueryNode.is(node) || InsertQueryNode.is(node) || UpdateQueryNode.is(node) || DeleteQueryNode.is(node) || MergeQueryNode.is(node);
  },
  cloneWithWhere(node, operation) {
    return freeze({
      ...node,
      where: node.where ? WhereNode.cloneWithOperation(node.where, "And", operation) : WhereNode.create(operation)
    });
  },
  cloneWithJoin(node, join) {
    return freeze({
      ...node,
      joins: node.joins ? freeze([...node.joins, join]) : freeze([join])
    });
  },
  cloneWithReturning(node, selections) {
    return freeze({
      ...node,
      returning: node.returning ? ReturningNode.cloneWithSelections(node.returning, selections) : ReturningNode.create(selections)
    });
  },
  cloneWithoutReturning(node) {
    return freeze({
      ...node,
      returning: void 0
    });
  },
  cloneWithoutWhere(node) {
    return freeze({
      ...node,
      where: void 0
    });
  },
  cloneWithExplain(node, format, options) {
    return freeze({
      ...node,
      explain: ExplainNode.create(format, options == null ? void 0 : options.toOperationNode())
    });
  },
  cloneWithTop(node, top) {
    return freeze({
      ...node,
      top
    });
  },
  cloneWithOutput(node, selections) {
    return freeze({
      ...node,
      output: node.output ? OutputNode.cloneWithSelections(node.output, selections) : OutputNode.create(selections)
    });
  }
});

// ../../../node_modules/.pnpm/kysely@0.27.4/node_modules/kysely/dist/esm/parser/update-set-parser.js
init_define_ENV_DEFINED_IN_BUILD_STEP();

// ../../../node_modules/.pnpm/kysely@0.27.4/node_modules/kysely/dist/esm/operation-node/column-update-node.js
init_define_ENV_DEFINED_IN_BUILD_STEP();
var ColumnUpdateNode = freeze({
  is(node) {
    return node.kind === "ColumnUpdateNode";
  },
  create(column, value) {
    return freeze({
      kind: "ColumnUpdateNode",
      column,
      value
    });
  }
});

// ../../../node_modules/.pnpm/kysely@0.27.4/node_modules/kysely/dist/esm/parser/update-set-parser.js
function parseUpdate(...args) {
  if (args.length === 2) {
    return [
      ColumnUpdateNode.create(parseReferenceExpression(args[0]), parseValueExpression(args[1]))
    ];
  }
  return parseUpdateObjectExpression(args[0]);
}
function parseUpdateObjectExpression(update) {
  const updateObj = isFunction(update) ? update(expressionBuilder()) : update;
  return Object.entries(updateObj).filter(([_3, value]) => value !== void 0).map(([key, value]) => {
    return ColumnUpdateNode.create(ColumnNode.create(key), parseValueExpression(value));
  });
}

// ../../../node_modules/.pnpm/kysely@0.27.4/node_modules/kysely/dist/esm/operation-node/on-duplicate-key-node.js
init_define_ENV_DEFINED_IN_BUILD_STEP();
var OnDuplicateKeyNode = freeze({
  is(node) {
    return node.kind === "OnDuplicateKeyNode";
  },
  create(updates) {
    return freeze({
      kind: "OnDuplicateKeyNode",
      updates
    });
  }
});

// ../../../node_modules/.pnpm/kysely@0.27.4/node_modules/kysely/dist/esm/query-builder/insert-result.js
init_define_ENV_DEFINED_IN_BUILD_STEP();
var InsertResult = class {
  /**
   * The auto incrementing primary key of the inserted row.
   *
   * This property can be undefined when the query contains an `on conflict`
   * clause that makes the query succeed even when nothing gets inserted.
   *
   * This property is always undefined on dialects like PostgreSQL that
   * don't return the inserted id by default. On those dialects you need
   * to use the {@link ReturningInterface.returning | returning} method.
   */
  insertId;
  /**
   * Affected rows count.
   */
  numInsertedOrUpdatedRows;
  constructor(insertId, numInsertedOrUpdatedRows) {
    this.insertId = insertId;
    this.numInsertedOrUpdatedRows = numInsertedOrUpdatedRows;
  }
};

// ../../../node_modules/.pnpm/kysely@0.27.4/node_modules/kysely/dist/esm/query-builder/no-result-error.js
init_define_ENV_DEFINED_IN_BUILD_STEP();
var NoResultError = class extends Error {
  /**
   * The operation node tree of the query that was executed.
   */
  node;
  constructor(node) {
    super("no result");
    this.node = node;
  }
};
function isNoResultErrorConstructor(fn) {
  return Object.prototype.hasOwnProperty.call(fn, "prototype");
}

// ../../../node_modules/.pnpm/kysely@0.27.4/node_modules/kysely/dist/esm/query-builder/on-conflict-builder.js
init_define_ENV_DEFINED_IN_BUILD_STEP();

// ../../../node_modules/.pnpm/kysely@0.27.4/node_modules/kysely/dist/esm/operation-node/on-conflict-node.js
init_define_ENV_DEFINED_IN_BUILD_STEP();
var OnConflictNode = freeze({
  is(node) {
    return node.kind === "OnConflictNode";
  },
  create() {
    return freeze({
      kind: "OnConflictNode"
    });
  },
  cloneWith(node, props) {
    return freeze({
      ...node,
      ...props
    });
  },
  cloneWithIndexWhere(node, operation) {
    return freeze({
      ...node,
      indexWhere: node.indexWhere ? WhereNode.cloneWithOperation(node.indexWhere, "And", operation) : WhereNode.create(operation)
    });
  },
  cloneWithIndexOrWhere(node, operation) {
    return freeze({
      ...node,
      indexWhere: node.indexWhere ? WhereNode.cloneWithOperation(node.indexWhere, "Or", operation) : WhereNode.create(operation)
    });
  },
  cloneWithUpdateWhere(node, operation) {
    return freeze({
      ...node,
      updateWhere: node.updateWhere ? WhereNode.cloneWithOperation(node.updateWhere, "And", operation) : WhereNode.create(operation)
    });
  },
  cloneWithUpdateOrWhere(node, operation) {
    return freeze({
      ...node,
      updateWhere: node.updateWhere ? WhereNode.cloneWithOperation(node.updateWhere, "Or", operation) : WhereNode.create(operation)
    });
  },
  cloneWithoutIndexWhere(node) {
    return freeze({
      ...node,
      indexWhere: void 0
    });
  },
  cloneWithoutUpdateWhere(node) {
    return freeze({
      ...node,
      updateWhere: void 0
    });
  }
});

// ../../../node_modules/.pnpm/kysely@0.27.4/node_modules/kysely/dist/esm/query-builder/on-conflict-builder.js
var OnConflictBuilder = class _OnConflictBuilder {
  #props;
  constructor(props) {
    this.#props = freeze(props);
  }
  /**
   * Specify a single column as the conflict target.
   *
   * Also see the {@link columns}, {@link constraint} and {@link expression}
   * methods for alternative ways to specify the conflict target.
   */
  column(column) {
    const columnNode = ColumnNode.create(column);
    return new _OnConflictBuilder({
      ...this.#props,
      onConflictNode: OnConflictNode.cloneWith(this.#props.onConflictNode, {
        columns: this.#props.onConflictNode.columns ? freeze([...this.#props.onConflictNode.columns, columnNode]) : freeze([columnNode])
      })
    });
  }
  /**
   * Specify a list of columns as the conflict target.
   *
   * Also see the {@link column}, {@link constraint} and {@link expression}
   * methods for alternative ways to specify the conflict target.
   */
  columns(columns) {
    const columnNodes = columns.map(ColumnNode.create);
    return new _OnConflictBuilder({
      ...this.#props,
      onConflictNode: OnConflictNode.cloneWith(this.#props.onConflictNode, {
        columns: this.#props.onConflictNode.columns ? freeze([...this.#props.onConflictNode.columns, ...columnNodes]) : freeze(columnNodes)
      })
    });
  }
  /**
   * Specify a specific constraint by name as the conflict target.
   *
   * Also see the {@link column}, {@link columns} and {@link expression}
   * methods for alternative ways to specify the conflict target.
   */
  constraint(constraintName) {
    return new _OnConflictBuilder({
      ...this.#props,
      onConflictNode: OnConflictNode.cloneWith(this.#props.onConflictNode, {
        constraint: IdentifierNode.create(constraintName)
      })
    });
  }
  /**
   * Specify an expression as the conflict target.
   *
   * This can be used if the unique index is an expression index.
   *
   * Also see the {@link column}, {@link columns} and {@link constraint}
   * methods for alternative ways to specify the conflict target.
   */
  expression(expression) {
    return new _OnConflictBuilder({
      ...this.#props,
      onConflictNode: OnConflictNode.cloneWith(this.#props.onConflictNode, {
        indexExpression: expression.toOperationNode()
      })
    });
  }
  where(...args) {
    return new _OnConflictBuilder({
      ...this.#props,
      onConflictNode: OnConflictNode.cloneWithIndexWhere(this.#props.onConflictNode, parseValueBinaryOperationOrExpression(args))
    });
  }
  whereRef(lhs, op, rhs) {
    return new _OnConflictBuilder({
      ...this.#props,
      onConflictNode: OnConflictNode.cloneWithIndexWhere(this.#props.onConflictNode, parseReferentialBinaryOperation(lhs, op, rhs))
    });
  }
  clearWhere() {
    return new _OnConflictBuilder({
      ...this.#props,
      onConflictNode: OnConflictNode.cloneWithoutIndexWhere(this.#props.onConflictNode)
    });
  }
  /**
   * Adds the "do nothing" conflict action.
   *
   * ### Examples
   *
   * ```ts
   * await db
   *   .insertInto('person')
   *   .values({first_name, pic })
   *   .onConflict((oc) => oc
   *     .column('pic')
   *     .doNothing()
   *   )
   * ```
   *
   * The generated SQL (PostgreSQL):
   *
   * ```sql
   * insert into "person" ("first_name", "pic")
   * values ($1, $2)
   * on conflict ("pic") do nothing
   * ```
   */
  doNothing() {
    return new OnConflictDoNothingBuilder({
      ...this.#props,
      onConflictNode: OnConflictNode.cloneWith(this.#props.onConflictNode, {
        doNothing: true
      })
    });
  }
  /**
   * Adds the "do update set" conflict action.
   *
   * ### Examples
   *
   * ```ts
   * await db
   *   .insertInto('person')
   *   .values({first_name, pic })
   *   .onConflict((oc) => oc
   *     .column('pic')
   *     .doUpdateSet({ first_name })
   *   )
   * ```
   *
   * The generated SQL (PostgreSQL):
   *
   * ```sql
   * insert into "person" ("first_name", "pic")
   * values ($1, $2)
   * on conflict ("pic")
   * do update set "first_name" = $3
   * ```
   *
   * In the next example we use the `ref` method to reference
   * columns of the virtual table `excluded` in a type-safe way
   * to create an upsert operation:
   *
   * ```ts
   * db.insertInto('person')
   *   .values(person)
   *   .onConflict((oc) => oc
   *     .column('id')
   *     .doUpdateSet((eb) => ({
   *       first_name: eb.ref('excluded.first_name'),
   *       last_name: eb.ref('excluded.last_name')
   *     }))
   *   )
   * ```
   */
  doUpdateSet(update) {
    return new OnConflictUpdateBuilder({
      ...this.#props,
      onConflictNode: OnConflictNode.cloneWith(this.#props.onConflictNode, {
        updates: parseUpdateObjectExpression(update)
      })
    });
  }
  /**
   * Simply calls the provided function passing `this` as the only argument. `$call` returns
   * what the provided function returns.
   */
  $call(func) {
    return func(this);
  }
};
preventAwait(OnConflictBuilder, "don't await OnConflictBuilder instances.");
var OnConflictDoNothingBuilder = class {
  #props;
  constructor(props) {
    this.#props = freeze(props);
  }
  toOperationNode() {
    return this.#props.onConflictNode;
  }
};
preventAwait(OnConflictDoNothingBuilder, "don't await OnConflictDoNothingBuilder instances.");
var OnConflictUpdateBuilder = class _OnConflictUpdateBuilder {
  #props;
  constructor(props) {
    this.#props = freeze(props);
  }
  where(...args) {
    return new _OnConflictUpdateBuilder({
      ...this.#props,
      onConflictNode: OnConflictNode.cloneWithUpdateWhere(this.#props.onConflictNode, parseValueBinaryOperationOrExpression(args))
    });
  }
  /**
   * Specify a where condition for the update operation.
   *
   * See {@link WhereInterface.whereRef} for more info.
   */
  whereRef(lhs, op, rhs) {
    return new _OnConflictUpdateBuilder({
      ...this.#props,
      onConflictNode: OnConflictNode.cloneWithUpdateWhere(this.#props.onConflictNode, parseReferentialBinaryOperation(lhs, op, rhs))
    });
  }
  clearWhere() {
    return new _OnConflictUpdateBuilder({
      ...this.#props,
      onConflictNode: OnConflictNode.cloneWithoutUpdateWhere(this.#props.onConflictNode)
    });
  }
  /**
   * Simply calls the provided function passing `this` as the only argument. `$call` returns
   * what the provided function returns.
   */
  $call(func) {
    return func(this);
  }
  toOperationNode() {
    return this.#props.onConflictNode;
  }
};
preventAwait(OnConflictUpdateBuilder, "don't await OnConflictUpdateBuilder instances.");

// ../../../node_modules/.pnpm/kysely@0.27.4/node_modules/kysely/dist/esm/parser/top-parser.js
init_define_ENV_DEFINED_IN_BUILD_STEP();

// ../../../node_modules/.pnpm/kysely@0.27.4/node_modules/kysely/dist/esm/operation-node/top-node.js
init_define_ENV_DEFINED_IN_BUILD_STEP();
var TopNode = freeze({
  is(node) {
    return node.kind === "TopNode";
  },
  create(expression, modifiers) {
    return freeze({
      kind: "TopNode",
      expression,
      modifiers
    });
  }
});

// ../../../node_modules/.pnpm/kysely@0.27.4/node_modules/kysely/dist/esm/parser/top-parser.js
function parseTop(expression, modifiers) {
  if (!isNumber(expression) && !isBigInt(expression)) {
    throw new Error(`Invalid top expression: ${expression}`);
  }
  if (!isUndefined(modifiers) && !isTopModifiers(modifiers)) {
    throw new Error(`Invalid top modifiers: ${modifiers}`);
  }
  return TopNode.create(expression, modifiers);
}
function isTopModifiers(modifiers) {
  return modifiers === "percent" || modifiers === "with ties" || modifiers === "percent with ties";
}

// ../../../node_modules/.pnpm/kysely@0.27.4/node_modules/kysely/dist/esm/query-builder/insert-query-builder.js
var InsertQueryBuilder = class _InsertQueryBuilder {
  #props;
  constructor(props) {
    this.#props = freeze(props);
  }
  /**
   * Sets the values to insert for an {@link Kysely.insertInto | insert} query.
   *
   * This method takes an object whose keys are column names and values are
   * values to insert. In addition to the column's type, the values can be
   * raw {@link sql} snippets or select queries.
   *
   * You must provide all fields you haven't explicitly marked as nullable
   * or optional using {@link Generated} or {@link ColumnType}.
   *
   * The return value of an `insert` query is an instance of {@link InsertResult}. The
   * {@link InsertResult.insertId | insertId} field holds the auto incremented primary
   * key if the database returned one.
   *
   * On PostgreSQL and some other dialects, you need to call `returning` to get
   * something out of the query.
   *
   * Also see the {@link expression} method for inserting the result of a select
   * query or any other expression.
   *
   * ### Examples
   *
   * <!-- siteExample("insert", "Single row", 10) -->
   *
   * Insert a single row:
   *
   * ```ts
   * const result = await db
   *   .insertInto('person')
   *   .values({
   *     first_name: 'Jennifer',
   *     last_name: 'Aniston',
   *     age: 40
   *   })
   *   .executeTakeFirst()
   *
   * // `insertId` is only available on dialects that
   * // automatically return the id of the inserted row
   * // such as MySQL and SQLite. On PostgreSQL, for example,
   * // you need to add a `returning` clause to the query to
   * // get anything out. See the "returning data" example.
   * console.log(result.insertId)
   * ```
   *
   * The generated SQL (MySQL):
   *
   * ```sql
   * insert into `person` (`first_name`, `last_name`, `age`) values (?, ?, ?)
   * ```
   *
   * <!-- siteExample("insert", "Multiple rows", 20) -->
   *
   * On dialects that support it (for example PostgreSQL) you can insert multiple
   * rows by providing an array. Note that the return value is once again very
   * dialect-specific. Some databases may only return the id of the *last* inserted
   * row and some return nothing at all unless you call `returning`.
   *
   * ```ts
   * await db
   *   .insertInto('person')
   *   .values([{
   *     first_name: 'Jennifer',
   *     last_name: 'Aniston',
   *     age: 40,
   *   }, {
   *     first_name: 'Arnold',
   *     last_name: 'Schwarzenegger',
   *     age: 70,
   *   }])
   *   .execute()
   * ```
   *
   * The generated SQL (PostgreSQL):
   *
   * ```sql
   * insert into "person" ("first_name", "last_name", "age") values (($1, $2, $3), ($4, $5, $6))
   * ```
   *
   * <!-- siteExample("insert", "Returning data", 30) -->
   *
   * On supported dialects like PostgreSQL you need to chain `returning` to the query to get
   * the inserted row's columns (or any other expression) as the return value. `returning`
   * works just like `select`. Refer to `select` method's examples and documentation for
   * more info.
   *
   * ```ts
   * const result = await db
   *   .insertInto('person')
   *   .values({
   *     first_name: 'Jennifer',
   *     last_name: 'Aniston',
   *     age: 40,
   *   })
   *   .returning(['id', 'first_name as name'])
   *   .executeTakeFirstOrThrow()
   * ```
   *
   * The generated SQL (PostgreSQL):
   *
   * ```sql
   * insert into "person" ("first_name", "last_name", "age") values ($1, $2, $3) returning "id", "first_name" as "name"
   * ```
   *
   * <!-- siteExample("insert", "Complex values", 40) -->
   *
   * In addition to primitives, the values can also be arbitrary expressions.
   * You can build the expressions by using a callback and calling the methods
   * on the expression builder passed to it:
   *
   * ```ts
   * import { sql } from 'kysely'
   *
   * const ani = "Ani"
   * const ston = "ston"
   *
   * const result = await db
   *   .insertInto('person')
   *   .values(({ ref, selectFrom, fn }) => ({
   *     first_name: 'Jennifer',
   *     last_name: sql<string>`>concat(${ani}, ${ston})`,
   *     middle_name: ref('first_name'),
   *     age: selectFrom('person')
   *       .select(fn.avg<number>('age').as('avg_age')),
   *   }))
   *   .executeTakeFirst()
   * ```
   *
   * The generated SQL (PostgreSQL):
   *
   * ```sql
   * insert into "person" (
   *   "first_name",
   *   "last_name",
   *   "middle_name",
   *   "age"
   * )
   * values (
   *   $1,
   *   concat($2, $3),
   *   "first_name",
   *   (select avg("age") as "avg_age" from "person")
   * )
   * ```
   *
   * You can also use the callback version of subqueries or raw expressions:
   *
   * ```ts
   * db.with('jennifer', (db) => db
   *   .selectFrom('person')
   *   .where('first_name', '=', 'Jennifer')
   *   .select(['id', 'first_name', 'gender'])
   *   .limit(1)
   * ).insertInto('pet').values((eb) => ({
   *   owner_id: eb.selectFrom('jennifer').select('id'),
   *   name: eb.selectFrom('jennifer').select('first_name'),
   *   species: 'cat',
   * }))
   * ```
   */
  values(insert) {
    const [columns, values] = parseInsertExpression(insert);
    return new _InsertQueryBuilder({
      ...this.#props,
      queryNode: InsertQueryNode.cloneWith(this.#props.queryNode, {
        columns,
        values
      })
    });
  }
  /**
   * Sets the columns to insert.
   *
   * The {@link values} method sets both the columns and the values and this method
   * is not needed. But if you are using the {@link expression} method, you can use
   * this method to set the columns to insert.
   *
   * ### Examples
   *
   * ```ts
   * db.insertInto('person')
   *   .columns(['first_name'])
   *   .expression((eb) => eb.selectFrom('pet').select('pet.name'))
   * ```
   *
   * The generated SQL (PostgreSQL):
   *
   * ```sql
   * insert into "person" ("first_name")
   * select "pet"."name" from "pet"
   * ```
   */
  columns(columns) {
    return new _InsertQueryBuilder({
      ...this.#props,
      queryNode: InsertQueryNode.cloneWith(this.#props.queryNode, {
        columns: freeze(columns.map(ColumnNode.create))
      })
    });
  }
  /**
   * Insert an arbitrary expression. For example the result of a select query.
   *
   * ### Examples
   *
   * <!-- siteExample("insert", "Insert subquery", 50) -->
   *
   * You can create an `INSERT INTO SELECT FROM` query using the `expression` method.
   * This API doesn't follow our WYSIWYG principles and might be a bit difficult to
   * remember. The reasons for this design stem from implementation difficulties.
   *
   * ```ts
   * const result = await db.insertInto('person')
   *   .columns(['first_name', 'last_name', 'age'])
   *   .expression((eb) => eb
   *     .selectFrom('pet')
   *     .select((eb) => [
   *       'pet.name',
   *       eb.val('Petson').as('last_name'),
   *       eb.lit(7).as('age'),
   *     ])
   *   )
   *   .execute()
   * ```
   *
   * The generated SQL (PostgreSQL):
   *
   * ```sql
   * insert into "person" ("first_name", "last_name", "age")
   * select "pet"."name", $1 as "last_name", 7 as "age from "pet"
   * ```
   */
  expression(expression) {
    return new _InsertQueryBuilder({
      ...this.#props,
      queryNode: InsertQueryNode.cloneWith(this.#props.queryNode, {
        values: parseExpression(expression)
      })
    });
  }
  /**
   * Creates an `insert into "person" default values` query.
   *
   * ### Examples
   *
   * ```ts
   * await db.insertInto('person')
   *   .defaultValues()
   *   .execute()
   * ```
   */
  defaultValues() {
    return new _InsertQueryBuilder({
      ...this.#props,
      queryNode: InsertQueryNode.cloneWith(this.#props.queryNode, {
        defaultValues: true
      })
    });
  }
  /**
   * Changes an `insert into` query to an `insert ignore into` query.
   *
   * If you use the ignore modifier, ignorable errors that occur while executing the
   * insert statement are ignored. For example, without ignore, a row that duplicates
   * an existing unique index or primary key value in the table causes a duplicate-key
   * error and the statement is aborted. With ignore, the row is discarded and no error
   * occurs.
   *
   * This is only supported on some dialects like MySQL. On most dialects you should
   * use the {@link onConflict} method.
   *
   * ### Examples
   *
   * ```ts
   * await db.insertInto('person')
   *   .ignore()
   *   .values(values)
   *   .execute()
   * ```
   */
  ignore() {
    return new _InsertQueryBuilder({
      ...this.#props,
      queryNode: InsertQueryNode.cloneWith(this.#props.queryNode, {
        ignore: true
      })
    });
  }
  /**
   * Changes an `insert into` query to an `insert top into` query.
   *
   * `top` clause is only supported by some dialects like MS SQL Server.
   *
   * ### Examples
   *
   * Insert the first 5 rows:
   *
   * ```ts
   * await db.insertInto('person')
   *   .top(5)
   *   .columns(['first_name', 'gender'])
   *   .expression(
   *     (eb) => eb.selectFrom('pet').select(['name', sql.lit('other').as('gender')])
   *   )
   *   .execute()
   * ```
   *
   * The generated SQL (MS SQL Server):
   *
   * ```sql
   * insert top(5) into "person" ("first_name", "gender") select "name", 'other' as "gender" from "pet"
   * ```
   *
   * Insert the first 50 percent of rows:
   *
   * ```ts
   * await db.insertInto('person')
   *   .top(50, 'percent')
   *   .columns(['first_name', 'gender'])
   *   .expression(
   *     (eb) => eb.selectFrom('pet').select(['name', sql.lit('other').as('gender')])
   *   )
   *   .execute()
   * ```
   *
   * The generated SQL (MS SQL Server):
   *
   * ```sql
   * insert top(50) percent into "person" ("first_name", "gender") select "name", 'other' as "gender" from "pet"
   * ```
   */
  top(expression, modifiers) {
    return new _InsertQueryBuilder({
      ...this.#props,
      queryNode: QueryNode.cloneWithTop(this.#props.queryNode, parseTop(expression, modifiers))
    });
  }
  /**
   * Adds an `on conflict` clause to the query.
   *
   * `on conflict` is only supported by some dialects like PostgreSQL and SQLite. On MySQL
   * you can use {@link ignore} and {@link onDuplicateKeyUpdate} to achieve similar results.
   *
   * ### Examples
   *
   * ```ts
   * await db
   *   .insertInto('pet')
   *   .values({
   *     name: 'Catto',
   *     species: 'cat',
   *   })
   *   .onConflict((oc) => oc
   *     .column('name')
   *     .doUpdateSet({ species: 'hamster' })
   *   )
   *   .execute()
   * ```
   *
   * The generated SQL (PostgreSQL):
   *
   * ```sql
   * insert into "pet" ("name", "species")
   * values ($1, $2)
   * on conflict ("name")
   * do update set "species" = $3
   * ```
   *
   * You can provide the name of the constraint instead of a column name:
   *
   * ```ts
   * await db
   *   .insertInto('pet')
   *   .values({
   *     name: 'Catto',
   *     species: 'cat',
   *   })
   *   .onConflict((oc) => oc
   *     .constraint('pet_name_key')
   *     .doUpdateSet({ species: 'hamster' })
   *   )
   *   .execute()
   * ```
   *
   * The generated SQL (PostgreSQL):
   *
   * ```sql
   * insert into "pet" ("name", "species")
   * values ($1, $2)
   * on conflict on constraint "pet_name_key"
   * do update set "species" = $3
   * ```
   *
   * You can also specify an expression as the conflict target in case
   * the unique index is an expression index:
   *
   * ```ts
   * import { sql } from 'kysely'
   *
   * await db
   *   .insertInto('pet')
   *   .values({
   *     name: 'Catto',
   *     species: 'cat',
   *   })
   *   .onConflict((oc) => oc
   *     .expression(sql<string>`lower(name)`)
   *     .doUpdateSet({ species: 'hamster' })
   *   )
   *   .execute()
   * ```
   *
   * The generated SQL (PostgreSQL):
   *
   * ```sql
   * insert into "pet" ("name", "species")
   * values ($1, $2)
   * on conflict (lower(name))
   * do update set "species" = $3
   * ```
   *
   * You can add a filter for the update statement like this:
   *
   * ```ts
   * await db
   *   .insertInto('pet')
   *   .values({
   *     name: 'Catto',
   *     species: 'cat',
   *   })
   *   .onConflict((oc) => oc
   *     .column('name')
   *     .doUpdateSet({ species: 'hamster' })
   *     .where('excluded.name', '!=', 'Catto'')
   *   )
   *   .execute()
   * ```
   *
   * The generated SQL (PostgreSQL):
   *
   * ```sql
   * insert into "pet" ("name", "species")
   * values ($1, $2)
   * on conflict ("name")
   * do update set "species" = $3
   * where "excluded"."name" != $4
   * ```
   *
   * You can create an `on conflict do nothing` clauses like this:
   *
   * ```ts
   * await db
   *   .insertInto('pet')
   *   .values({
   *     name: 'Catto',
   *     species: 'cat',
   *   })
   *   .onConflict((oc) => oc
   *     .column('name')
   *     .doNothing()
   *   )
   *   .execute()
   * ```
   *
   * The generated SQL (PostgreSQL):
   *
   * ```sql
   * insert into "pet" ("name", "species")
   * values ($1, $2)
   * on conflict ("name") do nothing
   * ```
   *
   * You can refer to the columns of the virtual `excluded` table
   * in a type-safe way using a callback and the `ref` method of
   * `ExpressionBuilder`:
   *
   * ```ts
   * db.insertInto('person')
   *   .values(person)
   *   .onConflict(oc => oc
   *     .column('id')
   *     .doUpdateSet({
   *       first_name: (eb) => eb.ref('excluded.first_name'),
   *       last_name: (eb) => eb.ref('excluded.last_name')
   *     })
   *   )
   * ```
   */
  onConflict(callback) {
    return new _InsertQueryBuilder({
      ...this.#props,
      queryNode: InsertQueryNode.cloneWith(this.#props.queryNode, {
        onConflict: callback(new OnConflictBuilder({
          onConflictNode: OnConflictNode.create()
        })).toOperationNode()
      })
    });
  }
  /**
   * Adds `on duplicate key update` to the query.
   *
   * If you specify `on duplicate key update`, and a row is inserted that would cause
   * a duplicate value in a unique index or primary key, an update of the old row occurs.
   *
   * This is only implemented by some dialects like MySQL. On most dialects you should
   * use {@link onConflict} instead.
   *
   * ### Examples
   *
   * ```ts
   * await db
   *   .insertInto('person')
   *   .values(values)
   *   .onDuplicateKeyUpdate({ species: 'hamster' })
   * ```
   */
  onDuplicateKeyUpdate(update) {
    return new _InsertQueryBuilder({
      ...this.#props,
      queryNode: InsertQueryNode.cloneWith(this.#props.queryNode, {
        onDuplicateKey: OnDuplicateKeyNode.create(parseUpdateObjectExpression(update))
      })
    });
  }
  returning(selection) {
    return new _InsertQueryBuilder({
      ...this.#props,
      queryNode: QueryNode.cloneWithReturning(this.#props.queryNode, parseSelectArg(selection))
    });
  }
  returningAll() {
    return new _InsertQueryBuilder({
      ...this.#props,
      queryNode: QueryNode.cloneWithReturning(this.#props.queryNode, parseSelectAll())
    });
  }
  output(args) {
    return new _InsertQueryBuilder({
      ...this.#props,
      queryNode: QueryNode.cloneWithOutput(this.#props.queryNode, parseSelectArg(args))
    });
  }
  outputAll(table) {
    return new _InsertQueryBuilder({
      ...this.#props,
      queryNode: QueryNode.cloneWithOutput(this.#props.queryNode, parseSelectAll(table))
    });
  }
  /**
   * Clears all `returning` clauses from the query.
   *
   * ### Examples
   *
   * ```ts
   * db.insertInto('person')
   *   .values({ first_name: 'James', last_name: 'Smith', age: 42 })
   *   .returning(['first_name'])
   *   .clearReturning()
   * ```
   *
   * The generated SQL(PostgreSQL):
   *
   * ```sql
   * insert into "person" ("James", "Smith", 42)
   * ```
   */
  clearReturning() {
    return new _InsertQueryBuilder({
      ...this.#props,
      queryNode: QueryNode.cloneWithoutReturning(this.#props.queryNode)
    });
  }
  /**
   * Simply calls the provided function passing `this` as the only argument. `$call` returns
   * what the provided function returns.
   *
   * If you want to conditionally call a method on `this`, see
   * the {@link $if} method.
   *
   * ### Examples
   *
   * The next example uses a helper function `log` to log a query:
   *
   * ```ts
   * function log<T extends Compilable>(qb: T): T {
   *   console.log(qb.compile())
   *   return qb
   * }
   *
   * db.updateTable('person')
   *   .set(values)
   *   .$call(log)
   *   .execute()
   * ```
   */
  $call(func) {
    return func(this);
  }
  /**
   * Call `func(this)` if `condition` is true.
   *
   * This method is especially handy with optional selects. Any `returning` or `returningAll`
   * method calls add columns as optional fields to the output type when called inside
   * the `func` callback. This is because we can't know if those selections were actually
   * made before running the code.
   *
   * You can also call any other methods inside the callback.
   *
   * ### Examples
   *
   * ```ts
   * async function insertPerson(values: InsertablePerson, returnLastName: boolean) {
   *   return await db
   *     .insertInto('person')
   *     .values(values)
   *     .returning(['id', 'first_name'])
   *     .$if(returnLastName, (qb) => qb.returning('last_name'))
   *     .executeTakeFirstOrThrow()
   * }
   * ```
   *
   * Any selections added inside the `if` callback will be added as optional fields to the
   * output type since we can't know if the selections were actually made before running
   * the code. In the example above the return type of the `insertPerson` function is:
   *
   * ```ts
   * {
   *   id: number
   *   first_name: string
   *   last_name?: string
   * }
   * ```
   */
  $if(condition, func) {
    if (condition) {
      return func(this);
    }
    return new _InsertQueryBuilder({
      ...this.#props
    });
  }
  /**
   * Change the output type of the query.
   *
   * This method call doesn't change the SQL in any way. This methods simply
   * returns a copy of this `InsertQueryBuilder` with a new output type.
   */
  $castTo() {
    return new _InsertQueryBuilder(this.#props);
  }
  /**
   * Narrows (parts of) the output type of the query.
   *
   * Kysely tries to be as type-safe as possible, but in some cases we have to make
   * compromises for better maintainability and compilation performance. At present,
   * Kysely doesn't narrow the output type of the query based on {@link values} input
   * when using {@link returning} or {@link returningAll}.
   *
   * This utility method is very useful for these situations, as it removes unncessary
   * runtime assertion/guard code. Its input type is limited to the output type
   * of the query, so you can't add a column that doesn't exist, or change a column's
   * type to something that doesn't exist in its union type.
   *
   * ### Examples
   *
   * Turn this code:
   *
   * ```ts
   * const person = await db.insertInto('person')
   *   .values({ ...inputPerson, nullable_column: 'hell yeah!' })
   *   .returningAll()
   *   .executeTakeFirstOrThrow()
   *
   * if (nullable_column) {
   *   functionThatExpectsPersonWithNonNullValue(person)
   * }
   * ```
   *
   * Into this:
   *
   * ```ts
   * const person = await db.insertInto('person')
   *   .values({ ...inputPerson, nullable_column: 'hell yeah!' })
   *   .returningAll()
   *   .$narrowType<{ nullable_column: string }>()
   *   .executeTakeFirstOrThrow()
   *
   * functionThatExpectsPersonWithNonNullValue(person)
   * ```
   */
  $narrowType() {
    return new _InsertQueryBuilder(this.#props);
  }
  /**
   * Asserts that query's output row type equals the given type `T`.
   *
   * This method can be used to simplify excessively complex types to make TypeScript happy
   * and much faster.
   *
   * Kysely uses complex type magic to achieve its type safety. This complexity is sometimes too much
   * for TypeScript and you get errors like this:
   *
   * ```
   * error TS2589: Type instantiation is excessively deep and possibly infinite.
   * ```
   *
   * In these case you can often use this method to help TypeScript a little bit. When you use this
   * method to assert the output type of a query, Kysely can drop the complex output type that
   * consists of multiple nested helper types and replace it with the simple asserted type.
   *
   * Using this method doesn't reduce type safety at all. You have to pass in a type that is
   * structurally equal to the current type.
   *
   * ### Examples
   *
   * ```ts
   * const result = await db
   *   .with('new_person', (qb) => qb
   *     .insertInto('person')
   *     .values(person)
   *     .returning('id')
   *     .$assertType<{ id: string }>()
   *   )
   *   .with('new_pet', (qb) => qb
   *     .insertInto('pet')
   *     .values((eb) => ({ owner_id: eb.selectFrom('new_person').select('id'), ...pet }))
   *     .returning(['name as pet_name', 'species'])
   *     .$assertType<{ pet_name: string, species: Species }>()
   *   )
   *   .selectFrom(['new_person', 'new_pet'])
   *   .selectAll()
   *   .executeTakeFirstOrThrow()
   * ```
   */
  $assertType() {
    return new _InsertQueryBuilder(this.#props);
  }
  /**
   * Returns a copy of this InsertQueryBuilder instance with the given plugin installed.
   */
  withPlugin(plugin2) {
    return new _InsertQueryBuilder({
      ...this.#props,
      executor: this.#props.executor.withPlugin(plugin2)
    });
  }
  toOperationNode() {
    return this.#props.executor.transformQuery(this.#props.queryNode, this.#props.queryId);
  }
  compile() {
    return this.#props.executor.compileQuery(this.toOperationNode(), this.#props.queryId);
  }
  /**
   * Executes the query and returns an array of rows.
   *
   * Also see the {@link executeTakeFirst} and {@link executeTakeFirstOrThrow} methods.
   */
  async execute() {
    const compiledQuery = this.compile();
    const result = await this.#props.executor.executeQuery(compiledQuery, this.#props.queryId);
    const { adapter } = this.#props.executor;
    const query = compiledQuery.query;
    if (query.returning && adapter.supportsReturning || query.output && adapter.supportsOutput) {
      return result.rows;
    }
    return [
      new InsertResult(
        result.insertId,
        // TODO: remove numUpdatedOrDeletedRows.
        result.numAffectedRows ?? result.numUpdatedOrDeletedRows
      )
    ];
  }
  /**
   * Executes the query and returns the first result or undefined if
   * the query returned no result.
   */
  async executeTakeFirst() {
    const [result] = await this.execute();
    return result;
  }
  /**
   * Executes the query and returns the first result or throws if
   * the query returned no result.
   *
   * By default an instance of {@link NoResultError} is thrown, but you can
   * provide a custom error class, or callback as the only argument to throw a different
   * error.
   */
  async executeTakeFirstOrThrow(errorConstructor = NoResultError) {
    const result = await this.executeTakeFirst();
    if (result === void 0) {
      const error = isNoResultErrorConstructor(errorConstructor) ? new errorConstructor(this.toOperationNode()) : errorConstructor(this.toOperationNode());
      throw error;
    }
    return result;
  }
  async *stream(chunkSize = 100) {
    const compiledQuery = this.compile();
    const stream = this.#props.executor.stream(compiledQuery, chunkSize, this.#props.queryId);
    for await (const item of stream) {
      yield* item.rows;
    }
  }
  async explain(format, options) {
    const builder = new _InsertQueryBuilder({
      ...this.#props,
      queryNode: QueryNode.cloneWithExplain(this.#props.queryNode, format, options)
    });
    return await builder.execute();
  }
};
preventAwait(InsertQueryBuilder, "don't await InsertQueryBuilder instances directly. To execute the query you need to call `execute` or `executeTakeFirst`.");

// ../../../node_modules/.pnpm/kysely@0.27.4/node_modules/kysely/dist/esm/query-builder/delete-query-builder.js
init_define_ENV_DEFINED_IN_BUILD_STEP();

// ../../../node_modules/.pnpm/kysely@0.27.4/node_modules/kysely/dist/esm/query-builder/delete-result.js
init_define_ENV_DEFINED_IN_BUILD_STEP();
var DeleteResult = class {
  numDeletedRows;
  constructor(numDeletedRows) {
    this.numDeletedRows = numDeletedRows;
  }
};

// ../../../node_modules/.pnpm/kysely@0.27.4/node_modules/kysely/dist/esm/operation-node/limit-node.js
init_define_ENV_DEFINED_IN_BUILD_STEP();
var LimitNode = freeze({
  is(node) {
    return node.kind === "LimitNode";
  },
  create(limit) {
    return freeze({
      kind: "LimitNode",
      limit
    });
  }
});

// ../../../node_modules/.pnpm/kysely@0.27.4/node_modules/kysely/dist/esm/query-builder/delete-query-builder.js
var DeleteQueryBuilder = class _DeleteQueryBuilder {
  #props;
  constructor(props) {
    this.#props = freeze(props);
  }
  where(...args) {
    return new _DeleteQueryBuilder({
      ...this.#props,
      queryNode: QueryNode.cloneWithWhere(this.#props.queryNode, parseValueBinaryOperationOrExpression(args))
    });
  }
  whereRef(lhs, op, rhs) {
    return new _DeleteQueryBuilder({
      ...this.#props,
      queryNode: QueryNode.cloneWithWhere(this.#props.queryNode, parseReferentialBinaryOperation(lhs, op, rhs))
    });
  }
  clearWhere() {
    return new _DeleteQueryBuilder({
      ...this.#props,
      queryNode: QueryNode.cloneWithoutWhere(this.#props.queryNode)
    });
  }
  /**
   * Changes a `delete from` query into a `delete top from` query.
   *
   * `top` clause is only supported by some dialects like MS SQL Server.
   *
   * ### Examples
   *
   * Delete the first 5 rows:
   *
   * ```ts
   * await db
   *   .deleteFrom('person')
   *   .top(5)
   *   .where('age', '>', 18)
   *   .executeTakeFirstOrThrow()
   * ```
   *
   * The generated SQL (MS SQL Server):
   *
   * ```sql
   * delete top(5) from "person" where "age" > @1
   * ```
   *
   * Delete the first 50% of rows:
   *
   * ```ts
   * await db
   *   .deleteFrom('person')
   *   .top(50, 'percent')
   *   .where('age', '>', 18)
   *   .executeTakeFirstOrThrow()
   * ```
   *
   * The generated SQL (MS SQL Server):
   *
   * ```sql
   * delete top(50) percent from "person" where "age" > @1
   * ```
   */
  top(expression, modifiers) {
    return new _DeleteQueryBuilder({
      ...this.#props,
      queryNode: QueryNode.cloneWithTop(this.#props.queryNode, parseTop(expression, modifiers))
    });
  }
  using(tables) {
    return new _DeleteQueryBuilder({
      ...this.#props,
      queryNode: DeleteQueryNode.cloneWithUsing(this.#props.queryNode, parseTableExpressionOrList(tables))
    });
  }
  innerJoin(...args) {
    return new _DeleteQueryBuilder({
      ...this.#props,
      queryNode: QueryNode.cloneWithJoin(this.#props.queryNode, parseJoin("InnerJoin", args))
    });
  }
  leftJoin(...args) {
    return new _DeleteQueryBuilder({
      ...this.#props,
      queryNode: QueryNode.cloneWithJoin(this.#props.queryNode, parseJoin("LeftJoin", args))
    });
  }
  rightJoin(...args) {
    return new _DeleteQueryBuilder({
      ...this.#props,
      queryNode: QueryNode.cloneWithJoin(this.#props.queryNode, parseJoin("RightJoin", args))
    });
  }
  fullJoin(...args) {
    return new _DeleteQueryBuilder({
      ...this.#props,
      queryNode: QueryNode.cloneWithJoin(this.#props.queryNode, parseJoin("FullJoin", args))
    });
  }
  returning(selection) {
    return new _DeleteQueryBuilder({
      ...this.#props,
      queryNode: QueryNode.cloneWithReturning(this.#props.queryNode, parseSelectArg(selection))
    });
  }
  returningAll(table) {
    return new _DeleteQueryBuilder({
      ...this.#props,
      queryNode: QueryNode.cloneWithReturning(this.#props.queryNode, parseSelectAll(table))
    });
  }
  output(args) {
    return new _DeleteQueryBuilder({
      ...this.#props,
      queryNode: QueryNode.cloneWithOutput(this.#props.queryNode, parseSelectArg(args))
    });
  }
  outputAll(table) {
    return new _DeleteQueryBuilder({
      ...this.#props,
      queryNode: QueryNode.cloneWithOutput(this.#props.queryNode, parseSelectAll(table))
    });
  }
  /**
   * Clears all `returning` clauses from the query.
   *
   * ### Examples
   *
   * ```ts
   * db.deleteFrom('pet')
   *   .returningAll()
   *   .where('name', '=', 'Max')
   *   .clearReturning()
   * ```
   *
   * The generated SQL(PostgreSQL):
   *
   * ```sql
   * delete from "pet" where "name" = "Max"
   * ```
   */
  clearReturning() {
    return new _DeleteQueryBuilder({
      ...this.#props,
      queryNode: QueryNode.cloneWithoutReturning(this.#props.queryNode)
    });
  }
  /**
   * Clears the `limit` clause from the query.
   *
   * ### Examples
   *
   * ```ts
   * db.deleteFrom('pet')
   *   .returningAll()
   *   .where('name', '=', 'Max')
   *   .limit(5)
   *   .clearLimit()
   * ```
   *
   * The generated SQL(PostgreSQL):
   *
   * ```sql
   * delete from "pet" where "name" = "Max" returning *
   * ```
   */
  clearLimit() {
    return new _DeleteQueryBuilder({
      ...this.#props,
      queryNode: DeleteQueryNode.cloneWithoutLimit(this.#props.queryNode)
    });
  }
  /**
   * Clears the `order by` clause from the query.
   *
   * ### Examples
   *
   * ```ts
   * db.deleteFrom('pet')
   *   .returningAll()
   *   .where('name', '=', 'Max')
   *   .orderBy('id')
   *   .clearOrderBy()
   * ```
   *
   * The generated SQL(PostgreSQL):
   *
   * ```sql
   * delete from "pet" where "name" = "Max" returning *
   * ```
   */
  clearOrderBy() {
    return new _DeleteQueryBuilder({
      ...this.#props,
      queryNode: DeleteQueryNode.cloneWithoutOrderBy(this.#props.queryNode)
    });
  }
  /**
   * Adds an `order by` clause to the query.
   *
   * `orderBy` calls are additive. To order by multiple columns, call `orderBy`
   * multiple times.
   *
   * The first argument is the expression to order by and the second is the
   * order (`asc` or `desc`).
   *
   * An `order by` clause in a delete query is only supported by some dialects
   * like MySQL.
   *
   * See {@link SelectQueryBuilder.orderBy} for more examples.
   *
   * ### Examples
   *
   * Delete 5 oldest items in a table:
   *
   * ```ts
   * await db
   *   .deleteFrom('pet')
   *   .orderBy('created_at')
   *   .limit(5)
   *   .execute()
   * ```
   *
   * The generated SQL (MySQL):
   *
   * ```sql
   * delete from `pet`
   * order by `created_at`
   * limit ?
   * ```
   */
  orderBy(orderBy, direction) {
    return new _DeleteQueryBuilder({
      ...this.#props,
      queryNode: DeleteQueryNode.cloneWithOrderByItems(this.#props.queryNode, parseOrderBy([orderBy, direction]))
    });
  }
  /**
   * Adds a limit clause to the query.
   *
   * A limit clause in a delete query is only supported by some dialects
   * like MySQL.
   *
   * ### Examples
   *
   * Delete 5 oldest items in a table:
   *
   * ```ts
   * await db
   *   .deleteFrom('pet')
   *   .orderBy('created_at')
   *   .limit(5)
   *   .execute()
   * ```
   */
  limit(limit) {
    return new _DeleteQueryBuilder({
      ...this.#props,
      queryNode: DeleteQueryNode.cloneWithLimit(this.#props.queryNode, LimitNode.create(parseValueExpression(limit)))
    });
  }
  /**
   * Simply calls the provided function passing `this` as the only argument. `$call` returns
   * what the provided function returns.
   *
   * If you want to conditionally call a method on `this`, see
   * the {@link $if} method.
   *
   * ### Examples
   *
   * The next example uses a helper function `log` to log a query:
   *
   * ```ts
   * function log<T extends Compilable>(qb: T): T {
   *   console.log(qb.compile())
   *   return qb
   * }
   *
   * db.deleteFrom('person')
   *   .$call(log)
   *   .execute()
   * ```
   */
  $call(func) {
    return func(this);
  }
  /**
   * Call `func(this)` if `condition` is true.
   *
   * This method is especially handy with optional selects. Any `returning` or `returningAll`
   * method calls add columns as optional fields to the output type when called inside
   * the `func` callback. This is because we can't know if those selections were actually
   * made before running the code.
   *
   * You can also call any other methods inside the callback.
   *
   * ### Examples
   *
   * ```ts
   * async function deletePerson(id: number, returnLastName: boolean) {
   *   return await db
   *     .deleteFrom('person')
   *     .where('id', '=', id)
   *     .returning(['id', 'first_name'])
   *     .$if(returnLastName, (qb) => qb.returning('last_name'))
   *     .executeTakeFirstOrThrow()
   * }
   * ```
   *
   * Any selections added inside the `if` callback will be added as optional fields to the
   * output type since we can't know if the selections were actually made before running
   * the code. In the example above the return type of the `deletePerson` function is:
   *
   * ```ts
   * {
   *   id: number
   *   first_name: string
   *   last_name?: string
   * }
   * ```
   */
  $if(condition, func) {
    if (condition) {
      return func(this);
    }
    return new _DeleteQueryBuilder({
      ...this.#props
    });
  }
  /**
   * Change the output type of the query.
   *
   * This method call doesn't change the SQL in any way. This methods simply
   * returns a copy of this `DeleteQueryBuilder` with a new output type.
   */
  $castTo() {
    return new _DeleteQueryBuilder(this.#props);
  }
  /**
   * Narrows (parts of) the output type of the query.
   *
   * Kysely tries to be as type-safe as possible, but in some cases we have to make
   * compromises for better maintainability and compilation performance. At present,
   * Kysely doesn't narrow the output type of the query when using {@link where} and {@link returning} or {@link returningAll}.
   *
   * This utility method is very useful for these situations, as it removes unncessary
   * runtime assertion/guard code. Its input type is limited to the output type
   * of the query, so you can't add a column that doesn't exist, or change a column's
   * type to something that doesn't exist in its union type.
   *
   * ### Examples
   *
   * Turn this code:
   *
   * ```ts
   * const person = await db.deleteFrom('person')
   *   .where('id', '=', id)
   *   .where('nullable_column', 'is not', null)
   *   .returningAll()
   *   .executeTakeFirstOrThrow()
   *
   * if (person.nullable_column) {
   *   functionThatExpectsPersonWithNonNullValue(person)
   * }
   * ```
   *
   * Into this:
   *
   * ```ts
   * const person = await db.deleteFrom('person')
   *   .where('id', '=', id)
   *   .where('nullable_column', 'is not', null)
   *   .returningAll()
   *   .$narrowType<{ nullable_column: string }>()
   *   .executeTakeFirstOrThrow()
   *
   * functionThatExpectsPersonWithNonNullValue(person)
   * ```
   */
  $narrowType() {
    return new _DeleteQueryBuilder(this.#props);
  }
  /**
   * Asserts that query's output row type equals the given type `T`.
   *
   * This method can be used to simplify excessively complex types to make TypeScript happy
   * and much faster.
   *
   * Kysely uses complex type magic to achieve its type safety. This complexity is sometimes too much
   * for TypeScript and you get errors like this:
   *
   * ```
   * error TS2589: Type instantiation is excessively deep and possibly infinite.
   * ```
   *
   * In these case you can often use this method to help TypeScript a little bit. When you use this
   * method to assert the output type of a query, Kysely can drop the complex output type that
   * consists of multiple nested helper types and replace it with the simple asserted type.
   *
   * Using this method doesn't reduce type safety at all. You have to pass in a type that is
   * structurally equal to the current type.
   *
   * ### Examples
   *
   * ```ts
   * const result = await db
   *   .with('deleted_person', (qb) => qb
   *     .deleteFrom('person')
   *     .where('id', '=', person.id)
   *     .returning('first_name')
   *     .$assertType<{ first_name: string }>()
   *   )
   *   .with('deleted_pet', (qb) => qb
   *     .deleteFrom('pet')
   *     .where('owner_id', '=', person.id)
   *     .returning(['name as pet_name', 'species'])
   *     .$assertType<{ pet_name: string, species: Species }>()
   *   )
   *   .selectFrom(['deleted_person', 'deleted_pet'])
   *   .selectAll()
   *   .executeTakeFirstOrThrow()
   * ```
   */
  $assertType() {
    return new _DeleteQueryBuilder(this.#props);
  }
  /**
   * Returns a copy of this DeleteQueryBuilder instance with the given plugin installed.
   */
  withPlugin(plugin2) {
    return new _DeleteQueryBuilder({
      ...this.#props,
      executor: this.#props.executor.withPlugin(plugin2)
    });
  }
  toOperationNode() {
    return this.#props.executor.transformQuery(this.#props.queryNode, this.#props.queryId);
  }
  compile() {
    return this.#props.executor.compileQuery(this.toOperationNode(), this.#props.queryId);
  }
  /**
   * Executes the query and returns an array of rows.
   *
   * Also see the {@link executeTakeFirst} and {@link executeTakeFirstOrThrow} methods.
   */
  async execute() {
    const compiledQuery = this.compile();
    const result = await this.#props.executor.executeQuery(compiledQuery, this.#props.queryId);
    const { adapter } = this.#props.executor;
    const query = compiledQuery.query;
    if (query.returning && adapter.supportsReturning || query.output && adapter.supportsOutput) {
      return result.rows;
    }
    return [
      new DeleteResult(
        // TODO: remove numUpdatedOrDeletedRows.
        result.numAffectedRows ?? result.numUpdatedOrDeletedRows ?? BigInt(0)
      )
    ];
  }
  /**
   * Executes the query and returns the first result or undefined if
   * the query returned no result.
   */
  async executeTakeFirst() {
    const [result] = await this.execute();
    return result;
  }
  /**
   * Executes the query and returns the first result or throws if
   * the query returned no result.
   *
   * By default an instance of {@link NoResultError} is thrown, but you can
   * provide a custom error class, or callback as the only argument to throw a different
   * error.
   */
  async executeTakeFirstOrThrow(errorConstructor = NoResultError) {
    const result = await this.executeTakeFirst();
    if (result === void 0) {
      const error = isNoResultErrorConstructor(errorConstructor) ? new errorConstructor(this.toOperationNode()) : errorConstructor(this.toOperationNode());
      throw error;
    }
    return result;
  }
  async *stream(chunkSize = 100) {
    const compiledQuery = this.compile();
    const stream = this.#props.executor.stream(compiledQuery, chunkSize, this.#props.queryId);
    for await (const item of stream) {
      yield* item.rows;
    }
  }
  async explain(format, options) {
    const builder = new _DeleteQueryBuilder({
      ...this.#props,
      queryNode: QueryNode.cloneWithExplain(this.#props.queryNode, format, options)
    });
    return await builder.execute();
  }
};
preventAwait(DeleteQueryBuilder, "don't await DeleteQueryBuilder instances directly. To execute the query you need to call `execute` or `executeTakeFirst`.");

// ../../../node_modules/.pnpm/kysely@0.27.4/node_modules/kysely/dist/esm/query-builder/update-query-builder.js
init_define_ENV_DEFINED_IN_BUILD_STEP();

// ../../../node_modules/.pnpm/kysely@0.27.4/node_modules/kysely/dist/esm/query-builder/update-result.js
init_define_ENV_DEFINED_IN_BUILD_STEP();
var UpdateResult = class {
  /**
   * The number of rows the update query updated (even if not changed).
  */
  numUpdatedRows;
  /**
   * The number of rows the update query changed.
   *
   * This is **optional** and only supported in dialects such as MySQL.
   * You would probably use {@link numUpdatedRows} in most cases.
  */
  numChangedRows;
  constructor(numUpdatedRows, numChangedRows) {
    this.numUpdatedRows = numUpdatedRows;
    this.numChangedRows = numChangedRows;
  }
};

// ../../../node_modules/.pnpm/kysely@0.27.4/node_modules/kysely/dist/esm/query-builder/update-query-builder.js
var UpdateQueryBuilder = class _UpdateQueryBuilder {
  #props;
  constructor(props) {
    this.#props = freeze(props);
  }
  where(...args) {
    return new _UpdateQueryBuilder({
      ...this.#props,
      queryNode: QueryNode.cloneWithWhere(this.#props.queryNode, parseValueBinaryOperationOrExpression(args))
    });
  }
  whereRef(lhs, op, rhs) {
    return new _UpdateQueryBuilder({
      ...this.#props,
      queryNode: QueryNode.cloneWithWhere(this.#props.queryNode, parseReferentialBinaryOperation(lhs, op, rhs))
    });
  }
  clearWhere() {
    return new _UpdateQueryBuilder({
      ...this.#props,
      queryNode: QueryNode.cloneWithoutWhere(this.#props.queryNode)
    });
  }
  /**
   * Changes an `update` query into a `update top` query.
   *
   * `top` clause is only supported by some dialects like MS SQL Server.
   *
   * ### Examples
   *
   * Update the first row:
   *
   * ```ts
   * await db.updateTable('person')
   *   .top(1)
   *   .set({ first_name: 'Foo' })
   *   .where('age', '>', 18)
   *   .executeTakeFirstOrThrow()
   * ```
   *
   * The generated SQL (MS SQL Server):
   *
   * ```sql
   * update top(1) "person" set "first_name" = @1 where "age" > @2
   * ```
   *
   * Update the 50% first rows:
   *
   * ```ts
   * await db.updateTable('person')
   *   .top(50, 'percent')
   *   .set({ first_name: 'Foo' })
   *   .where('age', '>', 18)
   *   .executeTakeFirstOrThrow()
   * ```
   *
   * The generated SQL (MS SQL Server):
   *
   * ```sql
   * update top(50) percent "person" set "first_name" = @1 where "age" > @2
   * ```
   */
  top(expression, modifiers) {
    return new _UpdateQueryBuilder({
      ...this.#props,
      queryNode: QueryNode.cloneWithTop(this.#props.queryNode, parseTop(expression, modifiers))
    });
  }
  from(from) {
    return new _UpdateQueryBuilder({
      ...this.#props,
      queryNode: UpdateQueryNode.cloneWithFromItems(this.#props.queryNode, parseTableExpressionOrList(from))
    });
  }
  innerJoin(...args) {
    return new _UpdateQueryBuilder({
      ...this.#props,
      queryNode: QueryNode.cloneWithJoin(this.#props.queryNode, parseJoin("InnerJoin", args))
    });
  }
  leftJoin(...args) {
    return new _UpdateQueryBuilder({
      ...this.#props,
      queryNode: QueryNode.cloneWithJoin(this.#props.queryNode, parseJoin("LeftJoin", args))
    });
  }
  rightJoin(...args) {
    return new _UpdateQueryBuilder({
      ...this.#props,
      queryNode: QueryNode.cloneWithJoin(this.#props.queryNode, parseJoin("RightJoin", args))
    });
  }
  fullJoin(...args) {
    return new _UpdateQueryBuilder({
      ...this.#props,
      queryNode: QueryNode.cloneWithJoin(this.#props.queryNode, parseJoin("FullJoin", args))
    });
  }
  /**
   * Adds a limit clause to the update query for supported databases, such as MySQL.
   *
   * ### Examples
   *
   * Update the first 2 rows in the 'person' table:
   *
   * ```ts
   * return await db
   *   .updateTable('person')
   *   .set({ first_name: 'Foo' })
   *   .limit(2);
   * ```
   *
   * The generated SQL (MySQL):
   * ```sql
   * update `person` set `first_name` = 'Foo' limit 2
   * ```
   */
  limit(limit) {
    return new _UpdateQueryBuilder({
      ...this.#props,
      queryNode: UpdateQueryNode.cloneWithLimit(this.#props.queryNode, LimitNode.create(parseValueExpression(limit)))
    });
  }
  set(...args) {
    return new _UpdateQueryBuilder({
      ...this.#props,
      queryNode: UpdateQueryNode.cloneWithUpdates(this.#props.queryNode, parseUpdate(...args))
    });
  }
  returning(selection) {
    return new _UpdateQueryBuilder({
      ...this.#props,
      queryNode: QueryNode.cloneWithReturning(this.#props.queryNode, parseSelectArg(selection))
    });
  }
  returningAll(table) {
    return new _UpdateQueryBuilder({
      ...this.#props,
      queryNode: QueryNode.cloneWithReturning(this.#props.queryNode, parseSelectAll(table))
    });
  }
  output(args) {
    return new _UpdateQueryBuilder({
      ...this.#props,
      queryNode: QueryNode.cloneWithOutput(this.#props.queryNode, parseSelectArg(args))
    });
  }
  outputAll(table) {
    return new _UpdateQueryBuilder({
      ...this.#props,
      queryNode: QueryNode.cloneWithOutput(this.#props.queryNode, parseSelectAll(table))
    });
  }
  /**
   * Clears all `returning` clauses from the query.
   *
   * ### Examples
   *
   * ```ts
   * db.updateTable('person')
   *   .returningAll()
   *   .set({ age: 39 })
   *   .where('first_name', '=', 'John')
   *   .clearReturning()
   * ```
   *
   * The generated SQL(PostgreSQL):
   *
   * ```sql
   * update "person" set "age" = 39 where "first_name" = "John"
   * ```
   */
  clearReturning() {
    return new _UpdateQueryBuilder({
      ...this.#props,
      queryNode: QueryNode.cloneWithoutReturning(this.#props.queryNode)
    });
  }
  /**
   * Simply calls the provided function passing `this` as the only argument. `$call` returns
   * what the provided function returns.
   *
   * If you want to conditionally call a method on `this`, see
   * the {@link $if} method.
   *
   * ### Examples
   *
   * The next example uses a helper function `log` to log a query:
   *
   * ```ts
   * function log<T extends Compilable>(qb: T): T {
   *   console.log(qb.compile())
   *   return qb
   * }
   *
   * db.updateTable('person')
   *   .set(values)
   *   .$call(log)
   *   .execute()
   * ```
   */
  $call(func) {
    return func(this);
  }
  /**
   * Call `func(this)` if `condition` is true.
   *
   * This method is especially handy with optional selects. Any `returning` or `returningAll`
   * method calls add columns as optional fields to the output type when called inside
   * the `func` callback. This is because we can't know if those selections were actually
   * made before running the code.
   *
   * You can also call any other methods inside the callback.
   *
   * ### Examples
   *
   * ```ts
   * async function updatePerson(id: number, updates: UpdateablePerson, returnLastName: boolean) {
   *   return await db
   *     .updateTable('person')
   *     .set(updates)
   *     .where('id', '=', id)
   *     .returning(['id', 'first_name'])
   *     .$if(returnLastName, (qb) => qb.returning('last_name'))
   *     .executeTakeFirstOrThrow()
   * }
   * ```
   *
   * Any selections added inside the `if` callback will be added as optional fields to the
   * output type since we can't know if the selections were actually made before running
   * the code. In the example above the return type of the `updatePerson` function is:
   *
   * ```ts
   * {
   *   id: number
   *   first_name: string
   *   last_name?: string
   * }
   * ```
   */
  $if(condition, func) {
    if (condition) {
      return func(this);
    }
    return new _UpdateQueryBuilder({
      ...this.#props
    });
  }
  /**
   * Change the output type of the query.
   *
   * This method call doesn't change the SQL in any way. This methods simply
   * returns a copy of this `UpdateQueryBuilder` with a new output type.
   */
  $castTo() {
    return new _UpdateQueryBuilder(this.#props);
  }
  /**
   * Narrows (parts of) the output type of the query.
   *
   * Kysely tries to be as type-safe as possible, but in some cases we have to make
   * compromises for better maintainability and compilation performance. At present,
   * Kysely doesn't narrow the output type of the query based on {@link set} input
   * when using {@link where} and/or {@link returning} or {@link returningAll}.
   *
   * This utility method is very useful for these situations, as it removes unncessary
   * runtime assertion/guard code. Its input type is limited to the output type
   * of the query, so you can't add a column that doesn't exist, or change a column's
   * type to something that doesn't exist in its union type.
   *
   * ### Examples
   *
   * Turn this code:
   *
   * ```ts
   * const person = await db.updateTable('person')
   *   .set({ deletedAt: now })
   *   .where('id', '=', id)
   *   .where('nullable_column', 'is not', null)
   *   .returningAll()
   *   .executeTakeFirstOrThrow()
   *
   * if (person.nullable_column) {
   *   functionThatExpectsPersonWithNonNullValue(person)
   * }
   * ```
   *
   * Into this:
   *
   * ```ts
   * const person = await db.updateTable('person')
   *   .set({ deletedAt: now })
   *   .where('id', '=', id)
   *   .where('nullable_column', 'is not', null)
   *   .returningAll()
   *   .$narrowType<{ deletedAt: Date; nullable_column: string }>()
   *   .executeTakeFirstOrThrow()
   *
   * functionThatExpectsPersonWithNonNullValue(person)
   * ```
   */
  $narrowType() {
    return new _UpdateQueryBuilder(this.#props);
  }
  /**
   * Asserts that query's output row type equals the given type `T`.
   *
   * This method can be used to simplify excessively complex types to make TypeScript happy
   * and much faster.
   *
   * Kysely uses complex type magic to achieve its type safety. This complexity is sometimes too much
   * for TypeScript and you get errors like this:
   *
   * ```
   * error TS2589: Type instantiation is excessively deep and possibly infinite.
   * ```
   *
   * In these case you can often use this method to help TypeScript a little bit. When you use this
   * method to assert the output type of a query, Kysely can drop the complex output type that
   * consists of multiple nested helper types and replace it with the simple asserted type.
   *
   * Using this method doesn't reduce type safety at all. You have to pass in a type that is
   * structurally equal to the current type.
   *
   * ### Examples
   *
   * ```ts
   * const result = await db
   *   .with('updated_person', (qb) => qb
   *     .updateTable('person')
   *     .set(person)
   *     .where('id', '=', person.id)
   *     .returning('first_name')
   *     .$assertType<{ first_name: string }>()
   *   )
   *   .with('updated_pet', (qb) => qb
   *     .updateTable('pet')
   *     .set(pet)
   *     .where('owner_id', '=', person.id)
   *     .returning(['name as pet_name', 'species'])
   *     .$assertType<{ pet_name: string, species: Species }>()
   *   )
   *   .selectFrom(['updated_person', 'updated_pet'])
   *   .selectAll()
   *   .executeTakeFirstOrThrow()
   * ```
   */
  $assertType() {
    return new _UpdateQueryBuilder(this.#props);
  }
  /**
   * Returns a copy of this UpdateQueryBuilder instance with the given plugin installed.
   */
  withPlugin(plugin2) {
    return new _UpdateQueryBuilder({
      ...this.#props,
      executor: this.#props.executor.withPlugin(plugin2)
    });
  }
  toOperationNode() {
    return this.#props.executor.transformQuery(this.#props.queryNode, this.#props.queryId);
  }
  compile() {
    return this.#props.executor.compileQuery(this.toOperationNode(), this.#props.queryId);
  }
  /**
   * Executes the query and returns an array of rows.
   *
   * Also see the {@link executeTakeFirst} and {@link executeTakeFirstOrThrow} methods.
   */
  async execute() {
    const compiledQuery = this.compile();
    const result = await this.#props.executor.executeQuery(compiledQuery, this.#props.queryId);
    const { adapter } = this.#props.executor;
    const query = compiledQuery.query;
    if (query.returning && adapter.supportsReturning || query.output && adapter.supportsOutput) {
      return result.rows;
    }
    return [
      new UpdateResult(
        // TODO: remove numUpdatedOrDeletedRows.
        // TODO: https://github.com/kysely-org/kysely/pull/431#discussion_r1172330899
        result.numAffectedRows ?? result.numUpdatedOrDeletedRows ?? BigInt(0),
        result.numChangedRows
      )
    ];
  }
  /**
   * Executes the query and returns the first result or undefined if
   * the query returned no result.
   */
  async executeTakeFirst() {
    const [result] = await this.execute();
    return result;
  }
  /**
   * Executes the query and returns the first result or throws if
   * the query returned no result.
   *
   * By default an instance of {@link NoResultError} is thrown, but you can
   * provide a custom error class, or callback as the only argument to throw a different
   * error.
   */
  async executeTakeFirstOrThrow(errorConstructor = NoResultError) {
    const result = await this.executeTakeFirst();
    if (result === void 0) {
      const error = isNoResultErrorConstructor(errorConstructor) ? new errorConstructor(this.toOperationNode()) : errorConstructor(this.toOperationNode());
      throw error;
    }
    return result;
  }
  async *stream(chunkSize = 100) {
    const compiledQuery = this.compile();
    const stream = this.#props.executor.stream(compiledQuery, chunkSize, this.#props.queryId);
    for await (const item of stream) {
      yield* item.rows;
    }
  }
  async explain(format, options) {
    const builder = new _UpdateQueryBuilder({
      ...this.#props,
      queryNode: QueryNode.cloneWithExplain(this.#props.queryNode, format, options)
    });
    return await builder.execute();
  }
};
preventAwait(UpdateQueryBuilder, "don't await UpdateQueryBuilder instances directly. To execute the query you need to call `execute` or `executeTakeFirst`.");

// ../../../node_modules/.pnpm/kysely@0.27.4/node_modules/kysely/dist/esm/parser/with-parser.js
init_define_ENV_DEFINED_IN_BUILD_STEP();

// ../../../node_modules/.pnpm/kysely@0.27.4/node_modules/kysely/dist/esm/operation-node/common-table-expression-name-node.js
init_define_ENV_DEFINED_IN_BUILD_STEP();
var CommonTableExpressionNameNode = freeze({
  is(node) {
    return node.kind === "CommonTableExpressionNameNode";
  },
  create(tableName, columnNames) {
    return freeze({
      kind: "CommonTableExpressionNameNode",
      table: TableNode.create(tableName),
      columns: columnNames ? freeze(columnNames.map(ColumnNode.create)) : void 0
    });
  }
});

// ../../../node_modules/.pnpm/kysely@0.27.4/node_modules/kysely/dist/esm/query-builder/cte-builder.js
init_define_ENV_DEFINED_IN_BUILD_STEP();

// ../../../node_modules/.pnpm/kysely@0.27.4/node_modules/kysely/dist/esm/operation-node/common-table-expression-node.js
init_define_ENV_DEFINED_IN_BUILD_STEP();
var CommonTableExpressionNode = freeze({
  is(node) {
    return node.kind === "CommonTableExpressionNode";
  },
  create(name, expression) {
    return freeze({
      kind: "CommonTableExpressionNode",
      name,
      expression
    });
  },
  cloneWith(node, props) {
    return freeze({
      ...node,
      ...props
    });
  }
});

// ../../../node_modules/.pnpm/kysely@0.27.4/node_modules/kysely/dist/esm/query-builder/cte-builder.js
var CTEBuilder = class _CTEBuilder {
  #props;
  constructor(props) {
    this.#props = freeze(props);
  }
  /**
   * Makes the common table expression materialized.
   */
  materialized() {
    return new _CTEBuilder({
      ...this.#props,
      node: CommonTableExpressionNode.cloneWith(this.#props.node, {
        materialized: true
      })
    });
  }
  /**
   * Makes the common table expression not materialized.
   */
  notMaterialized() {
    return new _CTEBuilder({
      ...this.#props,
      node: CommonTableExpressionNode.cloneWith(this.#props.node, {
        materialized: false
      })
    });
  }
  toOperationNode() {
    return this.#props.node;
  }
};
preventAwait(CTEBuilder, "don't await CTEBuilder instances. They are never executed directly and are always just a part of a query.");

// ../../../node_modules/.pnpm/kysely@0.27.4/node_modules/kysely/dist/esm/parser/with-parser.js
function parseCommonTableExpression(nameOrBuilderCallback, expression) {
  const expressionNode = expression(createQueryCreator()).toOperationNode();
  if (isFunction(nameOrBuilderCallback)) {
    return nameOrBuilderCallback(cteBuilderFactory(expressionNode)).toOperationNode();
  }
  return CommonTableExpressionNode.create(parseCommonTableExpressionName(nameOrBuilderCallback), expressionNode);
}
function cteBuilderFactory(expressionNode) {
  return (name) => {
    return new CTEBuilder({
      node: CommonTableExpressionNode.create(parseCommonTableExpressionName(name), expressionNode)
    });
  };
}
function parseCommonTableExpressionName(name) {
  if (name.includes("(")) {
    const parts = name.split(/[\(\)]/);
    const table = parts[0];
    const columns = parts[1].split(",").map((it) => it.trim());
    return CommonTableExpressionNameNode.create(table, columns);
  } else {
    return CommonTableExpressionNameNode.create(name);
  }
}

// ../../../node_modules/.pnpm/kysely@0.27.4/node_modules/kysely/dist/esm/operation-node/with-node.js
init_define_ENV_DEFINED_IN_BUILD_STEP();
var WithNode = freeze({
  is(node) {
    return node.kind === "WithNode";
  },
  create(expression, params) {
    return freeze({
      kind: "WithNode",
      expressions: freeze([expression]),
      ...params
    });
  },
  cloneWithExpression(withNode, expression) {
    return freeze({
      ...withNode,
      expressions: freeze([...withNode.expressions, expression])
    });
  }
});

// ../../../node_modules/.pnpm/kysely@0.27.4/node_modules/kysely/dist/esm/util/query-id.js
init_define_ENV_DEFINED_IN_BUILD_STEP();

// ../../../node_modules/.pnpm/kysely@0.27.4/node_modules/kysely/dist/esm/util/random-string.js
init_define_ENV_DEFINED_IN_BUILD_STEP();
var CHARS = [
  "A",
  "B",
  "C",
  "D",
  "E",
  "F",
  "G",
  "H",
  "I",
  "J",
  "K",
  "L",
  "M",
  "N",
  "O",
  "P",
  "Q",
  "R",
  "S",
  "T",
  "U",
  "V",
  "W",
  "X",
  "Y",
  "Z",
  "a",
  "b",
  "c",
  "d",
  "e",
  "f",
  "g",
  "h",
  "i",
  "j",
  "k",
  "l",
  "m",
  "n",
  "o",
  "p",
  "q",
  "r",
  "s",
  "t",
  "u",
  "v",
  "w",
  "x",
  "y",
  "z",
  "0",
  "1",
  "2",
  "3",
  "4",
  "5",
  "6",
  "7",
  "8",
  "9"
];
function randomString(length) {
  let chars = "";
  for (let i2 = 0; i2 < length; ++i2) {
    chars += randomChar();
  }
  return chars;
}
function randomChar() {
  return CHARS[~~(Math.random() * CHARS.length)];
}

// ../../../node_modules/.pnpm/kysely@0.27.4/node_modules/kysely/dist/esm/util/query-id.js
function createQueryId() {
  return new LazyQueryId();
}
var LazyQueryId = class {
  #queryId;
  get queryId() {
    if (this.#queryId === void 0) {
      this.#queryId = randomString(8);
    }
    return this.#queryId;
  }
};

// ../../../node_modules/.pnpm/kysely@0.27.4/node_modules/kysely/dist/esm/plugin/with-schema/with-schema-plugin.js
init_define_ENV_DEFINED_IN_BUILD_STEP();

// ../../../node_modules/.pnpm/kysely@0.27.4/node_modules/kysely/dist/esm/plugin/with-schema/with-schema-transformer.js
init_define_ENV_DEFINED_IN_BUILD_STEP();

// ../../../node_modules/.pnpm/kysely@0.27.4/node_modules/kysely/dist/esm/operation-node/operation-node-transformer.js
init_define_ENV_DEFINED_IN_BUILD_STEP();

// ../../../node_modules/.pnpm/kysely@0.27.4/node_modules/kysely/dist/esm/util/require-all-props.js
init_define_ENV_DEFINED_IN_BUILD_STEP();
function requireAllProps(obj) {
  return obj;
}

// ../../../node_modules/.pnpm/kysely@0.27.4/node_modules/kysely/dist/esm/operation-node/operation-node-transformer.js
var OperationNodeTransformer = class {
  nodeStack = [];
  #transformers = freeze({
    AliasNode: this.transformAlias.bind(this),
    ColumnNode: this.transformColumn.bind(this),
    IdentifierNode: this.transformIdentifier.bind(this),
    SchemableIdentifierNode: this.transformSchemableIdentifier.bind(this),
    RawNode: this.transformRaw.bind(this),
    ReferenceNode: this.transformReference.bind(this),
    SelectQueryNode: this.transformSelectQuery.bind(this),
    SelectionNode: this.transformSelection.bind(this),
    TableNode: this.transformTable.bind(this),
    FromNode: this.transformFrom.bind(this),
    SelectAllNode: this.transformSelectAll.bind(this),
    AndNode: this.transformAnd.bind(this),
    OrNode: this.transformOr.bind(this),
    ValueNode: this.transformValue.bind(this),
    ValueListNode: this.transformValueList.bind(this),
    PrimitiveValueListNode: this.transformPrimitiveValueList.bind(this),
    ParensNode: this.transformParens.bind(this),
    JoinNode: this.transformJoin.bind(this),
    OperatorNode: this.transformOperator.bind(this),
    WhereNode: this.transformWhere.bind(this),
    InsertQueryNode: this.transformInsertQuery.bind(this),
    DeleteQueryNode: this.transformDeleteQuery.bind(this),
    ReturningNode: this.transformReturning.bind(this),
    CreateTableNode: this.transformCreateTable.bind(this),
    AddColumnNode: this.transformAddColumn.bind(this),
    ColumnDefinitionNode: this.transformColumnDefinition.bind(this),
    DropTableNode: this.transformDropTable.bind(this),
    DataTypeNode: this.transformDataType.bind(this),
    OrderByNode: this.transformOrderBy.bind(this),
    OrderByItemNode: this.transformOrderByItem.bind(this),
    GroupByNode: this.transformGroupBy.bind(this),
    GroupByItemNode: this.transformGroupByItem.bind(this),
    UpdateQueryNode: this.transformUpdateQuery.bind(this),
    ColumnUpdateNode: this.transformColumnUpdate.bind(this),
    LimitNode: this.transformLimit.bind(this),
    OffsetNode: this.transformOffset.bind(this),
    OnConflictNode: this.transformOnConflict.bind(this),
    OnDuplicateKeyNode: this.transformOnDuplicateKey.bind(this),
    CreateIndexNode: this.transformCreateIndex.bind(this),
    DropIndexNode: this.transformDropIndex.bind(this),
    ListNode: this.transformList.bind(this),
    PrimaryKeyConstraintNode: this.transformPrimaryKeyConstraint.bind(this),
    UniqueConstraintNode: this.transformUniqueConstraint.bind(this),
    ReferencesNode: this.transformReferences.bind(this),
    CheckConstraintNode: this.transformCheckConstraint.bind(this),
    WithNode: this.transformWith.bind(this),
    CommonTableExpressionNode: this.transformCommonTableExpression.bind(this),
    CommonTableExpressionNameNode: this.transformCommonTableExpressionName.bind(this),
    HavingNode: this.transformHaving.bind(this),
    CreateSchemaNode: this.transformCreateSchema.bind(this),
    DropSchemaNode: this.transformDropSchema.bind(this),
    AlterTableNode: this.transformAlterTable.bind(this),
    DropColumnNode: this.transformDropColumn.bind(this),
    RenameColumnNode: this.transformRenameColumn.bind(this),
    AlterColumnNode: this.transformAlterColumn.bind(this),
    ModifyColumnNode: this.transformModifyColumn.bind(this),
    AddConstraintNode: this.transformAddConstraint.bind(this),
    DropConstraintNode: this.transformDropConstraint.bind(this),
    ForeignKeyConstraintNode: this.transformForeignKeyConstraint.bind(this),
    CreateViewNode: this.transformCreateView.bind(this),
    DropViewNode: this.transformDropView.bind(this),
    GeneratedNode: this.transformGenerated.bind(this),
    DefaultValueNode: this.transformDefaultValue.bind(this),
    OnNode: this.transformOn.bind(this),
    ValuesNode: this.transformValues.bind(this),
    SelectModifierNode: this.transformSelectModifier.bind(this),
    CreateTypeNode: this.transformCreateType.bind(this),
    DropTypeNode: this.transformDropType.bind(this),
    ExplainNode: this.transformExplain.bind(this),
    DefaultInsertValueNode: this.transformDefaultInsertValue.bind(this),
    AggregateFunctionNode: this.transformAggregateFunction.bind(this),
    OverNode: this.transformOver.bind(this),
    PartitionByNode: this.transformPartitionBy.bind(this),
    PartitionByItemNode: this.transformPartitionByItem.bind(this),
    SetOperationNode: this.transformSetOperation.bind(this),
    BinaryOperationNode: this.transformBinaryOperation.bind(this),
    UnaryOperationNode: this.transformUnaryOperation.bind(this),
    UsingNode: this.transformUsing.bind(this),
    FunctionNode: this.transformFunction.bind(this),
    CaseNode: this.transformCase.bind(this),
    WhenNode: this.transformWhen.bind(this),
    JSONReferenceNode: this.transformJSONReference.bind(this),
    JSONPathNode: this.transformJSONPath.bind(this),
    JSONPathLegNode: this.transformJSONPathLeg.bind(this),
    JSONOperatorChainNode: this.transformJSONOperatorChain.bind(this),
    TupleNode: this.transformTuple.bind(this),
    MergeQueryNode: this.transformMergeQuery.bind(this),
    MatchedNode: this.transformMatched.bind(this),
    AddIndexNode: this.transformAddIndex.bind(this),
    CastNode: this.transformCast.bind(this),
    FetchNode: this.transformFetch.bind(this),
    TopNode: this.transformTop.bind(this),
    OutputNode: this.transformOutput.bind(this)
  });
  transformNode(node) {
    if (!node) {
      return node;
    }
    this.nodeStack.push(node);
    const out = this.transformNodeImpl(node);
    this.nodeStack.pop();
    return freeze(out);
  }
  transformNodeImpl(node) {
    return this.#transformers[node.kind](node);
  }
  transformNodeList(list) {
    if (!list) {
      return list;
    }
    return freeze(list.map((node) => this.transformNode(node)));
  }
  transformSelectQuery(node) {
    return requireAllProps({
      kind: "SelectQueryNode",
      from: this.transformNode(node.from),
      selections: this.transformNodeList(node.selections),
      distinctOn: this.transformNodeList(node.distinctOn),
      joins: this.transformNodeList(node.joins),
      groupBy: this.transformNode(node.groupBy),
      orderBy: this.transformNode(node.orderBy),
      where: this.transformNode(node.where),
      frontModifiers: this.transformNodeList(node.frontModifiers),
      endModifiers: this.transformNodeList(node.endModifiers),
      limit: this.transformNode(node.limit),
      offset: this.transformNode(node.offset),
      with: this.transformNode(node.with),
      having: this.transformNode(node.having),
      explain: this.transformNode(node.explain),
      setOperations: this.transformNodeList(node.setOperations),
      fetch: this.transformNode(node.fetch),
      top: this.transformNode(node.top)
    });
  }
  transformSelection(node) {
    return requireAllProps({
      kind: "SelectionNode",
      selection: this.transformNode(node.selection)
    });
  }
  transformColumn(node) {
    return requireAllProps({
      kind: "ColumnNode",
      column: this.transformNode(node.column)
    });
  }
  transformAlias(node) {
    return requireAllProps({
      kind: "AliasNode",
      node: this.transformNode(node.node),
      alias: this.transformNode(node.alias)
    });
  }
  transformTable(node) {
    return requireAllProps({
      kind: "TableNode",
      table: this.transformNode(node.table)
    });
  }
  transformFrom(node) {
    return requireAllProps({
      kind: "FromNode",
      froms: this.transformNodeList(node.froms)
    });
  }
  transformReference(node) {
    return requireAllProps({
      kind: "ReferenceNode",
      column: this.transformNode(node.column),
      table: this.transformNode(node.table)
    });
  }
  transformAnd(node) {
    return requireAllProps({
      kind: "AndNode",
      left: this.transformNode(node.left),
      right: this.transformNode(node.right)
    });
  }
  transformOr(node) {
    return requireAllProps({
      kind: "OrNode",
      left: this.transformNode(node.left),
      right: this.transformNode(node.right)
    });
  }
  transformValueList(node) {
    return requireAllProps({
      kind: "ValueListNode",
      values: this.transformNodeList(node.values)
    });
  }
  transformParens(node) {
    return requireAllProps({
      kind: "ParensNode",
      node: this.transformNode(node.node)
    });
  }
  transformJoin(node) {
    return requireAllProps({
      kind: "JoinNode",
      joinType: node.joinType,
      table: this.transformNode(node.table),
      on: this.transformNode(node.on)
    });
  }
  transformRaw(node) {
    return requireAllProps({
      kind: "RawNode",
      sqlFragments: freeze([...node.sqlFragments]),
      parameters: this.transformNodeList(node.parameters)
    });
  }
  transformWhere(node) {
    return requireAllProps({
      kind: "WhereNode",
      where: this.transformNode(node.where)
    });
  }
  transformInsertQuery(node) {
    return requireAllProps({
      kind: "InsertQueryNode",
      into: this.transformNode(node.into),
      columns: this.transformNodeList(node.columns),
      values: this.transformNode(node.values),
      returning: this.transformNode(node.returning),
      onConflict: this.transformNode(node.onConflict),
      onDuplicateKey: this.transformNode(node.onDuplicateKey),
      with: this.transformNode(node.with),
      ignore: node.ignore,
      replace: node.replace,
      explain: this.transformNode(node.explain),
      defaultValues: node.defaultValues,
      top: this.transformNode(node.top),
      output: this.transformNode(node.output)
    });
  }
  transformValues(node) {
    return requireAllProps({
      kind: "ValuesNode",
      values: this.transformNodeList(node.values)
    });
  }
  transformDeleteQuery(node) {
    return requireAllProps({
      kind: "DeleteQueryNode",
      from: this.transformNode(node.from),
      using: this.transformNode(node.using),
      joins: this.transformNodeList(node.joins),
      where: this.transformNode(node.where),
      returning: this.transformNode(node.returning),
      with: this.transformNode(node.with),
      orderBy: this.transformNode(node.orderBy),
      limit: this.transformNode(node.limit),
      explain: this.transformNode(node.explain),
      top: this.transformNode(node.top),
      output: this.transformNode(node.output)
    });
  }
  transformReturning(node) {
    return requireAllProps({
      kind: "ReturningNode",
      selections: this.transformNodeList(node.selections)
    });
  }
  transformCreateTable(node) {
    return requireAllProps({
      kind: "CreateTableNode",
      table: this.transformNode(node.table),
      columns: this.transformNodeList(node.columns),
      constraints: this.transformNodeList(node.constraints),
      temporary: node.temporary,
      ifNotExists: node.ifNotExists,
      onCommit: node.onCommit,
      frontModifiers: this.transformNodeList(node.frontModifiers),
      endModifiers: this.transformNodeList(node.endModifiers),
      selectQuery: this.transformNode(node.selectQuery)
    });
  }
  transformColumnDefinition(node) {
    return requireAllProps({
      kind: "ColumnDefinitionNode",
      column: this.transformNode(node.column),
      dataType: this.transformNode(node.dataType),
      references: this.transformNode(node.references),
      primaryKey: node.primaryKey,
      autoIncrement: node.autoIncrement,
      unique: node.unique,
      notNull: node.notNull,
      unsigned: node.unsigned,
      defaultTo: this.transformNode(node.defaultTo),
      check: this.transformNode(node.check),
      generated: this.transformNode(node.generated),
      frontModifiers: this.transformNodeList(node.frontModifiers),
      endModifiers: this.transformNodeList(node.endModifiers),
      nullsNotDistinct: node.nullsNotDistinct,
      identity: node.identity,
      ifNotExists: node.ifNotExists
    });
  }
  transformAddColumn(node) {
    return requireAllProps({
      kind: "AddColumnNode",
      column: this.transformNode(node.column)
    });
  }
  transformDropTable(node) {
    return requireAllProps({
      kind: "DropTableNode",
      table: this.transformNode(node.table),
      ifExists: node.ifExists,
      cascade: node.cascade
    });
  }
  transformOrderBy(node) {
    return requireAllProps({
      kind: "OrderByNode",
      items: this.transformNodeList(node.items)
    });
  }
  transformOrderByItem(node) {
    return requireAllProps({
      kind: "OrderByItemNode",
      orderBy: this.transformNode(node.orderBy),
      direction: this.transformNode(node.direction)
    });
  }
  transformGroupBy(node) {
    return requireAllProps({
      kind: "GroupByNode",
      items: this.transformNodeList(node.items)
    });
  }
  transformGroupByItem(node) {
    return requireAllProps({
      kind: "GroupByItemNode",
      groupBy: this.transformNode(node.groupBy)
    });
  }
  transformUpdateQuery(node) {
    return requireAllProps({
      kind: "UpdateQueryNode",
      table: this.transformNode(node.table),
      from: this.transformNode(node.from),
      joins: this.transformNodeList(node.joins),
      where: this.transformNode(node.where),
      updates: this.transformNodeList(node.updates),
      returning: this.transformNode(node.returning),
      with: this.transformNode(node.with),
      explain: this.transformNode(node.explain),
      limit: this.transformNode(node.limit),
      top: this.transformNode(node.top),
      output: this.transformNode(node.output)
    });
  }
  transformColumnUpdate(node) {
    return requireAllProps({
      kind: "ColumnUpdateNode",
      column: this.transformNode(node.column),
      value: this.transformNode(node.value)
    });
  }
  transformLimit(node) {
    return requireAllProps({
      kind: "LimitNode",
      limit: this.transformNode(node.limit)
    });
  }
  transformOffset(node) {
    return requireAllProps({
      kind: "OffsetNode",
      offset: this.transformNode(node.offset)
    });
  }
  transformOnConflict(node) {
    return requireAllProps({
      kind: "OnConflictNode",
      columns: this.transformNodeList(node.columns),
      constraint: this.transformNode(node.constraint),
      indexExpression: this.transformNode(node.indexExpression),
      indexWhere: this.transformNode(node.indexWhere),
      updates: this.transformNodeList(node.updates),
      updateWhere: this.transformNode(node.updateWhere),
      doNothing: node.doNothing
    });
  }
  transformOnDuplicateKey(node) {
    return requireAllProps({
      kind: "OnDuplicateKeyNode",
      updates: this.transformNodeList(node.updates)
    });
  }
  transformCreateIndex(node) {
    return requireAllProps({
      kind: "CreateIndexNode",
      name: this.transformNode(node.name),
      table: this.transformNode(node.table),
      columns: this.transformNodeList(node.columns),
      unique: node.unique,
      using: this.transformNode(node.using),
      ifNotExists: node.ifNotExists,
      where: this.transformNode(node.where),
      nullsNotDistinct: node.nullsNotDistinct
    });
  }
  transformList(node) {
    return requireAllProps({
      kind: "ListNode",
      items: this.transformNodeList(node.items)
    });
  }
  transformDropIndex(node) {
    return requireAllProps({
      kind: "DropIndexNode",
      name: this.transformNode(node.name),
      table: this.transformNode(node.table),
      ifExists: node.ifExists,
      cascade: node.cascade
    });
  }
  transformPrimaryKeyConstraint(node) {
    return requireAllProps({
      kind: "PrimaryKeyConstraintNode",
      columns: this.transformNodeList(node.columns),
      name: this.transformNode(node.name)
    });
  }
  transformUniqueConstraint(node) {
    return requireAllProps({
      kind: "UniqueConstraintNode",
      columns: this.transformNodeList(node.columns),
      name: this.transformNode(node.name),
      nullsNotDistinct: node.nullsNotDistinct
    });
  }
  transformForeignKeyConstraint(node) {
    return requireAllProps({
      kind: "ForeignKeyConstraintNode",
      columns: this.transformNodeList(node.columns),
      references: this.transformNode(node.references),
      name: this.transformNode(node.name),
      onDelete: node.onDelete,
      onUpdate: node.onUpdate
    });
  }
  transformSetOperation(node) {
    return requireAllProps({
      kind: "SetOperationNode",
      operator: node.operator,
      expression: this.transformNode(node.expression),
      all: node.all
    });
  }
  transformReferences(node) {
    return requireAllProps({
      kind: "ReferencesNode",
      table: this.transformNode(node.table),
      columns: this.transformNodeList(node.columns),
      onDelete: node.onDelete,
      onUpdate: node.onUpdate
    });
  }
  transformCheckConstraint(node) {
    return requireAllProps({
      kind: "CheckConstraintNode",
      expression: this.transformNode(node.expression),
      name: this.transformNode(node.name)
    });
  }
  transformWith(node) {
    return requireAllProps({
      kind: "WithNode",
      expressions: this.transformNodeList(node.expressions),
      recursive: node.recursive
    });
  }
  transformCommonTableExpression(node) {
    return requireAllProps({
      kind: "CommonTableExpressionNode",
      name: this.transformNode(node.name),
      materialized: node.materialized,
      expression: this.transformNode(node.expression)
    });
  }
  transformCommonTableExpressionName(node) {
    return requireAllProps({
      kind: "CommonTableExpressionNameNode",
      table: this.transformNode(node.table),
      columns: this.transformNodeList(node.columns)
    });
  }
  transformHaving(node) {
    return requireAllProps({
      kind: "HavingNode",
      having: this.transformNode(node.having)
    });
  }
  transformCreateSchema(node) {
    return requireAllProps({
      kind: "CreateSchemaNode",
      schema: this.transformNode(node.schema),
      ifNotExists: node.ifNotExists
    });
  }
  transformDropSchema(node) {
    return requireAllProps({
      kind: "DropSchemaNode",
      schema: this.transformNode(node.schema),
      ifExists: node.ifExists,
      cascade: node.cascade
    });
  }
  transformAlterTable(node) {
    return requireAllProps({
      kind: "AlterTableNode",
      table: this.transformNode(node.table),
      renameTo: this.transformNode(node.renameTo),
      setSchema: this.transformNode(node.setSchema),
      columnAlterations: this.transformNodeList(node.columnAlterations),
      addConstraint: this.transformNode(node.addConstraint),
      dropConstraint: this.transformNode(node.dropConstraint),
      addIndex: this.transformNode(node.addIndex),
      dropIndex: this.transformNode(node.dropIndex)
    });
  }
  transformDropColumn(node) {
    return requireAllProps({
      kind: "DropColumnNode",
      column: this.transformNode(node.column)
    });
  }
  transformRenameColumn(node) {
    return requireAllProps({
      kind: "RenameColumnNode",
      column: this.transformNode(node.column),
      renameTo: this.transformNode(node.renameTo)
    });
  }
  transformAlterColumn(node) {
    return requireAllProps({
      kind: "AlterColumnNode",
      column: this.transformNode(node.column),
      dataType: this.transformNode(node.dataType),
      dataTypeExpression: this.transformNode(node.dataTypeExpression),
      setDefault: this.transformNode(node.setDefault),
      dropDefault: node.dropDefault,
      setNotNull: node.setNotNull,
      dropNotNull: node.dropNotNull
    });
  }
  transformModifyColumn(node) {
    return requireAllProps({
      kind: "ModifyColumnNode",
      column: this.transformNode(node.column)
    });
  }
  transformAddConstraint(node) {
    return requireAllProps({
      kind: "AddConstraintNode",
      constraint: this.transformNode(node.constraint)
    });
  }
  transformDropConstraint(node) {
    return requireAllProps({
      kind: "DropConstraintNode",
      constraintName: this.transformNode(node.constraintName),
      ifExists: node.ifExists,
      modifier: node.modifier
    });
  }
  transformCreateView(node) {
    return requireAllProps({
      kind: "CreateViewNode",
      name: this.transformNode(node.name),
      temporary: node.temporary,
      orReplace: node.orReplace,
      ifNotExists: node.ifNotExists,
      materialized: node.materialized,
      columns: this.transformNodeList(node.columns),
      as: this.transformNode(node.as)
    });
  }
  transformDropView(node) {
    return requireAllProps({
      kind: "DropViewNode",
      name: this.transformNode(node.name),
      ifExists: node.ifExists,
      materialized: node.materialized,
      cascade: node.cascade
    });
  }
  transformGenerated(node) {
    return requireAllProps({
      kind: "GeneratedNode",
      byDefault: node.byDefault,
      always: node.always,
      identity: node.identity,
      stored: node.stored,
      expression: this.transformNode(node.expression)
    });
  }
  transformDefaultValue(node) {
    return requireAllProps({
      kind: "DefaultValueNode",
      defaultValue: this.transformNode(node.defaultValue)
    });
  }
  transformOn(node) {
    return requireAllProps({
      kind: "OnNode",
      on: this.transformNode(node.on)
    });
  }
  transformSelectModifier(node) {
    return requireAllProps({
      kind: "SelectModifierNode",
      modifier: node.modifier,
      rawModifier: this.transformNode(node.rawModifier),
      of: this.transformNodeList(node.of)
    });
  }
  transformCreateType(node) {
    return requireAllProps({
      kind: "CreateTypeNode",
      name: this.transformNode(node.name),
      enum: this.transformNode(node.enum)
    });
  }
  transformDropType(node) {
    return requireAllProps({
      kind: "DropTypeNode",
      name: this.transformNode(node.name),
      ifExists: node.ifExists
    });
  }
  transformExplain(node) {
    return requireAllProps({
      kind: "ExplainNode",
      format: node.format,
      options: this.transformNode(node.options)
    });
  }
  transformSchemableIdentifier(node) {
    return requireAllProps({
      kind: "SchemableIdentifierNode",
      schema: this.transformNode(node.schema),
      identifier: this.transformNode(node.identifier)
    });
  }
  transformAggregateFunction(node) {
    return requireAllProps({
      kind: "AggregateFunctionNode",
      aggregated: this.transformNodeList(node.aggregated),
      distinct: node.distinct,
      filter: this.transformNode(node.filter),
      func: node.func,
      over: this.transformNode(node.over)
    });
  }
  transformOver(node) {
    return requireAllProps({
      kind: "OverNode",
      orderBy: this.transformNode(node.orderBy),
      partitionBy: this.transformNode(node.partitionBy)
    });
  }
  transformPartitionBy(node) {
    return requireAllProps({
      kind: "PartitionByNode",
      items: this.transformNodeList(node.items)
    });
  }
  transformPartitionByItem(node) {
    return requireAllProps({
      kind: "PartitionByItemNode",
      partitionBy: this.transformNode(node.partitionBy)
    });
  }
  transformBinaryOperation(node) {
    return requireAllProps({
      kind: "BinaryOperationNode",
      leftOperand: this.transformNode(node.leftOperand),
      operator: this.transformNode(node.operator),
      rightOperand: this.transformNode(node.rightOperand)
    });
  }
  transformUnaryOperation(node) {
    return requireAllProps({
      kind: "UnaryOperationNode",
      operator: this.transformNode(node.operator),
      operand: this.transformNode(node.operand)
    });
  }
  transformUsing(node) {
    return requireAllProps({
      kind: "UsingNode",
      tables: this.transformNodeList(node.tables)
    });
  }
  transformFunction(node) {
    return requireAllProps({
      kind: "FunctionNode",
      func: node.func,
      arguments: this.transformNodeList(node.arguments)
    });
  }
  transformCase(node) {
    return requireAllProps({
      kind: "CaseNode",
      value: this.transformNode(node.value),
      when: this.transformNodeList(node.when),
      else: this.transformNode(node.else),
      isStatement: node.isStatement
    });
  }
  transformWhen(node) {
    return requireAllProps({
      kind: "WhenNode",
      condition: this.transformNode(node.condition),
      result: this.transformNode(node.result)
    });
  }
  transformJSONReference(node) {
    return requireAllProps({
      kind: "JSONReferenceNode",
      reference: this.transformNode(node.reference),
      traversal: this.transformNode(node.traversal)
    });
  }
  transformJSONPath(node) {
    return requireAllProps({
      kind: "JSONPathNode",
      inOperator: this.transformNode(node.inOperator),
      pathLegs: this.transformNodeList(node.pathLegs)
    });
  }
  transformJSONPathLeg(node) {
    return requireAllProps({
      kind: "JSONPathLegNode",
      type: node.type,
      value: node.value
    });
  }
  transformJSONOperatorChain(node) {
    return requireAllProps({
      kind: "JSONOperatorChainNode",
      operator: this.transformNode(node.operator),
      values: this.transformNodeList(node.values)
    });
  }
  transformTuple(node) {
    return requireAllProps({
      kind: "TupleNode",
      values: this.transformNodeList(node.values)
    });
  }
  transformMergeQuery(node) {
    return requireAllProps({
      kind: "MergeQueryNode",
      into: this.transformNode(node.into),
      using: this.transformNode(node.using),
      whens: this.transformNodeList(node.whens),
      with: this.transformNode(node.with),
      top: this.transformNode(node.top),
      output: this.transformNode(node.output)
    });
  }
  transformMatched(node) {
    return requireAllProps({
      kind: "MatchedNode",
      not: node.not,
      bySource: node.bySource
    });
  }
  transformAddIndex(node) {
    return requireAllProps({
      kind: "AddIndexNode",
      name: this.transformNode(node.name),
      columns: this.transformNodeList(node.columns),
      unique: node.unique,
      using: this.transformNode(node.using),
      ifNotExists: node.ifNotExists
    });
  }
  transformCast(node) {
    return requireAllProps({
      kind: "CastNode",
      expression: this.transformNode(node.expression),
      dataType: this.transformNode(node.dataType)
    });
  }
  transformFetch(node) {
    return requireAllProps({
      kind: "FetchNode",
      rowCount: this.transformNode(node.rowCount),
      modifier: node.modifier
    });
  }
  transformTop(node) {
    return requireAllProps({
      kind: "TopNode",
      expression: node.expression,
      modifiers: node.modifiers
    });
  }
  transformOutput(node) {
    return requireAllProps({
      kind: "OutputNode",
      selections: this.transformNodeList(node.selections)
    });
  }
  transformDataType(node) {
    return node;
  }
  transformSelectAll(node) {
    return node;
  }
  transformIdentifier(node) {
    return node;
  }
  transformValue(node) {
    return node;
  }
  transformPrimitiveValueList(node) {
    return node;
  }
  transformOperator(node) {
    return node;
  }
  transformDefaultInsertValue(node) {
    return node;
  }
};

// ../../../node_modules/.pnpm/kysely@0.27.4/node_modules/kysely/dist/esm/plugin/with-schema/with-schema-transformer.js
var ROOT_OPERATION_NODES = freeze({
  AlterTableNode: true,
  CreateIndexNode: true,
  CreateSchemaNode: true,
  CreateTableNode: true,
  CreateTypeNode: true,
  CreateViewNode: true,
  DeleteQueryNode: true,
  DropIndexNode: true,
  DropSchemaNode: true,
  DropTableNode: true,
  DropTypeNode: true,
  DropViewNode: true,
  InsertQueryNode: true,
  RawNode: true,
  SelectQueryNode: true,
  UpdateQueryNode: true,
  MergeQueryNode: true
});
var WithSchemaTransformer = class extends OperationNodeTransformer {
  #schema;
  #schemableIds = /* @__PURE__ */ new Set();
  #ctes = /* @__PURE__ */ new Set();
  constructor(schema) {
    super();
    this.#schema = schema;
  }
  transformNodeImpl(node) {
    if (!this.#isRootOperationNode(node)) {
      return super.transformNodeImpl(node);
    }
    const ctes = this.#collectCTEs(node);
    for (const cte of ctes) {
      this.#ctes.add(cte);
    }
    const tables = this.#collectSchemableIds(node);
    for (const table of tables) {
      this.#schemableIds.add(table);
    }
    const transformed = super.transformNodeImpl(node);
    for (const table of tables) {
      this.#schemableIds.delete(table);
    }
    for (const cte of ctes) {
      this.#ctes.delete(cte);
    }
    return transformed;
  }
  transformSchemableIdentifier(node) {
    const transformed = super.transformSchemableIdentifier(node);
    if (transformed.schema || !this.#schemableIds.has(node.identifier.name)) {
      return transformed;
    }
    return {
      ...transformed,
      schema: IdentifierNode.create(this.#schema)
    };
  }
  transformReferences(node) {
    const transformed = super.transformReferences(node);
    if (transformed.table.table.schema) {
      return transformed;
    }
    return {
      ...transformed,
      table: TableNode.createWithSchema(this.#schema, transformed.table.table.identifier.name)
    };
  }
  #isRootOperationNode(node) {
    return node.kind in ROOT_OPERATION_NODES;
  }
  #collectSchemableIds(node) {
    const schemableIds = /* @__PURE__ */ new Set();
    if ("name" in node && node.name && SchemableIdentifierNode.is(node.name)) {
      this.#collectSchemableId(node.name, schemableIds);
    }
    if ("from" in node && node.from) {
      for (const from of node.from.froms) {
        this.#collectSchemableIdsFromTableExpr(from, schemableIds);
      }
    }
    if ("into" in node && node.into) {
      this.#collectSchemableIdsFromTableExpr(node.into, schemableIds);
    }
    if ("table" in node && node.table) {
      this.#collectSchemableIdsFromTableExpr(node.table, schemableIds);
    }
    if ("joins" in node && node.joins) {
      for (const join of node.joins) {
        this.#collectSchemableIdsFromTableExpr(join.table, schemableIds);
      }
    }
    if ("using" in node && node.using) {
      this.#collectSchemableIdsFromTableExpr(node.using, schemableIds);
    }
    return schemableIds;
  }
  #collectCTEs(node) {
    const ctes = /* @__PURE__ */ new Set();
    if ("with" in node && node.with) {
      this.#collectCTEIds(node.with, ctes);
    }
    return ctes;
  }
  #collectSchemableIdsFromTableExpr(node, schemableIds) {
    const table = TableNode.is(node) ? node : AliasNode.is(node) && TableNode.is(node.node) ? node.node : null;
    if (table) {
      this.#collectSchemableId(table.table, schemableIds);
    }
  }
  #collectSchemableId(node, schemableIds) {
    const id = node.identifier.name;
    if (!this.#schemableIds.has(id) && !this.#ctes.has(id)) {
      schemableIds.add(id);
    }
  }
  #collectCTEIds(node, ctes) {
    for (const expr of node.expressions) {
      const cteId = expr.name.table.table.identifier.name;
      if (!this.#ctes.has(cteId)) {
        ctes.add(cteId);
      }
    }
  }
};

// ../../../node_modules/.pnpm/kysely@0.27.4/node_modules/kysely/dist/esm/plugin/with-schema/with-schema-plugin.js
var WithSchemaPlugin = class {
  #transformer;
  constructor(schema) {
    this.#transformer = new WithSchemaTransformer(schema);
  }
  transformQuery(args) {
    return this.#transformer.transformNode(args.node);
  }
  async transformResult(args) {
    return args.result;
  }
};

// ../../../node_modules/.pnpm/kysely@0.27.4/node_modules/kysely/dist/esm/query-builder/merge-query-builder.js
init_define_ENV_DEFINED_IN_BUILD_STEP();

// ../../../node_modules/.pnpm/kysely@0.27.4/node_modules/kysely/dist/esm/parser/merge-parser.js
init_define_ENV_DEFINED_IN_BUILD_STEP();

// ../../../node_modules/.pnpm/kysely@0.27.4/node_modules/kysely/dist/esm/operation-node/matched-node.js
init_define_ENV_DEFINED_IN_BUILD_STEP();
var MatchedNode = freeze({
  is(node) {
    return node.kind === "MatchedNode";
  },
  create(not, bySource = false) {
    return freeze({
      kind: "MatchedNode",
      not,
      bySource
    });
  }
});

// ../../../node_modules/.pnpm/kysely@0.27.4/node_modules/kysely/dist/esm/parser/merge-parser.js
function parseMergeWhen(type, args, refRight) {
  return WhenNode.create(parseFilterList([
    MatchedNode.create(!type.isMatched, type.bySource),
    ...args && args.length > 0 ? [
      args.length === 3 && refRight ? parseReferentialBinaryOperation(args[0], args[1], args[2]) : parseValueBinaryOperationOrExpression(args)
    ] : []
  ], "and", false));
}
function parseMergeThen(result) {
  if (isString(result)) {
    return RawNode.create([result], []);
  }
  if (isOperationNodeSource(result)) {
    return result.toOperationNode();
  }
  return result;
}

// ../../../node_modules/.pnpm/kysely@0.27.4/node_modules/kysely/dist/esm/query-executor/noop-query-executor.js
init_define_ENV_DEFINED_IN_BUILD_STEP();

// ../../../node_modules/.pnpm/kysely@0.27.4/node_modules/kysely/dist/esm/query-executor/query-executor-base.js
init_define_ENV_DEFINED_IN_BUILD_STEP();

// ../../../node_modules/.pnpm/kysely@0.27.4/node_modules/kysely/dist/esm/util/deferred.js
init_define_ENV_DEFINED_IN_BUILD_STEP();
var Deferred = class {
  #promise;
  #resolve;
  #reject;
  constructor() {
    this.#promise = new Promise((resolve2, reject) => {
      this.#reject = reject;
      this.#resolve = resolve2;
    });
  }
  get promise() {
    return this.#promise;
  }
  resolve = (value) => {
    if (this.#resolve) {
      this.#resolve(value);
    }
  };
  reject = (reason) => {
    if (this.#reject) {
      this.#reject(reason);
    }
  };
};

// ../../../node_modules/.pnpm/kysely@0.27.4/node_modules/kysely/dist/esm/util/log-once.js
init_define_ENV_DEFINED_IN_BUILD_STEP();
var LOGGED_MESSAGES = /* @__PURE__ */ new Set();
function logOnce(message) {
  if (LOGGED_MESSAGES.has(message)) {
    return;
  }
  LOGGED_MESSAGES.add(message);
  console.log(message);
}

// ../../../node_modules/.pnpm/kysely@0.27.4/node_modules/kysely/dist/esm/query-executor/query-executor-base.js
var NO_PLUGINS = freeze([]);
var QueryExecutorBase = class {
  #plugins;
  constructor(plugins = NO_PLUGINS) {
    this.#plugins = plugins;
  }
  get plugins() {
    return this.#plugins;
  }
  transformQuery(node, queryId) {
    for (const plugin2 of this.#plugins) {
      const transformedNode = plugin2.transformQuery({ node, queryId });
      if (transformedNode.kind === node.kind) {
        node = transformedNode;
      } else {
        throw new Error([
          `KyselyPlugin.transformQuery must return a node`,
          `of the same kind that was given to it.`,
          `The plugin was given a ${node.kind}`,
          `but it returned a ${transformedNode.kind}`
        ].join(" "));
      }
    }
    return node;
  }
  async executeQuery(compiledQuery, queryId) {
    return await this.provideConnection(async (connection) => {
      const result = await connection.executeQuery(compiledQuery);
      const transformedResult = await this.#transformResult(result, queryId);
      warnOfOutdatedDriverOrPlugins(result, transformedResult);
      return transformedResult;
    });
  }
  async *stream(compiledQuery, chunkSize, queryId) {
    const connectionDefer = new Deferred();
    const connectionReleaseDefer = new Deferred();
    this.provideConnection(async (connection2) => {
      connectionDefer.resolve(connection2);
      return await connectionReleaseDefer.promise;
    }).catch((ex) => connectionDefer.reject(ex));
    const connection = await connectionDefer.promise;
    try {
      for await (const result of connection.streamQuery(compiledQuery, chunkSize)) {
        yield await this.#transformResult(result, queryId);
      }
    } finally {
      connectionReleaseDefer.resolve();
    }
  }
  async #transformResult(result, queryId) {
    for (const plugin2 of this.#plugins) {
      result = await plugin2.transformResult({ result, queryId });
    }
    return result;
  }
};
function warnOfOutdatedDriverOrPlugins(result, transformedResult) {
  const { numAffectedRows } = result;
  if (numAffectedRows === void 0 && result.numUpdatedOrDeletedRows === void 0 || numAffectedRows !== void 0 && transformedResult.numAffectedRows !== void 0) {
    return;
  }
  logOnce("kysely:warning: outdated driver/plugin detected! QueryResult.numUpdatedOrDeletedRows is deprecated and will be removed in a future release.");
}

// ../../../node_modules/.pnpm/kysely@0.27.4/node_modules/kysely/dist/esm/query-executor/noop-query-executor.js
var NoopQueryExecutor = class _NoopQueryExecutor extends QueryExecutorBase {
  get adapter() {
    throw new Error("this query cannot be compiled to SQL");
  }
  compileQuery() {
    throw new Error("this query cannot be compiled to SQL");
  }
  provideConnection() {
    throw new Error("this query cannot be executed");
  }
  withConnectionProvider() {
    throw new Error("this query cannot have a connection provider");
  }
  withPlugin(plugin2) {
    return new _NoopQueryExecutor([...this.plugins, plugin2]);
  }
  withPlugins(plugins) {
    return new _NoopQueryExecutor([...this.plugins, ...plugins]);
  }
  withPluginAtFront(plugin2) {
    return new _NoopQueryExecutor([plugin2, ...this.plugins]);
  }
  withoutPlugins() {
    return new _NoopQueryExecutor([]);
  }
};
var NOOP_QUERY_EXECUTOR = new NoopQueryExecutor();

// ../../../node_modules/.pnpm/kysely@0.27.4/node_modules/kysely/dist/esm/query-builder/merge-result.js
init_define_ENV_DEFINED_IN_BUILD_STEP();
var MergeResult = class {
  numChangedRows;
  constructor(numChangedRows) {
    this.numChangedRows = numChangedRows;
  }
};

// ../../../node_modules/.pnpm/kysely@0.27.4/node_modules/kysely/dist/esm/query-builder/merge-query-builder.js
var MergeQueryBuilder = class _MergeQueryBuilder {
  #props;
  constructor(props) {
    this.#props = freeze(props);
  }
  /**
   * Changes a `merge into` query to an `merge top into` query.
   *
   * `top` clause is only supported by some dialects like MS SQL Server.
   *
   * ### Examples
   *
   * Affect 5 matched rows at most:
   *
   * ```ts
   * await db.mergeInto('person')
   *   .top(5)
   *   .using('pet', 'person.id', 'pet.owner_id')
   *   .whenMatched()
   *   .thenDelete()
   *   .execute()
   * ```
   *
   * The generated SQL (MS SQL Server):
   *
   * ```sql
   * merge top(5) into "person"
   * using "pet" on "person"."id" = "pet"."owner_id"
   * when matched then
   *   delete
   * ```
   *
   * Affect 50% of matched rows:
   *
   * ```ts
   * await db.mergeInto('person')
   *   .top(50, 'percent')
   *   .using('pet', 'person.id', 'pet.owner_id')
   *   .whenMatched()
   *   .thenDelete()
   *   .execute()
   * ```
   *
   * The generated SQL (MS SQL Server):
   *
   * ```sql
   * merge top(50) percent into "person"
   * using "pet" on "person"."id" = "pet"."owner_id"
   * when matched then
   *   delete
   * ```
   */
  top(expression, modifiers) {
    return new _MergeQueryBuilder({
      ...this.#props,
      queryNode: QueryNode.cloneWithTop(this.#props.queryNode, parseTop(expression, modifiers))
    });
  }
  using(...args) {
    return new WheneableMergeQueryBuilder({
      ...this.#props,
      queryNode: MergeQueryNode.cloneWithUsing(this.#props.queryNode, parseJoin("Using", args))
    });
  }
  output(args) {
    return new _MergeQueryBuilder({
      ...this.#props,
      queryNode: QueryNode.cloneWithOutput(this.#props.queryNode, parseSelectArg(args))
    });
  }
  outputAll(table) {
    return new _MergeQueryBuilder({
      ...this.#props,
      queryNode: QueryNode.cloneWithOutput(this.#props.queryNode, parseSelectAll(table))
    });
  }
};
preventAwait(MergeQueryBuilder, "don't await MergeQueryBuilder instances directly. To execute the query you need to call `execute` when available.");
var WheneableMergeQueryBuilder = class _WheneableMergeQueryBuilder {
  #props;
  constructor(props) {
    this.#props = freeze(props);
  }
  /**
   * See {@link MergeQueryBuilder.top}.
   */
  top(expression, modifiers) {
    return new _WheneableMergeQueryBuilder({
      ...this.#props,
      queryNode: QueryNode.cloneWithTop(this.#props.queryNode, parseTop(expression, modifiers))
    });
  }
  /**
   * Adds a simple `when matched` clause to the query.
   *
   * For a `when matched` clause with an `and` condition, see {@link whenMatchedAnd}.
   *
   * For a simple `when not matched` clause, see {@link whenNotMatched}.
   *
   * For a `when not matched` clause with an `and` condition, see {@link whenNotMatchedAnd}.
   *
   * ### Examples
   *
   * ```ts
   * const result = await db.mergeInto('person')
   *   .using('pet', 'person.id', 'pet.owner_id')
   *   .whenMatched()
   *   .thenDelete()
   *   .execute()
   * ```
   *
   * The generated SQL (PostgreSQL):
   *
   * ```sql
   * merge into "person"
   * using "pet" on "person"."id" = "pet"."owner_id"
   * when matched then
   *   delete
   * ```
   */
  whenMatched() {
    return this.#whenMatched([]);
  }
  whenMatchedAnd(...args) {
    return this.#whenMatched(args);
  }
  /**
   * Adds the `when matched` clause to the query with an `and` condition. But unlike
   * {@link whenMatchedAnd}, this method accepts a column reference as the 3rd argument.
   *
   * This method is similar to {@link SelectQueryBuilder.whereRef}, so see the documentation
   * for that method for more examples.
   */
  whenMatchedAndRef(lhs, op, rhs) {
    return this.#whenMatched([lhs, op, rhs], true);
  }
  #whenMatched(args, refRight) {
    return new MatchedThenableMergeQueryBuilder({
      ...this.#props,
      queryNode: MergeQueryNode.cloneWithWhen(this.#props.queryNode, parseMergeWhen({ isMatched: true }, args, refRight))
    });
  }
  /**
   * Adds a simple `when not matched` clause to the query.
   *
   * For a `when not matched` clause with an `and` condition, see {@link whenNotMatchedAnd}.
   *
   * For a simple `when matched` clause, see {@link whenMatched}.
   *
   * For a `when matched` clause with an `and` condition, see {@link whenMatchedAnd}.
   *
   * ### Examples
   *
   * ```ts
   * const result = await db.mergeInto('person')
   *   .using('pet', 'person.id', 'pet.owner_id')
   *   .whenNotMatched()
   *   .thenInsertValues({
   *     first_name: 'John',
   *     last_name: 'Doe',
   *   })
   *   .execute()
   * ```
   *
   * The generated SQL (PostgreSQL):
   *
   * ```sql
   * merge into "person"
   * using "pet" on "person"."id" = "pet"."owner_id"
   * when not matched then
   *   insert ("first_name", "last_name") values ($1, $2)
   * ```
   */
  whenNotMatched() {
    return this.#whenNotMatched([]);
  }
  whenNotMatchedAnd(...args) {
    return this.#whenNotMatched(args);
  }
  /**
   * Adds the `when not matched` clause to the query with an `and` condition. But unlike
   * {@link whenNotMatchedAnd}, this method accepts a column reference as the 3rd argument.
   *
   * Unlike {@link whenMatchedAndRef}, you cannot reference columns from the target table.
   *
   * This method is similar to {@link SelectQueryBuilder.whereRef}, so see the documentation
   * for that method for more examples.
   */
  whenNotMatchedAndRef(lhs, op, rhs) {
    return this.#whenNotMatched([lhs, op, rhs], true);
  }
  /**
   * Adds a simple `when not matched by source` clause to the query.
   *
   * Supported in MS SQL Server.
   *
   * Similar to {@link whenNotMatched}, but returns a {@link MatchedThenableMergeQueryBuilder}.
   */
  whenNotMatchedBySource() {
    return this.#whenNotMatched([], false, true);
  }
  whenNotMatchedBySourceAnd(...args) {
    return this.#whenNotMatched(args, false, true);
  }
  /**
   * Adds the `when not matched by source` clause to the query with an `and` condition.
   *
   * Similar to {@link whenNotMatchedAndRef}, but you can reference columns from
   * the target table, and not from source table and returns a {@link MatchedThenableMergeQueryBuilder}.
   */
  whenNotMatchedBySourceAndRef(lhs, op, rhs) {
    return this.#whenNotMatched([lhs, op, rhs], true, true);
  }
  output(args) {
    return new _WheneableMergeQueryBuilder({
      ...this.#props,
      queryNode: QueryNode.cloneWithOutput(this.#props.queryNode, parseSelectArg(args))
    });
  }
  outputAll(table) {
    return new _WheneableMergeQueryBuilder({
      ...this.#props,
      queryNode: QueryNode.cloneWithOutput(this.#props.queryNode, parseSelectAll(table))
    });
  }
  #whenNotMatched(args, refRight = false, bySource = false) {
    const props = {
      ...this.#props,
      queryNode: MergeQueryNode.cloneWithWhen(this.#props.queryNode, parseMergeWhen({ isMatched: false, bySource }, args, refRight))
    };
    const Builder = bySource ? MatchedThenableMergeQueryBuilder : NotMatchedThenableMergeQueryBuilder;
    return new Builder(props);
  }
  /**
   * Simply calls the provided function passing `this` as the only argument. `$call` returns
   * what the provided function returns.
   *
   * If you want to conditionally call a method on `this`, see
   * the {@link $if} method.
   *
   * ### Examples
   *
   * The next example uses a helper function `log` to log a query:
   *
   * ```ts
   * function log<T extends Compilable>(qb: T): T {
   *   console.log(qb.compile())
   *   return qb
   * }
   *
   * db.updateTable('person')
   *   .set(values)
   *   .$call(log)
   *   .execute()
   * ```
   */
  $call(func) {
    return func(this);
  }
  /**
   * Call `func(this)` if `condition` is true.
   *
   * This method is especially handy with optional selects. Any `returning` or `returningAll`
   * method calls add columns as optional fields to the output type when called inside
   * the `func` callback. This is because we can't know if those selections were actually
   * made before running the code.
   *
   * You can also call any other methods inside the callback.
   *
   * ### Examples
   *
   * ```ts
   * async function updatePerson(id: number, updates: UpdateablePerson, returnLastName: boolean) {
   *   return await db
   *     .updateTable('person')
   *     .set(updates)
   *     .where('id', '=', id)
   *     .returning(['id', 'first_name'])
   *     .$if(returnLastName, (qb) => qb.returning('last_name'))
   *     .executeTakeFirstOrThrow()
   * }
   * ```
   *
   * Any selections added inside the `if` callback will be added as optional fields to the
   * output type since we can't know if the selections were actually made before running
   * the code. In the example above the return type of the `updatePerson` function is:
   *
   * ```ts
   * {
   *   id: number
   *   first_name: string
   *   last_name?: string
   * }
   * ```
   */
  $if(condition, func) {
    if (condition) {
      return func(this);
    }
    return new _WheneableMergeQueryBuilder({
      ...this.#props
    });
  }
  toOperationNode() {
    return this.#props.executor.transformQuery(this.#props.queryNode, this.#props.queryId);
  }
  compile() {
    return this.#props.executor.compileQuery(this.toOperationNode(), this.#props.queryId);
  }
  /**
   * Executes the query and returns an array of rows.
   *
   * Also see the {@link executeTakeFirst} and {@link executeTakeFirstOrThrow} methods.
   */
  async execute() {
    const compiledQuery = this.compile();
    const result = await this.#props.executor.executeQuery(compiledQuery, this.#props.queryId);
    if (compiledQuery.query.output && this.#props.executor.adapter.supportsOutput) {
      return result.rows;
    }
    return [new MergeResult(result.numAffectedRows)];
  }
  /**
   * Executes the query and returns the first result or undefined if
   * the query returned no result.
   */
  async executeTakeFirst() {
    const [result] = await this.execute();
    return result;
  }
  /**
   * Executes the query and returns the first result or throws if
   * the query returned no result.
   *
   * By default an instance of {@link NoResultError} is thrown, but you can
   * provide a custom error class, or callback as the only argument to throw a different
   * error.
   */
  async executeTakeFirstOrThrow(errorConstructor = NoResultError) {
    const result = await this.executeTakeFirst();
    if (result === void 0) {
      const error = isNoResultErrorConstructor(errorConstructor) ? new errorConstructor(this.toOperationNode()) : errorConstructor(this.toOperationNode());
      throw error;
    }
    return result;
  }
};
preventAwait(WheneableMergeQueryBuilder, "don't await WheneableMergeQueryBuilder instances directly. To execute the query you need to call `execute`.");
var MatchedThenableMergeQueryBuilder = class {
  #props;
  constructor(props) {
    this.#props = freeze(props);
  }
  /**
   * Performs the `delete` action.
   *
   * To perform the `do nothing` action, see {@link thenDoNothing}.
   *
   * To perform the `update` action, see {@link thenUpdate} or {@link thenUpdateSet}.
   *
   * ### Examples
   *
   * ```ts
   * const result = await db.mergeInto('person')
   *   .using('pet', 'person.id', 'pet.owner_id')
   *   .whenMatched()
   *   .thenDelete()
   *   .execute()
   * ```
   *
   * The generated SQL (PostgreSQL):
   *
   * ```sql
   * merge into "person"
   * using "pet" on "person"."id" = "pet"."owner_id"
   * when matched then
   *   delete
   * ```
   */
  thenDelete() {
    return new WheneableMergeQueryBuilder({
      ...this.#props,
      queryNode: MergeQueryNode.cloneWithThen(this.#props.queryNode, parseMergeThen("delete"))
    });
  }
  /**
   * Performs the `do nothing` action.
   *
   * This is supported in PostgreSQL.
   *
   * To perform the `delete` action, see {@link thenDelete}.
   *
   * To perform the `update` action, see {@link thenUpdate} or {@link thenUpdateSet}.
   *
   * ### Examples
   *
   * ```ts
   * const result = await db.mergeInto('person')
   *   .using('pet', 'person.id', 'pet.owner_id')
   *   .whenMatched()
   *   .thenDoNothing()
   *   .execute()
   * ```
   *
   * The generated SQL (PostgreSQL):
   *
   * ```sql
   * merge into "person"
   * using "pet" on "person"."id" = "pet"."owner_id"
   * when matched then
   *   do nothing
   * ```
   */
  thenDoNothing() {
    return new WheneableMergeQueryBuilder({
      ...this.#props,
      queryNode: MergeQueryNode.cloneWithThen(this.#props.queryNode, parseMergeThen("do nothing"))
    });
  }
  /**
   * Perform an `update` operation with a full-fledged {@link UpdateQueryBuilder}.
   * This is handy when multiple `set` invocations are needed.
   *
   * For a shorthand version of this method, see {@link thenUpdateSet}.
   *
   * To perform the `delete` action, see {@link thenDelete}.
   *
   * To perform the `do nothing` action, see {@link thenDoNothing}.
   *
   * ### Examples
   *
   * ```ts
   * import { sql } from 'kysely'
   *
   * const result = await db.mergeInto('person')
   *   .using('pet', 'person.id', 'pet.owner_id')
   *   .whenMatched()
   *   .thenUpdate((ub) => ub
   *     .set(sql`metadata['has_pets']`, 'Y')
   *     .set({
   *       updated_at: Date.now(),
   *     })
   *   )
   *   .execute()
   * ```
   *
   * The generated SQL (PostgreSQL):
   *
   * ```sql
   * merge into "person"
   * using "pet" on "person"."id" = "pet"."owner_id"
   * when matched then
   *   update set metadata['has_pets'] = $1, "updated_at" = $2
   * ```
   */
  thenUpdate(set) {
    return new WheneableMergeQueryBuilder({
      ...this.#props,
      queryNode: MergeQueryNode.cloneWithThen(this.#props.queryNode, parseMergeThen(set(new UpdateQueryBuilder({
        queryId: this.#props.queryId,
        executor: NOOP_QUERY_EXECUTOR,
        queryNode: UpdateQueryNode.createWithoutTable()
      }))))
    });
  }
  thenUpdateSet(...args) {
    return this.thenUpdate((ub) => ub.set(...args));
  }
};
preventAwait(MatchedThenableMergeQueryBuilder, "don't await MatchedThenableMergeQueryBuilder instances directly. To execute the query you need to call `execute` when available.");
var NotMatchedThenableMergeQueryBuilder = class {
  #props;
  constructor(props) {
    this.#props = freeze(props);
  }
  /**
   * Performs the `do nothing` action.
   *
   * This is supported in PostgreSQL.
   *
   * To perform the `insert` action, see {@link thenInsertValues}.
   *
   * ### Examples
   *
   * ```ts
   * const result = await db.mergeInto('person')
   *   .using('pet', 'person.id', 'pet.owner_id')
   *   .whenNotMatched()
   *   .thenDoNothing()
   *   .execute()
   * ```
   *
   * The generated SQL (PostgreSQL):
   *
   * ```sql
   * merge into "person"
   * using "pet" on "person"."id" = "pet"."owner_id"
   * when not matched then
   *   do nothing
   * ```
   */
  thenDoNothing() {
    return new WheneableMergeQueryBuilder({
      ...this.#props,
      queryNode: MergeQueryNode.cloneWithThen(this.#props.queryNode, parseMergeThen("do nothing"))
    });
  }
  thenInsertValues(insert) {
    const [columns, values] = parseInsertExpression(insert);
    return new WheneableMergeQueryBuilder({
      ...this.#props,
      queryNode: MergeQueryNode.cloneWithThen(this.#props.queryNode, parseMergeThen(InsertQueryNode.cloneWith(InsertQueryNode.createWithoutInto(), {
        columns,
        values
      })))
    });
  }
};
preventAwait(NotMatchedThenableMergeQueryBuilder, "don't await NotMatchedThenableMergeQueryBuilder instances directly. To execute the query you need to call `execute` when available.");

// ../../../node_modules/.pnpm/kysely@0.27.4/node_modules/kysely/dist/esm/query-creator.js
var QueryCreator = class _QueryCreator {
  #props;
  constructor(props) {
    this.#props = freeze(props);
  }
  selectFrom(from) {
    return createSelectQueryBuilder({
      queryId: createQueryId(),
      executor: this.#props.executor,
      queryNode: SelectQueryNode.createFrom(parseTableExpressionOrList(from), this.#props.withNode)
    });
  }
  selectNoFrom(selection) {
    return createSelectQueryBuilder({
      queryId: createQueryId(),
      executor: this.#props.executor,
      queryNode: SelectQueryNode.cloneWithSelections(SelectQueryNode.create(this.#props.withNode), parseSelectArg(selection))
    });
  }
  /**
   * Creates an insert query.
   *
   * The return value of this query is an instance of {@link InsertResult}. {@link InsertResult}
   * has the {@link InsertResult.insertId | insertId} field that holds the auto incremented id of
   * the inserted row if the db returned one.
   *
   * See the {@link InsertQueryBuilder.values | values} method for more info and examples. Also see
   * the {@link ReturningInterface.returning | returning} method for a way to return columns
   * on supported databases like PostgreSQL.
   *
   * ### Examples
   *
   * ```ts
   * const result = await db
   *   .insertInto('person')
   *   .values({
   *     first_name: 'Jennifer',
   *     last_name: 'Aniston'
   *   })
   *   .executeTakeFirst()
   *
   * console.log(result.insertId)
   * ```
   *
   * Some databases like PostgreSQL support the `returning` method:
   *
   * ```ts
   * const { id } = await db
   *   .insertInto('person')
   *   .values({
   *     first_name: 'Jennifer',
   *     last_name: 'Aniston'
   *   })
   *   .returning('id')
   *   .executeTakeFirst()
   * ```
   */
  insertInto(table) {
    return new InsertQueryBuilder({
      queryId: createQueryId(),
      executor: this.#props.executor,
      queryNode: InsertQueryNode.create(parseTable(table), this.#props.withNode)
    });
  }
  /**
   * Creates a replace query.
   *
   * A MySQL-only statement similar to {@link InsertQueryBuilder.onDuplicateKeyUpdate}
   * that deletes and inserts values on collision instead of updating existing rows.
   *
   * The return value of this query is an instance of {@link InsertResult}. {@link InsertResult}
   * has the {@link InsertResult.insertId | insertId} field that holds the auto incremented id of
   * the inserted row if the db returned one.
   *
   * See the {@link InsertQueryBuilder.values | values} method for more info and examples.
   *
   * ### Examples
   *
   * ```ts
   * const result = await db
   *   .replaceInto('person')
   *   .values({
   *     first_name: 'Jennifer',
   *     last_name: 'Aniston'
   *   })
   *   .executeTakeFirst()
   *
   * console.log(result.insertId)
   * ```
   */
  replaceInto(table) {
    return new InsertQueryBuilder({
      queryId: createQueryId(),
      executor: this.#props.executor,
      queryNode: InsertQueryNode.create(parseTable(table), this.#props.withNode, true)
    });
  }
  deleteFrom(tables) {
    return new DeleteQueryBuilder({
      queryId: createQueryId(),
      executor: this.#props.executor,
      queryNode: DeleteQueryNode.create(parseTableExpressionOrList(tables), this.#props.withNode)
    });
  }
  updateTable(table) {
    return new UpdateQueryBuilder({
      queryId: createQueryId(),
      executor: this.#props.executor,
      queryNode: UpdateQueryNode.create(parseTableExpression(table), this.#props.withNode)
    });
  }
  mergeInto(targetTable) {
    return new MergeQueryBuilder({
      queryId: createQueryId(),
      executor: this.#props.executor,
      queryNode: MergeQueryNode.create(parseAliasedTable(targetTable), this.#props.withNode)
    });
  }
  /**
   * Creates a `with` query (Common Table Expression).
   *
   * ### Examples
   *
   * <!-- siteExample("cte", "Simple selects", 10) -->
   *
   * Common table expressions (CTE) are a great way to modularize complex queries.
   * Essentially they allow you to run multiple separate queries within a
   * single roundtrip to the DB.
   *
   * Since CTEs are a part of the main query, query optimizers inside DB
   * engines are able to optimize the overall query. For example, postgres
   * is able to inline the CTEs inside the using queries if it decides it's
   * faster.
   *
   * ```ts
   * const result = await db
   *   // Create a CTE called `jennifers` that selects all
   *   // persons named 'Jennifer'.
   *   .with('jennifers', (db) => db
   *     .selectFrom('person')
   *     .where('first_name', '=', 'Jennifer')
   *     .select(['id', 'age'])
   *   )
   *   // Select all rows from the `jennifers` CTE and
   *   // further filter it.
   *   .with('adult_jennifers', (db) => db
   *     .selectFrom('jennifers')
   *     .where('age', '>', 18)
   *     .select(['id', 'age'])
   *   )
   *   // Finally select all adult jennifers that are
   *   // also younger than 60.
   *   .selectFrom('adult_jennifers')
   *   .where('age', '<', 60)
   *   .selectAll()
   *   .execute()
   * ```
   *
   * <!-- siteExample("cte", "Inserts, updates and deletions", 20) -->
   *
   * Some databases like postgres also allow you to run other queries than selects
   * in CTEs. On these databases CTEs are extremely powerful:
   *
   * ```ts
   * const result = await db
   *   .with('new_person', (db) => db
   *     .insertInto('person')
   *     .values({
   *       first_name: 'Jennifer',
   *       age: 35,
   *     })
   *     .returning('id')
   *   )
   *   .with('new_pet', (db) => db
   *     .insertInto('pet')
   *     .values({
   *       name: 'Doggo',
   *       species: 'dog',
   *       is_favorite: true,
   *       // Use the id of the person we just inserted.
   *       owner_id: db
   *         .selectFrom('new_person')
   *         .select('id')
   *     })
   *     .returning('id')
   *   )
   *   .selectFrom(['new_person', 'new_pet'])
   *   .select([
   *     'new_person.id as person_id',
   *     'new_pet.id as pet_id'
   *   ])
   *   .execute()
   * ```
   *
   * The CTE name can optionally specify column names in addition to
   * a name. In that case Kysely requires the expression to retun
   * rows with the same columns.
   *
   * ```ts
   * await db
   *   .with('jennifers(id, age)', (db) => db
   *     .selectFrom('person')
   *     .where('first_name', '=', 'Jennifer')
   *     // This is ok since we return columns with the same
   *     // names as specified by `jennifers(id, age)`.
   *     .select(['id', 'age'])
   *   )
   *   .selectFrom('jennifers')
   *   .selectAll()
   *   .execute()
   * ```
   *
   * The first argument can also be a callback. The callback is passed
   * a `CTEBuilder` instance that can be used to configure the CTE:
   *
   * ```ts
   * await db
   *   .with(
   *     (cte) => cte('jennifers').materialized(),
   *     (db) => db
   *       .selectFrom('person')
   *       .where('first_name', '=', 'Jennifer')
   *       .select(['id', 'age'])
   *   )
   *   .selectFrom('jennifers')
   *   .selectAll()
   *   .execute()
   * ```
   */
  with(nameOrBuilder, expression) {
    const cte = parseCommonTableExpression(nameOrBuilder, expression);
    return new _QueryCreator({
      ...this.#props,
      withNode: this.#props.withNode ? WithNode.cloneWithExpression(this.#props.withNode, cte) : WithNode.create(cte)
    });
  }
  /**
   * Creates a recursive `with` query (Common Table Expression).
   *
   * Note that recursiveness is a property of the whole `with` statement.
   * You cannot have recursive and non-recursive CTEs in a same `with` statement.
   * Therefore the recursiveness is determined by the **first** `with` or
   * `withRecusive` call you make.
   *
   * See the {@link with} method for examples and more documentation.
   */
  withRecursive(nameOrBuilder, expression) {
    const cte = parseCommonTableExpression(nameOrBuilder, expression);
    return new _QueryCreator({
      ...this.#props,
      withNode: this.#props.withNode ? WithNode.cloneWithExpression(this.#props.withNode, cte) : WithNode.create(cte, { recursive: true })
    });
  }
  /**
   * Returns a copy of this query creator instance with the given plugin installed.
   */
  withPlugin(plugin2) {
    return new _QueryCreator({
      ...this.#props,
      executor: this.#props.executor.withPlugin(plugin2)
    });
  }
  /**
   * Returns a copy of this query creator instance without any plugins.
   */
  withoutPlugins() {
    return new _QueryCreator({
      ...this.#props,
      executor: this.#props.executor.withoutPlugins()
    });
  }
  /**
   * Sets the schema to be used for all table references that don't explicitly
   * specify a schema.
   *
   * This only affects the query created through the builder returned from
   * this method and doesn't modify the `db` instance.
   *
   * See [this recipe](https://github.com/koskimas/kysely/tree/master/site/docs/recipes/schemas.md)
   * for a more detailed explanation.
   *
   * ### Examples
   *
   * ```
   * await db
   *   .withSchema('mammals')
   *   .selectFrom('pet')
   *   .selectAll()
   *   .innerJoin('public.person', 'public.person.id', 'pet.owner_id')
   *   .execute()
   * ```
   *
   * The generated SQL (PostgreSQL):
   *
   * ```sql
   * select * from "mammals"."pet"
   * inner join "public"."person"
   * on "public"."person"."id" = "mammals"."pet"."owner_id"
   * ```
   *
   * `withSchema` is smart enough to not add schema for aliases,
   * common table expressions or other places where the schema
   * doesn't belong to:
   *
   * ```
   * await db
   *   .withSchema('mammals')
   *   .selectFrom('pet as p')
   *   .select('p.name')
   *   .execute()
   * ```
   *
   * The generated SQL (PostgreSQL):
   *
   * ```sql
   * select "p"."name" from "mammals"."pet" as "p"
   * ```
   */
  withSchema(schema) {
    return new _QueryCreator({
      ...this.#props,
      executor: this.#props.executor.withPluginAtFront(new WithSchemaPlugin(schema))
    });
  }
};

// ../../../node_modules/.pnpm/kysely@0.27.4/node_modules/kysely/dist/esm/parser/parse-utils.js
function createQueryCreator() {
  return new QueryCreator({
    executor: NOOP_QUERY_EXECUTOR
  });
}
function createJoinBuilder(joinType, table) {
  return new JoinBuilder({
    joinNode: JoinNode.create(joinType, parseTableExpression(table))
  });
}
function createOverBuilder() {
  return new OverBuilder({
    overNode: OverNode.create()
  });
}

// ../../../node_modules/.pnpm/kysely@0.27.4/node_modules/kysely/dist/esm/parser/join-parser.js
function parseJoin(joinType, args) {
  if (args.length === 3) {
    return parseSingleOnJoin(joinType, args[0], args[1], args[2]);
  } else if (args.length === 2) {
    return parseCallbackJoin(joinType, args[0], args[1]);
  } else {
    throw new Error("not implemented");
  }
}
function parseCallbackJoin(joinType, from, callback) {
  return callback(createJoinBuilder(joinType, from)).toOperationNode();
}
function parseSingleOnJoin(joinType, from, lhsColumn, rhsColumn) {
  return JoinNode.createWithOn(joinType, parseTableExpression(from), parseReferentialBinaryOperation(lhsColumn, "=", rhsColumn));
}

// ../../../node_modules/.pnpm/kysely@0.27.4/node_modules/kysely/dist/esm/operation-node/offset-node.js
init_define_ENV_DEFINED_IN_BUILD_STEP();
var OffsetNode = freeze({
  is(node) {
    return node.kind === "OffsetNode";
  },
  create(offset) {
    return freeze({
      kind: "OffsetNode",
      offset
    });
  }
});

// ../../../node_modules/.pnpm/kysely@0.27.4/node_modules/kysely/dist/esm/parser/group-by-parser.js
init_define_ENV_DEFINED_IN_BUILD_STEP();

// ../../../node_modules/.pnpm/kysely@0.27.4/node_modules/kysely/dist/esm/operation-node/group-by-item-node.js
init_define_ENV_DEFINED_IN_BUILD_STEP();
var GroupByItemNode = freeze({
  is(node) {
    return node.kind === "GroupByItemNode";
  },
  create(groupBy) {
    return freeze({
      kind: "GroupByItemNode",
      groupBy
    });
  }
});

// ../../../node_modules/.pnpm/kysely@0.27.4/node_modules/kysely/dist/esm/parser/group-by-parser.js
function parseGroupBy(groupBy) {
  groupBy = isFunction(groupBy) ? groupBy(expressionBuilder()) : groupBy;
  return parseReferenceExpressionOrList(groupBy).map(GroupByItemNode.create);
}

// ../../../node_modules/.pnpm/kysely@0.27.4/node_modules/kysely/dist/esm/parser/set-operation-parser.js
init_define_ENV_DEFINED_IN_BUILD_STEP();

// ../../../node_modules/.pnpm/kysely@0.27.4/node_modules/kysely/dist/esm/operation-node/set-operation-node.js
init_define_ENV_DEFINED_IN_BUILD_STEP();
var SetOperationNode = freeze({
  is(node) {
    return node.kind === "SetOperationNode";
  },
  create(operator, expression, all) {
    return freeze({
      kind: "SetOperationNode",
      operator,
      expression,
      all
    });
  }
});

// ../../../node_modules/.pnpm/kysely@0.27.4/node_modules/kysely/dist/esm/parser/set-operation-parser.js
function parseSetOperations(operator, expression, all) {
  if (isFunction(expression)) {
    expression = expression(createExpressionBuilder());
  }
  if (!isReadonlyArray(expression)) {
    expression = [expression];
  }
  return expression.map((expr) => SetOperationNode.create(operator, parseExpression(expr), all));
}

// ../../../node_modules/.pnpm/kysely@0.27.4/node_modules/kysely/dist/esm/expression/expression-wrapper.js
init_define_ENV_DEFINED_IN_BUILD_STEP();
var ExpressionWrapper = class _ExpressionWrapper {
  #node;
  constructor(node) {
    this.#node = node;
  }
  /** @private */
  get expressionType() {
    return void 0;
  }
  as(alias) {
    return new AliasedExpressionWrapper(this, alias);
  }
  or(...args) {
    return new OrWrapper(OrNode.create(this.#node, parseValueBinaryOperationOrExpression(args)));
  }
  and(...args) {
    return new AndWrapper(AndNode.create(this.#node, parseValueBinaryOperationOrExpression(args)));
  }
  /**
   * Change the output type of the expression.
   *
   * This method call doesn't change the SQL in any way. This methods simply
   * returns a copy of this `ExpressionWrapper` with a new output type.
   */
  $castTo() {
    return new _ExpressionWrapper(this.#node);
  }
  /**
   * Omit null from the expression's type.
   *
   * This function can be useful in cases where you know an expression can't be
   * null, but Kysely is unable to infer it.
   *
   * This method call doesn't change the SQL in any way. This methods simply
   * returns a copy of `this` with a new output type.
   */
  $notNull() {
    return new _ExpressionWrapper(this.#node);
  }
  toOperationNode() {
    return this.#node;
  }
};
var AliasedExpressionWrapper = class {
  #expr;
  #alias;
  constructor(expr, alias) {
    this.#expr = expr;
    this.#alias = alias;
  }
  /** @private */
  get expression() {
    return this.#expr;
  }
  /** @private */
  get alias() {
    return this.#alias;
  }
  toOperationNode() {
    return AliasNode.create(this.#expr.toOperationNode(), isOperationNodeSource(this.#alias) ? this.#alias.toOperationNode() : IdentifierNode.create(this.#alias));
  }
};
var OrWrapper = class _OrWrapper {
  #node;
  constructor(node) {
    this.#node = node;
  }
  /** @private */
  get expressionType() {
    return void 0;
  }
  as(alias) {
    return new AliasedExpressionWrapper(this, alias);
  }
  or(...args) {
    return new _OrWrapper(OrNode.create(this.#node, parseValueBinaryOperationOrExpression(args)));
  }
  /**
   * Change the output type of the expression.
   *
   * This method call doesn't change the SQL in any way. This methods simply
   * returns a copy of this `OrWrapper` with a new output type.
   */
  $castTo() {
    return new _OrWrapper(this.#node);
  }
  toOperationNode() {
    return ParensNode.create(this.#node);
  }
};
var AndWrapper = class _AndWrapper {
  #node;
  constructor(node) {
    this.#node = node;
  }
  /** @private */
  get expressionType() {
    return void 0;
  }
  as(alias) {
    return new AliasedExpressionWrapper(this, alias);
  }
  and(...args) {
    return new _AndWrapper(AndNode.create(this.#node, parseValueBinaryOperationOrExpression(args)));
  }
  /**
   * Change the output type of the expression.
   *
   * This method call doesn't change the SQL in any way. This methods simply
   * returns a copy of this `AndWrapper` with a new output type.
   */
  $castTo() {
    return new _AndWrapper(this.#node);
  }
  toOperationNode() {
    return ParensNode.create(this.#node);
  }
};

// ../../../node_modules/.pnpm/kysely@0.27.4/node_modules/kysely/dist/esm/parser/fetch-parser.js
init_define_ENV_DEFINED_IN_BUILD_STEP();

// ../../../node_modules/.pnpm/kysely@0.27.4/node_modules/kysely/dist/esm/operation-node/fetch-node.js
init_define_ENV_DEFINED_IN_BUILD_STEP();
var FetchNode = {
  is(node) {
    return node.kind === "FetchNode";
  },
  create(rowCount, modifier) {
    return {
      kind: "FetchNode",
      rowCount: ValueNode.create(rowCount),
      modifier
    };
  }
};

// ../../../node_modules/.pnpm/kysely@0.27.4/node_modules/kysely/dist/esm/parser/fetch-parser.js
function parseFetch(rowCount, modifier) {
  if (!isNumber(rowCount) && !isBigInt(rowCount)) {
    throw new Error(`Invalid fetch row count: ${rowCount}`);
  }
  if (!isFetchModifier(modifier)) {
    throw new Error(`Invalid fetch modifier: ${modifier}`);
  }
  return FetchNode.create(rowCount, modifier);
}
function isFetchModifier(value) {
  return value === "only" || value === "with ties";
}

// ../../../node_modules/.pnpm/kysely@0.27.4/node_modules/kysely/dist/esm/query-builder/select-query-builder.js
var SelectQueryBuilderImpl = class _SelectQueryBuilderImpl {
  #props;
  constructor(props) {
    this.#props = freeze(props);
  }
  get expressionType() {
    return void 0;
  }
  get isSelectQueryBuilder() {
    return true;
  }
  where(...args) {
    return new _SelectQueryBuilderImpl({
      ...this.#props,
      queryNode: QueryNode.cloneWithWhere(this.#props.queryNode, parseValueBinaryOperationOrExpression(args))
    });
  }
  whereRef(lhs, op, rhs) {
    return new _SelectQueryBuilderImpl({
      ...this.#props,
      queryNode: QueryNode.cloneWithWhere(this.#props.queryNode, parseReferentialBinaryOperation(lhs, op, rhs))
    });
  }
  having(...args) {
    return new _SelectQueryBuilderImpl({
      ...this.#props,
      queryNode: SelectQueryNode.cloneWithHaving(this.#props.queryNode, parseValueBinaryOperationOrExpression(args))
    });
  }
  havingRef(lhs, op, rhs) {
    return new _SelectQueryBuilderImpl({
      ...this.#props,
      queryNode: SelectQueryNode.cloneWithHaving(this.#props.queryNode, parseReferentialBinaryOperation(lhs, op, rhs))
    });
  }
  select(selection) {
    return new _SelectQueryBuilderImpl({
      ...this.#props,
      queryNode: SelectQueryNode.cloneWithSelections(this.#props.queryNode, parseSelectArg(selection))
    });
  }
  distinctOn(selection) {
    return new _SelectQueryBuilderImpl({
      ...this.#props,
      queryNode: SelectQueryNode.cloneWithDistinctOn(this.#props.queryNode, parseReferenceExpressionOrList(selection))
    });
  }
  modifyFront(modifier) {
    return new _SelectQueryBuilderImpl({
      ...this.#props,
      queryNode: SelectQueryNode.cloneWithFrontModifier(this.#props.queryNode, SelectModifierNode.createWithExpression(modifier.toOperationNode()))
    });
  }
  modifyEnd(modifier) {
    return new _SelectQueryBuilderImpl({
      ...this.#props,
      queryNode: SelectQueryNode.cloneWithEndModifier(this.#props.queryNode, SelectModifierNode.createWithExpression(modifier.toOperationNode()))
    });
  }
  distinct() {
    return new _SelectQueryBuilderImpl({
      ...this.#props,
      queryNode: SelectQueryNode.cloneWithFrontModifier(this.#props.queryNode, SelectModifierNode.create("Distinct"))
    });
  }
  forUpdate(of) {
    return new _SelectQueryBuilderImpl({
      ...this.#props,
      queryNode: SelectQueryNode.cloneWithEndModifier(this.#props.queryNode, SelectModifierNode.create("ForUpdate", of ? asArray(of).map(parseTable) : void 0))
    });
  }
  forShare(of) {
    return new _SelectQueryBuilderImpl({
      ...this.#props,
      queryNode: SelectQueryNode.cloneWithEndModifier(this.#props.queryNode, SelectModifierNode.create("ForShare", of ? asArray(of).map(parseTable) : void 0))
    });
  }
  forKeyShare(of) {
    return new _SelectQueryBuilderImpl({
      ...this.#props,
      queryNode: SelectQueryNode.cloneWithEndModifier(this.#props.queryNode, SelectModifierNode.create("ForKeyShare", of ? asArray(of).map(parseTable) : void 0))
    });
  }
  forNoKeyUpdate(of) {
    return new _SelectQueryBuilderImpl({
      ...this.#props,
      queryNode: SelectQueryNode.cloneWithEndModifier(this.#props.queryNode, SelectModifierNode.create("ForNoKeyUpdate", of ? asArray(of).map(parseTable) : void 0))
    });
  }
  skipLocked() {
    return new _SelectQueryBuilderImpl({
      ...this.#props,
      queryNode: SelectQueryNode.cloneWithEndModifier(this.#props.queryNode, SelectModifierNode.create("SkipLocked"))
    });
  }
  noWait() {
    return new _SelectQueryBuilderImpl({
      ...this.#props,
      queryNode: SelectQueryNode.cloneWithEndModifier(this.#props.queryNode, SelectModifierNode.create("NoWait"))
    });
  }
  selectAll(table) {
    return new _SelectQueryBuilderImpl({
      ...this.#props,
      queryNode: SelectQueryNode.cloneWithSelections(this.#props.queryNode, parseSelectAll(table))
    });
  }
  innerJoin(...args) {
    return new _SelectQueryBuilderImpl({
      ...this.#props,
      queryNode: QueryNode.cloneWithJoin(this.#props.queryNode, parseJoin("InnerJoin", args))
    });
  }
  leftJoin(...args) {
    return new _SelectQueryBuilderImpl({
      ...this.#props,
      queryNode: QueryNode.cloneWithJoin(this.#props.queryNode, parseJoin("LeftJoin", args))
    });
  }
  rightJoin(...args) {
    return new _SelectQueryBuilderImpl({
      ...this.#props,
      queryNode: QueryNode.cloneWithJoin(this.#props.queryNode, parseJoin("RightJoin", args))
    });
  }
  fullJoin(...args) {
    return new _SelectQueryBuilderImpl({
      ...this.#props,
      queryNode: QueryNode.cloneWithJoin(this.#props.queryNode, parseJoin("FullJoin", args))
    });
  }
  innerJoinLateral(...args) {
    return new _SelectQueryBuilderImpl({
      ...this.#props,
      queryNode: QueryNode.cloneWithJoin(this.#props.queryNode, parseJoin("LateralInnerJoin", args))
    });
  }
  leftJoinLateral(...args) {
    return new _SelectQueryBuilderImpl({
      ...this.#props,
      queryNode: QueryNode.cloneWithJoin(this.#props.queryNode, parseJoin("LateralLeftJoin", args))
    });
  }
  orderBy(...args) {
    return new _SelectQueryBuilderImpl({
      ...this.#props,
      queryNode: SelectQueryNode.cloneWithOrderByItems(this.#props.queryNode, parseOrderBy(args))
    });
  }
  groupBy(groupBy) {
    return new _SelectQueryBuilderImpl({
      ...this.#props,
      queryNode: SelectQueryNode.cloneWithGroupByItems(this.#props.queryNode, parseGroupBy(groupBy))
    });
  }
  limit(limit) {
    return new _SelectQueryBuilderImpl({
      ...this.#props,
      queryNode: SelectQueryNode.cloneWithLimit(this.#props.queryNode, LimitNode.create(parseValueExpression(limit)))
    });
  }
  offset(offset) {
    return new _SelectQueryBuilderImpl({
      ...this.#props,
      queryNode: SelectQueryNode.cloneWithOffset(this.#props.queryNode, OffsetNode.create(parseValueExpression(offset)))
    });
  }
  fetch(rowCount, modifier = "only") {
    return new _SelectQueryBuilderImpl({
      ...this.#props,
      queryNode: SelectQueryNode.cloneWithFetch(this.#props.queryNode, parseFetch(rowCount, modifier))
    });
  }
  top(expression, modifiers) {
    return new _SelectQueryBuilderImpl({
      ...this.#props,
      queryNode: QueryNode.cloneWithTop(this.#props.queryNode, parseTop(expression, modifiers))
    });
  }
  union(expression) {
    return new _SelectQueryBuilderImpl({
      ...this.#props,
      queryNode: SelectQueryNode.cloneWithSetOperations(this.#props.queryNode, parseSetOperations("union", expression, false))
    });
  }
  unionAll(expression) {
    return new _SelectQueryBuilderImpl({
      ...this.#props,
      queryNode: SelectQueryNode.cloneWithSetOperations(this.#props.queryNode, parseSetOperations("union", expression, true))
    });
  }
  intersect(expression) {
    return new _SelectQueryBuilderImpl({
      ...this.#props,
      queryNode: SelectQueryNode.cloneWithSetOperations(this.#props.queryNode, parseSetOperations("intersect", expression, false))
    });
  }
  intersectAll(expression) {
    return new _SelectQueryBuilderImpl({
      ...this.#props,
      queryNode: SelectQueryNode.cloneWithSetOperations(this.#props.queryNode, parseSetOperations("intersect", expression, true))
    });
  }
  except(expression) {
    return new _SelectQueryBuilderImpl({
      ...this.#props,
      queryNode: SelectQueryNode.cloneWithSetOperations(this.#props.queryNode, parseSetOperations("except", expression, false))
    });
  }
  exceptAll(expression) {
    return new _SelectQueryBuilderImpl({
      ...this.#props,
      queryNode: SelectQueryNode.cloneWithSetOperations(this.#props.queryNode, parseSetOperations("except", expression, true))
    });
  }
  as(alias) {
    return new AliasedSelectQueryBuilderImpl(this, alias);
  }
  clearSelect() {
    return new _SelectQueryBuilderImpl({
      ...this.#props,
      queryNode: SelectQueryNode.cloneWithoutSelections(this.#props.queryNode)
    });
  }
  clearWhere() {
    return new _SelectQueryBuilderImpl({
      ...this.#props,
      queryNode: QueryNode.cloneWithoutWhere(this.#props.queryNode)
    });
  }
  clearLimit() {
    return new _SelectQueryBuilderImpl({
      ...this.#props,
      queryNode: SelectQueryNode.cloneWithoutLimit(this.#props.queryNode)
    });
  }
  clearOffset() {
    return new _SelectQueryBuilderImpl({
      ...this.#props,
      queryNode: SelectQueryNode.cloneWithoutOffset(this.#props.queryNode)
    });
  }
  clearOrderBy() {
    return new _SelectQueryBuilderImpl({
      ...this.#props,
      queryNode: SelectQueryNode.cloneWithoutOrderBy(this.#props.queryNode)
    });
  }
  clearGroupBy() {
    return new _SelectQueryBuilderImpl({
      ...this.#props,
      queryNode: SelectQueryNode.cloneWithoutGroupBy(this.#props.queryNode)
    });
  }
  $call(func) {
    return func(this);
  }
  $if(condition, func) {
    if (condition) {
      return func(this);
    }
    return new _SelectQueryBuilderImpl({
      ...this.#props
    });
  }
  $castTo() {
    return new _SelectQueryBuilderImpl(this.#props);
  }
  $narrowType() {
    return new _SelectQueryBuilderImpl(this.#props);
  }
  $assertType() {
    return new _SelectQueryBuilderImpl(this.#props);
  }
  $asTuple() {
    return new ExpressionWrapper(this.toOperationNode());
  }
  withPlugin(plugin2) {
    return new _SelectQueryBuilderImpl({
      ...this.#props,
      executor: this.#props.executor.withPlugin(plugin2)
    });
  }
  toOperationNode() {
    return this.#props.executor.transformQuery(this.#props.queryNode, this.#props.queryId);
  }
  compile() {
    return this.#props.executor.compileQuery(this.toOperationNode(), this.#props.queryId);
  }
  async execute() {
    const compiledQuery = this.compile();
    const result = await this.#props.executor.executeQuery(compiledQuery, this.#props.queryId);
    return result.rows;
  }
  async executeTakeFirst() {
    const [result] = await this.execute();
    return result;
  }
  async executeTakeFirstOrThrow(errorConstructor = NoResultError) {
    const result = await this.executeTakeFirst();
    if (result === void 0) {
      const error = isNoResultErrorConstructor(errorConstructor) ? new errorConstructor(this.toOperationNode()) : errorConstructor(this.toOperationNode());
      throw error;
    }
    return result;
  }
  async *stream(chunkSize = 100) {
    const compiledQuery = this.compile();
    const stream = this.#props.executor.stream(compiledQuery, chunkSize, this.#props.queryId);
    for await (const item of stream) {
      yield* item.rows;
    }
  }
  async explain(format, options) {
    const builder = new _SelectQueryBuilderImpl({
      ...this.#props,
      queryNode: QueryNode.cloneWithExplain(this.#props.queryNode, format, options)
    });
    return await builder.execute();
  }
};
preventAwait(SelectQueryBuilderImpl, "don't await SelectQueryBuilder instances directly. To execute the query you need to call `execute` or `executeTakeFirst`.");
function createSelectQueryBuilder(props) {
  return new SelectQueryBuilderImpl(props);
}
var AliasedSelectQueryBuilderImpl = class {
  #queryBuilder;
  #alias;
  constructor(queryBuilder, alias) {
    this.#queryBuilder = queryBuilder;
    this.#alias = alias;
  }
  get expression() {
    return this.#queryBuilder;
  }
  get alias() {
    return this.#alias;
  }
  get isAliasedSelectQueryBuilder() {
    return true;
  }
  toOperationNode() {
    return AliasNode.create(this.#queryBuilder.toOperationNode(), IdentifierNode.create(this.#alias));
  }
};
preventAwait(AliasedSelectQueryBuilderImpl, "don't await AliasedSelectQueryBuilder instances directly. AliasedSelectQueryBuilder should never be executed directly since it's always a part of another query.");

// ../../../node_modules/.pnpm/kysely@0.27.4/node_modules/kysely/dist/esm/query-builder/function-module.js
init_define_ENV_DEFINED_IN_BUILD_STEP();

// ../../../node_modules/.pnpm/kysely@0.27.4/node_modules/kysely/dist/esm/operation-node/aggregate-function-node.js
init_define_ENV_DEFINED_IN_BUILD_STEP();
var AggregateFunctionNode = freeze({
  is(node) {
    return node.kind === "AggregateFunctionNode";
  },
  create(aggregateFunction, aggregated = []) {
    return freeze({
      kind: "AggregateFunctionNode",
      func: aggregateFunction,
      aggregated
    });
  },
  cloneWithDistinct(aggregateFunctionNode) {
    return freeze({
      ...aggregateFunctionNode,
      distinct: true
    });
  },
  cloneWithFilter(aggregateFunctionNode, filter) {
    return freeze({
      ...aggregateFunctionNode,
      filter: aggregateFunctionNode.filter ? WhereNode.cloneWithOperation(aggregateFunctionNode.filter, "And", filter) : WhereNode.create(filter)
    });
  },
  cloneWithOrFilter(aggregateFunctionNode, filter) {
    return freeze({
      ...aggregateFunctionNode,
      filter: aggregateFunctionNode.filter ? WhereNode.cloneWithOperation(aggregateFunctionNode.filter, "Or", filter) : WhereNode.create(filter)
    });
  },
  cloneWithOver(aggregateFunctionNode, over) {
    return freeze({
      ...aggregateFunctionNode,
      over
    });
  }
});

// ../../../node_modules/.pnpm/kysely@0.27.4/node_modules/kysely/dist/esm/operation-node/function-node.js
init_define_ENV_DEFINED_IN_BUILD_STEP();
var FunctionNode = freeze({
  is(node) {
    return node.kind === "FunctionNode";
  },
  create(func, args) {
    return freeze({
      kind: "FunctionNode",
      func,
      arguments: args
    });
  }
});

// ../../../node_modules/.pnpm/kysely@0.27.4/node_modules/kysely/dist/esm/query-builder/aggregate-function-builder.js
init_define_ENV_DEFINED_IN_BUILD_STEP();
var AggregateFunctionBuilder = class _AggregateFunctionBuilder {
  #props;
  constructor(props) {
    this.#props = freeze(props);
  }
  /** @private */
  get expressionType() {
    return void 0;
  }
  /**
   * Returns an aliased version of the function.
   *
   * In addition to slapping `as "the_alias"` to the end of the SQL,
   * this method also provides strict typing:
   *
   * ```ts
   * const result = await db
   *   .selectFrom('person')
   *   .select(
   *     (eb) => eb.fn.count<number>('id').as('person_count')
   *   )
   *   .executeTakeFirstOrThrow()
   *
   * // `person_count: number` field exists in the result type.
   * console.log(result.person_count)
   * ```
   *
   * The generated SQL (PostgreSQL):
   *
   * ```sql
   * select count("id") as "person_count"
   * from "person"
   * ```
   */
  as(alias) {
    return new AliasedAggregateFunctionBuilder(this, alias);
  }
  /**
   * Adds a `distinct` clause inside the function.
   *
   * ### Examples
   *
   * ```ts
   * const result = await db
   *   .selectFrom('person')
   *   .select((eb) =>
   *     eb.fn.count<number>('first_name').distinct().as('first_name_count')
   *   )
   *   .executeTakeFirstOrThrow()
   * ```
   *
   * The generated SQL (PostgreSQL):
   *
   * ```sql
   * select count(distinct "first_name") as "first_name_count"
   * from "person"
   * ```
   */
  distinct() {
    return new _AggregateFunctionBuilder({
      ...this.#props,
      aggregateFunctionNode: AggregateFunctionNode.cloneWithDistinct(this.#props.aggregateFunctionNode)
    });
  }
  filterWhere(...args) {
    return new _AggregateFunctionBuilder({
      ...this.#props,
      aggregateFunctionNode: AggregateFunctionNode.cloneWithFilter(this.#props.aggregateFunctionNode, parseValueBinaryOperationOrExpression(args))
    });
  }
  /**
   * Adds a `filter` clause with a nested `where` clause after the function, where
   * both sides of the operator are references to columns.
   *
   * Similar to {@link WhereInterface}'s `whereRef` method.
   *
   * ### Examples
   *
   * Count people with same first and last names versus general public:
   *
   * ```ts
   * const result = await db
   *   .selectFrom('person')
   *   .select((eb) => [
   *     eb.fn
   *       .count<number>('id')
   *       .filterWhereRef('first_name', '=', 'last_name')
   *       .as('repeat_name_count'),
   *     eb.fn.count<number>('id').as('total_count'),
   *   ])
   *   .executeTakeFirstOrThrow()
   * ```
   *
   * The generated SQL (PostgreSQL):
   *
   * ```sql
   * select
   *   count("id") filter(where "first_name" = "last_name") as "repeat_name_count",
   *   count("id") as "total_count"
   * from "person"
   * ```
   */
  filterWhereRef(lhs, op, rhs) {
    return new _AggregateFunctionBuilder({
      ...this.#props,
      aggregateFunctionNode: AggregateFunctionNode.cloneWithFilter(this.#props.aggregateFunctionNode, parseReferentialBinaryOperation(lhs, op, rhs))
    });
  }
  /**
   * Adds an `over` clause (window functions) after the function.
   *
   * ### Examples
   *
   * ```ts
   * const result = await db
   *   .selectFrom('person')
   *   .select(
   *     (eb) => eb.fn.avg<number>('age').over().as('average_age')
   *   )
   *   .execute()
   * ```
   *
   * The generated SQL (PostgreSQL):
   *
   * ```sql
   * select avg("age") over() as "average_age"
   * from "person"
   * ```
   *
   * Also supports passing a callback that returns an over builder,
   * allowing to add partition by and sort by clauses inside over.
   *
   * ```ts
   * const result = await db
   *   .selectFrom('person')
   *   .select(
   *     (eb) => eb.fn.avg<number>('age').over(
   *       ob => ob.partitionBy('last_name').orderBy('first_name', 'asc')
   *     ).as('average_age')
   *   )
   *   .execute()
   * ```
   *
   * The generated SQL (PostgreSQL):
   *
   * ```sql
   * select avg("age") over(partition by "last_name" order by "first_name" asc) as "average_age"
   * from "person"
   * ```
   */
  over(over) {
    const builder = createOverBuilder();
    return new _AggregateFunctionBuilder({
      ...this.#props,
      aggregateFunctionNode: AggregateFunctionNode.cloneWithOver(this.#props.aggregateFunctionNode, (over ? over(builder) : builder).toOperationNode())
    });
  }
  /**
   * Simply calls the provided function passing `this` as the only argument. `$call` returns
   * what the provided function returns.
   */
  $call(func) {
    return func(this);
  }
  /**
   * Casts the expression to the given type.
   *
   * This method call doesn't change the SQL in any way. This methods simply
   * returns a copy of this `AggregateFunctionBuilder` with a new output type.
   */
  $castTo() {
    return new _AggregateFunctionBuilder(this.#props);
  }
  /**
   * Omit null from the expression's type.
   *
   * This function can be useful in cases where you know an expression can't be
   * null, but Kysely is unable to infer it.
   *
   * This method call doesn't change the SQL in any way. This methods simply
   * returns a copy of `this` with a new output type.
   */
  $notNull() {
    return new _AggregateFunctionBuilder(this.#props);
  }
  toOperationNode() {
    return this.#props.aggregateFunctionNode;
  }
};
preventAwait(AggregateFunctionBuilder, "don't await AggregateFunctionBuilder instances. They are never executed directly and are always just a part of a query.");
var AliasedAggregateFunctionBuilder = class {
  #aggregateFunctionBuilder;
  #alias;
  constructor(aggregateFunctionBuilder, alias) {
    this.#aggregateFunctionBuilder = aggregateFunctionBuilder;
    this.#alias = alias;
  }
  /** @private */
  get expression() {
    return this.#aggregateFunctionBuilder;
  }
  /** @private */
  get alias() {
    return this.#alias;
  }
  toOperationNode() {
    return AliasNode.create(this.#aggregateFunctionBuilder.toOperationNode(), IdentifierNode.create(this.#alias));
  }
};

// ../../../node_modules/.pnpm/kysely@0.27.4/node_modules/kysely/dist/esm/query-builder/function-module.js
function createFunctionModule() {
  const fn = (name, args) => {
    return new ExpressionWrapper(FunctionNode.create(name, parseReferenceExpressionOrList(args ?? [])));
  };
  const agg = (name, args) => {
    return new AggregateFunctionBuilder({
      aggregateFunctionNode: AggregateFunctionNode.create(name, args ? parseReferenceExpressionOrList(args) : void 0)
    });
  };
  return Object.assign(fn, {
    agg,
    avg(column) {
      return agg("avg", [column]);
    },
    coalesce(...values) {
      return fn("coalesce", values);
    },
    count(column) {
      return agg("count", [column]);
    },
    countAll(table) {
      return new AggregateFunctionBuilder({
        aggregateFunctionNode: AggregateFunctionNode.create("count", parseSelectAll(table))
      });
    },
    max(column) {
      return agg("max", [column]);
    },
    min(column) {
      return agg("min", [column]);
    },
    sum(column) {
      return agg("sum", [column]);
    },
    any(column) {
      return fn("any", [column]);
    },
    jsonAgg(table) {
      return new AggregateFunctionBuilder({
        aggregateFunctionNode: AggregateFunctionNode.create("json_agg", [
          isString(table) ? parseTable(table) : table.toOperationNode()
        ])
      });
    },
    toJson(table) {
      return new ExpressionWrapper(FunctionNode.create("to_json", [
        isString(table) ? parseTable(table) : table.toOperationNode()
      ]));
    }
  });
}

// ../../../node_modules/.pnpm/kysely@0.27.4/node_modules/kysely/dist/esm/parser/unary-operation-parser.js
init_define_ENV_DEFINED_IN_BUILD_STEP();

// ../../../node_modules/.pnpm/kysely@0.27.4/node_modules/kysely/dist/esm/operation-node/unary-operation-node.js
init_define_ENV_DEFINED_IN_BUILD_STEP();
var UnaryOperationNode = freeze({
  is(node) {
    return node.kind === "UnaryOperationNode";
  },
  create(operator, operand) {
    return freeze({
      kind: "UnaryOperationNode",
      operator,
      operand
    });
  }
});

// ../../../node_modules/.pnpm/kysely@0.27.4/node_modules/kysely/dist/esm/parser/unary-operation-parser.js
function parseUnaryOperation(operator, operand) {
  return UnaryOperationNode.create(OperatorNode.create(operator), parseReferenceExpression(operand));
}

// ../../../node_modules/.pnpm/kysely@0.27.4/node_modules/kysely/dist/esm/query-builder/case-builder.js
init_define_ENV_DEFINED_IN_BUILD_STEP();

// ../../../node_modules/.pnpm/kysely@0.27.4/node_modules/kysely/dist/esm/operation-node/case-node.js
init_define_ENV_DEFINED_IN_BUILD_STEP();
var CaseNode = freeze({
  is(node) {
    return node.kind === "CaseNode";
  },
  create(value) {
    return freeze({
      kind: "CaseNode",
      value
    });
  },
  cloneWithWhen(caseNode, when) {
    return freeze({
      ...caseNode,
      when: freeze(caseNode.when ? [...caseNode.when, when] : [when])
    });
  },
  cloneWithThen(caseNode, then) {
    return freeze({
      ...caseNode,
      when: caseNode.when ? freeze([
        ...caseNode.when.slice(0, -1),
        WhenNode.cloneWithResult(caseNode.when[caseNode.when.length - 1], then)
      ]) : void 0
    });
  },
  cloneWith(caseNode, props) {
    return freeze({
      ...caseNode,
      ...props
    });
  }
});

// ../../../node_modules/.pnpm/kysely@0.27.4/node_modules/kysely/dist/esm/query-builder/case-builder.js
var CaseBuilder = class {
  #props;
  constructor(props) {
    this.#props = freeze(props);
  }
  when(...args) {
    return new CaseThenBuilder({
      ...this.#props,
      node: CaseNode.cloneWithWhen(this.#props.node, WhenNode.create(parseValueBinaryOperationOrExpression(args)))
    });
  }
};
var CaseThenBuilder = class {
  #props;
  constructor(props) {
    this.#props = freeze(props);
  }
  then(valueExpression) {
    return new CaseWhenBuilder({
      ...this.#props,
      node: CaseNode.cloneWithThen(this.#props.node, isSafeImmediateValue(valueExpression) ? parseSafeImmediateValue(valueExpression) : parseValueExpression(valueExpression))
    });
  }
};
var CaseWhenBuilder = class {
  #props;
  constructor(props) {
    this.#props = freeze(props);
  }
  when(...args) {
    return new CaseThenBuilder({
      ...this.#props,
      node: CaseNode.cloneWithWhen(this.#props.node, WhenNode.create(parseValueBinaryOperationOrExpression(args)))
    });
  }
  else(valueExpression) {
    return new CaseEndBuilder({
      ...this.#props,
      node: CaseNode.cloneWith(this.#props.node, {
        else: isSafeImmediateValue(valueExpression) ? parseSafeImmediateValue(valueExpression) : parseValueExpression(valueExpression)
      })
    });
  }
  end() {
    return new ExpressionWrapper(CaseNode.cloneWith(this.#props.node, { isStatement: false }));
  }
  endCase() {
    return new ExpressionWrapper(CaseNode.cloneWith(this.#props.node, { isStatement: true }));
  }
};
var CaseEndBuilder = class {
  #props;
  constructor(props) {
    this.#props = freeze(props);
  }
  end() {
    return new ExpressionWrapper(CaseNode.cloneWith(this.#props.node, { isStatement: false }));
  }
  endCase() {
    return new ExpressionWrapper(CaseNode.cloneWith(this.#props.node, { isStatement: true }));
  }
};

// ../../../node_modules/.pnpm/kysely@0.27.4/node_modules/kysely/dist/esm/query-builder/json-path-builder.js
init_define_ENV_DEFINED_IN_BUILD_STEP();

// ../../../node_modules/.pnpm/kysely@0.27.4/node_modules/kysely/dist/esm/operation-node/json-path-leg-node.js
init_define_ENV_DEFINED_IN_BUILD_STEP();
var JSONPathLegNode = freeze({
  is(node) {
    return node.kind === "JSONPathLegNode";
  },
  create(type, value) {
    return freeze({
      kind: "JSONPathLegNode",
      type,
      value
    });
  }
});

// ../../../node_modules/.pnpm/kysely@0.27.4/node_modules/kysely/dist/esm/query-builder/json-path-builder.js
var JSONPathBuilder = class {
  #node;
  constructor(node) {
    this.#node = node;
  }
  /**
   * Access an element of a JSON array in a specific location.
   *
   * Since there's no guarantee an element exists in the given array location, the
   * resulting type is always nullable. If you're sure the element exists, you
   * should use {@link SelectQueryBuilder.$assertType} to narrow the type safely.
   *
   * See also {@link key} to access properties of JSON objects.
   *
   * ### Examples
   *
   * ```ts
   * db.selectFrom('person').select(eb =>
   *   eb.ref('nicknames', '->').at(0).as('primary_nickname')
   * )
   *
   * The generated SQL (PostgreSQL):
   *
   * ```sql
   * select "nicknames"->0 as "primary_nickname" from "person"
   *```
   *
   * Combined with {@link key}:
   *
   * ```ts
   * db.selectFrom('person').select(eb =>
   *   eb.ref('experience', '->').at(0).key('role').as('first_role')
   * )
   * ```
   *
   * The generated SQL (PostgreSQL):
   *
   * ```sql
   * select "experience"->0->'role' as "first_role" from "person"
   * ```
   *
   * You can use `'last'` to access the last element of the array in MySQL:
   *
   * ```ts
   * db.selectFrom('person').select(eb =>
   *   eb.ref('nicknames', '->$').at('last').as('last_nickname')
   * )
   * ```
   *
   * The generated SQL (MySQL):
   *
   * ```sql
   * select `nicknames`->'$[last]' as `last_nickname` from `person`
   * ```
   *
   * Or `'#-1'` in SQLite:
   *
   * ```ts
   * db.selectFrom('person').select(eb =>
   *   eb.ref('nicknames', '->>$').at('#-1').as('last_nickname')
   * )
   * ```
   *
   * The generated SQL (SQLite):
   *
   * ```sql
   * select "nicknames"->>'$[#-1]' as `last_nickname` from `person`
   * ```
   */
  at(index) {
    return this.#createBuilderWithPathLeg("ArrayLocation", index);
  }
  /**
   * Access a property of a JSON object.
   *
   * If a field is optional, the resulting type will be nullable.
   *
   * See also {@link at} to access elements of JSON arrays.
   *
   * ### Examples
   *
   * ```ts
   * db.selectFrom('person').select(eb =>
   *   eb.ref('address', '->').key('city').as('city')
   * )
   * ```
   *
   * The generated SQL (PostgreSQL):
   *
   * ```sql
   * select "address"->'city' as "city" from "person"
   * ```
   *
   * Going deeper:
   *
   * ```ts
   * db.selectFrom('person').select(eb =>
   *   eb.ref('profile', '->$').key('website').key('url').as('website_url')
   * )
   * ```
   *
   * The generated SQL (MySQL):
   *
   * ```sql
   * select `profile`->'$.website.url' as `website_url` from `person`
   * ```
   *
   * Combined with {@link at}:
   *
   * ```ts
   * db.selectFrom('person').select(eb =>
   *   eb.ref('profile', '->').key('addresses').at(0).key('city').as('city')
   * )
   * ```
   *
   * The generated SQL (PostgreSQL):
   *
   * ```sql
   * select "profile"->'addresses'->0->'city' as "city" from "person"
   * ```
   */
  key(key) {
    return this.#createBuilderWithPathLeg("Member", key);
  }
  #createBuilderWithPathLeg(legType, value) {
    if (JSONReferenceNode.is(this.#node)) {
      return new TraversedJSONPathBuilder(JSONReferenceNode.cloneWithTraversal(this.#node, JSONPathNode.is(this.#node.traversal) ? JSONPathNode.cloneWithLeg(this.#node.traversal, JSONPathLegNode.create(legType, value)) : JSONOperatorChainNode.cloneWithValue(this.#node.traversal, ValueNode.createImmediate(value))));
    }
    return new TraversedJSONPathBuilder(JSONPathNode.cloneWithLeg(this.#node, JSONPathLegNode.create(legType, value)));
  }
};
var TraversedJSONPathBuilder = class extends JSONPathBuilder {
  #node;
  constructor(node) {
    super(node);
    this.#node = node;
  }
  /** @private */
  get expressionType() {
    return void 0;
  }
  as(alias) {
    return new AliasedJSONPathBuilder(this, alias);
  }
  /**
   * Change the output type of the json path.
   *
   * This method call doesn't change the SQL in any way. This methods simply
   * returns a copy of this `JSONPathBuilder` with a new output type.
   */
  $castTo() {
    return new JSONPathBuilder(this.#node);
  }
  $notNull() {
    return new JSONPathBuilder(this.#node);
  }
  toOperationNode() {
    return this.#node;
  }
};
var AliasedJSONPathBuilder = class {
  #jsonPath;
  #alias;
  constructor(jsonPath, alias) {
    this.#jsonPath = jsonPath;
    this.#alias = alias;
  }
  /** @private */
  get expression() {
    return this.#jsonPath;
  }
  /** @private */
  get alias() {
    return this.#alias;
  }
  toOperationNode() {
    return AliasNode.create(this.#jsonPath.toOperationNode(), isOperationNodeSource(this.#alias) ? this.#alias.toOperationNode() : IdentifierNode.create(this.#alias));
  }
};

// ../../../node_modules/.pnpm/kysely@0.27.4/node_modules/kysely/dist/esm/operation-node/tuple-node.js
init_define_ENV_DEFINED_IN_BUILD_STEP();
var TupleNode = freeze({
  is(node) {
    return node.kind === "TupleNode";
  },
  create(values) {
    return freeze({
      kind: "TupleNode",
      values: freeze(values)
    });
  }
});

// ../../../node_modules/.pnpm/kysely@0.27.4/node_modules/kysely/dist/esm/parser/data-type-parser.js
init_define_ENV_DEFINED_IN_BUILD_STEP();

// ../../../node_modules/.pnpm/kysely@0.27.4/node_modules/kysely/dist/esm/operation-node/data-type-node.js
init_define_ENV_DEFINED_IN_BUILD_STEP();
var SIMPLE_COLUMN_DATA_TYPES = [
  "varchar",
  "char",
  "text",
  "integer",
  "int2",
  "int4",
  "int8",
  "smallint",
  "bigint",
  "boolean",
  "real",
  "double precision",
  "float4",
  "float8",
  "decimal",
  "numeric",
  "binary",
  "bytea",
  "date",
  "datetime",
  "time",
  "timetz",
  "timestamp",
  "timestamptz",
  "serial",
  "bigserial",
  "uuid",
  "json",
  "jsonb",
  "blob",
  "varbinary"
];
var COLUMN_DATA_TYPE_REGEX = [
  /^varchar\(\d+\)$/,
  /^char\(\d+\)$/,
  /^decimal\(\d+, \d+\)$/,
  /^numeric\(\d+, \d+\)$/,
  /^binary\(\d+\)$/,
  /^datetime\(\d+\)$/,
  /^time\(\d+\)$/,
  /^timetz\(\d+\)$/,
  /^timestamp\(\d+\)$/,
  /^timestamptz\(\d+\)$/,
  /^varbinary\(\d+\)$/
];
var DataTypeNode = freeze({
  is(node) {
    return node.kind === "DataTypeNode";
  },
  create(dataType) {
    return freeze({
      kind: "DataTypeNode",
      dataType
    });
  }
});
function isColumnDataType(dataType) {
  if (SIMPLE_COLUMN_DATA_TYPES.includes(dataType)) {
    return true;
  }
  if (COLUMN_DATA_TYPE_REGEX.some((r3) => r3.test(dataType))) {
    return true;
  }
  return false;
}

// ../../../node_modules/.pnpm/kysely@0.27.4/node_modules/kysely/dist/esm/parser/data-type-parser.js
function parseDataTypeExpression(dataType) {
  if (isOperationNodeSource(dataType)) {
    return dataType.toOperationNode();
  }
  if (isColumnDataType(dataType)) {
    return DataTypeNode.create(dataType);
  }
  throw new Error(`invalid column data type ${JSON.stringify(dataType)}`);
}

// ../../../node_modules/.pnpm/kysely@0.27.4/node_modules/kysely/dist/esm/operation-node/cast-node.js
init_define_ENV_DEFINED_IN_BUILD_STEP();
var CastNode = freeze({
  is(node) {
    return node.kind === "CastNode";
  },
  create(expression, dataType) {
    return freeze({
      kind: "CastNode",
      expression,
      dataType
    });
  }
});

// ../../../node_modules/.pnpm/kysely@0.27.4/node_modules/kysely/dist/esm/expression/expression-builder.js
function createExpressionBuilder(executor = NOOP_QUERY_EXECUTOR) {
  function binary(lhs, op, rhs) {
    return new ExpressionWrapper(parseValueBinaryOperation(lhs, op, rhs));
  }
  function unary(op, expr) {
    return new ExpressionWrapper(parseUnaryOperation(op, expr));
  }
  const eb = Object.assign(binary, {
    fn: void 0,
    eb: void 0,
    selectFrom(table) {
      return createSelectQueryBuilder({
        queryId: createQueryId(),
        executor,
        queryNode: SelectQueryNode.createFrom(parseTableExpressionOrList(table))
      });
    },
    case(reference) {
      return new CaseBuilder({
        node: CaseNode.create(isUndefined(reference) ? void 0 : parseReferenceExpression(reference))
      });
    },
    ref(reference, op) {
      if (isUndefined(op)) {
        return new ExpressionWrapper(parseStringReference(reference));
      }
      return new JSONPathBuilder(parseJSONReference(reference, op));
    },
    jsonPath() {
      return new JSONPathBuilder(JSONPathNode.create());
    },
    table(table) {
      return new ExpressionWrapper(parseTable(table));
    },
    val(value) {
      return new ExpressionWrapper(parseValueExpression(value));
    },
    refTuple(...values) {
      return new ExpressionWrapper(TupleNode.create(values.map(parseReferenceExpression)));
    },
    tuple(...values) {
      return new ExpressionWrapper(TupleNode.create(values.map(parseValueExpression)));
    },
    lit(value) {
      return new ExpressionWrapper(parseSafeImmediateValue(value));
    },
    unary,
    not(expr) {
      return unary("not", expr);
    },
    exists(expr) {
      return unary("exists", expr);
    },
    neg(expr) {
      return unary("-", expr);
    },
    between(expr, start, end) {
      return new ExpressionWrapper(BinaryOperationNode.create(parseReferenceExpression(expr), OperatorNode.create("between"), AndNode.create(parseValueExpression(start), parseValueExpression(end))));
    },
    betweenSymmetric(expr, start, end) {
      return new ExpressionWrapper(BinaryOperationNode.create(parseReferenceExpression(expr), OperatorNode.create("between symmetric"), AndNode.create(parseValueExpression(start), parseValueExpression(end))));
    },
    and(exprs) {
      if (isReadonlyArray(exprs)) {
        return new ExpressionWrapper(parseFilterList(exprs, "and"));
      }
      return new ExpressionWrapper(parseFilterObject(exprs, "and"));
    },
    or(exprs) {
      if (isReadonlyArray(exprs)) {
        return new ExpressionWrapper(parseFilterList(exprs, "or"));
      }
      return new ExpressionWrapper(parseFilterObject(exprs, "or"));
    },
    parens(...args) {
      const node = parseValueBinaryOperationOrExpression(args);
      if (ParensNode.is(node)) {
        return new ExpressionWrapper(node);
      } else {
        return new ExpressionWrapper(ParensNode.create(node));
      }
    },
    cast(expr, dataType) {
      return new ExpressionWrapper(CastNode.create(parseReferenceExpression(expr), parseDataTypeExpression(dataType)));
    },
    withSchema(schema) {
      return createExpressionBuilder(executor.withPluginAtFront(new WithSchemaPlugin(schema)));
    }
  });
  eb.fn = createFunctionModule();
  eb.eb = eb;
  return eb;
}
function expressionBuilder(_3) {
  return createExpressionBuilder();
}

// ../../../node_modules/.pnpm/kysely@0.27.4/node_modules/kysely/dist/esm/parser/expression-parser.js
function parseExpression(exp) {
  if (isOperationNodeSource(exp)) {
    return exp.toOperationNode();
  } else if (isFunction(exp)) {
    return exp(expressionBuilder()).toOperationNode();
  }
  throw new Error(`invalid expression: ${JSON.stringify(exp)}`);
}
function parseAliasedExpression(exp) {
  if (isOperationNodeSource(exp)) {
    return exp.toOperationNode();
  } else if (isFunction(exp)) {
    return exp(expressionBuilder()).toOperationNode();
  }
  throw new Error(`invalid aliased expression: ${JSON.stringify(exp)}`);
}
function isExpressionOrFactory(obj) {
  return isExpression(obj) || isAliasedExpression(obj) || isFunction(obj);
}

// ../../../node_modules/.pnpm/kysely@0.27.4/node_modules/kysely/dist/esm/parser/table-parser.js
function parseTableExpressionOrList(table) {
  if (isReadonlyArray(table)) {
    return table.map((it) => parseTableExpression(it));
  } else {
    return [parseTableExpression(table)];
  }
}
function parseTableExpression(table) {
  if (isString(table)) {
    return parseAliasedTable(table);
  } else {
    return parseAliasedExpression(table);
  }
}
function parseAliasedTable(from) {
  const ALIAS_SEPARATOR = " as ";
  if (from.includes(ALIAS_SEPARATOR)) {
    const [table, alias] = from.split(ALIAS_SEPARATOR).map(trim2);
    return AliasNode.create(parseTable(table), IdentifierNode.create(alias));
  } else {
    return parseTable(from);
  }
}
function parseTable(from) {
  const SCHEMA_SEPARATOR = ".";
  if (from.includes(SCHEMA_SEPARATOR)) {
    const [schema, table] = from.split(SCHEMA_SEPARATOR).map(trim2);
    return TableNode.createWithSchema(schema, table);
  } else {
    return TableNode.create(from);
  }
}
function trim2(str) {
  return str.trim();
}

// ../../../node_modules/.pnpm/kysely@0.27.4/node_modules/kysely/dist/esm/schema/alter-table-builder.js
init_define_ENV_DEFINED_IN_BUILD_STEP();

// ../../../node_modules/.pnpm/kysely@0.27.4/node_modules/kysely/dist/esm/operation-node/add-column-node.js
init_define_ENV_DEFINED_IN_BUILD_STEP();
var AddColumnNode = freeze({
  is(node) {
    return node.kind === "AddColumnNode";
  },
  create(column) {
    return freeze({
      kind: "AddColumnNode",
      column
    });
  }
});

// ../../../node_modules/.pnpm/kysely@0.27.4/node_modules/kysely/dist/esm/operation-node/column-definition-node.js
init_define_ENV_DEFINED_IN_BUILD_STEP();
var ColumnDefinitionNode = freeze({
  is(node) {
    return node.kind === "ColumnDefinitionNode";
  },
  create(column, dataType) {
    return freeze({
      kind: "ColumnDefinitionNode",
      column: ColumnNode.create(column),
      dataType
    });
  },
  cloneWithFrontModifier(node, modifier) {
    return freeze({
      ...node,
      frontModifiers: node.frontModifiers ? freeze([...node.frontModifiers, modifier]) : [modifier]
    });
  },
  cloneWithEndModifier(node, modifier) {
    return freeze({
      ...node,
      endModifiers: node.endModifiers ? freeze([...node.endModifiers, modifier]) : [modifier]
    });
  },
  cloneWith(node, props) {
    return freeze({
      ...node,
      ...props
    });
  }
});

// ../../../node_modules/.pnpm/kysely@0.27.4/node_modules/kysely/dist/esm/operation-node/drop-column-node.js
init_define_ENV_DEFINED_IN_BUILD_STEP();
var DropColumnNode = freeze({
  is(node) {
    return node.kind === "DropColumnNode";
  },
  create(column) {
    return freeze({
      kind: "DropColumnNode",
      column: ColumnNode.create(column)
    });
  }
});

// ../../../node_modules/.pnpm/kysely@0.27.4/node_modules/kysely/dist/esm/operation-node/rename-column-node.js
init_define_ENV_DEFINED_IN_BUILD_STEP();
var RenameColumnNode = freeze({
  is(node) {
    return node.kind === "RenameColumnNode";
  },
  create(column, newColumn) {
    return freeze({
      kind: "RenameColumnNode",
      column: ColumnNode.create(column),
      renameTo: ColumnNode.create(newColumn)
    });
  }
});

// ../../../node_modules/.pnpm/kysely@0.27.4/node_modules/kysely/dist/esm/schema/column-definition-builder.js
init_define_ENV_DEFINED_IN_BUILD_STEP();

// ../../../node_modules/.pnpm/kysely@0.27.4/node_modules/kysely/dist/esm/operation-node/check-constraint-node.js
init_define_ENV_DEFINED_IN_BUILD_STEP();
var CheckConstraintNode = freeze({
  is(node) {
    return node.kind === "CheckConstraintNode";
  },
  create(expression, constraintName) {
    return freeze({
      kind: "CheckConstraintNode",
      expression,
      name: constraintName ? IdentifierNode.create(constraintName) : void 0
    });
  }
});

// ../../../node_modules/.pnpm/kysely@0.27.4/node_modules/kysely/dist/esm/operation-node/references-node.js
init_define_ENV_DEFINED_IN_BUILD_STEP();
var ON_MODIFY_FOREIGN_ACTIONS = [
  "no action",
  "restrict",
  "cascade",
  "set null",
  "set default"
];
var ReferencesNode = freeze({
  is(node) {
    return node.kind === "ReferencesNode";
  },
  create(table, columns) {
    return freeze({
      kind: "ReferencesNode",
      table,
      columns: freeze([...columns])
    });
  },
  cloneWithOnDelete(references, onDelete) {
    return freeze({
      ...references,
      onDelete
    });
  },
  cloneWithOnUpdate(references, onUpdate) {
    return freeze({
      ...references,
      onUpdate
    });
  }
});

// ../../../node_modules/.pnpm/kysely@0.27.4/node_modules/kysely/dist/esm/parser/default-value-parser.js
init_define_ENV_DEFINED_IN_BUILD_STEP();
function parseDefaultValueExpression(value) {
  return isOperationNodeSource(value) ? value.toOperationNode() : ValueNode.createImmediate(value);
}

// ../../../node_modules/.pnpm/kysely@0.27.4/node_modules/kysely/dist/esm/operation-node/generated-node.js
init_define_ENV_DEFINED_IN_BUILD_STEP();
var GeneratedNode = freeze({
  is(node) {
    return node.kind === "GeneratedNode";
  },
  create(params) {
    return freeze({
      kind: "GeneratedNode",
      ...params
    });
  },
  createWithExpression(expression) {
    return freeze({
      kind: "GeneratedNode",
      always: true,
      expression
    });
  },
  cloneWith(node, params) {
    return freeze({
      ...node,
      ...params
    });
  }
});

// ../../../node_modules/.pnpm/kysely@0.27.4/node_modules/kysely/dist/esm/operation-node/default-value-node.js
init_define_ENV_DEFINED_IN_BUILD_STEP();
var DefaultValueNode = freeze({
  is(node) {
    return node.kind === "DefaultValueNode";
  },
  create(defaultValue) {
    return freeze({
      kind: "DefaultValueNode",
      defaultValue
    });
  }
});

// ../../../node_modules/.pnpm/kysely@0.27.4/node_modules/kysely/dist/esm/parser/on-modify-action-parser.js
init_define_ENV_DEFINED_IN_BUILD_STEP();
function parseOnModifyForeignAction(action) {
  if (ON_MODIFY_FOREIGN_ACTIONS.includes(action)) {
    return action;
  }
  throw new Error(`invalid OnModifyForeignAction ${action}`);
}

// ../../../node_modules/.pnpm/kysely@0.27.4/node_modules/kysely/dist/esm/schema/column-definition-builder.js
var ColumnDefinitionBuilder = class _ColumnDefinitionBuilder {
  #node;
  constructor(node) {
    this.#node = node;
  }
  /**
   * Adds `auto_increment` or `autoincrement` to the column definition
   * depending on the dialect.
   *
   * Some dialects like PostgreSQL don't support this. On PostgreSQL
   * you can use the `serial` or `bigserial` data type instead.
   */
  autoIncrement() {
    return new _ColumnDefinitionBuilder(ColumnDefinitionNode.cloneWith(this.#node, { autoIncrement: true }));
  }
  /**
   * Makes the column an identity column.
   *
   * This only works on some dialects like MS SQL Server (MSSQL).
   *
   * For PostgreSQL's `generated always as identity` use {@link generatedAlwaysAsIdentity}.
   */
  identity() {
    return new _ColumnDefinitionBuilder(ColumnDefinitionNode.cloneWith(this.#node, { identity: true }));
  }
  /**
   * Makes the column the primary key.
   *
   * If you want to specify a composite primary key use the
   * {@link CreateTableBuilder.addPrimaryKeyConstraint} method.
   */
  primaryKey() {
    return new _ColumnDefinitionBuilder(ColumnDefinitionNode.cloneWith(this.#node, { primaryKey: true }));
  }
  /**
   * Adds a foreign key constraint for the column.
   *
   * If your database engine doesn't support foreign key constraints in the
   * column definition (like MySQL 5) you need to call the table level
   * {@link CreateTableBuilder.addForeignKeyConstraint} method instead.
   *
   * ### Examples
   *
   * ```ts
   * col.references('person.id')
   * ```
   */
  references(ref) {
    const references = parseStringReference(ref);
    if (!references.table || SelectAllNode.is(references.column)) {
      throw new Error(`invalid call references('${ref}'). The reference must have format table.column or schema.table.column`);
    }
    return new _ColumnDefinitionBuilder(ColumnDefinitionNode.cloneWith(this.#node, {
      references: ReferencesNode.create(references.table, [
        references.column
      ])
    }));
  }
  /**
   * Adds an `on delete` constraint for the foreign key column.
   *
   * If your database engine doesn't support foreign key constraints in the
   * column definition (like MySQL 5) you need to call the table level
   * {@link CreateTableBuilder.addForeignKeyConstraint} method instead.
   *
   * ### Examples
   *
   * ```ts
   * col.references('person.id').onDelete('cascade')
   * ```
   */
  onDelete(onDelete) {
    if (!this.#node.references) {
      throw new Error("on delete constraint can only be added for foreign keys");
    }
    return new _ColumnDefinitionBuilder(ColumnDefinitionNode.cloneWith(this.#node, {
      references: ReferencesNode.cloneWithOnDelete(this.#node.references, parseOnModifyForeignAction(onDelete))
    }));
  }
  /**
   * Adds an `on update` constraint for the foreign key column.
   *
   * ### Examples
   *
   * ```ts
   * col.references('person.id').onUpdate('cascade')
   * ```
   */
  onUpdate(onUpdate) {
    if (!this.#node.references) {
      throw new Error("on update constraint can only be added for foreign keys");
    }
    return new _ColumnDefinitionBuilder(ColumnDefinitionNode.cloneWith(this.#node, {
      references: ReferencesNode.cloneWithOnUpdate(this.#node.references, parseOnModifyForeignAction(onUpdate))
    }));
  }
  /**
   * Adds a unique constraint for the column.
   */
  unique() {
    return new _ColumnDefinitionBuilder(ColumnDefinitionNode.cloneWith(this.#node, { unique: true }));
  }
  /**
   * Adds a `not null` constraint for the column.
   */
  notNull() {
    return new _ColumnDefinitionBuilder(ColumnDefinitionNode.cloneWith(this.#node, { notNull: true }));
  }
  /**
   * Adds a `unsigned` modifier for the column.
   *
   * This only works on some dialects like MySQL.
   */
  unsigned() {
    return new _ColumnDefinitionBuilder(ColumnDefinitionNode.cloneWith(this.#node, { unsigned: true }));
  }
  /**
   * Adds a default value constraint for the column.
   *
   * ### Examples
   *
   * ```ts
   * db.schema
   *   .createTable('pet')
   *   .addColumn('number_of_legs', 'integer', (col) => col.defaultTo(4))
   *   .execute()
   * ```
   *
   * Values passed to `defaultTo` are interpreted as value literals by default. You can define
   * an arbitrary SQL expression using the {@link sql} template tag:
   *
   * ```ts
   * import {sql } from 'kysely'
   *
   * db.schema
   *   .createTable('pet')
   *   .addColumn(
   *     'number_of_legs',
   *     'integer',
   *     (col) => col.defaultTo(sql`any SQL here`)
   *   )
   *   .execute()
   * ```
   */
  defaultTo(value) {
    return new _ColumnDefinitionBuilder(ColumnDefinitionNode.cloneWith(this.#node, {
      defaultTo: DefaultValueNode.create(parseDefaultValueExpression(value))
    }));
  }
  /**
   * Adds a check constraint for the column.
   *
   * ### Examples
   *
   * ```ts
   * import {sql } from 'kysely'
   *
   * db.schema
   *   .createTable('pet')
   *   .addColumn('number_of_legs', 'integer', (col) =>
   *     col.check(sql`number_of_legs < 5`)
   *   )
   *   .execute()
   * ```
   */
  check(expression) {
    return new _ColumnDefinitionBuilder(ColumnDefinitionNode.cloneWith(this.#node, {
      check: CheckConstraintNode.create(expression.toOperationNode())
    }));
  }
  /**
   * Makes the column a generated column using a `generated always as` statement.
   *
   * ### Examples
   *
   * ```ts
   * import {sql } from 'kysely'
   *
   * db.schema
   *   .createTable('person')
   *   .addColumn('full_name', 'varchar(255)',
   *     (col) => col.generatedAlwaysAs(sql`concat(first_name, ' ', last_name)`)
   *   )
   *   .execute()
   * ```
   */
  generatedAlwaysAs(expression) {
    return new _ColumnDefinitionBuilder(ColumnDefinitionNode.cloneWith(this.#node, {
      generated: GeneratedNode.createWithExpression(expression.toOperationNode())
    }));
  }
  /**
   * Adds the `generated always as identity` specifier.
   *
   * This only works on some dialects like PostgreSQL.
   *
   * For MS SQL Server (MSSQL)'s identity column use {@link identity}.
   */
  generatedAlwaysAsIdentity() {
    return new _ColumnDefinitionBuilder(ColumnDefinitionNode.cloneWith(this.#node, {
      generated: GeneratedNode.create({ identity: true, always: true })
    }));
  }
  /**
   * Adds the `generated by default as identity` specifier on supported dialects.
   */
  generatedByDefaultAsIdentity() {
    return new _ColumnDefinitionBuilder(ColumnDefinitionNode.cloneWith(this.#node, {
      generated: GeneratedNode.create({ identity: true, byDefault: true })
    }));
  }
  /**
   * Makes a generated column stored instead of virtual. This method can only
   * be used with {@link generatedAlwaysAs}
   *
   * ### Examples
   *
   * ```ts
   * db.schema
   *   .createTable('person')
   *   .addColumn('full_name', 'varchar(255)', (col) => col
   *     .generatedAlwaysAs("concat(first_name, ' ', last_name)")
   *     .stored()
   *   )
   *   .execute()
   * ```
   */
  stored() {
    if (!this.#node.generated) {
      throw new Error("stored() can only be called after generatedAlwaysAs");
    }
    return new _ColumnDefinitionBuilder(ColumnDefinitionNode.cloneWith(this.#node, {
      generated: GeneratedNode.cloneWith(this.#node.generated, {
        stored: true
      })
    }));
  }
  /**
   * This can be used to add any additional SQL right after the column's data type.
   *
   * ### Examples
   *
   * ```ts
   * db.schema.createTable('person')
   *  .addColumn('id', 'integer', col => col.primaryKey())
   *  .addColumn('first_name', 'varchar(36)', col => col.modifyFront(sql`collate utf8mb4_general_ci`).notNull())
   *  .execute()
   * ```
   *
   * The generated SQL (MySQL):
   *
   * ```sql
   * create table `person` (
   *   `id` integer primary key,
   *   `first_name` varchar(36) collate utf8mb4_general_ci not null
   * )
   * ```
   */
  modifyFront(modifier) {
    return new _ColumnDefinitionBuilder(ColumnDefinitionNode.cloneWithFrontModifier(this.#node, modifier.toOperationNode()));
  }
  /**
   * Adds `nulls not distinct` specifier.
   * Should be used with `unique` constraint.
   *
   * This only works on some dialects like PostgreSQL.
   *
   * ### Examples
   *
   * ```ts
   * db.schema.createTable('person')
   *  .addColumn('id', 'integer', col => col.primaryKey())
   *  .addColumn('first_name', 'varchar(30)', col => col.unique().nullsNotDistinct())
   *  .execute()
   * ```
   *
   * The generated SQL (PostgreSQL):
   *
   * ```sql
   * create table "person" (
   *   "id" integer primary key,
   *   "first_name" varchar(30) unique nulls not distinct
   * )
   * ```
   */
  nullsNotDistinct() {
    return new _ColumnDefinitionBuilder(ColumnDefinitionNode.cloneWith(this.#node, { nullsNotDistinct: true }));
  }
  /**
   * Adds `if not exists` specifier.
   * This only works for PostgreSQL.
   */
  ifNotExists() {
    return new _ColumnDefinitionBuilder(ColumnDefinitionNode.cloneWith(this.#node, { ifNotExists: true }));
  }
  /**
   * This can be used to add any additional SQL to the end of the column definition.
   *
   * ### Examples
   *
   * ```ts
   * db.schema.createTable('person')
   *  .addColumn('id', 'integer', col => col.primaryKey())
   *  .addColumn('age', 'integer', col => col.unsigned().notNull().modifyEnd(sql`comment ${sql.lit('it is not polite to ask a woman her age')}`))
   *  .execute()
   * ```
   *
   * The generated SQL (MySQL):
   *
   * ```sql
   * create table `person` (
   *   `id` integer primary key,
   *   `age` integer unsigned not null comment 'it is not polite to ask a woman her age'
   * )
   * ```
   */
  modifyEnd(modifier) {
    return new _ColumnDefinitionBuilder(ColumnDefinitionNode.cloneWithEndModifier(this.#node, modifier.toOperationNode()));
  }
  /**
   * Simply calls the provided function passing `this` as the only argument. `$call` returns
   * what the provided function returns.
   */
  $call(func) {
    return func(this);
  }
  toOperationNode() {
    return this.#node;
  }
};
preventAwait(ColumnDefinitionBuilder, "don't await ColumnDefinitionBuilder instances directly.");

// ../../../node_modules/.pnpm/kysely@0.27.4/node_modules/kysely/dist/esm/operation-node/modify-column-node.js
init_define_ENV_DEFINED_IN_BUILD_STEP();
var ModifyColumnNode = freeze({
  is(node) {
    return node.kind === "ModifyColumnNode";
  },
  create(column) {
    return freeze({
      kind: "ModifyColumnNode",
      column
    });
  }
});

// ../../../node_modules/.pnpm/kysely@0.27.4/node_modules/kysely/dist/esm/schema/foreign-key-constraint-builder.js
init_define_ENV_DEFINED_IN_BUILD_STEP();

// ../../../node_modules/.pnpm/kysely@0.27.4/node_modules/kysely/dist/esm/operation-node/foreign-key-constraint-node.js
init_define_ENV_DEFINED_IN_BUILD_STEP();
var ForeignKeyConstraintNode = freeze({
  is(node) {
    return node.kind === "ForeignKeyConstraintNode";
  },
  create(sourceColumns, targetTable, targetColumns, constraintName) {
    return freeze({
      kind: "ForeignKeyConstraintNode",
      columns: sourceColumns,
      references: ReferencesNode.create(targetTable, targetColumns),
      name: constraintName ? IdentifierNode.create(constraintName) : void 0
    });
  },
  cloneWith(node, props) {
    return freeze({
      ...node,
      ...props
    });
  }
});

// ../../../node_modules/.pnpm/kysely@0.27.4/node_modules/kysely/dist/esm/schema/foreign-key-constraint-builder.js
var ForeignKeyConstraintBuilder = class _ForeignKeyConstraintBuilder {
  #node;
  constructor(node) {
    this.#node = node;
  }
  onDelete(onDelete) {
    return new _ForeignKeyConstraintBuilder(ForeignKeyConstraintNode.cloneWith(this.#node, {
      onDelete: parseOnModifyForeignAction(onDelete)
    }));
  }
  onUpdate(onUpdate) {
    return new _ForeignKeyConstraintBuilder(ForeignKeyConstraintNode.cloneWith(this.#node, {
      onUpdate: parseOnModifyForeignAction(onUpdate)
    }));
  }
  /**
   * Simply calls the provided function passing `this` as the only argument. `$call` returns
   * what the provided function returns.
   */
  $call(func) {
    return func(this);
  }
  toOperationNode() {
    return this.#node;
  }
};
preventAwait(ForeignKeyConstraintBuilder, "don't await ForeignKeyConstraintBuilder instances directly.");

// ../../../node_modules/.pnpm/kysely@0.27.4/node_modules/kysely/dist/esm/operation-node/add-constraint-node.js
init_define_ENV_DEFINED_IN_BUILD_STEP();
var AddConstraintNode = freeze({
  is(node) {
    return node.kind === "AddConstraintNode";
  },
  create(constraint) {
    return freeze({
      kind: "AddConstraintNode",
      constraint
    });
  }
});

// ../../../node_modules/.pnpm/kysely@0.27.4/node_modules/kysely/dist/esm/operation-node/unique-constraint-node.js
init_define_ENV_DEFINED_IN_BUILD_STEP();
var UniqueConstraintNode = freeze({
  is(node) {
    return node.kind === "UniqueConstraintNode";
  },
  create(columns, constraintName, nullsNotDistinct) {
    return freeze({
      kind: "UniqueConstraintNode",
      columns: freeze(columns.map(ColumnNode.create)),
      name: constraintName ? IdentifierNode.create(constraintName) : void 0,
      nullsNotDistinct
    });
  },
  cloneWith(node, props) {
    return freeze({
      ...node,
      ...props
    });
  }
});

// ../../../node_modules/.pnpm/kysely@0.27.4/node_modules/kysely/dist/esm/operation-node/drop-constraint-node.js
init_define_ENV_DEFINED_IN_BUILD_STEP();
var DropConstraintNode = freeze({
  is(node) {
    return node.kind === "DropConstraintNode";
  },
  create(constraintName) {
    return freeze({
      kind: "DropConstraintNode",
      constraintName: IdentifierNode.create(constraintName)
    });
  },
  cloneWith(dropConstraint, props) {
    return freeze({
      ...dropConstraint,
      ...props
    });
  }
});

// ../../../node_modules/.pnpm/kysely@0.27.4/node_modules/kysely/dist/esm/schema/alter-column-builder.js
init_define_ENV_DEFINED_IN_BUILD_STEP();

// ../../../node_modules/.pnpm/kysely@0.27.4/node_modules/kysely/dist/esm/operation-node/alter-column-node.js
init_define_ENV_DEFINED_IN_BUILD_STEP();
var AlterColumnNode = freeze({
  is(node) {
    return node.kind === "AlterColumnNode";
  },
  create(column, prop, value) {
    return freeze({
      kind: "AlterColumnNode",
      column: ColumnNode.create(column),
      [prop]: value
    });
  }
});

// ../../../node_modules/.pnpm/kysely@0.27.4/node_modules/kysely/dist/esm/schema/alter-column-builder.js
var AlterColumnBuilder = class {
  #column;
  constructor(column) {
    this.#column = column;
  }
  setDataType(dataType) {
    return new AlteredColumnBuilder(AlterColumnNode.create(this.#column, "dataType", parseDataTypeExpression(dataType)));
  }
  setDefault(value) {
    return new AlteredColumnBuilder(AlterColumnNode.create(this.#column, "setDefault", parseDefaultValueExpression(value)));
  }
  dropDefault() {
    return new AlteredColumnBuilder(AlterColumnNode.create(this.#column, "dropDefault", true));
  }
  setNotNull() {
    return new AlteredColumnBuilder(AlterColumnNode.create(this.#column, "setNotNull", true));
  }
  dropNotNull() {
    return new AlteredColumnBuilder(AlterColumnNode.create(this.#column, "dropNotNull", true));
  }
  /**
   * Simply calls the provided function passing `this` as the only argument. `$call` returns
   * what the provided function returns.
   */
  $call(func) {
    return func(this);
  }
};
preventAwait(AlterColumnBuilder, "don't await AlterColumnBuilder instances");
var AlteredColumnBuilder = class {
  #alterColumnNode;
  constructor(alterColumnNode) {
    this.#alterColumnNode = alterColumnNode;
  }
  toOperationNode() {
    return this.#alterColumnNode;
  }
};
preventAwait(AlteredColumnBuilder, "don't await AlteredColumnBuilder instances");

// ../../../node_modules/.pnpm/kysely@0.27.4/node_modules/kysely/dist/esm/schema/alter-table-executor.js
init_define_ENV_DEFINED_IN_BUILD_STEP();
var AlterTableExecutor = class {
  #props;
  constructor(props) {
    this.#props = freeze(props);
  }
  toOperationNode() {
    return this.#props.executor.transformQuery(this.#props.node, this.#props.queryId);
  }
  compile() {
    return this.#props.executor.compileQuery(this.toOperationNode(), this.#props.queryId);
  }
  async execute() {
    await this.#props.executor.executeQuery(this.compile(), this.#props.queryId);
  }
};
preventAwait(AlterTableExecutor, "don't await AlterTableExecutor instances directly. To execute the query you need to call `execute`");

// ../../../node_modules/.pnpm/kysely@0.27.4/node_modules/kysely/dist/esm/schema/alter-table-add-foreign-key-constraint-builder.js
init_define_ENV_DEFINED_IN_BUILD_STEP();
var AlterTableAddForeignKeyConstraintBuilder = class _AlterTableAddForeignKeyConstraintBuilder {
  #props;
  constructor(props) {
    this.#props = freeze(props);
  }
  onDelete(onDelete) {
    return new _AlterTableAddForeignKeyConstraintBuilder({
      ...this.#props,
      constraintBuilder: this.#props.constraintBuilder.onDelete(onDelete)
    });
  }
  onUpdate(onUpdate) {
    return new _AlterTableAddForeignKeyConstraintBuilder({
      ...this.#props,
      constraintBuilder: this.#props.constraintBuilder.onUpdate(onUpdate)
    });
  }
  /**
   * Simply calls the provided function passing `this` as the only argument. `$call` returns
   * what the provided function returns.
   */
  $call(func) {
    return func(this);
  }
  toOperationNode() {
    return this.#props.executor.transformQuery(AlterTableNode.cloneWithTableProps(this.#props.node, {
      addConstraint: AddConstraintNode.create(this.#props.constraintBuilder.toOperationNode())
    }), this.#props.queryId);
  }
  compile() {
    return this.#props.executor.compileQuery(this.toOperationNode(), this.#props.queryId);
  }
  async execute() {
    await this.#props.executor.executeQuery(this.compile(), this.#props.queryId);
  }
};
preventAwait(AlterTableAddForeignKeyConstraintBuilder, "don't await AlterTableAddForeignKeyConstraintBuilder instances directly. To execute the query you need to call `execute`");

// ../../../node_modules/.pnpm/kysely@0.27.4/node_modules/kysely/dist/esm/schema/alter-table-drop-constraint-builder.js
init_define_ENV_DEFINED_IN_BUILD_STEP();
var AlterTableDropConstraintBuilder = class _AlterTableDropConstraintBuilder {
  #props;
  constructor(props) {
    this.#props = freeze(props);
  }
  ifExists() {
    return new _AlterTableDropConstraintBuilder({
      ...this.#props,
      node: AlterTableNode.cloneWithTableProps(this.#props.node, {
        dropConstraint: DropConstraintNode.cloneWith(this.#props.node.dropConstraint, {
          ifExists: true
        })
      })
    });
  }
  cascade() {
    return new _AlterTableDropConstraintBuilder({
      ...this.#props,
      node: AlterTableNode.cloneWithTableProps(this.#props.node, {
        dropConstraint: DropConstraintNode.cloneWith(this.#props.node.dropConstraint, {
          modifier: "cascade"
        })
      })
    });
  }
  restrict() {
    return new _AlterTableDropConstraintBuilder({
      ...this.#props,
      node: AlterTableNode.cloneWithTableProps(this.#props.node, {
        dropConstraint: DropConstraintNode.cloneWith(this.#props.node.dropConstraint, {
          modifier: "restrict"
        })
      })
    });
  }
  /**
   * Simply calls the provided function passing `this` as the only argument. `$call` returns
   * what the provided function returns.
   */
  $call(func) {
    return func(this);
  }
  toOperationNode() {
    return this.#props.executor.transformQuery(this.#props.node, this.#props.queryId);
  }
  compile() {
    return this.#props.executor.compileQuery(this.toOperationNode(), this.#props.queryId);
  }
  async execute() {
    await this.#props.executor.executeQuery(this.compile(), this.#props.queryId);
  }
};
preventAwait(AlterTableDropConstraintBuilder, "don't await AlterTableDropConstraintBuilder instances directly. To execute the query you need to call `execute`");

// ../../../node_modules/.pnpm/kysely@0.27.4/node_modules/kysely/dist/esm/operation-node/primary-constraint-node.js
init_define_ENV_DEFINED_IN_BUILD_STEP();
var PrimaryConstraintNode = freeze({
  is(node) {
    return node.kind === "PrimaryKeyConstraintNode";
  },
  create(columns, constraintName) {
    return freeze({
      kind: "PrimaryKeyConstraintNode",
      columns: freeze(columns.map(ColumnNode.create)),
      name: constraintName ? IdentifierNode.create(constraintName) : void 0
    });
  }
});

// ../../../node_modules/.pnpm/kysely@0.27.4/node_modules/kysely/dist/esm/operation-node/add-index-node.js
init_define_ENV_DEFINED_IN_BUILD_STEP();
var AddIndexNode = freeze({
  is(node) {
    return node.kind === "AddIndexNode";
  },
  create(name) {
    return freeze({
      kind: "AddIndexNode",
      name: IdentifierNode.create(name)
    });
  },
  cloneWith(node, props) {
    return freeze({
      ...node,
      ...props
    });
  },
  cloneWithColumns(node, columns) {
    return freeze({
      ...node,
      columns: [...node.columns || [], ...columns]
    });
  }
});

// ../../../node_modules/.pnpm/kysely@0.27.4/node_modules/kysely/dist/esm/schema/alter-table-add-index-builder.js
init_define_ENV_DEFINED_IN_BUILD_STEP();
var AlterTableAddIndexBuilder = class _AlterTableAddIndexBuilder {
  #props;
  constructor(props) {
    this.#props = freeze(props);
  }
  /**
   * Makes the index unique.
   */
  unique() {
    return new _AlterTableAddIndexBuilder({
      ...this.#props,
      node: AlterTableNode.cloneWithTableProps(this.#props.node, {
        addIndex: AddIndexNode.cloneWith(this.#props.node.addIndex, {
          unique: true
        })
      })
    });
  }
  /**
   * Adds a column to the index.
   *
   * Also see {@link columns} for adding multiple columns at once or {@link expression}
   * for specifying an arbitrary expression.
   *
   * ### Examples
   *
   * ```ts
   * await db.schema
   *         .alterTable('person')
   *         .createIndex('person_first_name_and_age_index')
   *         .column('first_name')
   *         .column('age desc')
   *         .execute()
   * ```
   *
   * The generated SQL (MySQL):
   *
   * ```sql
   * alter table `person` add index `person_first_name_and_age_index` (`first_name`, `age` desc)
   * ```
   */
  column(column) {
    return new _AlterTableAddIndexBuilder({
      ...this.#props,
      node: AlterTableNode.cloneWithTableProps(this.#props.node, {
        addIndex: AddIndexNode.cloneWithColumns(this.#props.node.addIndex, [
          parseOrderedColumnName(column)
        ])
      })
    });
  }
  /**
   * Specifies a list of columns for the index.
   *
   * Also see {@link column} for adding a single column or {@link expression} for
   * specifying an arbitrary expression.
   *
   * ### Examples
   *
   * ```ts
   * await db.schema
   *         .alterTable('person')
   *         .addIndex('person_first_name_and_age_index')
   *         .columns(['first_name', 'age desc'])
   *         .execute()
   * ```
   *
   * The generated SQL (MySQL):
   *
   * ```sql
   * alter table `person` add index `person_first_name_and_age_index` (`first_name`, `age` desc)
   * ```
   */
  columns(columns) {
    return new _AlterTableAddIndexBuilder({
      ...this.#props,
      node: AlterTableNode.cloneWithTableProps(this.#props.node, {
        addIndex: AddIndexNode.cloneWithColumns(this.#props.node.addIndex, columns.map(parseOrderedColumnName))
      })
    });
  }
  /**
   * Specifies an arbitrary expression for the index.
   *
   * ### Examples
   *
   * ```ts
   * import {sql } from 'kysely'
   *
   * await db.schema
   *   .alterTable('person')
   *   .addIndex('person_first_name_index')
   *   .expression(sql<boolean>`(first_name < 'Sami')`)
   *   .execute()
   * ```
   *
   * The generated SQL (MySQL):
   *
   * ```sql
   * alter table `person` add index `person_first_name_index` ((first_name < 'Sami'))
   * ```
   */
  expression(expression) {
    return new _AlterTableAddIndexBuilder({
      ...this.#props,
      node: AlterTableNode.cloneWithTableProps(this.#props.node, {
        addIndex: AddIndexNode.cloneWithColumns(this.#props.node.addIndex, [
          expression.toOperationNode()
        ])
      })
    });
  }
  using(indexType) {
    return new _AlterTableAddIndexBuilder({
      ...this.#props,
      node: AlterTableNode.cloneWithTableProps(this.#props.node, {
        addIndex: AddIndexNode.cloneWith(this.#props.node.addIndex, {
          using: RawNode.createWithSql(indexType)
        })
      })
    });
  }
  /**
   * Simply calls the provided function passing `this` as the only argument. `$call` returns
   * what the provided function returns.
   */
  $call(func) {
    return func(this);
  }
  toOperationNode() {
    return this.#props.executor.transformQuery(this.#props.node, this.#props.queryId);
  }
  compile() {
    return this.#props.executor.compileQuery(this.toOperationNode(), this.#props.queryId);
  }
  async execute() {
    await this.#props.executor.executeQuery(this.compile(), this.#props.queryId);
  }
};
preventAwait(AlterTableAddIndexBuilder, "don't await AlterTableAddIndexBuilder instances directly. To execute the query you need to call `execute`");

// ../../../node_modules/.pnpm/kysely@0.27.4/node_modules/kysely/dist/esm/schema/unique-constraint-builder.js
init_define_ENV_DEFINED_IN_BUILD_STEP();
var UniqueConstraintNodeBuilder = class _UniqueConstraintNodeBuilder {
  #node;
  constructor(node) {
    this.#node = node;
  }
  toOperationNode() {
    return this.#node;
  }
  /**
   * Adds `nulls not distinct` to the unique constraint definition
   *
   * Supported by PostgreSQL dialect only
   */
  nullsNotDistinct() {
    return new _UniqueConstraintNodeBuilder(UniqueConstraintNode.cloneWith(this.#node, { nullsNotDistinct: true }));
  }
};
preventAwait(UniqueConstraintNodeBuilder, "don't await UniqueConstraintNodeBuilder instances directly.");

// ../../../node_modules/.pnpm/kysely@0.27.4/node_modules/kysely/dist/esm/schema/alter-table-builder.js
var AlterTableBuilder = class {
  #props;
  constructor(props) {
    this.#props = freeze(props);
  }
  renameTo(newTableName) {
    return new AlterTableExecutor({
      ...this.#props,
      node: AlterTableNode.cloneWithTableProps(this.#props.node, {
        renameTo: parseTable(newTableName)
      })
    });
  }
  setSchema(newSchema) {
    return new AlterTableExecutor({
      ...this.#props,
      node: AlterTableNode.cloneWithTableProps(this.#props.node, {
        setSchema: IdentifierNode.create(newSchema)
      })
    });
  }
  alterColumn(column, alteration) {
    const builder = alteration(new AlterColumnBuilder(column));
    return new AlterTableColumnAlteringBuilder({
      ...this.#props,
      node: AlterTableNode.cloneWithColumnAlteration(this.#props.node, builder.toOperationNode())
    });
  }
  dropColumn(column) {
    return new AlterTableColumnAlteringBuilder({
      ...this.#props,
      node: AlterTableNode.cloneWithColumnAlteration(this.#props.node, DropColumnNode.create(column))
    });
  }
  renameColumn(column, newColumn) {
    return new AlterTableColumnAlteringBuilder({
      ...this.#props,
      node: AlterTableNode.cloneWithColumnAlteration(this.#props.node, RenameColumnNode.create(column, newColumn))
    });
  }
  addColumn(columnName, dataType, build2 = noop) {
    const builder = build2(new ColumnDefinitionBuilder(ColumnDefinitionNode.create(columnName, parseDataTypeExpression(dataType))));
    return new AlterTableColumnAlteringBuilder({
      ...this.#props,
      node: AlterTableNode.cloneWithColumnAlteration(this.#props.node, AddColumnNode.create(builder.toOperationNode()))
    });
  }
  modifyColumn(columnName, dataType, build2 = noop) {
    const builder = build2(new ColumnDefinitionBuilder(ColumnDefinitionNode.create(columnName, parseDataTypeExpression(dataType))));
    return new AlterTableColumnAlteringBuilder({
      ...this.#props,
      node: AlterTableNode.cloneWithColumnAlteration(this.#props.node, ModifyColumnNode.create(builder.toOperationNode()))
    });
  }
  /**
   * See {@link CreateTableBuilder.addUniqueConstraint}
   */
  addUniqueConstraint(constraintName, columns, build2 = noop) {
    const uniqueConstraintBuilder = build2(new UniqueConstraintNodeBuilder(UniqueConstraintNode.create(columns, constraintName)));
    return new AlterTableExecutor({
      ...this.#props,
      node: AlterTableNode.cloneWithTableProps(this.#props.node, {
        addConstraint: AddConstraintNode.create(uniqueConstraintBuilder.toOperationNode())
      })
    });
  }
  /**
   * See {@link CreateTableBuilder.addCheckConstraint}
   */
  addCheckConstraint(constraintName, checkExpression) {
    return new AlterTableExecutor({
      ...this.#props,
      node: AlterTableNode.cloneWithTableProps(this.#props.node, {
        addConstraint: AddConstraintNode.create(CheckConstraintNode.create(checkExpression.toOperationNode(), constraintName))
      })
    });
  }
  /**
   * See {@link CreateTableBuilder.addForeignKeyConstraint}
   *
   * Unlike {@link CreateTableBuilder.addForeignKeyConstraint} this method returns
   * the constraint builder and doesn't take a callback as the last argument. This
   * is because you can only add one column per `ALTER TABLE` query.
   */
  addForeignKeyConstraint(constraintName, columns, targetTable, targetColumns) {
    return new AlterTableAddForeignKeyConstraintBuilder({
      ...this.#props,
      constraintBuilder: new ForeignKeyConstraintBuilder(ForeignKeyConstraintNode.create(columns.map(ColumnNode.create), parseTable(targetTable), targetColumns.map(ColumnNode.create), constraintName))
    });
  }
  /**
   * See {@link CreateTableBuilder.addPrimaryKeyConstraint}
   */
  addPrimaryKeyConstraint(constraintName, columns) {
    return new AlterTableExecutor({
      ...this.#props,
      node: AlterTableNode.cloneWithTableProps(this.#props.node, {
        addConstraint: AddConstraintNode.create(PrimaryConstraintNode.create(columns, constraintName))
      })
    });
  }
  dropConstraint(constraintName) {
    return new AlterTableDropConstraintBuilder({
      ...this.#props,
      node: AlterTableNode.cloneWithTableProps(this.#props.node, {
        dropConstraint: DropConstraintNode.create(constraintName)
      })
    });
  }
  /**
   * This can be used to add index to table.
   *
   *  ### Examples
   *
   * ```ts
   * db.schema.alterTable('person')
   *   .addIndex('person_email_index')
   *   .column('email')
   *   .unique()
   *   .execute()
   * ```
   *
   * The generated SQL (MySQL):
   *
   * ```sql
   * alter table `person` add unique index `person_email_index` (`email`)
   * ```
   */
  addIndex(indexName) {
    return new AlterTableAddIndexBuilder({
      ...this.#props,
      node: AlterTableNode.cloneWithTableProps(this.#props.node, {
        addIndex: AddIndexNode.create(indexName)
      })
    });
  }
  /**
   * This can be used to drop index from table.
   *
   * ### Examples
   *
   * ```ts
   * db.schema.alterTable('person')
   *   .dropIndex('person_email_index')
   *   .execute()
   * ```
   *
   * The generated SQL (MySQL):
   *
   * ```sql
   * alter table `person` drop index `test_first_name_index`
   * ```
   */
  dropIndex(indexName) {
    return new AlterTableExecutor({
      ...this.#props,
      node: AlterTableNode.cloneWithTableProps(this.#props.node, {
        dropIndex: DropIndexNode.create(indexName)
      })
    });
  }
  /**
   * Calls the given function passing `this` as the only argument.
   *
   * See {@link CreateTableBuilder.$call}
   */
  $call(func) {
    return func(this);
  }
};
preventAwait(AlterTableBuilder, "don't await AlterTableBuilder instances");
var AlterTableColumnAlteringBuilder = class _AlterTableColumnAlteringBuilder {
  #props;
  constructor(props) {
    this.#props = freeze(props);
  }
  alterColumn(column, alteration) {
    const builder = alteration(new AlterColumnBuilder(column));
    return new _AlterTableColumnAlteringBuilder({
      ...this.#props,
      node: AlterTableNode.cloneWithColumnAlteration(this.#props.node, builder.toOperationNode())
    });
  }
  dropColumn(column) {
    return new _AlterTableColumnAlteringBuilder({
      ...this.#props,
      node: AlterTableNode.cloneWithColumnAlteration(this.#props.node, DropColumnNode.create(column))
    });
  }
  renameColumn(column, newColumn) {
    return new _AlterTableColumnAlteringBuilder({
      ...this.#props,
      node: AlterTableNode.cloneWithColumnAlteration(this.#props.node, RenameColumnNode.create(column, newColumn))
    });
  }
  addColumn(columnName, dataType, build2 = noop) {
    const builder = build2(new ColumnDefinitionBuilder(ColumnDefinitionNode.create(columnName, parseDataTypeExpression(dataType))));
    return new _AlterTableColumnAlteringBuilder({
      ...this.#props,
      node: AlterTableNode.cloneWithColumnAlteration(this.#props.node, AddColumnNode.create(builder.toOperationNode()))
    });
  }
  modifyColumn(columnName, dataType, build2 = noop) {
    const builder = build2(new ColumnDefinitionBuilder(ColumnDefinitionNode.create(columnName, parseDataTypeExpression(dataType))));
    return new _AlterTableColumnAlteringBuilder({
      ...this.#props,
      node: AlterTableNode.cloneWithColumnAlteration(this.#props.node, ModifyColumnNode.create(builder.toOperationNode()))
    });
  }
  toOperationNode() {
    return this.#props.executor.transformQuery(this.#props.node, this.#props.queryId);
  }
  compile() {
    return this.#props.executor.compileQuery(this.toOperationNode(), this.#props.queryId);
  }
  async execute() {
    await this.#props.executor.executeQuery(this.compile(), this.#props.queryId);
  }
};
preventAwait(AlterTableColumnAlteringBuilder, "don't await AlterTableColumnAlteringBuilder instances directly. To execute the query you need to call `execute`");

// ../../../node_modules/.pnpm/kysely@0.27.4/node_modules/kysely/dist/esm/schema/create-index-builder.js
init_define_ENV_DEFINED_IN_BUILD_STEP();

// ../../../node_modules/.pnpm/kysely@0.27.4/node_modules/kysely/dist/esm/plugin/immediate-value/immediate-value-transformer.js
init_define_ENV_DEFINED_IN_BUILD_STEP();
var ImmediateValueTransformer = class extends OperationNodeTransformer {
  transformValue(node) {
    return {
      ...super.transformValue(node),
      immediate: true
    };
  }
};

// ../../../node_modules/.pnpm/kysely@0.27.4/node_modules/kysely/dist/esm/schema/create-index-builder.js
var CreateIndexBuilder = class _CreateIndexBuilder {
  #props;
  constructor(props) {
    this.#props = freeze(props);
  }
  /**
   * Adds the "if not exists" modifier.
   *
   * If the index already exists, no error is thrown if this method has been called.
   */
  ifNotExists() {
    return new _CreateIndexBuilder({
      ...this.#props,
      node: CreateIndexNode.cloneWith(this.#props.node, {
        ifNotExists: true
      })
    });
  }
  /**
   * Makes the index unique.
   */
  unique() {
    return new _CreateIndexBuilder({
      ...this.#props,
      node: CreateIndexNode.cloneWith(this.#props.node, {
        unique: true
      })
    });
  }
  /**
   * Adds `nulls not distinct` specifier to index.
   * This only works on some dialects like PostgreSQL.
   *
   * ### Examples
   *
   * ```ts
   * db.schema.createIndex('person_first_name_index')
   *  .on('person')
   *  .column('first_name')
   *  .nullsNotDistinct()
   *  .execute()
   * ```
   *
   * The generated SQL (PostgreSQL):
   *
   * ```sql
   * create index "person_first_name_index"
   * on "test" ("first_name")
   * nulls not distinct;
   * ```
   */
  nullsNotDistinct() {
    return new _CreateIndexBuilder({
      ...this.#props,
      node: CreateIndexNode.cloneWith(this.#props.node, {
        nullsNotDistinct: true
      })
    });
  }
  /**
   * Specifies the table for the index.
   */
  on(table) {
    return new _CreateIndexBuilder({
      ...this.#props,
      node: CreateIndexNode.cloneWith(this.#props.node, {
        table: parseTable(table)
      })
    });
  }
  /**
   * Adds a column to the index.
   *
   * Also see {@link columns} for adding multiple columns at once or {@link expression}
   * for specifying an arbitrary expression.
   *
   * ### Examples
   *
   * ```ts
   * await db.schema
   *         .createIndex('person_first_name_and_age_index')
   *         .on('person')
   *         .column('first_name')
   *         .column('age desc')
   *         .execute()
   * ```
   *
   * The generated SQL (PostgreSQL):
   *
   * ```sql
   * create index "person_first_name_and_age_index" on "person" ("first_name", "age" desc)
   * ```
   */
  column(column) {
    return new _CreateIndexBuilder({
      ...this.#props,
      node: CreateIndexNode.cloneWithColumns(this.#props.node, [
        parseOrderedColumnName(column)
      ])
    });
  }
  /**
   * Specifies a list of columns for the index.
   *
   * Also see {@link column} for adding a single column or {@link expression} for
   * specifying an arbitrary expression.
   *
   * ### Examples
   *
   * ```ts
   * await db.schema
   *         .createIndex('person_first_name_and_age_index')
   *         .on('person')
   *         .columns(['first_name', 'age desc'])
   *         .execute()
   * ```
   *
   * The generated SQL (PostgreSQL):
   *
   * ```sql
   * create index "person_first_name_and_age_index" on "person" ("first_name", "age" desc)
   * ```
   */
  columns(columns) {
    return new _CreateIndexBuilder({
      ...this.#props,
      node: CreateIndexNode.cloneWithColumns(this.#props.node, columns.map(parseOrderedColumnName))
    });
  }
  /**
   * Specifies an arbitrary expression for the index.
   *
   * ### Examples
   *
   * ```ts
   * import {sql } from 'kysely'
   *
   * await db.schema
   *   .createIndex('person_first_name_index')
   *   .on('person')
   *   .expression(sql`first_name COLLATE "fi_FI"`)
   *   .execute()
   * ```
   *
   * The generated SQL (PostgreSQL):
   *
   * ```sql
   * create index "person_first_name_index" on "person" (first_name COLLATE "fi_FI")
   * ```
   */
  expression(expression) {
    return new _CreateIndexBuilder({
      ...this.#props,
      node: CreateIndexNode.cloneWithColumns(this.#props.node, [
        expression.toOperationNode()
      ])
    });
  }
  using(indexType) {
    return new _CreateIndexBuilder({
      ...this.#props,
      node: CreateIndexNode.cloneWith(this.#props.node, {
        using: RawNode.createWithSql(indexType)
      })
    });
  }
  where(...args) {
    const transformer = new ImmediateValueTransformer();
    return new _CreateIndexBuilder({
      ...this.#props,
      node: QueryNode.cloneWithWhere(this.#props.node, transformer.transformNode(parseValueBinaryOperationOrExpression(args)))
    });
  }
  /**
   * Simply calls the provided function passing `this` as the only argument. `$call` returns
   * what the provided function returns.
   */
  $call(func) {
    return func(this);
  }
  toOperationNode() {
    return this.#props.executor.transformQuery(this.#props.node, this.#props.queryId);
  }
  compile() {
    return this.#props.executor.compileQuery(this.toOperationNode(), this.#props.queryId);
  }
  async execute() {
    await this.#props.executor.executeQuery(this.compile(), this.#props.queryId);
  }
};
preventAwait(CreateIndexBuilder, "don't await CreateIndexBuilder instances directly. To execute the query you need to call `execute`");

// ../../../node_modules/.pnpm/kysely@0.27.4/node_modules/kysely/dist/esm/schema/create-schema-builder.js
init_define_ENV_DEFINED_IN_BUILD_STEP();
var CreateSchemaBuilder = class _CreateSchemaBuilder {
  #props;
  constructor(props) {
    this.#props = freeze(props);
  }
  ifNotExists() {
    return new _CreateSchemaBuilder({
      ...this.#props,
      node: CreateSchemaNode.cloneWith(this.#props.node, { ifNotExists: true })
    });
  }
  /**
   * Simply calls the provided function passing `this` as the only argument. `$call` returns
   * what the provided function returns.
   */
  $call(func) {
    return func(this);
  }
  toOperationNode() {
    return this.#props.executor.transformQuery(this.#props.node, this.#props.queryId);
  }
  compile() {
    return this.#props.executor.compileQuery(this.toOperationNode(), this.#props.queryId);
  }
  async execute() {
    await this.#props.executor.executeQuery(this.compile(), this.#props.queryId);
  }
};
preventAwait(CreateSchemaBuilder, "don't await CreateSchemaBuilder instances directly. To execute the query you need to call `execute`");

// ../../../node_modules/.pnpm/kysely@0.27.4/node_modules/kysely/dist/esm/schema/create-table-builder.js
init_define_ENV_DEFINED_IN_BUILD_STEP();

// ../../../node_modules/.pnpm/kysely@0.27.4/node_modules/kysely/dist/esm/parser/on-commit-action-parse.js
init_define_ENV_DEFINED_IN_BUILD_STEP();
function parseOnCommitAction(action) {
  if (ON_COMMIT_ACTIONS.includes(action)) {
    return action;
  }
  throw new Error(`invalid OnCommitAction ${action}`);
}

// ../../../node_modules/.pnpm/kysely@0.27.4/node_modules/kysely/dist/esm/schema/create-table-builder.js
var CreateTableBuilder = class _CreateTableBuilder {
  #props;
  constructor(props) {
    this.#props = freeze(props);
  }
  /**
   * Adds the "temporary" modifier.
   *
   * Use this to create a temporary table.
   */
  temporary() {
    return new _CreateTableBuilder({
      ...this.#props,
      node: CreateTableNode.cloneWith(this.#props.node, {
        temporary: true
      })
    });
  }
  /**
   * Adds an "on commit" statement.
   *
   * This can be used in conjunction with temporary tables on supported databases
   * like PostgreSQL.
   */
  onCommit(onCommit) {
    return new _CreateTableBuilder({
      ...this.#props,
      node: CreateTableNode.cloneWith(this.#props.node, {
        onCommit: parseOnCommitAction(onCommit)
      })
    });
  }
  /**
   * Adds the "if not exists" modifier.
   *
   * If the table already exists, no error is thrown if this method has been called.
   */
  ifNotExists() {
    return new _CreateTableBuilder({
      ...this.#props,
      node: CreateTableNode.cloneWith(this.#props.node, {
        ifNotExists: true
      })
    });
  }
  /**
   * Adds a column to the table.
   *
   * ### Examples
   *
   * ```ts
   * import {sql } from 'kysely'
   *
   * await db.schema
   *   .createTable('person')
   *   .addColumn('id', 'integer', (col) => col.autoIncrement().primaryKey()),
   *   .addColumn('first_name', 'varchar(50)', (col) => col.notNull())
   *   .addColumn('last_name', 'varchar(255)')
   *   .addColumn('bank_balance', 'numeric(8, 2)')
   *   // You can specify any data type using the `sql` tag if the types
   *   // don't include it.
   *   .addColumn('data', sql`any_type_here`)
   *   .addColumn('parent_id', 'integer', (col) =>
   *     col.references('person.id').onDelete('cascade'))
   *   )
   * ```
   *
   * With this method, it's once again good to remember that Kysely just builds the
   * query and doesn't provide the same API for all databases. For example, some
   * databases like older MySQL don't support the `references` statement in the
   * column definition. Instead foreign key constraints need to be defined in the
   * `create table` query. See the next example:
   *
   * ```ts
   *   .addColumn('parent_id', 'integer')
   *   .addForeignKeyConstraint(
   *     'person_parent_id_fk', ['parent_id'], 'person', ['id'],
   *     (cb) => cb.onDelete('cascade')
   *   )
   * ```
   *
   * Another good example is that PostgreSQL doesn't support the `auto_increment`
   * keyword and you need to define an autoincrementing column for example using
   * `serial`:
   *
   * ```ts
   * await db.schema
   *   .createTable('person')
   *   .addColumn('id', 'serial', (col) => col.primaryKey()),
   * ```
   */
  addColumn(columnName, dataType, build2 = noop) {
    const columnBuilder = build2(new ColumnDefinitionBuilder(ColumnDefinitionNode.create(columnName, parseDataTypeExpression(dataType))));
    return new _CreateTableBuilder({
      ...this.#props,
      node: CreateTableNode.cloneWithColumn(this.#props.node, columnBuilder.toOperationNode())
    });
  }
  /**
   * Adds a primary key constraint for one or more columns.
   *
   * The constraint name can be anything you want, but it must be unique
   * across the whole database.
   *
   * ### Examples
   *
   * ```ts
   * addPrimaryKeyConstraint('primary_key', ['first_name', 'last_name'])
   * ```
   */
  addPrimaryKeyConstraint(constraintName, columns) {
    return new _CreateTableBuilder({
      ...this.#props,
      node: CreateTableNode.cloneWithConstraint(this.#props.node, PrimaryConstraintNode.create(columns, constraintName))
    });
  }
  /**
   * Adds a unique constraint for one or more columns.
   *
   * The constraint name can be anything you want, but it must be unique
   * across the whole database.
   *
   * ### Examples
   *
   * ```ts
   * addUniqueConstraint('first_name_last_name_unique', ['first_name', 'last_name'])
   * ```
   *
   * In dialects such as PostgreSQL you can specify `nulls not distinct` as follows:
   * ```ts
   * addUniqueConstraint('first_name_last_name_unique', ['first_name', 'last_name'], (builder) => builder.nullsNotDistinct())
   * ```
   */
  addUniqueConstraint(constraintName, columns, build2 = noop) {
    const uniqueConstraintBuilder = build2(new UniqueConstraintNodeBuilder(UniqueConstraintNode.create(columns, constraintName)));
    return new _CreateTableBuilder({
      ...this.#props,
      node: CreateTableNode.cloneWithConstraint(this.#props.node, uniqueConstraintBuilder.toOperationNode())
    });
  }
  /**
   * Adds a check constraint.
   *
   * The constraint name can be anything you want, but it must be unique
   * across the whole database.
   *
   * ### Examples
   *
   * ```ts
   * import {sql } from 'kysely'
   *
   * addCheckConstraint('check_legs', sql`number_of_legs < 5`)
   * ```
   */
  addCheckConstraint(constraintName, checkExpression) {
    return new _CreateTableBuilder({
      ...this.#props,
      node: CreateTableNode.cloneWithConstraint(this.#props.node, CheckConstraintNode.create(checkExpression.toOperationNode(), constraintName))
    });
  }
  /**
   * Adds a foreign key constraint.
   *
   * The constraint name can be anything you want, but it must be unique
   * across the whole database.
   *
   * ### Examples
   *
   * ```ts
   * addForeignKeyConstraint(
   *   'owner_id_foreign',
   *   ['owner_id'],
   *   'person',
   *   ['id'],
   * )
   * ```
   *
   * Add constraint for multiple columns:
   *
   * ```ts
   * addForeignKeyConstraint(
   *   'owner_id_foreign',
   *   ['owner_id1', 'owner_id2'],
   *   'person',
   *   ['id1', 'id2'],
   *   (cb) => cb.onDelete('cascade')
   * )
   * ```
   */
  addForeignKeyConstraint(constraintName, columns, targetTable, targetColumns, build2 = noop) {
    const builder = build2(new ForeignKeyConstraintBuilder(ForeignKeyConstraintNode.create(columns.map(ColumnNode.create), parseTable(targetTable), targetColumns.map(ColumnNode.create), constraintName)));
    return new _CreateTableBuilder({
      ...this.#props,
      node: CreateTableNode.cloneWithConstraint(this.#props.node, builder.toOperationNode())
    });
  }
  /**
   * This can be used to add any additional SQL to the front of the query __after__ the `create` keyword.
   *
   * Also see {@link temporary}.
   *
   * ### Examples
   *
   * ```ts
   * db.schema.createTable('person')
   *   .modifyFront(sql`global temporary`)
   *   .addColumn('id', 'integer', col => col.primaryKey())
   *   .addColumn('first_name', 'varchar(64)', col => col.notNull())
   *   .addColumn('last_name', 'varchar(64), col => col.notNull())
   *   .execute()
   * ```
   *
   * The generated SQL (Postgres):
   *
   * ```sql
   * create global temporary table "person" (
   *   "id" integer primary key,
   *   "first_name" varchar(64) not null,
   *   "last_name" varchar(64) not null
   * )
   * ```
   */
  modifyFront(modifier) {
    return new _CreateTableBuilder({
      ...this.#props,
      node: CreateTableNode.cloneWithFrontModifier(this.#props.node, modifier.toOperationNode())
    });
  }
  /**
   * This can be used to add any additional SQL to the end of the query.
   *
   * Also see {@link onCommit}.
   *
   * ### Examples
   *
   * ```ts
   * db.schema.createTable('person')
   *   .addColumn('id', 'integer', col => col => primaryKey())
   *   .addColumn('first_name', 'varchar(64)', col => col.notNull())
   *   .addColumn('last_name', 'varchar(64), col => col.notNull())
   *   .modifyEnd(sql`collate utf8_unicode_ci`)
   *   .execute()
   * ```
   *
   * The generated SQL (MySQL):
   *
   * ```sql
   * create table `person` (
   *   `id` integer primary key,
   *   `first_name` varchar(64) not null,
   *   `last_name` varchar(64) not null
   * ) collate utf8_unicode_ci
   * ```
   */
  modifyEnd(modifier) {
    return new _CreateTableBuilder({
      ...this.#props,
      node: CreateTableNode.cloneWithEndModifier(this.#props.node, modifier.toOperationNode())
    });
  }
  /**
   * Allows to create table from `select` query.
   *
   * ### Examples
   *
   * ```ts
   * db.schema.createTable('copy')
   *   .temporary()
   *   .as(db.selectFrom('person').select(['first_name', 'last_name']))
   *   .execute()
   * ```
   *
   * The generated SQL (PostgreSQL):
   *
   * ```sql
   * create temporary table "copy" as
   * select "first_name", "last_name" from "person"
   * ```
   */
  as(expression) {
    return new _CreateTableBuilder({
      ...this.#props,
      node: CreateTableNode.cloneWith(this.#props.node, {
        selectQuery: parseExpression(expression)
      })
    });
  }
  /**
   * Calls the given function passing `this` as the only argument.
   *
   * ### Examples
   *
   * ```ts
   * db.schema
   *   .createTable('test')
   *   .$call((builder) => builder.addColumn('id', 'integer'))
   *   .execute()
   * ```
   *
   * ```ts
   * const addDefaultColumns = <T extends string, C extends string = never>(
   *   builder: CreateTableBuilder<T, C>
   * ) => {
   *   return builder
   *     .addColumn('id', 'integer', (col) => col.notNull())
   *     .addColumn('created_at', 'date', (col) =>
   *       col.notNull().defaultTo(sql`now()`)
   *     )
   *     .addColumn('updated_at', 'date', (col) =>
   *       col.notNull().defaultTo(sql`now()`)
   *     )
   * }
   *
   * db.schema
   *   .createTable('test')
   *   .$call(addDefaultColumns)
   *   .execute()
   * ```
   */
  $call(func) {
    return func(this);
  }
  toOperationNode() {
    return this.#props.executor.transformQuery(this.#props.node, this.#props.queryId);
  }
  compile() {
    return this.#props.executor.compileQuery(this.toOperationNode(), this.#props.queryId);
  }
  async execute() {
    await this.#props.executor.executeQuery(this.compile(), this.#props.queryId);
  }
};
preventAwait(CreateTableBuilder, "don't await CreateTableBuilder instances directly. To execute the query you need to call `execute`");

// ../../../node_modules/.pnpm/kysely@0.27.4/node_modules/kysely/dist/esm/schema/drop-index-builder.js
init_define_ENV_DEFINED_IN_BUILD_STEP();
var DropIndexBuilder = class _DropIndexBuilder {
  #props;
  constructor(props) {
    this.#props = freeze(props);
  }
  /**
   * Specifies the table the index was created for. This is not needed
   * in all dialects.
   */
  on(table) {
    return new _DropIndexBuilder({
      ...this.#props,
      node: DropIndexNode.cloneWith(this.#props.node, {
        table: parseTable(table)
      })
    });
  }
  ifExists() {
    return new _DropIndexBuilder({
      ...this.#props,
      node: DropIndexNode.cloneWith(this.#props.node, {
        ifExists: true
      })
    });
  }
  cascade() {
    return new _DropIndexBuilder({
      ...this.#props,
      node: DropIndexNode.cloneWith(this.#props.node, {
        cascade: true
      })
    });
  }
  /**
   * Simply calls the provided function passing `this` as the only argument. `$call` returns
   * what the provided function returns.
   */
  $call(func) {
    return func(this);
  }
  toOperationNode() {
    return this.#props.executor.transformQuery(this.#props.node, this.#props.queryId);
  }
  compile() {
    return this.#props.executor.compileQuery(this.toOperationNode(), this.#props.queryId);
  }
  async execute() {
    await this.#props.executor.executeQuery(this.compile(), this.#props.queryId);
  }
};
preventAwait(DropIndexBuilder, "don't await DropIndexBuilder instances directly. To execute the query you need to call `execute`");

// ../../../node_modules/.pnpm/kysely@0.27.4/node_modules/kysely/dist/esm/schema/drop-schema-builder.js
init_define_ENV_DEFINED_IN_BUILD_STEP();
var DropSchemaBuilder = class _DropSchemaBuilder {
  #props;
  constructor(props) {
    this.#props = freeze(props);
  }
  ifExists() {
    return new _DropSchemaBuilder({
      ...this.#props,
      node: DropSchemaNode.cloneWith(this.#props.node, {
        ifExists: true
      })
    });
  }
  cascade() {
    return new _DropSchemaBuilder({
      ...this.#props,
      node: DropSchemaNode.cloneWith(this.#props.node, {
        cascade: true
      })
    });
  }
  /**
   * Simply calls the provided function passing `this` as the only argument. `$call` returns
   * what the provided function returns.
   */
  $call(func) {
    return func(this);
  }
  toOperationNode() {
    return this.#props.executor.transformQuery(this.#props.node, this.#props.queryId);
  }
  compile() {
    return this.#props.executor.compileQuery(this.toOperationNode(), this.#props.queryId);
  }
  async execute() {
    await this.#props.executor.executeQuery(this.compile(), this.#props.queryId);
  }
};
preventAwait(DropSchemaBuilder, "don't await DropSchemaBuilder instances directly. To execute the query you need to call `execute`");

// ../../../node_modules/.pnpm/kysely@0.27.4/node_modules/kysely/dist/esm/schema/drop-table-builder.js
init_define_ENV_DEFINED_IN_BUILD_STEP();
var DropTableBuilder = class _DropTableBuilder {
  #props;
  constructor(props) {
    this.#props = freeze(props);
  }
  ifExists() {
    return new _DropTableBuilder({
      ...this.#props,
      node: DropTableNode.cloneWith(this.#props.node, {
        ifExists: true
      })
    });
  }
  cascade() {
    return new _DropTableBuilder({
      ...this.#props,
      node: DropTableNode.cloneWith(this.#props.node, {
        cascade: true
      })
    });
  }
  /**
   * Simply calls the provided function passing `this` as the only argument. `$call` returns
   * what the provided function returns.
   */
  $call(func) {
    return func(this);
  }
  toOperationNode() {
    return this.#props.executor.transformQuery(this.#props.node, this.#props.queryId);
  }
  compile() {
    return this.#props.executor.compileQuery(this.toOperationNode(), this.#props.queryId);
  }
  async execute() {
    await this.#props.executor.executeQuery(this.compile(), this.#props.queryId);
  }
};
preventAwait(DropTableBuilder, "don't await DropTableBuilder instances directly. To execute the query you need to call `execute`");

// ../../../node_modules/.pnpm/kysely@0.27.4/node_modules/kysely/dist/esm/schema/create-view-builder.js
init_define_ENV_DEFINED_IN_BUILD_STEP();

// ../../../node_modules/.pnpm/kysely@0.27.4/node_modules/kysely/dist/esm/operation-node/create-view-node.js
init_define_ENV_DEFINED_IN_BUILD_STEP();
var CreateViewNode = freeze({
  is(node) {
    return node.kind === "CreateViewNode";
  },
  create(name) {
    return freeze({
      kind: "CreateViewNode",
      name: SchemableIdentifierNode.create(name)
    });
  },
  cloneWith(createView, params) {
    return freeze({
      ...createView,
      ...params
    });
  }
});

// ../../../node_modules/.pnpm/kysely@0.27.4/node_modules/kysely/dist/esm/plugin/immediate-value/immediate-value-plugin.js
init_define_ENV_DEFINED_IN_BUILD_STEP();
var ImmediateValuePlugin = class {
  #transformer = new ImmediateValueTransformer();
  transformQuery(args) {
    return this.#transformer.transformNode(args.node);
  }
  transformResult(args) {
    return Promise.resolve(args.result);
  }
};

// ../../../node_modules/.pnpm/kysely@0.27.4/node_modules/kysely/dist/esm/schema/create-view-builder.js
var CreateViewBuilder = class _CreateViewBuilder {
  #props;
  constructor(props) {
    this.#props = freeze(props);
  }
  /**
   * Adds the "temporary" modifier.
   *
   * Use this to create a temporary view.
   */
  temporary() {
    return new _CreateViewBuilder({
      ...this.#props,
      node: CreateViewNode.cloneWith(this.#props.node, {
        temporary: true
      })
    });
  }
  materialized() {
    return new _CreateViewBuilder({
      ...this.#props,
      node: CreateViewNode.cloneWith(this.#props.node, {
        materialized: true
      })
    });
  }
  /**
   * Only implemented on some dialects like SQLite. On most dialects, use {@link orReplace}.
   */
  ifNotExists() {
    return new _CreateViewBuilder({
      ...this.#props,
      node: CreateViewNode.cloneWith(this.#props.node, {
        ifNotExists: true
      })
    });
  }
  orReplace() {
    return new _CreateViewBuilder({
      ...this.#props,
      node: CreateViewNode.cloneWith(this.#props.node, {
        orReplace: true
      })
    });
  }
  columns(columns) {
    return new _CreateViewBuilder({
      ...this.#props,
      node: CreateViewNode.cloneWith(this.#props.node, {
        columns: columns.map(parseColumnName)
      })
    });
  }
  /**
   * Sets the select query or a `values` statement that creates the view.
   *
   * WARNING!
   * Some dialects don't support parameterized queries in DDL statements and therefore
   * the query or raw {@link sql } expression passed here is interpolated into a single
   * string opening an SQL injection vulnerability. DO NOT pass unchecked user input
   * into the query or raw expression passed to this method!
   */
  as(query) {
    const queryNode = query.withPlugin(new ImmediateValuePlugin()).toOperationNode();
    return new _CreateViewBuilder({
      ...this.#props,
      node: CreateViewNode.cloneWith(this.#props.node, {
        as: queryNode
      })
    });
  }
  /**
   * Simply calls the provided function passing `this` as the only argument. `$call` returns
   * what the provided function returns.
   */
  $call(func) {
    return func(this);
  }
  toOperationNode() {
    return this.#props.executor.transformQuery(this.#props.node, this.#props.queryId);
  }
  compile() {
    return this.#props.executor.compileQuery(this.toOperationNode(), this.#props.queryId);
  }
  async execute() {
    await this.#props.executor.executeQuery(this.compile(), this.#props.queryId);
  }
};
preventAwait(CreateViewBuilder, "don't await CreateViewBuilder instances directly. To execute the query you need to call `execute`");

// ../../../node_modules/.pnpm/kysely@0.27.4/node_modules/kysely/dist/esm/schema/drop-view-builder.js
init_define_ENV_DEFINED_IN_BUILD_STEP();

// ../../../node_modules/.pnpm/kysely@0.27.4/node_modules/kysely/dist/esm/operation-node/drop-view-node.js
init_define_ENV_DEFINED_IN_BUILD_STEP();
var DropViewNode = freeze({
  is(node) {
    return node.kind === "DropViewNode";
  },
  create(name) {
    return freeze({
      kind: "DropViewNode",
      name: SchemableIdentifierNode.create(name)
    });
  },
  cloneWith(dropView, params) {
    return freeze({
      ...dropView,
      ...params
    });
  }
});

// ../../../node_modules/.pnpm/kysely@0.27.4/node_modules/kysely/dist/esm/schema/drop-view-builder.js
var DropViewBuilder = class _DropViewBuilder {
  #props;
  constructor(props) {
    this.#props = freeze(props);
  }
  materialized() {
    return new _DropViewBuilder({
      ...this.#props,
      node: DropViewNode.cloneWith(this.#props.node, {
        materialized: true
      })
    });
  }
  ifExists() {
    return new _DropViewBuilder({
      ...this.#props,
      node: DropViewNode.cloneWith(this.#props.node, {
        ifExists: true
      })
    });
  }
  cascade() {
    return new _DropViewBuilder({
      ...this.#props,
      node: DropViewNode.cloneWith(this.#props.node, {
        cascade: true
      })
    });
  }
  /**
   * Simply calls the provided function passing `this` as the only argument. `$call` returns
   * what the provided function returns.
   */
  $call(func) {
    return func(this);
  }
  toOperationNode() {
    return this.#props.executor.transformQuery(this.#props.node, this.#props.queryId);
  }
  compile() {
    return this.#props.executor.compileQuery(this.toOperationNode(), this.#props.queryId);
  }
  async execute() {
    await this.#props.executor.executeQuery(this.compile(), this.#props.queryId);
  }
};
preventAwait(DropViewBuilder, "don't await DropViewBuilder instances directly. To execute the query you need to call `execute`");

// ../../../node_modules/.pnpm/kysely@0.27.4/node_modules/kysely/dist/esm/schema/create-type-builder.js
init_define_ENV_DEFINED_IN_BUILD_STEP();

// ../../../node_modules/.pnpm/kysely@0.27.4/node_modules/kysely/dist/esm/operation-node/create-type-node.js
init_define_ENV_DEFINED_IN_BUILD_STEP();
var CreateTypeNode = freeze({
  is(node) {
    return node.kind === "CreateTypeNode";
  },
  create(name) {
    return freeze({
      kind: "CreateTypeNode",
      name
    });
  },
  cloneWithEnum(createType, values) {
    return freeze({
      ...createType,
      enum: ValueListNode.create(values.map((value) => ValueNode.createImmediate(value)))
    });
  }
});

// ../../../node_modules/.pnpm/kysely@0.27.4/node_modules/kysely/dist/esm/schema/create-type-builder.js
var CreateTypeBuilder = class _CreateTypeBuilder {
  #props;
  constructor(props) {
    this.#props = freeze(props);
  }
  toOperationNode() {
    return this.#props.executor.transformQuery(this.#props.node, this.#props.queryId);
  }
  /**
   * Creates an anum type.
   *
   * ### Examples
   *
   * ```ts
   * db.schema.createType('species').asEnum(['cat', 'dog', 'frog'])
   * ```
   */
  asEnum(values) {
    return new _CreateTypeBuilder({
      ...this.#props,
      node: CreateTypeNode.cloneWithEnum(this.#props.node, values)
    });
  }
  /**
   * Simply calls the provided function passing `this` as the only argument. `$call` returns
   * what the provided function returns.
   */
  $call(func) {
    return func(this);
  }
  compile() {
    return this.#props.executor.compileQuery(this.toOperationNode(), this.#props.queryId);
  }
  async execute() {
    await this.#props.executor.executeQuery(this.compile(), this.#props.queryId);
  }
};
preventAwait(CreateTypeBuilder, "don't await CreateTypeBuilder instances directly. To execute the query you need to call `execute`");

// ../../../node_modules/.pnpm/kysely@0.27.4/node_modules/kysely/dist/esm/schema/drop-type-builder.js
init_define_ENV_DEFINED_IN_BUILD_STEP();

// ../../../node_modules/.pnpm/kysely@0.27.4/node_modules/kysely/dist/esm/operation-node/drop-type-node.js
init_define_ENV_DEFINED_IN_BUILD_STEP();
var DropTypeNode = freeze({
  is(node) {
    return node.kind === "DropTypeNode";
  },
  create(name) {
    return freeze({
      kind: "DropTypeNode",
      name
    });
  },
  cloneWith(dropType, params) {
    return freeze({
      ...dropType,
      ...params
    });
  }
});

// ../../../node_modules/.pnpm/kysely@0.27.4/node_modules/kysely/dist/esm/schema/drop-type-builder.js
var DropTypeBuilder = class _DropTypeBuilder {
  #props;
  constructor(props) {
    this.#props = freeze(props);
  }
  ifExists() {
    return new _DropTypeBuilder({
      ...this.#props,
      node: DropTypeNode.cloneWith(this.#props.node, {
        ifExists: true
      })
    });
  }
  /**
   * Simply calls the provided function passing `this` as the only argument. `$call` returns
   * what the provided function returns.
   */
  $call(func) {
    return func(this);
  }
  toOperationNode() {
    return this.#props.executor.transformQuery(this.#props.node, this.#props.queryId);
  }
  compile() {
    return this.#props.executor.compileQuery(this.toOperationNode(), this.#props.queryId);
  }
  async execute() {
    await this.#props.executor.executeQuery(this.compile(), this.#props.queryId);
  }
};
preventAwait(DropTypeBuilder, "don't await DropTypeBuilder instances directly. To execute the query you need to call `execute`");

// ../../../node_modules/.pnpm/kysely@0.27.4/node_modules/kysely/dist/esm/parser/identifier-parser.js
init_define_ENV_DEFINED_IN_BUILD_STEP();
function parseSchemableIdentifier(id) {
  const SCHEMA_SEPARATOR = ".";
  if (id.includes(SCHEMA_SEPARATOR)) {
    const parts = id.split(SCHEMA_SEPARATOR).map(trim3);
    if (parts.length === 2) {
      return SchemableIdentifierNode.createWithSchema(parts[0], parts[1]);
    } else {
      throw new Error(`invalid schemable identifier ${id}`);
    }
  } else {
    return SchemableIdentifierNode.create(id);
  }
}
function trim3(str) {
  return str.trim();
}

// ../../../node_modules/.pnpm/kysely@0.27.4/node_modules/kysely/dist/esm/schema/schema.js
var SchemaModule = class _SchemaModule {
  #executor;
  constructor(executor) {
    this.#executor = executor;
  }
  /**
   * Create a new table.
   *
   * ### Examples
   *
   * This example creates a new table with columns `id`, `first_name`,
   * `last_name` and `gender`:
   *
   * ```ts
   * await db.schema
   *   .createTable('person')
   *   .addColumn('id', 'integer', col => col.primaryKey().autoIncrement())
   *   .addColumn('first_name', 'varchar', col => col.notNull())
   *   .addColumn('last_name', 'varchar', col => col.notNull())
   *   .addColumn('gender', 'varchar')
   *   .execute()
   * ```
   *
   * This example creates a table with a foreign key. Not all database
   * engines support column-level foreign key constraint definitions.
   * For example if you are using MySQL 5.X see the next example after
   * this one.
   *
   * ```ts
   * await db.schema
   *   .createTable('pet')
   *   .addColumn('id', 'integer', col => col.primaryKey().autoIncrement())
   *   .addColumn('owner_id', 'integer', col => col
   *     .references('person.id')
   *     .onDelete('cascade')
   *   )
   *   .execute()
   * ```
   *
   * This example adds a foreign key constraint for a columns just
   * like the previous example, but using a table-level statement.
   * On MySQL 5.X you need to define foreign key constraints like
   * this:
   *
   * ```ts
   * await db.schema
   *   .createTable('pet')
   *   .addColumn('id', 'integer', col => col.primaryKey().autoIncrement())
   *   .addColumn('owner_id', 'integer')
   *   .addForeignKeyConstraint(
   *     'pet_owner_id_foreign', ['owner_id'], 'person', ['id'],
   *     (constraint) => constraint.onDelete('cascade')
   *   )
   *   .execute()
   * ```
   */
  createTable(table) {
    return new CreateTableBuilder({
      queryId: createQueryId(),
      executor: this.#executor,
      node: CreateTableNode.create(parseTable(table))
    });
  }
  /**
   * Drop a table.
   *
   * ### Examples
   *
   * ```ts
   * await db.schema
   *   .dropTable('person')
   *   .execute()
   * ```
   */
  dropTable(table) {
    return new DropTableBuilder({
      queryId: createQueryId(),
      executor: this.#executor,
      node: DropTableNode.create(parseTable(table))
    });
  }
  /**
   * Create a new index.
   *
   * ### Examples
   *
   * ```ts
   * await db.schema
   *   .createIndex('person_full_name_unique_index')
   *   .on('person')
   *   .columns(['first_name', 'last_name'])
   *   .execute()
   * ```
   */
  createIndex(indexName) {
    return new CreateIndexBuilder({
      queryId: createQueryId(),
      executor: this.#executor,
      node: CreateIndexNode.create(indexName)
    });
  }
  /**
   * Drop an index.
   *
   * ### Examples
   *
   * ```ts
   * await db.schema
   *   .dropIndex('person_full_name_unique_index')
   *   .execute()
   * ```
   */
  dropIndex(indexName) {
    return new DropIndexBuilder({
      queryId: createQueryId(),
      executor: this.#executor,
      node: DropIndexNode.create(indexName)
    });
  }
  /**
   * Create a new schema.
   *
   * ### Examples
   *
   * ```ts
   * await db.schema
   *   .createSchema('some_schema')
   *   .execute()
   * ```
   */
  createSchema(schema) {
    return new CreateSchemaBuilder({
      queryId: createQueryId(),
      executor: this.#executor,
      node: CreateSchemaNode.create(schema)
    });
  }
  /**
   * Drop a schema.
   *
   * ### Examples
   *
   * ```ts
   * await db.schema
   *   .dropSchema('some_schema')
   *   .execute()
   * ```
   */
  dropSchema(schema) {
    return new DropSchemaBuilder({
      queryId: createQueryId(),
      executor: this.#executor,
      node: DropSchemaNode.create(schema)
    });
  }
  /**
   * Alter a table.
   *
   * ### Examples
   *
   * ```ts
   * await db.schema
   *   .alterTable('person')
   *   .alterColumn('first_name', (ac) => ac.setDataType('text'))
   *   .execute()
   * ```
   */
  alterTable(table) {
    return new AlterTableBuilder({
      queryId: createQueryId(),
      executor: this.#executor,
      node: AlterTableNode.create(parseTable(table))
    });
  }
  /**
   * Create a new view.
   *
   * ### Examples
   *
   * ```ts
   * await db.schema
   *   .createView('dogs')
   *   .orReplace()
   *   .as(db.selectFrom('pet').selectAll().where('species', '=', 'dog'))
   *   .execute()
   * ```
   */
  createView(viewName) {
    return new CreateViewBuilder({
      queryId: createQueryId(),
      executor: this.#executor,
      node: CreateViewNode.create(viewName)
    });
  }
  /**
   * Drop a view.
   *
   * ### Examples
   *
   * ```ts
   * await db.schema
   *   .dropView('dogs')
   *   .ifExists()
   *   .execute()
   * ```
   */
  dropView(viewName) {
    return new DropViewBuilder({
      queryId: createQueryId(),
      executor: this.#executor,
      node: DropViewNode.create(viewName)
    });
  }
  /**
   * Create a new type.
   *
   * Only some dialects like PostgreSQL have user-defined types.
   *
   * ### Examples
   *
   * ```ts
   * await db.schema
   *   .createType('species')
   *   .asEnum(['dog', 'cat', 'frog'])
   *   .execute()
   * ```
   */
  createType(typeName) {
    return new CreateTypeBuilder({
      queryId: createQueryId(),
      executor: this.#executor,
      node: CreateTypeNode.create(parseSchemableIdentifier(typeName))
    });
  }
  /**
   * Drop a type.
   *
   * Only some dialects like PostgreSQL have user-defined types.
   *
   * ### Examples
   *
   * ```ts
   * await db.schema
   *   .dropType('species')
   *   .ifExists()
   *   .execute()
   * ```
   */
  dropType(typeName) {
    return new DropTypeBuilder({
      queryId: createQueryId(),
      executor: this.#executor,
      node: DropTypeNode.create(parseSchemableIdentifier(typeName))
    });
  }
  /**
   * Returns a copy of this schema module with the given plugin installed.
   */
  withPlugin(plugin2) {
    return new _SchemaModule(this.#executor.withPlugin(plugin2));
  }
  /**
   * Returns a copy of this schema module  without any plugins.
   */
  withoutPlugins() {
    return new _SchemaModule(this.#executor.withoutPlugins());
  }
  /**
   * See {@link QueryCreator.withSchema}
   */
  withSchema(schema) {
    return new _SchemaModule(this.#executor.withPluginAtFront(new WithSchemaPlugin(schema)));
  }
};

// ../../../node_modules/.pnpm/kysely@0.27.4/node_modules/kysely/dist/esm/dynamic/dynamic.js
init_define_ENV_DEFINED_IN_BUILD_STEP();
var DynamicModule = class {
  /**
   * Creates a dynamic reference to a column that is not know at compile time.
   *
   * Kysely is built in a way that by default you can't refer to tables or columns
   * that are not actually visible in the current query and context. This is all
   * done by TypeScript at compile time, which means that you need to know the
   * columns and tables at compile time. This is not always the case of course.
   *
   * This method is meant to be used in those cases where the column names
   * come from the user input or are not otherwise known at compile time.
   *
   * WARNING! Unlike values, column names are not escaped by the database engine
   * or Kysely and if you pass in unchecked column names using this method, you
   * create an SQL injection vulnerability. Always __always__ validate the user
   * input before passing it to this method.
   *
   * There are couple of examples below for some use cases, but you can pass
   * `ref` to other methods as well. If the types allow you to pass a `ref`
   * value to some place, it should work.
   *
   * ### Examples
   *
   * Filter by a column not know at compile time:
   *
   * ```ts
   * async function someQuery(filterColumn: string, filterValue: string) {
   *   const { ref } = db.dynamic
   *
   *   return await db
   *     .selectFrom('person')
   *     .selectAll()
   *     .where(ref(filterColumn), '=', filterValue)
   *     .execute()
   * }
   *
   * someQuery('first_name', 'Arnold')
   * someQuery('person.last_name', 'Aniston')
   * ```
   *
   * Order by a column not know at compile time:
   *
   * ```ts
   * async function someQuery(orderBy: string) {
   *   const { ref } = db.dynamic
   *
   *   return await db
   *     .selectFrom('person')
   *     .select('person.first_name as fn')
   *     .orderBy(ref(orderBy))
   *     .execute()
   * }
   *
   * someQuery('fn')
   * ```
   *
   * In this example we add selections dynamically:
   *
   * ```ts
   * const { ref } = db.dynamic
   *
   * // Some column name provided by the user. Value not known at compile time.
   * const columnFromUserInput = req.query.select;
   *
   * // A type that lists all possible values `columnFromUserInput` can have.
   * // You can use `keyof Person` if any column of an interface is allowed.
   * type PossibleColumns = 'last_name' | 'first_name' | 'birth_date'
   *
   * const [person] = await db.selectFrom('person')
   *   .select([
   *     ref<PossibleColumns>(columnFromUserInput),
   *     'id'
   *   ])
   *   .execute()
   *
   * // The resulting type contains all `PossibleColumns` as optional fields
   * // because we cannot know which field was actually selected before
   * // running the code.
   * const lastName: string | undefined = person.last_name
   * const firstName: string | undefined = person.first_name
   * const birthDate: string | undefined = person.birth_date
   *
   * // The result type also contains the compile time selection `id`.
   * person.id
   * ```
   */
  ref(reference) {
    return new DynamicReferenceBuilder(reference);
  }
};

// ../../../node_modules/.pnpm/kysely@0.27.4/node_modules/kysely/dist/esm/driver/default-connection-provider.js
init_define_ENV_DEFINED_IN_BUILD_STEP();
var DefaultConnectionProvider = class {
  #driver;
  constructor(driver) {
    this.#driver = driver;
  }
  async provideConnection(consumer) {
    const connection = await this.#driver.acquireConnection();
    try {
      return await consumer(connection);
    } finally {
      await this.#driver.releaseConnection(connection);
    }
  }
};

// ../../../node_modules/.pnpm/kysely@0.27.4/node_modules/kysely/dist/esm/query-executor/default-query-executor.js
init_define_ENV_DEFINED_IN_BUILD_STEP();
var DefaultQueryExecutor = class _DefaultQueryExecutor extends QueryExecutorBase {
  #compiler;
  #adapter;
  #connectionProvider;
  constructor(compiler, adapter, connectionProvider, plugins = []) {
    super(plugins);
    this.#compiler = compiler;
    this.#adapter = adapter;
    this.#connectionProvider = connectionProvider;
  }
  get adapter() {
    return this.#adapter;
  }
  compileQuery(node) {
    return this.#compiler.compileQuery(node);
  }
  provideConnection(consumer) {
    return this.#connectionProvider.provideConnection(consumer);
  }
  withPlugins(plugins) {
    return new _DefaultQueryExecutor(this.#compiler, this.#adapter, this.#connectionProvider, [...this.plugins, ...plugins]);
  }
  withPlugin(plugin2) {
    return new _DefaultQueryExecutor(this.#compiler, this.#adapter, this.#connectionProvider, [...this.plugins, plugin2]);
  }
  withPluginAtFront(plugin2) {
    return new _DefaultQueryExecutor(this.#compiler, this.#adapter, this.#connectionProvider, [plugin2, ...this.plugins]);
  }
  withConnectionProvider(connectionProvider) {
    return new _DefaultQueryExecutor(this.#compiler, this.#adapter, connectionProvider, [...this.plugins]);
  }
  withoutPlugins() {
    return new _DefaultQueryExecutor(this.#compiler, this.#adapter, this.#connectionProvider, []);
  }
};

// ../../../node_modules/.pnpm/kysely@0.27.4/node_modules/kysely/dist/esm/driver/runtime-driver.js
init_define_ENV_DEFINED_IN_BUILD_STEP();

// ../../../node_modules/.pnpm/kysely@0.27.4/node_modules/kysely/dist/esm/util/performance-now.js
init_define_ENV_DEFINED_IN_BUILD_STEP();
function performanceNow() {
  if (typeof performance !== "undefined" && isFunction(performance.now)) {
    return performance.now();
  } else {
    return Date.now();
  }
}

// ../../../node_modules/.pnpm/kysely@0.27.4/node_modules/kysely/dist/esm/driver/runtime-driver.js
var RuntimeDriver = class {
  #driver;
  #log;
  #initPromise;
  #initDone;
  #destroyPromise;
  #connections = /* @__PURE__ */ new WeakSet();
  constructor(driver, log2) {
    this.#initDone = false;
    this.#driver = driver;
    this.#log = log2;
  }
  async init() {
    if (this.#destroyPromise) {
      throw new Error("driver has already been destroyed");
    }
    if (!this.#initPromise) {
      this.#initPromise = this.#driver.init().then(() => {
        this.#initDone = true;
      }).catch((err) => {
        this.#initPromise = void 0;
        return Promise.reject(err);
      });
    }
    await this.#initPromise;
  }
  async acquireConnection() {
    if (this.#destroyPromise) {
      throw new Error("driver has already been destroyed");
    }
    if (!this.#initDone) {
      await this.init();
    }
    const connection = await this.#driver.acquireConnection();
    if (!this.#connections.has(connection)) {
      if (this.#needsLogging()) {
        this.#addLogging(connection);
      }
      this.#connections.add(connection);
    }
    return connection;
  }
  async releaseConnection(connection) {
    await this.#driver.releaseConnection(connection);
  }
  beginTransaction(connection, settings) {
    return this.#driver.beginTransaction(connection, settings);
  }
  commitTransaction(connection) {
    return this.#driver.commitTransaction(connection);
  }
  rollbackTransaction(connection) {
    return this.#driver.rollbackTransaction(connection);
  }
  async destroy() {
    if (!this.#initPromise) {
      return;
    }
    await this.#initPromise;
    if (!this.#destroyPromise) {
      this.#destroyPromise = this.#driver.destroy().catch((err) => {
        this.#destroyPromise = void 0;
        return Promise.reject(err);
      });
    }
    await this.#destroyPromise;
  }
  #needsLogging() {
    return this.#log.isLevelEnabled("query") || this.#log.isLevelEnabled("error");
  }
  // This method monkey patches the database connection's executeQuery method
  // by adding logging code around it. Monkey patching is not pretty, but it's
  // the best option in this case.
  #addLogging(connection) {
    const executeQuery = connection.executeQuery;
    connection.executeQuery = async (compiledQuery) => {
      let caughtError;
      const startTime = performanceNow();
      try {
        return await executeQuery.call(connection, compiledQuery);
      } catch (error) {
        caughtError = error;
        await this.#logError(error, compiledQuery, startTime);
        throw error;
      } finally {
        if (!caughtError) {
          await this.#logQuery(compiledQuery, startTime);
        }
      }
    };
  }
  async #logError(error, compiledQuery, startTime) {
    await this.#log.error(() => ({
      level: "error",
      error,
      query: compiledQuery,
      queryDurationMillis: this.#calculateDurationMillis(startTime)
    }));
  }
  async #logQuery(compiledQuery, startTime) {
    await this.#log.query(() => ({
      level: "query",
      query: compiledQuery,
      queryDurationMillis: this.#calculateDurationMillis(startTime)
    }));
  }
  #calculateDurationMillis(startTime) {
    return performanceNow() - startTime;
  }
};

// ../../../node_modules/.pnpm/kysely@0.27.4/node_modules/kysely/dist/esm/driver/single-connection-provider.js
init_define_ENV_DEFINED_IN_BUILD_STEP();
var ignoreError = () => {
};
var SingleConnectionProvider = class {
  #connection;
  #runningPromise;
  constructor(connection) {
    this.#connection = connection;
  }
  async provideConnection(consumer) {
    while (this.#runningPromise) {
      await this.#runningPromise.catch(ignoreError);
    }
    this.#runningPromise = this.#run(consumer).finally(() => {
      this.#runningPromise = void 0;
    });
    return this.#runningPromise;
  }
  // Run the runner in an async function to make sure it doesn't
  // throw synchronous errors.
  async #run(runner) {
    return await runner(this.#connection);
  }
};

// ../../../node_modules/.pnpm/kysely@0.27.4/node_modules/kysely/dist/esm/driver/driver.js
init_define_ENV_DEFINED_IN_BUILD_STEP();
var TRANSACTION_ISOLATION_LEVELS = [
  "read uncommitted",
  "read committed",
  "repeatable read",
  "serializable",
  "snapshot"
];

// ../../../node_modules/.pnpm/kysely@0.27.4/node_modules/kysely/dist/esm/util/log.js
init_define_ENV_DEFINED_IN_BUILD_STEP();
var LOG_LEVELS = freeze(["query", "error"]);
var Log = class {
  #levels;
  #logger;
  constructor(config) {
    if (isFunction(config)) {
      this.#logger = config;
      this.#levels = freeze({
        query: true,
        error: true
      });
    } else {
      this.#logger = defaultLogger;
      this.#levels = freeze({
        query: config.includes("query"),
        error: config.includes("error")
      });
    }
  }
  isLevelEnabled(level) {
    return this.#levels[level];
  }
  async query(getEvent) {
    if (this.#levels.query) {
      await this.#logger(getEvent());
    }
  }
  async error(getEvent) {
    if (this.#levels.error) {
      await this.#logger(getEvent());
    }
  }
};
function defaultLogger(event) {
  if (event.level === "query") {
    console.log(`kysely:query: ${event.query.sql}`);
    console.log(`kysely:query: duration: ${event.queryDurationMillis.toFixed(1)}ms`);
  } else if (event.level === "error") {
    if (event.error instanceof Error) {
      console.error(`kysely:error: ${event.error.stack ?? event.error.message}`);
    } else {
      console.error(`kysely:error: ${JSON.stringify({
        error: event.error,
        query: event.query.sql,
        queryDurationMillis: event.queryDurationMillis
      })}`);
    }
  }
}

// ../../../node_modules/.pnpm/kysely@0.27.4/node_modules/kysely/dist/esm/util/compilable.js
init_define_ENV_DEFINED_IN_BUILD_STEP();
function isCompilable(value) {
  return isObject(value) && isFunction(value.compile);
}

// ../../../node_modules/.pnpm/kysely@0.27.4/node_modules/kysely/dist/esm/kysely.js
var Kysely = class _Kysely extends QueryCreator {
  #props;
  constructor(args) {
    let superProps;
    let props;
    if (isKyselyProps(args)) {
      superProps = { executor: args.executor };
      props = { ...args };
    } else {
      const dialect = args.dialect;
      const driver = dialect.createDriver();
      const compiler = dialect.createQueryCompiler();
      const adapter = dialect.createAdapter();
      const log2 = new Log(args.log ?? []);
      const runtimeDriver = new RuntimeDriver(driver, log2);
      const connectionProvider = new DefaultConnectionProvider(runtimeDriver);
      const executor = new DefaultQueryExecutor(compiler, adapter, connectionProvider, args.plugins ?? []);
      superProps = { executor };
      props = {
        config: args,
        executor,
        dialect,
        driver: runtimeDriver
      };
    }
    super(superProps);
    this.#props = freeze(props);
  }
  /**
   * Returns the {@link SchemaModule} module for building database schema.
   */
  get schema() {
    return new SchemaModule(this.#props.executor);
  }
  /**
   * Returns a the {@link DynamicModule} module.
   *
   * The {@link DynamicModule} module can be used to bypass strict typing and
   * passing in dynamic values for the queries.
   */
  get dynamic() {
    return new DynamicModule();
  }
  /**
   * Returns a {@link DatabaseIntrospector | database introspector}.
   */
  get introspection() {
    return this.#props.dialect.createIntrospector(this.withoutPlugins());
  }
  case(value) {
    return new CaseBuilder({
      node: CaseNode.create(isUndefined(value) ? void 0 : parseExpression(value))
    });
  }
  /**
   * Returns a {@link FunctionModule} that can be used to write type safe function
   * calls.
   *
   * ```ts
   * await db.selectFrom('person')
   *   .innerJoin('pet', 'pet.owner_id', 'person.id')
   *   .select((eb) => [
   *     'person.id',
   *     eb.fn.count('pet.id').as('pet_count')
   *   ])
   *   .groupBy('person.id')
   *   .having((eb) => eb.fn.count('pet.id'), '>', 10)
   *   .execute()
   * ```
   *
   * The generated SQL (PostgreSQL):
   *
   * ```sql
   * select "person"."id", count("pet"."id") as "pet_count"
   * from "person"
   * inner join "pet" on "pet"."owner_id" = "person"."id"
   * group by "person"."id"
   * having count("pet"."id") > $1
   * ```
   */
  get fn() {
    return createFunctionModule();
  }
  /**
   * Creates a {@link TransactionBuilder} that can be used to run queries inside a transaction.
   *
   * The returned {@link TransactionBuilder} can be used to configure the transaction. The
   * {@link TransactionBuilder.execute} method can then be called to run the transaction.
   * {@link TransactionBuilder.execute} takes a function that is run inside the
   * transaction. If the function throws, the transaction is rolled back. Otherwise
   * the transaction is committed.
   *
   * The callback function passed to the {@link TransactionBuilder.execute | execute}
   * method gets the transaction object as its only argument. The transaction is
   * of type {@link Transaction} which inherits {@link Kysely}. Any query
   * started through the transaction object is executed inside the transaction.
   *
   * ### Examples
   *
   * <!-- siteExample("transactions", "Simple transaction", 10) -->
   *
   * This example inserts two rows in a transaction. If an error is thrown inside
   * the callback passed to the `execute` method, the transaction is rolled back.
   * Otherwise it's committed.
   *
   * ```ts
   * const catto = await db.transaction().execute(async (trx) => {
   *   const jennifer = await trx.insertInto('person')
   *     .values({
   *       first_name: 'Jennifer',
   *       last_name: 'Aniston',
   *       age: 40,
   *     })
   *     .returning('id')
   *     .executeTakeFirstOrThrow()
   *
   *   return await trx.insertInto('pet')
   *     .values({
   *       owner_id: jennifer.id,
   *       name: 'Catto',
   *       species: 'cat',
   *       is_favorite: false,
   *     })
   *     .returningAll()
   *     .executeTakeFirst()
   * })
   * ```
   *
   * Setting the isolation level:
   *
   * ```ts
   * await db
   *   .transaction()
   *   .setIsolationLevel('serializable')
   *   .execute(async (trx) => {
   *     await doStuff(trx)
   *   })
   * ```
   */
  transaction() {
    return new TransactionBuilder({ ...this.#props });
  }
  /**
   * Provides a kysely instance bound to a single database connection.
   *
   * ### Examples
   *
   * ```ts
   * await db
   *   .connection()
   *   .execute(async (db) => {
   *     // `db` is an instance of `Kysely` that's bound to a single
   *     // database connection. All queries executed through `db` use
   *     // the same connection.
   *     await doStuff(db)
   *   })
   * ```
   */
  connection() {
    return new ConnectionBuilder({ ...this.#props });
  }
  /**
   * Returns a copy of this Kysely instance with the given plugin installed.
   */
  withPlugin(plugin2) {
    return new _Kysely({
      ...this.#props,
      executor: this.#props.executor.withPlugin(plugin2)
    });
  }
  /**
   * Returns a copy of this Kysely instance without any plugins.
   */
  withoutPlugins() {
    return new _Kysely({
      ...this.#props,
      executor: this.#props.executor.withoutPlugins()
    });
  }
  /**
   * @override
   */
  withSchema(schema) {
    return new _Kysely({
      ...this.#props,
      executor: this.#props.executor.withPluginAtFront(new WithSchemaPlugin(schema))
    });
  }
  /**
   * Returns a copy of this Kysely instance with tables added to its
   * database type.
   *
   * This method only modifies the types and doesn't affect any of the
   * executed queries in any way.
   *
   * ### Examples
   *
   * The following example adds and uses a temporary table:
   *
   * @example
   * ```ts
   * await db.schema
   *   .createTable('temp_table')
   *   .temporary()
   *   .addColumn('some_column', 'integer')
   *   .execute()
   *
   * const tempDb = db.withTables<{
   *   temp_table: {
   *     some_column: number
   *   }
   * }>()
   *
   * await tempDb
   *   .insertInto('temp_table')
   *   .values({ some_column: 100 })
   *   .execute()
   * ```
   */
  withTables() {
    return new _Kysely({ ...this.#props });
  }
  /**
   * Releases all resources and disconnects from the database.
   *
   * You need to call this when you are done using the `Kysely` instance.
   */
  async destroy() {
    await this.#props.driver.destroy();
  }
  /**
   * Returns true if this `Kysely` instance is a transaction.
   *
   * You can also use `db instanceof Transaction`.
   */
  get isTransaction() {
    return false;
  }
  /**
   * @internal
   * @private
   */
  getExecutor() {
    return this.#props.executor;
  }
  /**
   * Executes a given compiled query or query builder.
   *
   * See {@link https://github.com/koskimas/kysely/blob/master/site/docs/recipes/splitting-build-compile-and-execute-code.md#execute-compiled-queries splitting build, compile and execute code recipe} for more information.
   */
  executeQuery(query, queryId = createQueryId()) {
    const compiledQuery = isCompilable(query) ? query.compile() : query;
    return this.getExecutor().executeQuery(compiledQuery, queryId);
  }
};
var Transaction = class _Transaction extends Kysely {
  #props;
  constructor(props) {
    super(props);
    this.#props = props;
  }
  // The return type is `true` instead of `boolean` to make Kysely<DB>
  // unassignable to Transaction<DB> while allowing assignment the
  // other way around.
  get isTransaction() {
    return true;
  }
  transaction() {
    throw new Error("calling the transaction method for a Transaction is not supported");
  }
  connection() {
    throw new Error("calling the connection method for a Transaction is not supported");
  }
  async destroy() {
    throw new Error("calling the destroy method for a Transaction is not supported");
  }
  withPlugin(plugin2) {
    return new _Transaction({
      ...this.#props,
      executor: this.#props.executor.withPlugin(plugin2)
    });
  }
  withoutPlugins() {
    return new _Transaction({
      ...this.#props,
      executor: this.#props.executor.withoutPlugins()
    });
  }
  /**
   * @override
   */
  withSchema(schema) {
    return new _Transaction({
      ...this.#props,
      executor: this.#props.executor.withPluginAtFront(new WithSchemaPlugin(schema))
    });
  }
  withTables() {
    return new _Transaction({ ...this.#props });
  }
};
function isKyselyProps(obj) {
  return isObject(obj) && isObject(obj.config) && isObject(obj.driver) && isObject(obj.executor) && isObject(obj.dialect);
}
var ConnectionBuilder = class {
  #props;
  constructor(props) {
    this.#props = freeze(props);
  }
  async execute(callback) {
    return this.#props.executor.provideConnection(async (connection) => {
      const executor = this.#props.executor.withConnectionProvider(new SingleConnectionProvider(connection));
      const db = new Kysely({
        ...this.#props,
        executor
      });
      return await callback(db);
    });
  }
};
preventAwait(ConnectionBuilder, "don't await ConnectionBuilder instances directly. To execute the query you need to call the `execute` method");
var TransactionBuilder = class _TransactionBuilder {
  #props;
  constructor(props) {
    this.#props = freeze(props);
  }
  setIsolationLevel(isolationLevel) {
    return new _TransactionBuilder({
      ...this.#props,
      isolationLevel
    });
  }
  async execute(callback) {
    const { isolationLevel, ...kyselyProps } = this.#props;
    const settings = { isolationLevel };
    validateTransactionSettings(settings);
    return this.#props.executor.provideConnection(async (connection) => {
      const executor = this.#props.executor.withConnectionProvider(new SingleConnectionProvider(connection));
      const transaction = new Transaction({
        ...kyselyProps,
        executor
      });
      try {
        await this.#props.driver.beginTransaction(connection, settings);
        const result = await callback(transaction);
        await this.#props.driver.commitTransaction(connection);
        return result;
      } catch (error) {
        await this.#props.driver.rollbackTransaction(connection);
        throw error;
      }
    });
  }
};
preventAwait(TransactionBuilder, "don't await TransactionBuilder instances directly. To execute the transaction you need to call the `execute` method");
function validateTransactionSettings(settings) {
  if (settings.isolationLevel && !TRANSACTION_ISOLATION_LEVELS.includes(settings.isolationLevel)) {
    throw new Error(`invalid transaction isolation level ${settings.isolationLevel}`);
  }
}

// ../../../node_modules/.pnpm/kysely@0.27.4/node_modules/kysely/dist/esm/raw-builder/raw-builder.js
init_define_ENV_DEFINED_IN_BUILD_STEP();
var RawBuilderImpl = class _RawBuilderImpl {
  #props;
  constructor(props) {
    this.#props = freeze(props);
  }
  get expressionType() {
    return void 0;
  }
  get isRawBuilder() {
    return true;
  }
  as(alias) {
    return new AliasedRawBuilderImpl(this, alias);
  }
  $castTo() {
    return new _RawBuilderImpl({ ...this.#props });
  }
  $notNull() {
    return new _RawBuilderImpl(this.#props);
  }
  withPlugin(plugin2) {
    return new _RawBuilderImpl({
      ...this.#props,
      plugins: this.#props.plugins !== void 0 ? freeze([...this.#props.plugins, plugin2]) : freeze([plugin2])
    });
  }
  toOperationNode() {
    return this.#toOperationNode(this.#getExecutor());
  }
  compile(executorProvider) {
    return this.#compile(this.#getExecutor(executorProvider));
  }
  async execute(executorProvider) {
    const executor = this.#getExecutor(executorProvider);
    return executor.executeQuery(this.#compile(executor), this.#props.queryId);
  }
  #getExecutor(executorProvider) {
    const executor = executorProvider !== void 0 ? executorProvider.getExecutor() : NOOP_QUERY_EXECUTOR;
    return this.#props.plugins !== void 0 ? executor.withPlugins(this.#props.plugins) : executor;
  }
  #toOperationNode(executor) {
    return executor.transformQuery(this.#props.rawNode, this.#props.queryId);
  }
  #compile(executor) {
    return executor.compileQuery(this.#toOperationNode(executor), this.#props.queryId);
  }
};
function createRawBuilder(props) {
  return new RawBuilderImpl(props);
}
preventAwait(RawBuilderImpl, "don't await RawBuilder instances directly. To execute the query you need to call `execute`");
var AliasedRawBuilderImpl = class {
  #rawBuilder;
  #alias;
  constructor(rawBuilder, alias) {
    this.#rawBuilder = rawBuilder;
    this.#alias = alias;
  }
  get expression() {
    return this.#rawBuilder;
  }
  get alias() {
    return this.#alias;
  }
  get rawBuilder() {
    return this.#rawBuilder;
  }
  toOperationNode() {
    return AliasNode.create(this.#rawBuilder.toOperationNode(), isOperationNodeSource(this.#alias) ? this.#alias.toOperationNode() : IdentifierNode.create(this.#alias));
  }
};
preventAwait(AliasedRawBuilderImpl, "don't await AliasedRawBuilder instances directly. AliasedRawBuilder should never be executed directly since it's always a part of another query.");

// ../../../node_modules/.pnpm/kysely@0.27.4/node_modules/kysely/dist/esm/raw-builder/sql.js
init_define_ENV_DEFINED_IN_BUILD_STEP();
var sql = Object.assign((sqlFragments, ...parameters) => {
  return createRawBuilder({
    queryId: createQueryId(),
    rawNode: RawNode.create(sqlFragments, (parameters == null ? void 0 : parameters.map(parseParameter)) ?? [])
  });
}, {
  ref(columnReference) {
    return createRawBuilder({
      queryId: createQueryId(),
      rawNode: RawNode.createWithChild(parseStringReference(columnReference))
    });
  },
  val(value) {
    return createRawBuilder({
      queryId: createQueryId(),
      rawNode: RawNode.createWithChild(parseValueExpression(value))
    });
  },
  value(value) {
    return this.val(value);
  },
  table(tableReference) {
    return createRawBuilder({
      queryId: createQueryId(),
      rawNode: RawNode.createWithChild(parseTable(tableReference))
    });
  },
  id(...ids) {
    const fragments = new Array(ids.length + 1).fill(".");
    fragments[0] = "";
    fragments[fragments.length - 1] = "";
    return createRawBuilder({
      queryId: createQueryId(),
      rawNode: RawNode.create(fragments, ids.map(IdentifierNode.create))
    });
  },
  lit(value) {
    return createRawBuilder({
      queryId: createQueryId(),
      rawNode: RawNode.createWithChild(ValueNode.createImmediate(value))
    });
  },
  literal(value) {
    return this.lit(value);
  },
  raw(sql2) {
    return createRawBuilder({
      queryId: createQueryId(),
      rawNode: RawNode.createWithSql(sql2)
    });
  },
  join(array, separator = sql`, `) {
    const nodes = new Array(2 * array.length - 1);
    const sep2 = separator.toOperationNode();
    for (let i2 = 0; i2 < array.length; ++i2) {
      nodes[2 * i2] = parseParameter(array[i2]);
      if (i2 !== array.length - 1) {
        nodes[2 * i2 + 1] = sep2;
      }
    }
    return createRawBuilder({
      queryId: createQueryId(),
      rawNode: RawNode.createWithChildren(nodes)
    });
  }
});
function parseParameter(param) {
  if (isOperationNodeSource(param)) {
    return param.toOperationNode();
  }
  return parseValueExpression(param);
}

// ../../../node_modules/.pnpm/kysely@0.27.4/node_modules/kysely/dist/esm/query-compiler/default-query-compiler.js
init_define_ENV_DEFINED_IN_BUILD_STEP();

// ../../../node_modules/.pnpm/kysely@0.27.4/node_modules/kysely/dist/esm/operation-node/operation-node-visitor.js
init_define_ENV_DEFINED_IN_BUILD_STEP();
var OperationNodeVisitor = class {
  nodeStack = [];
  get parentNode() {
    return this.nodeStack[this.nodeStack.length - 2];
  }
  #visitors = freeze({
    AliasNode: this.visitAlias.bind(this),
    ColumnNode: this.visitColumn.bind(this),
    IdentifierNode: this.visitIdentifier.bind(this),
    SchemableIdentifierNode: this.visitSchemableIdentifier.bind(this),
    RawNode: this.visitRaw.bind(this),
    ReferenceNode: this.visitReference.bind(this),
    SelectQueryNode: this.visitSelectQuery.bind(this),
    SelectionNode: this.visitSelection.bind(this),
    TableNode: this.visitTable.bind(this),
    FromNode: this.visitFrom.bind(this),
    SelectAllNode: this.visitSelectAll.bind(this),
    AndNode: this.visitAnd.bind(this),
    OrNode: this.visitOr.bind(this),
    ValueNode: this.visitValue.bind(this),
    ValueListNode: this.visitValueList.bind(this),
    PrimitiveValueListNode: this.visitPrimitiveValueList.bind(this),
    ParensNode: this.visitParens.bind(this),
    JoinNode: this.visitJoin.bind(this),
    OperatorNode: this.visitOperator.bind(this),
    WhereNode: this.visitWhere.bind(this),
    InsertQueryNode: this.visitInsertQuery.bind(this),
    DeleteQueryNode: this.visitDeleteQuery.bind(this),
    ReturningNode: this.visitReturning.bind(this),
    CreateTableNode: this.visitCreateTable.bind(this),
    AddColumnNode: this.visitAddColumn.bind(this),
    ColumnDefinitionNode: this.visitColumnDefinition.bind(this),
    DropTableNode: this.visitDropTable.bind(this),
    DataTypeNode: this.visitDataType.bind(this),
    OrderByNode: this.visitOrderBy.bind(this),
    OrderByItemNode: this.visitOrderByItem.bind(this),
    GroupByNode: this.visitGroupBy.bind(this),
    GroupByItemNode: this.visitGroupByItem.bind(this),
    UpdateQueryNode: this.visitUpdateQuery.bind(this),
    ColumnUpdateNode: this.visitColumnUpdate.bind(this),
    LimitNode: this.visitLimit.bind(this),
    OffsetNode: this.visitOffset.bind(this),
    OnConflictNode: this.visitOnConflict.bind(this),
    OnDuplicateKeyNode: this.visitOnDuplicateKey.bind(this),
    CreateIndexNode: this.visitCreateIndex.bind(this),
    DropIndexNode: this.visitDropIndex.bind(this),
    ListNode: this.visitList.bind(this),
    PrimaryKeyConstraintNode: this.visitPrimaryKeyConstraint.bind(this),
    UniqueConstraintNode: this.visitUniqueConstraint.bind(this),
    ReferencesNode: this.visitReferences.bind(this),
    CheckConstraintNode: this.visitCheckConstraint.bind(this),
    WithNode: this.visitWith.bind(this),
    CommonTableExpressionNode: this.visitCommonTableExpression.bind(this),
    CommonTableExpressionNameNode: this.visitCommonTableExpressionName.bind(this),
    HavingNode: this.visitHaving.bind(this),
    CreateSchemaNode: this.visitCreateSchema.bind(this),
    DropSchemaNode: this.visitDropSchema.bind(this),
    AlterTableNode: this.visitAlterTable.bind(this),
    DropColumnNode: this.visitDropColumn.bind(this),
    RenameColumnNode: this.visitRenameColumn.bind(this),
    AlterColumnNode: this.visitAlterColumn.bind(this),
    ModifyColumnNode: this.visitModifyColumn.bind(this),
    AddConstraintNode: this.visitAddConstraint.bind(this),
    DropConstraintNode: this.visitDropConstraint.bind(this),
    ForeignKeyConstraintNode: this.visitForeignKeyConstraint.bind(this),
    CreateViewNode: this.visitCreateView.bind(this),
    DropViewNode: this.visitDropView.bind(this),
    GeneratedNode: this.visitGenerated.bind(this),
    DefaultValueNode: this.visitDefaultValue.bind(this),
    OnNode: this.visitOn.bind(this),
    ValuesNode: this.visitValues.bind(this),
    SelectModifierNode: this.visitSelectModifier.bind(this),
    CreateTypeNode: this.visitCreateType.bind(this),
    DropTypeNode: this.visitDropType.bind(this),
    ExplainNode: this.visitExplain.bind(this),
    DefaultInsertValueNode: this.visitDefaultInsertValue.bind(this),
    AggregateFunctionNode: this.visitAggregateFunction.bind(this),
    OverNode: this.visitOver.bind(this),
    PartitionByNode: this.visitPartitionBy.bind(this),
    PartitionByItemNode: this.visitPartitionByItem.bind(this),
    SetOperationNode: this.visitSetOperation.bind(this),
    BinaryOperationNode: this.visitBinaryOperation.bind(this),
    UnaryOperationNode: this.visitUnaryOperation.bind(this),
    UsingNode: this.visitUsing.bind(this),
    FunctionNode: this.visitFunction.bind(this),
    CaseNode: this.visitCase.bind(this),
    WhenNode: this.visitWhen.bind(this),
    JSONReferenceNode: this.visitJSONReference.bind(this),
    JSONPathNode: this.visitJSONPath.bind(this),
    JSONPathLegNode: this.visitJSONPathLeg.bind(this),
    JSONOperatorChainNode: this.visitJSONOperatorChain.bind(this),
    TupleNode: this.visitTuple.bind(this),
    MergeQueryNode: this.visitMergeQuery.bind(this),
    MatchedNode: this.visitMatched.bind(this),
    AddIndexNode: this.visitAddIndex.bind(this),
    CastNode: this.visitCast.bind(this),
    FetchNode: this.visitFetch.bind(this),
    TopNode: this.visitTop.bind(this),
    OutputNode: this.visitOutput.bind(this)
  });
  visitNode = (node) => {
    this.nodeStack.push(node);
    this.#visitors[node.kind](node);
    this.nodeStack.pop();
  };
};

// ../../../node_modules/.pnpm/kysely@0.27.4/node_modules/kysely/dist/esm/query-compiler/default-query-compiler.js
var DefaultQueryCompiler = class extends OperationNodeVisitor {
  #sql = "";
  #parameters = [];
  get numParameters() {
    return this.#parameters.length;
  }
  compileQuery(node) {
    this.#sql = "";
    this.#parameters = [];
    this.nodeStack.splice(0, this.nodeStack.length);
    this.visitNode(node);
    return freeze({
      query: node,
      sql: this.getSql(),
      parameters: [...this.#parameters]
    });
  }
  getSql() {
    return this.#sql;
  }
  visitSelectQuery(node) {
    var _a8, _b5;
    const wrapInParens = this.parentNode !== void 0 && !ParensNode.is(this.parentNode) && !InsertQueryNode.is(this.parentNode) && !CreateTableNode.is(this.parentNode) && !CreateViewNode.is(this.parentNode) && !SetOperationNode.is(this.parentNode);
    if (this.parentNode === void 0 && node.explain) {
      this.visitNode(node.explain);
      this.append(" ");
    }
    if (wrapInParens) {
      this.append("(");
    }
    if (node.with) {
      this.visitNode(node.with);
      this.append(" ");
    }
    this.append("select");
    if (node.distinctOn) {
      this.append(" ");
      this.compileDistinctOn(node.distinctOn);
    }
    if ((_a8 = node.frontModifiers) == null ? void 0 : _a8.length) {
      this.append(" ");
      this.compileList(node.frontModifiers, " ");
    }
    if (node.top) {
      this.append(" ");
      this.visitNode(node.top);
    }
    if (node.selections) {
      this.append(" ");
      this.compileList(node.selections);
    }
    if (node.from) {
      this.append(" ");
      this.visitNode(node.from);
    }
    if (node.joins) {
      this.append(" ");
      this.compileList(node.joins, " ");
    }
    if (node.where) {
      this.append(" ");
      this.visitNode(node.where);
    }
    if (node.groupBy) {
      this.append(" ");
      this.visitNode(node.groupBy);
    }
    if (node.having) {
      this.append(" ");
      this.visitNode(node.having);
    }
    if (node.setOperations) {
      this.append(" ");
      this.compileList(node.setOperations, " ");
    }
    if (node.orderBy) {
      this.append(" ");
      this.visitNode(node.orderBy);
    }
    if (node.limit) {
      this.append(" ");
      this.visitNode(node.limit);
    }
    if (node.offset) {
      this.append(" ");
      this.visitNode(node.offset);
    }
    if (node.fetch) {
      this.append(" ");
      this.visitNode(node.fetch);
    }
    if ((_b5 = node.endModifiers) == null ? void 0 : _b5.length) {
      this.append(" ");
      this.compileList(this.sortSelectModifiers([...node.endModifiers]), " ");
    }
    if (wrapInParens) {
      this.append(")");
    }
  }
  visitFrom(node) {
    this.append("from ");
    this.compileList(node.froms);
  }
  visitSelection(node) {
    this.visitNode(node.selection);
  }
  visitColumn(node) {
    this.visitNode(node.column);
  }
  compileDistinctOn(expressions) {
    this.append("distinct on (");
    this.compileList(expressions);
    this.append(")");
  }
  compileList(nodes, separator = ", ") {
    const lastIndex = nodes.length - 1;
    for (let i2 = 0; i2 <= lastIndex; i2++) {
      this.visitNode(nodes[i2]);
      if (i2 < lastIndex) {
        this.append(separator);
      }
    }
  }
  visitWhere(node) {
    this.append("where ");
    this.visitNode(node.where);
  }
  visitHaving(node) {
    this.append("having ");
    this.visitNode(node.having);
  }
  visitInsertQuery(node) {
    const rootQueryNode = this.nodeStack.find(QueryNode.is);
    const isSubQuery = rootQueryNode !== node;
    if (!isSubQuery && node.explain) {
      this.visitNode(node.explain);
      this.append(" ");
    }
    if (isSubQuery && !MergeQueryNode.is(rootQueryNode)) {
      this.append("(");
    }
    if (node.with) {
      this.visitNode(node.with);
      this.append(" ");
    }
    this.append(node.replace ? "replace" : "insert");
    if (node.ignore) {
      this.append(" ignore");
    }
    if (node.top) {
      this.append(" ");
      this.visitNode(node.top);
    }
    if (node.into) {
      this.append(" into ");
      this.visitNode(node.into);
    }
    if (node.columns) {
      this.append(" (");
      this.compileList(node.columns);
      this.append(")");
    }
    if (node.output) {
      this.append(" ");
      this.visitNode(node.output);
    }
    if (node.values) {
      this.append(" ");
      this.visitNode(node.values);
    }
    if (node.defaultValues) {
      this.append(" ");
      this.append("default values");
    }
    if (node.onConflict) {
      this.append(" ");
      this.visitNode(node.onConflict);
    }
    if (node.onDuplicateKey) {
      this.append(" ");
      this.visitNode(node.onDuplicateKey);
    }
    if (node.returning) {
      this.append(" ");
      this.visitNode(node.returning);
    }
    if (isSubQuery && !MergeQueryNode.is(rootQueryNode)) {
      this.append(")");
    }
  }
  visitValues(node) {
    this.append("values ");
    this.compileList(node.values);
  }
  visitDeleteQuery(node) {
    const isSubQuery = this.nodeStack.find(QueryNode.is) !== node;
    if (!isSubQuery && node.explain) {
      this.visitNode(node.explain);
      this.append(" ");
    }
    if (isSubQuery) {
      this.append("(");
    }
    if (node.with) {
      this.visitNode(node.with);
      this.append(" ");
    }
    this.append("delete ");
    if (node.top) {
      this.visitNode(node.top);
      this.append(" ");
    }
    this.visitNode(node.from);
    if (node.output) {
      this.append(" ");
      this.visitNode(node.output);
    }
    if (node.using) {
      this.append(" ");
      this.visitNode(node.using);
    }
    if (node.joins) {
      this.append(" ");
      this.compileList(node.joins, " ");
    }
    if (node.where) {
      this.append(" ");
      this.visitNode(node.where);
    }
    if (node.orderBy) {
      this.append(" ");
      this.visitNode(node.orderBy);
    }
    if (node.limit) {
      this.append(" ");
      this.visitNode(node.limit);
    }
    if (node.returning) {
      this.append(" ");
      this.visitNode(node.returning);
    }
    if (isSubQuery) {
      this.append(")");
    }
  }
  visitReturning(node) {
    this.append("returning ");
    this.compileList(node.selections);
  }
  visitAlias(node) {
    this.visitNode(node.node);
    this.append(" as ");
    this.visitNode(node.alias);
  }
  visitReference(node) {
    if (node.table) {
      this.visitNode(node.table);
      this.append(".");
    }
    this.visitNode(node.column);
  }
  visitSelectAll(_3) {
    this.append("*");
  }
  visitIdentifier(node) {
    this.append(this.getLeftIdentifierWrapper());
    this.compileUnwrappedIdentifier(node);
    this.append(this.getRightIdentifierWrapper());
  }
  compileUnwrappedIdentifier(node) {
    if (!isString(node.name)) {
      throw new Error("a non-string identifier was passed to compileUnwrappedIdentifier.");
    }
    this.append(this.sanitizeIdentifier(node.name));
  }
  visitAnd(node) {
    this.visitNode(node.left);
    this.append(" and ");
    this.visitNode(node.right);
  }
  visitOr(node) {
    this.visitNode(node.left);
    this.append(" or ");
    this.visitNode(node.right);
  }
  visitValue(node) {
    if (node.immediate) {
      this.appendImmediateValue(node.value);
    } else {
      this.appendValue(node.value);
    }
  }
  visitValueList(node) {
    this.append("(");
    this.compileList(node.values);
    this.append(")");
  }
  visitTuple(node) {
    this.append("(");
    this.compileList(node.values);
    this.append(")");
  }
  visitPrimitiveValueList(node) {
    this.append("(");
    const { values } = node;
    for (let i2 = 0; i2 < values.length; ++i2) {
      this.appendValue(values[i2]);
      if (i2 !== values.length - 1) {
        this.append(", ");
      }
    }
    this.append(")");
  }
  visitParens(node) {
    this.append("(");
    this.visitNode(node.node);
    this.append(")");
  }
  visitJoin(node) {
    this.append(JOIN_TYPE_SQL[node.joinType]);
    this.append(" ");
    this.visitNode(node.table);
    if (node.on) {
      this.append(" ");
      this.visitNode(node.on);
    }
  }
  visitOn(node) {
    this.append("on ");
    this.visitNode(node.on);
  }
  visitRaw(node) {
    const { sqlFragments, parameters: params } = node;
    for (let i2 = 0; i2 < sqlFragments.length; ++i2) {
      this.append(sqlFragments[i2]);
      if (params.length > i2) {
        this.visitNode(params[i2]);
      }
    }
  }
  visitOperator(node) {
    this.append(node.operator);
  }
  visitTable(node) {
    this.visitNode(node.table);
  }
  visitSchemableIdentifier(node) {
    if (node.schema) {
      this.visitNode(node.schema);
      this.append(".");
    }
    this.visitNode(node.identifier);
  }
  visitCreateTable(node) {
    this.append("create ");
    if (node.frontModifiers && node.frontModifiers.length > 0) {
      this.compileList(node.frontModifiers, " ");
      this.append(" ");
    }
    if (node.temporary) {
      this.append("temporary ");
    }
    this.append("table ");
    if (node.ifNotExists) {
      this.append("if not exists ");
    }
    this.visitNode(node.table);
    if (node.selectQuery) {
      this.append(" as ");
      this.visitNode(node.selectQuery);
    } else {
      this.append(" (");
      this.compileList([...node.columns, ...node.constraints ?? []]);
      this.append(")");
      if (node.onCommit) {
        this.append(" on commit ");
        this.append(node.onCommit);
      }
      if (node.endModifiers && node.endModifiers.length > 0) {
        this.append(" ");
        this.compileList(node.endModifiers, " ");
      }
    }
  }
  visitColumnDefinition(node) {
    if (node.ifNotExists) {
      this.append("if not exists ");
    }
    this.visitNode(node.column);
    this.append(" ");
    this.visitNode(node.dataType);
    if (node.unsigned) {
      this.append(" unsigned");
    }
    if (node.frontModifiers && node.frontModifiers.length > 0) {
      this.append(" ");
      this.compileList(node.frontModifiers, " ");
    }
    if (node.generated) {
      this.append(" ");
      this.visitNode(node.generated);
    }
    if (node.identity) {
      this.append(" identity");
    }
    if (node.defaultTo) {
      this.append(" ");
      this.visitNode(node.defaultTo);
    }
    if (node.notNull) {
      this.append(" not null");
    }
    if (node.unique) {
      this.append(" unique");
    }
    if (node.nullsNotDistinct) {
      this.append(" nulls not distinct");
    }
    if (node.primaryKey) {
      this.append(" primary key");
    }
    if (node.autoIncrement) {
      this.append(" ");
      this.append(this.getAutoIncrement());
    }
    if (node.references) {
      this.append(" ");
      this.visitNode(node.references);
    }
    if (node.check) {
      this.append(" ");
      this.visitNode(node.check);
    }
    if (node.endModifiers && node.endModifiers.length > 0) {
      this.append(" ");
      this.compileList(node.endModifiers, " ");
    }
  }
  getAutoIncrement() {
    return "auto_increment";
  }
  visitReferences(node) {
    this.append("references ");
    this.visitNode(node.table);
    this.append(" (");
    this.compileList(node.columns);
    this.append(")");
    if (node.onDelete) {
      this.append(" on delete ");
      this.append(node.onDelete);
    }
    if (node.onUpdate) {
      this.append(" on update ");
      this.append(node.onUpdate);
    }
  }
  visitDropTable(node) {
    this.append("drop table ");
    if (node.ifExists) {
      this.append("if exists ");
    }
    this.visitNode(node.table);
    if (node.cascade) {
      this.append(" cascade");
    }
  }
  visitDataType(node) {
    this.append(node.dataType);
  }
  visitOrderBy(node) {
    this.append("order by ");
    this.compileList(node.items);
  }
  visitOrderByItem(node) {
    this.visitNode(node.orderBy);
    if (node.direction) {
      this.append(" ");
      this.visitNode(node.direction);
    }
  }
  visitGroupBy(node) {
    this.append("group by ");
    this.compileList(node.items);
  }
  visitGroupByItem(node) {
    this.visitNode(node.groupBy);
  }
  visitUpdateQuery(node) {
    const rootQueryNode = this.nodeStack.find(QueryNode.is);
    const isSubQuery = rootQueryNode !== node;
    if (!isSubQuery && node.explain) {
      this.visitNode(node.explain);
      this.append(" ");
    }
    if (isSubQuery && !MergeQueryNode.is(rootQueryNode)) {
      this.append("(");
    }
    if (node.with) {
      this.visitNode(node.with);
      this.append(" ");
    }
    this.append("update ");
    if (node.top) {
      this.visitNode(node.top);
      this.append(" ");
    }
    if (node.table) {
      this.visitNode(node.table);
      this.append(" ");
    }
    this.append("set ");
    if (node.updates) {
      this.compileList(node.updates);
    }
    if (node.output) {
      this.append(" ");
      this.visitNode(node.output);
    }
    if (node.from) {
      this.append(" ");
      this.visitNode(node.from);
    }
    if (node.joins) {
      this.append(" ");
      this.compileList(node.joins, " ");
    }
    if (node.where) {
      this.append(" ");
      this.visitNode(node.where);
    }
    if (node.limit) {
      this.append(" ");
      this.visitNode(node.limit);
    }
    if (node.returning) {
      this.append(" ");
      this.visitNode(node.returning);
    }
    if (isSubQuery && !MergeQueryNode.is(rootQueryNode)) {
      this.append(")");
    }
  }
  visitColumnUpdate(node) {
    this.visitNode(node.column);
    this.append(" = ");
    this.visitNode(node.value);
  }
  visitLimit(node) {
    this.append("limit ");
    this.visitNode(node.limit);
  }
  visitOffset(node) {
    this.append("offset ");
    this.visitNode(node.offset);
  }
  visitOnConflict(node) {
    this.append("on conflict");
    if (node.columns) {
      this.append(" (");
      this.compileList(node.columns);
      this.append(")");
    } else if (node.constraint) {
      this.append(" on constraint ");
      this.visitNode(node.constraint);
    } else if (node.indexExpression) {
      this.append(" (");
      this.visitNode(node.indexExpression);
      this.append(")");
    }
    if (node.indexWhere) {
      this.append(" ");
      this.visitNode(node.indexWhere);
    }
    if (node.doNothing === true) {
      this.append(" do nothing");
    } else if (node.updates) {
      this.append(" do update set ");
      this.compileList(node.updates);
      if (node.updateWhere) {
        this.append(" ");
        this.visitNode(node.updateWhere);
      }
    }
  }
  visitOnDuplicateKey(node) {
    this.append("on duplicate key update ");
    this.compileList(node.updates);
  }
  visitCreateIndex(node) {
    this.append("create ");
    if (node.unique) {
      this.append("unique ");
    }
    this.append("index ");
    if (node.ifNotExists) {
      this.append("if not exists ");
    }
    this.visitNode(node.name);
    if (node.table) {
      this.append(" on ");
      this.visitNode(node.table);
    }
    if (node.using) {
      this.append(" using ");
      this.visitNode(node.using);
    }
    if (node.columns) {
      this.append(" (");
      this.compileList(node.columns);
      this.append(")");
    }
    if (node.nullsNotDistinct) {
      this.append(" nulls not distinct");
    }
    if (node.where) {
      this.append(" ");
      this.visitNode(node.where);
    }
  }
  visitDropIndex(node) {
    this.append("drop index ");
    if (node.ifExists) {
      this.append("if exists ");
    }
    this.visitNode(node.name);
    if (node.table) {
      this.append(" on ");
      this.visitNode(node.table);
    }
    if (node.cascade) {
      this.append(" cascade");
    }
  }
  visitCreateSchema(node) {
    this.append("create schema ");
    if (node.ifNotExists) {
      this.append("if not exists ");
    }
    this.visitNode(node.schema);
  }
  visitDropSchema(node) {
    this.append("drop schema ");
    if (node.ifExists) {
      this.append("if exists ");
    }
    this.visitNode(node.schema);
    if (node.cascade) {
      this.append(" cascade");
    }
  }
  visitPrimaryKeyConstraint(node) {
    if (node.name) {
      this.append("constraint ");
      this.visitNode(node.name);
      this.append(" ");
    }
    this.append("primary key (");
    this.compileList(node.columns);
    this.append(")");
  }
  visitUniqueConstraint(node) {
    if (node.name) {
      this.append("constraint ");
      this.visitNode(node.name);
      this.append(" ");
    }
    this.append("unique");
    if (node.nullsNotDistinct) {
      this.append(" nulls not distinct");
    }
    this.append(" (");
    this.compileList(node.columns);
    this.append(")");
  }
  visitCheckConstraint(node) {
    if (node.name) {
      this.append("constraint ");
      this.visitNode(node.name);
      this.append(" ");
    }
    this.append("check (");
    this.visitNode(node.expression);
    this.append(")");
  }
  visitForeignKeyConstraint(node) {
    if (node.name) {
      this.append("constraint ");
      this.visitNode(node.name);
      this.append(" ");
    }
    this.append("foreign key (");
    this.compileList(node.columns);
    this.append(") ");
    this.visitNode(node.references);
    if (node.onDelete) {
      this.append(" on delete ");
      this.append(node.onDelete);
    }
    if (node.onUpdate) {
      this.append(" on update ");
      this.append(node.onUpdate);
    }
  }
  visitList(node) {
    this.compileList(node.items);
  }
  visitWith(node) {
    this.append("with ");
    if (node.recursive) {
      this.append("recursive ");
    }
    this.compileList(node.expressions);
  }
  visitCommonTableExpression(node) {
    this.visitNode(node.name);
    this.append(" as ");
    if (isBoolean(node.materialized)) {
      if (!node.materialized) {
        this.append("not ");
      }
      this.append("materialized ");
    }
    this.visitNode(node.expression);
  }
  visitCommonTableExpressionName(node) {
    this.visitNode(node.table);
    if (node.columns) {
      this.append("(");
      this.compileList(node.columns);
      this.append(")");
    }
  }
  visitAlterTable(node) {
    this.append("alter table ");
    this.visitNode(node.table);
    this.append(" ");
    if (node.renameTo) {
      this.append("rename to ");
      this.visitNode(node.renameTo);
    }
    if (node.setSchema) {
      this.append("set schema ");
      this.visitNode(node.setSchema);
    }
    if (node.addConstraint) {
      this.visitNode(node.addConstraint);
    }
    if (node.dropConstraint) {
      this.visitNode(node.dropConstraint);
    }
    if (node.columnAlterations) {
      this.compileColumnAlterations(node.columnAlterations);
    }
    if (node.addIndex) {
      this.visitNode(node.addIndex);
    }
    if (node.dropIndex) {
      this.visitNode(node.dropIndex);
    }
  }
  visitAddColumn(node) {
    this.append("add column ");
    this.visitNode(node.column);
  }
  visitRenameColumn(node) {
    this.append("rename column ");
    this.visitNode(node.column);
    this.append(" to ");
    this.visitNode(node.renameTo);
  }
  visitDropColumn(node) {
    this.append("drop column ");
    this.visitNode(node.column);
  }
  visitAlterColumn(node) {
    this.append("alter column ");
    this.visitNode(node.column);
    this.append(" ");
    if (node.dataType) {
      if (this.announcesNewColumnDataType()) {
        this.append("type ");
      }
      this.visitNode(node.dataType);
      if (node.dataTypeExpression) {
        this.append("using ");
        this.visitNode(node.dataTypeExpression);
      }
    }
    if (node.setDefault) {
      this.append("set default ");
      this.visitNode(node.setDefault);
    }
    if (node.dropDefault) {
      this.append("drop default");
    }
    if (node.setNotNull) {
      this.append("set not null");
    }
    if (node.dropNotNull) {
      this.append("drop not null");
    }
  }
  visitModifyColumn(node) {
    this.append("modify column ");
    this.visitNode(node.column);
  }
  visitAddConstraint(node) {
    this.append("add ");
    this.visitNode(node.constraint);
  }
  visitDropConstraint(node) {
    this.append("drop constraint ");
    if (node.ifExists) {
      this.append("if exists ");
    }
    this.visitNode(node.constraintName);
    if (node.modifier === "cascade") {
      this.append(" cascade");
    } else if (node.modifier === "restrict") {
      this.append(" restrict");
    }
  }
  visitSetOperation(node) {
    this.append(node.operator);
    this.append(" ");
    if (node.all) {
      this.append("all ");
    }
    this.visitNode(node.expression);
  }
  visitCreateView(node) {
    this.append("create ");
    if (node.orReplace) {
      this.append("or replace ");
    }
    if (node.materialized) {
      this.append("materialized ");
    }
    if (node.temporary) {
      this.append("temporary ");
    }
    this.append("view ");
    if (node.ifNotExists) {
      this.append("if not exists ");
    }
    this.visitNode(node.name);
    this.append(" ");
    if (node.columns) {
      this.append("(");
      this.compileList(node.columns);
      this.append(") ");
    }
    if (node.as) {
      this.append("as ");
      this.visitNode(node.as);
    }
  }
  visitDropView(node) {
    this.append("drop ");
    if (node.materialized) {
      this.append("materialized ");
    }
    this.append("view ");
    if (node.ifExists) {
      this.append("if exists ");
    }
    this.visitNode(node.name);
    if (node.cascade) {
      this.append(" cascade");
    }
  }
  visitGenerated(node) {
    this.append("generated ");
    if (node.always) {
      this.append("always ");
    }
    if (node.byDefault) {
      this.append("by default ");
    }
    this.append("as ");
    if (node.identity) {
      this.append("identity");
    }
    if (node.expression) {
      this.append("(");
      this.visitNode(node.expression);
      this.append(")");
    }
    if (node.stored) {
      this.append(" stored");
    }
  }
  visitDefaultValue(node) {
    this.append("default ");
    this.visitNode(node.defaultValue);
  }
  visitSelectModifier(node) {
    if (node.rawModifier) {
      this.visitNode(node.rawModifier);
    } else {
      this.append(SELECT_MODIFIER_SQL[node.modifier]);
    }
    if (node.of) {
      this.append(" of ");
      this.compileList(node.of, ", ");
    }
  }
  visitCreateType(node) {
    this.append("create type ");
    this.visitNode(node.name);
    if (node.enum) {
      this.append(" as enum ");
      this.visitNode(node.enum);
    }
  }
  visitDropType(node) {
    this.append("drop type ");
    if (node.ifExists) {
      this.append("if exists ");
    }
    this.visitNode(node.name);
  }
  visitExplain(node) {
    this.append("explain");
    if (node.options || node.format) {
      this.append(" ");
      this.append(this.getLeftExplainOptionsWrapper());
      if (node.options) {
        this.visitNode(node.options);
        if (node.format) {
          this.append(this.getExplainOptionsDelimiter());
        }
      }
      if (node.format) {
        this.append("format");
        this.append(this.getExplainOptionAssignment());
        this.append(node.format);
      }
      this.append(this.getRightExplainOptionsWrapper());
    }
  }
  visitDefaultInsertValue(_3) {
    this.append("default");
  }
  visitAggregateFunction(node) {
    this.append(node.func);
    this.append("(");
    if (node.distinct) {
      this.append("distinct ");
    }
    this.compileList(node.aggregated);
    this.append(")");
    if (node.filter) {
      this.append(" filter(");
      this.visitNode(node.filter);
      this.append(")");
    }
    if (node.over) {
      this.append(" ");
      this.visitNode(node.over);
    }
  }
  visitOver(node) {
    this.append("over(");
    if (node.partitionBy) {
      this.visitNode(node.partitionBy);
      if (node.orderBy) {
        this.append(" ");
      }
    }
    if (node.orderBy) {
      this.visitNode(node.orderBy);
    }
    this.append(")");
  }
  visitPartitionBy(node) {
    this.append("partition by ");
    this.compileList(node.items);
  }
  visitPartitionByItem(node) {
    this.visitNode(node.partitionBy);
  }
  visitBinaryOperation(node) {
    this.visitNode(node.leftOperand);
    this.append(" ");
    this.visitNode(node.operator);
    this.append(" ");
    this.visitNode(node.rightOperand);
  }
  visitUnaryOperation(node) {
    this.visitNode(node.operator);
    if (!this.isMinusOperator(node.operator)) {
      this.append(" ");
    }
    this.visitNode(node.operand);
  }
  isMinusOperator(node) {
    return OperatorNode.is(node) && node.operator === "-";
  }
  visitUsing(node) {
    this.append("using ");
    this.compileList(node.tables);
  }
  visitFunction(node) {
    this.append(node.func);
    this.append("(");
    this.compileList(node.arguments);
    this.append(")");
  }
  visitCase(node) {
    this.append("case");
    if (node.value) {
      this.append(" ");
      this.visitNode(node.value);
    }
    if (node.when) {
      this.append(" ");
      this.compileList(node.when, " ");
    }
    if (node.else) {
      this.append(" else ");
      this.visitNode(node.else);
    }
    this.append(" end");
    if (node.isStatement) {
      this.append(" case");
    }
  }
  visitWhen(node) {
    this.append("when ");
    this.visitNode(node.condition);
    if (node.result) {
      this.append(" then ");
      this.visitNode(node.result);
    }
  }
  visitJSONReference(node) {
    this.visitNode(node.reference);
    this.visitNode(node.traversal);
  }
  visitJSONPath(node) {
    if (node.inOperator) {
      this.visitNode(node.inOperator);
    }
    this.append("'$");
    for (const pathLeg of node.pathLegs) {
      this.visitNode(pathLeg);
    }
    this.append("'");
  }
  visitJSONPathLeg(node) {
    const isArrayLocation = node.type === "ArrayLocation";
    this.append(isArrayLocation ? "[" : ".");
    this.append(String(node.value));
    if (isArrayLocation) {
      this.append("]");
    }
  }
  visitJSONOperatorChain(node) {
    for (let i2 = 0, len = node.values.length; i2 < len; i2++) {
      if (i2 === len - 1) {
        this.visitNode(node.operator);
      } else {
        this.append("->");
      }
      this.visitNode(node.values[i2]);
    }
  }
  visitMergeQuery(node) {
    if (node.with) {
      this.visitNode(node.with);
      this.append(" ");
    }
    this.append("merge ");
    if (node.top) {
      this.visitNode(node.top);
      this.append(" ");
    }
    this.append("into ");
    this.visitNode(node.into);
    if (node.using) {
      this.append(" ");
      this.visitNode(node.using);
    }
    if (node.whens) {
      this.append(" ");
      this.compileList(node.whens, " ");
    }
    if (node.output) {
      this.append(" ");
      this.visitNode(node.output);
    }
  }
  visitMatched(node) {
    if (node.not) {
      this.append("not ");
    }
    this.append("matched");
    if (node.bySource) {
      this.append(" by source");
    }
  }
  visitAddIndex(node) {
    this.append("add ");
    if (node.unique) {
      this.append("unique ");
    }
    this.append("index ");
    this.visitNode(node.name);
    if (node.columns) {
      this.append(" (");
      this.compileList(node.columns);
      this.append(")");
    }
    if (node.using) {
      this.append(" using ");
      this.visitNode(node.using);
    }
  }
  visitCast(node) {
    this.append("cast(");
    this.visitNode(node.expression);
    this.append(" as ");
    this.visitNode(node.dataType);
    this.append(")");
  }
  visitFetch(node) {
    this.append("fetch next ");
    this.visitNode(node.rowCount);
    this.append(` rows ${node.modifier}`);
  }
  visitOutput(node) {
    this.append("output ");
    this.compileList(node.selections);
  }
  visitTop(node) {
    this.append(`top(${node.expression})`);
    if (node.modifiers) {
      this.append(` ${node.modifiers}`);
    }
  }
  append(str) {
    this.#sql += str;
  }
  appendValue(parameter) {
    this.addParameter(parameter);
    this.append(this.getCurrentParameterPlaceholder());
  }
  getLeftIdentifierWrapper() {
    return '"';
  }
  getRightIdentifierWrapper() {
    return '"';
  }
  getCurrentParameterPlaceholder() {
    return "$" + this.numParameters;
  }
  getLeftExplainOptionsWrapper() {
    return "(";
  }
  getExplainOptionAssignment() {
    return " ";
  }
  getExplainOptionsDelimiter() {
    return ", ";
  }
  getRightExplainOptionsWrapper() {
    return ")";
  }
  sanitizeIdentifier(identifier) {
    const leftWrap = this.getLeftIdentifierWrapper();
    const rightWrap = this.getRightIdentifierWrapper();
    let sanitized = "";
    for (const c3 of identifier) {
      sanitized += c3;
      if (c3 === leftWrap) {
        sanitized += leftWrap;
      } else if (c3 === rightWrap) {
        sanitized += rightWrap;
      }
    }
    return sanitized;
  }
  addParameter(parameter) {
    this.#parameters.push(parameter);
  }
  appendImmediateValue(value) {
    if (isString(value)) {
      this.append(`'${value}'`);
    } else if (isNumber(value) || isBoolean(value)) {
      this.append(value.toString());
    } else if (isNull(value)) {
      this.append("null");
    } else if (isDate(value)) {
      this.appendImmediateValue(value.toISOString());
    } else if (isBigInt(value)) {
      this.appendImmediateValue(value.toString());
    } else {
      throw new Error(`invalid immediate value ${value}`);
    }
  }
  sortSelectModifiers(arr) {
    arr.sort((left, right) => left.modifier && right.modifier ? SELECT_MODIFIER_PRIORITY[left.modifier] - SELECT_MODIFIER_PRIORITY[right.modifier] : 1);
    return freeze(arr);
  }
  compileColumnAlterations(columnAlterations) {
    this.compileList(columnAlterations);
  }
  /**
   * controls whether the dialect adds a "type" keyword before a column's new data
   * type in an ALTER TABLE statement.
   */
  announcesNewColumnDataType() {
    return true;
  }
};
var SELECT_MODIFIER_SQL = freeze({
  ForKeyShare: "for key share",
  ForNoKeyUpdate: "for no key update",
  ForUpdate: "for update",
  ForShare: "for share",
  NoWait: "nowait",
  SkipLocked: "skip locked",
  Distinct: "distinct"
});
var SELECT_MODIFIER_PRIORITY = freeze({
  ForKeyShare: 1,
  ForNoKeyUpdate: 1,
  ForUpdate: 1,
  ForShare: 1,
  NoWait: 2,
  SkipLocked: 2,
  Distinct: 0
});
var JOIN_TYPE_SQL = freeze({
  InnerJoin: "inner join",
  LeftJoin: "left join",
  RightJoin: "right join",
  FullJoin: "full join",
  LateralInnerJoin: "inner join lateral",
  LateralLeftJoin: "left join lateral",
  Using: "using"
});

// ../../../node_modules/.pnpm/kysely@0.27.4/node_modules/kysely/dist/esm/query-compiler/compiled-query.js
init_define_ENV_DEFINED_IN_BUILD_STEP();
var CompiledQuery = freeze({
  raw(sql2, parameters = []) {
    return freeze({
      sql: sql2,
      query: RawNode.createWithSql(sql2),
      parameters: freeze(parameters)
    });
  }
});

// ../../../node_modules/.pnpm/kysely@0.27.4/node_modules/kysely/dist/esm/dialect/dialect-adapter-base.js
init_define_ENV_DEFINED_IN_BUILD_STEP();
var DialectAdapterBase = class {
  get supportsCreateIfNotExists() {
    return true;
  }
  get supportsTransactionalDdl() {
    return false;
  }
  get supportsReturning() {
    return false;
  }
  get supportsOutput() {
    return false;
  }
};

// ../../../node_modules/.pnpm/kysely@0.27.4/node_modules/kysely/dist/esm/dialect/sqlite/sqlite-query-compiler.js
init_define_ENV_DEFINED_IN_BUILD_STEP();
var ID_WRAP_REGEX = /"/g;
var SqliteQueryCompiler = class extends DefaultQueryCompiler {
  getCurrentParameterPlaceholder() {
    return "?";
  }
  getLeftExplainOptionsWrapper() {
    return "";
  }
  getRightExplainOptionsWrapper() {
    return "";
  }
  getLeftIdentifierWrapper() {
    return '"';
  }
  getRightIdentifierWrapper() {
    return '"';
  }
  getAutoIncrement() {
    return "autoincrement";
  }
  sanitizeIdentifier(identifier) {
    return identifier.replace(ID_WRAP_REGEX, '""');
  }
  visitDefaultInsertValue(_3) {
    this.append("null");
  }
};

// ../../../node_modules/.pnpm/kysely@0.27.4/node_modules/kysely/dist/esm/dialect/sqlite/sqlite-introspector.js
init_define_ENV_DEFINED_IN_BUILD_STEP();

// ../../../node_modules/.pnpm/kysely@0.27.4/node_modules/kysely/dist/esm/migration/migrator.js
init_define_ENV_DEFINED_IN_BUILD_STEP();
var DEFAULT_MIGRATION_TABLE = "kysely_migration";
var DEFAULT_MIGRATION_LOCK_TABLE = "kysely_migration_lock";
var NO_MIGRATIONS = freeze({ __noMigrations__: true });

// ../../../node_modules/.pnpm/kysely@0.27.4/node_modules/kysely/dist/esm/dialect/sqlite/sqlite-introspector.js
var SqliteIntrospector = class {
  #db;
  constructor(db) {
    this.#db = db;
  }
  async getSchemas() {
    return [];
  }
  async getTables(options = { withInternalKyselyTables: false }) {
    let query = this.#db.selectFrom("sqlite_master").where("type", "in", ["table", "view"]).where("name", "not like", "sqlite_%").select("name").orderBy("name").$castTo();
    if (!options.withInternalKyselyTables) {
      query = query.where("name", "!=", DEFAULT_MIGRATION_TABLE).where("name", "!=", DEFAULT_MIGRATION_LOCK_TABLE);
    }
    const tables = await query.execute();
    return Promise.all(tables.map(({ name }) => this.#getTableMetadata(name)));
  }
  async getMetadata(options) {
    return {
      tables: await this.getTables(options)
    };
  }
  async #getTableMetadata(table) {
    var _a8, _b5, _c, _d, _e, _f;
    const db = this.#db;
    const tableDefinition = await db.selectFrom("sqlite_master").where("name", "=", table).select(["sql", "type"]).$castTo().executeTakeFirstOrThrow();
    const autoIncrementCol = (_f = (_e = (_d = (_c = (_b5 = (_a8 = tableDefinition.sql) == null ? void 0 : _a8.split(/[\(\),]/)) == null ? void 0 : _b5.find((it) => it.toLowerCase().includes("autoincrement"))) == null ? void 0 : _c.trimStart()) == null ? void 0 : _d.split(/\s+/)) == null ? void 0 : _e[0]) == null ? void 0 : _f.replace(/["`]/g, "");
    const columns = await db.selectFrom(sql`pragma_table_info(${table})`.as("table_info")).select(["name", "type", "notnull", "dflt_value"]).orderBy("cid").execute();
    return {
      name: table,
      isView: tableDefinition.type === "view",
      columns: columns.map((col) => ({
        name: col.name,
        dataType: col.type,
        isNullable: !col.notnull,
        isAutoIncrementing: col.name === autoIncrementCol,
        hasDefaultValue: col.dflt_value != null,
        comment: void 0
      }))
    };
  }
};

// ../../../node_modules/.pnpm/kysely@0.27.4/node_modules/kysely/dist/esm/dialect/sqlite/sqlite-adapter.js
init_define_ENV_DEFINED_IN_BUILD_STEP();
var SqliteAdapter = class extends DialectAdapterBase {
  get supportsTransactionalDdl() {
    return false;
  }
  get supportsReturning() {
    return true;
  }
  async acquireMigrationLock(_db, _opt) {
  }
  async releaseMigrationLock(_db, _opt) {
  }
};

// ../../../node_modules/.pnpm/kysely@0.27.4/node_modules/kysely/dist/esm/plugin/camel-case/camel-case-plugin.js
init_define_ENV_DEFINED_IN_BUILD_STEP();

// ../../../node_modules/.pnpm/kysely@0.27.4/node_modules/kysely/dist/esm/plugin/camel-case/camel-case-transformer.js
init_define_ENV_DEFINED_IN_BUILD_STEP();
var SnakeCaseTransformer = class extends OperationNodeTransformer {
  #snakeCase;
  constructor(snakeCase) {
    super();
    this.#snakeCase = snakeCase;
  }
  transformIdentifier(node) {
    node = super.transformIdentifier(node);
    return {
      ...node,
      name: this.#snakeCase(node.name)
    };
  }
};

// ../../../node_modules/.pnpm/kysely@0.27.4/node_modules/kysely/dist/esm/plugin/camel-case/camel-case.js
init_define_ENV_DEFINED_IN_BUILD_STEP();
function createSnakeCaseMapper({ upperCase = false, underscoreBeforeDigits = false, underscoreBetweenUppercaseLetters = false } = {}) {
  return memoize((str) => {
    if (str.length === 0) {
      return str;
    }
    const upper = str.toUpperCase();
    const lower = str.toLowerCase();
    let out = lower[0];
    for (let i2 = 1, l2 = str.length; i2 < l2; ++i2) {
      const char = str[i2];
      const prevChar = str[i2 - 1];
      const upperChar = upper[i2];
      const prevUpperChar = upper[i2 - 1];
      const lowerChar = lower[i2];
      const prevLowerChar = lower[i2 - 1];
      if (underscoreBeforeDigits && isDigit(char) && !isDigit(prevChar)) {
        out += "_" + char;
        continue;
      }
      if (char === upperChar && upperChar !== lowerChar) {
        const prevCharacterIsUppercase = prevChar === prevUpperChar && prevUpperChar !== prevLowerChar;
        if (underscoreBetweenUppercaseLetters || !prevCharacterIsUppercase) {
          out += "_" + lowerChar;
        } else {
          out += lowerChar;
        }
      } else {
        out += char;
      }
    }
    if (upperCase) {
      return out.toUpperCase();
    } else {
      return out;
    }
  });
}
function createCamelCaseMapper({ upperCase = false } = {}) {
  return memoize((str) => {
    if (str.length === 0) {
      return str;
    }
    if (upperCase && isAllUpperCaseSnakeCase(str)) {
      str = str.toLowerCase();
    }
    let out = str[0];
    for (let i2 = 1, l2 = str.length; i2 < l2; ++i2) {
      const char = str[i2];
      const prevChar = str[i2 - 1];
      if (char !== "_") {
        if (prevChar === "_") {
          out += char.toUpperCase();
        } else {
          out += char;
        }
      }
    }
    return out;
  });
}
function isAllUpperCaseSnakeCase(str) {
  for (let i2 = 1, l2 = str.length; i2 < l2; ++i2) {
    const char = str[i2];
    if (char !== "_" && char !== char.toUpperCase()) {
      return false;
    }
  }
  return true;
}
function isDigit(char) {
  return char >= "0" && char <= "9";
}
function memoize(func) {
  const cache = /* @__PURE__ */ new Map();
  return (str) => {
    let mapped = cache.get(str);
    if (!mapped) {
      mapped = func(str);
      cache.set(str, mapped);
    }
    return mapped;
  };
}

// ../../../node_modules/.pnpm/kysely@0.27.4/node_modules/kysely/dist/esm/plugin/camel-case/camel-case-plugin.js
var CamelCasePlugin = class {
  opt;
  #camelCase;
  #snakeCase;
  #snakeCaseTransformer;
  constructor(opt = {}) {
    this.opt = opt;
    this.#camelCase = createCamelCaseMapper(opt);
    this.#snakeCase = createSnakeCaseMapper(opt);
    this.#snakeCaseTransformer = new SnakeCaseTransformer(this.snakeCase.bind(this));
  }
  transformQuery(args) {
    return this.#snakeCaseTransformer.transformNode(args.node);
  }
  async transformResult(args) {
    if (args.result.rows && Array.isArray(args.result.rows)) {
      return {
        ...args.result,
        rows: args.result.rows.map((row) => this.mapRow(row))
      };
    }
    return args.result;
  }
  mapRow(row) {
    return Object.keys(row).reduce((obj, key) => {
      let value = row[key];
      if (Array.isArray(value)) {
        value = value.map((it) => canMap(it, this.opt) ? this.mapRow(it) : it);
      } else if (canMap(value, this.opt)) {
        value = this.mapRow(value);
      }
      obj[this.camelCase(key)] = value;
      return obj;
    }, {});
  }
  snakeCase(str) {
    return this.#snakeCase(str);
  }
  camelCase(str) {
    return this.#camelCase(str);
  }
};
function canMap(obj, opt) {
  return isPlainObject(obj) && !(opt == null ? void 0 : opt.maintainNestedObjectKeys);
}

// ../../../node_modules/.pnpm/kysely@0.27.4/node_modules/kysely/dist/esm/plugin/parse-json-results/parse-json-results-plugin.js
init_define_ENV_DEFINED_IN_BUILD_STEP();
var ParseJSONResultsPlugin = class {
  opt;
  #objectStrategy;
  constructor(opt = {}) {
    this.opt = opt;
    this.#objectStrategy = opt.objectStrategy || "in-place";
  }
  // noop
  transformQuery(args) {
    return args.node;
  }
  async transformResult(args) {
    return {
      ...args.result,
      rows: parseArray(args.result.rows, this.#objectStrategy)
    };
  }
};
function parseArray(arr, objectStrategy) {
  const target = objectStrategy === "create" ? new Array(arr.length) : arr;
  for (let i2 = 0; i2 < arr.length; ++i2) {
    target[i2] = parse(arr[i2], objectStrategy);
  }
  return target;
}
function parse(obj, objectStrategy) {
  if (isString(obj)) {
    return parseString(obj);
  }
  if (Array.isArray(obj)) {
    return parseArray(obj, objectStrategy);
  }
  if (isPlainObject(obj)) {
    return parseObject(obj, objectStrategy);
  }
  return obj;
}
function parseString(str) {
  if (maybeJson(str)) {
    try {
      return parse(JSON.parse(str), "in-place");
    } catch (err) {
    }
  }
  return str;
}
function maybeJson(value) {
  return value.match(/^[\[\{]/) != null;
}
function parseObject(obj, objectStrategy) {
  const target = objectStrategy === "create" ? {} : obj;
  for (const key in obj) {
    target[key] = parse(obj[key], objectStrategy);
  }
  return target;
}

// ../../../packages/lix-sdk/dist/query-filter/change-set-element-is-leaf-of.js
init_define_ENV_DEFINED_IN_BUILD_STEP();
function changeSetElementIsLeafOf(target) {
  const targetsArray = Array.isArray(target) ? target : [target];
  if (targetsArray.length === 0) {
    throw new Error("changeSetElementIsLeafOf requires at least one targetChangeSet.");
  }
  const ids = targetsArray.map((cs) => typeof cs === "object" && cs !== null ? cs.id : cs);
  const changeSetIds = ids.map((id) => sql`SELECT ${sql.lit(id)} as id`).reduce((acc, curr) => acc ? sql`${acc} UNION ALL ${curr}` : curr);
  return () => sql`
      -- Element must exist within the combined ancestry
      change_set_element.change_set_id IN (
        WITH RECURSIVE combined_ancestry(id) AS (
          ${changeSetIds}
          UNION -- Use UNION here to combine heads with recursive parent lookup (deduplicates)
          SELECT cse.parent_id
          FROM change_set_edge cse
          JOIN combined_ancestry a ON cse.child_id = a.id
          WHERE cse.parent_id IS NOT NULL
        )
        SELECT id FROM combined_ancestry
      )
      AND
      -- And it must be a leaf within that combined ancestry
      NOT EXISTS (
        WITH RECURSIVE
        -- Combined Ancestry: All change sets from ALL targetChangeSets upwards
        combined_ancestry(id) AS (
          ${changeSetIds}
          UNION -- Use UNION here to combine heads with recursive parent lookup (deduplicates)
          SELECT cse.parent_id
          FROM change_set_edge cse
          JOIN combined_ancestry a ON cse.child_id = a.id
          WHERE cse.parent_id IS NOT NULL
        ),
        -- Descendants: All change sets from the current element's change set downwards
        -- (relative to the element being checked, NOT the target heads)
        descendants(id) AS (
          SELECT change_set_element.change_set_id
          UNION ALL
          SELECT cse.child_id
          FROM change_set_edge cse
          JOIN descendants d ON cse.parent_id = d.id
        )
        -- Check for a newer element defining the same entity
        SELECT 1
        FROM change_set_element AS newer_cse
        WHERE
          -- Same entity definition
          newer_cse.entity_id = change_set_element.entity_id
          AND newer_cse.file_id = change_set_element.file_id
          AND newer_cse.schema_key = change_set_element.schema_key
          -- Different element instance
          AND (newer_cse.change_set_id != change_set_element.change_set_id 
               OR newer_cse.change_id != change_set_element.change_id)
          -- Newer element must be in the combined ancestry of the target change sets
          AND newer_cse.change_set_id IN (SELECT id FROM combined_ancestry)
          -- Newer element's change set must be a descendant of the current element's change set
          AND newer_cse.change_set_id IN (SELECT id FROM descendants)
      )
    `;
}

// ../../../packages/lix-sdk/dist/own-change-control/change-controlled-tables.js
init_define_ENV_DEFINED_IN_BUILD_STEP();
var changeControlledTableIds = {
  account: ["id"],
  // change_proposal: ["id"],
  change_set: ["id"],
  // Change author should be change controlled but
  // breaking the trigger loop turned out to be difficult.
  //
  // For the sake of getting lix v0.5 out, authors are not
  // change controlled. A future update should address this.
  // change_author: ["change_id", "account_id"],
  thread: ["id"],
  thread_comment: ["id"],
  change_set_label: ["change_set_id", "label_id"],
  change_set_thread: ["change_set_id", "thread_id"],
  file: ["id"],
  label: ["id"],
  key_value: ["key"]
  // version: ["id"],
  // version_change: ["version_id", "change_id"],
};
function entityIdForRow(tableName, ...values) {
  let entityId = "";
  const primaryKeyColumns = changeControlledTableIds[tableName];
  if (primaryKeyColumns.length === 1) {
    if (!values[0]) {
      throw new Error(`entityIdForRow: Missing value for single key in table '${tableName}'.`);
    }
    entityId = values[0];
  } else {
    const keyValues = [];
    for (let i2 = 0; i2 < primaryKeyColumns.length; i2++) {
      if (!values[i2]) {
        throw new Error(`entityIdForRow: Missing value for compound key part '${primaryKeyColumns[i2]}' in table '${tableName}' at index ${i2}.`);
      }
      keyValues.push(values[i2]);
    }
    entityId = keyValues.join(",");
  }
  return entityId;
}

// ../../../packages/lix-sdk/dist/query-filter/change-set-is-ancestor-of.js
init_define_ENV_DEFINED_IN_BUILD_STEP();
function changeSetIsAncestorOf(changeSet, options) {
  const depthLimit = options == null ? void 0 : options.depth;
  const includeSelf = (options == null ? void 0 : options.includeSelf) ?? false;
  return () => sql`
			change_set.id IN (
				WITH RECURSIVE ap(id, depth) AS (
					SELECT id, 0 AS depth FROM change_set WHERE id = ${sql.lit(changeSet.id)}
					UNION ALL
					SELECT change_set_edge.parent_id, ap.depth + 1
					FROM change_set_edge
					JOIN ap ON change_set_edge.child_id = ap.id
					${depthLimit !== void 0 ? sql`WHERE ap.depth < ${sql.lit(depthLimit)}` : sql``}
				)
				-- Select based on the includeSelf flag
				SELECT id FROM ap ${includeSelf ? sql`` : sql`WHERE depth > 0`}
			)
		`;
}

// ../../../packages/lix-sdk/dist/change-set-edge/database-schema.js
init_define_ENV_DEFINED_IN_BUILD_STEP();
function applyChangeSetEdgeDatabaseSchema(sqlite2) {
  const sql2 = `
    CREATE TABLE IF NOT EXISTS change_set_edge (
      parent_id TEXT NOT NULL,
      child_id TEXT NOT NULL,

      PRIMARY KEY (parent_id, child_id),

      FOREIGN KEY(parent_id) REFERENCES change_set(id) ON DELETE CASCADE,
      FOREIGN KEY(child_id) REFERENCES change_set(id) ON DELETE CASCADE,

      -- Prevent self referencing edges
      CHECK (parent_id != child_id)
    ) STRICT;

    -- Trigger to enforce that edges can only connect immutable change sets
    CREATE TRIGGER IF NOT EXISTS enforce_immutable_edge_creation
    BEFORE INSERT ON change_set_edge
    FOR EACH ROW
    WHEN
      (SELECT immutable_elements FROM change_set WHERE id = NEW.parent_id) = 0 OR
      (SELECT immutable_elements FROM change_set WHERE id = NEW.child_id) = 0
    BEGIN
      SELECT RAISE(ABORT, 'Change set edges can only be created between change sets with immutable elements.');
    END;
  `;
  return sqlite2.exec(sql2);
}

// ../../../packages/lix-sdk/dist/log/database-schema.js
init_define_ENV_DEFINED_IN_BUILD_STEP();
function applyLogDatabaseSchema(sqlite2) {
  return sqlite2.exec`
	CREATE TABLE IF NOT EXISTS log (
		key TEXT,
		message TEXT,
		level TEXT,
		created_at TEXT DEFAULT CURRENT_TIMESTAMP NOT NULL
	) STRICT;

	-- Garbage collect old logs (can be more sophisticated in the future)
	DELETE FROM log WHERE created_at < datetime('now', '-1 day');
`;
}

// ../../../packages/lix-sdk/dist/key-value/database-schema.js
init_define_ENV_DEFINED_IN_BUILD_STEP();
function applyKeyValueDatabaseSchema(sqlite2) {
  return sqlite2.exec`
	CREATE TABLE IF NOT EXISTS key_value (
		key TEXT PRIMARY KEY,
		value BLOB NOT NULL, --JSONB

		-- Options
		skip_change_control INT DEFAULT FALSE
	) STRICT;

	INSERT OR IGNORE INTO key_value (key, value)
	VALUES ('lix_id', jsonb(json_quote(nano_id(18))));

	-- default value for lix sync to false
	-- if not exist to remove conditional logic
	-- if the key exists or not
	INSERT OR IGNORE INTO key_value (key, value, skip_change_control)
	VALUES ('lix_sync', jsonb(json_quote('false')), 1);
`;
}

// ../../../node_modules/.pnpm/kysely@0.27.4/node_modules/kysely/dist/esm/helpers/sqlite.js
init_define_ENV_DEFINED_IN_BUILD_STEP();

// ../../../node_modules/.pnpm/kysely@0.27.4/node_modules/kysely/dist/esm/util/json-object-args.js
init_define_ENV_DEFINED_IN_BUILD_STEP();
function getJsonObjectArgs(node, table) {
  const args = [];
  for (const { selection: s2 } of node.selections ?? []) {
    if (ReferenceNode.is(s2) && ColumnNode.is(s2.column)) {
      args.push(colName(s2.column.column.name), colRef(table, s2.column.column.name));
    } else if (ColumnNode.is(s2)) {
      args.push(colName(s2.column.name), colRef(table, s2.column.name));
    } else if (AliasNode.is(s2) && IdentifierNode.is(s2.alias)) {
      args.push(colName(s2.alias.name), colRef(table, s2.alias.name));
    } else {
      throw new Error(`can't extract column names from the select query node`);
    }
  }
  return args;
}
function colName(col) {
  return new ExpressionWrapper(ValueNode.createImmediate(col));
}
function colRef(table, col) {
  return new ExpressionWrapper(ReferenceNode.create(ColumnNode.create(col), TableNode.create(table)));
}

// ../../../node_modules/.pnpm/kysely@0.27.4/node_modules/kysely/dist/esm/helpers/sqlite.js
function jsonArrayFrom(expr) {
  return sql`(select coalesce(json_group_array(json_object(${sql.join(getSqliteJsonObjectArgs(expr.toOperationNode(), "agg"))})), '[]') from ${expr} as agg)`;
}
function getSqliteJsonObjectArgs(node, table) {
  try {
    return getJsonObjectArgs(node, table);
  } catch {
    throw new Error("SQLite jsonArrayFrom and jsonObjectFrom functions can only handle explicit selections due to limitations of the json_object function. selectAll() is not allowed in the subquery.");
  }
}

// ../../../packages/lix-sdk/dist/file-queue/database-schema.js
init_define_ENV_DEFINED_IN_BUILD_STEP();
function applyFileQueueDatabaseSchema(sqlite2) {
  return sqlite2.exec`
  CREATE TABLE IF NOT EXISTS file_queue (
      id INTEGER PRIMARY KEY AUTOINCREMENT,
      file_id TEXT NOT NULL,
      data_before BLOB,
      data_after BLOB,
      path_before TEXT,
      path_after TEXT,
      metadata_before BLOB,
      metadata_after BLOB
    ) STRICT;
  
    CREATE TRIGGER IF NOT EXISTS file_insert AFTER INSERT ON file
    WHEN NOT EXISTS (SELECT 1 FROM key_value WHERE key = 'lix_skip_file_queue')
    BEGIN
      INSERT INTO file_queue(
        file_id, path_after, data_after, metadata_after
      )
      VALUES (
        NEW.id, NEW.path, NEW.data, NEW.metadata
      );
      SELECT triggerFileQueue();
    END;
  
    CREATE TRIGGER IF NOT EXISTS file_update AFTER UPDATE ON file
    WHEN NOT EXISTS (SELECT 1 FROM key_value WHERE key = 'lix_skip_file_queue')
    BEGIN
      INSERT INTO file_queue(
        file_id, 
        path_before, data_before, metadata_before, 
        path_after, data_after, metadata_after
      )
  
      VALUES (
        NEW.id, 
        OLD.path, OLD.data, OLD.metadata,
        NEW.path, NEW.data, NEW.metadata
      );
  
      SELECT triggerFileQueue();
    END;
  
    CREATE TRIGGER IF NOT EXISTS file_delete BEFORE DELETE ON file
    WHEN NOT EXISTS (SELECT 1 FROM key_value WHERE key = 'lix_skip_file_queue')
    BEGIN
      INSERT INTO file_queue(file_id)
      VALUES (OLD.id);
      SELECT triggerFileQueue();
    END;
  `;
}

// ../../../packages/lix-sdk/dist/file/database-schema.js
init_define_ENV_DEFINED_IN_BUILD_STEP();

// ../../../packages/lix-sdk/dist/file/validate-file-path.js
init_define_ENV_DEFINED_IN_BUILD_STEP();
function validateFilePath(path2) {
  if (path2.length === 0) {
    throw new Error("File path must not be empty.");
  }
  if (path2[0] !== "/") {
    throw new Error("File path must start with a slash.\n\nFiles must start with a root slash to identify the path as root.");
  }
  if (path2.endsWith("/")) {
    throw new Error("File path must not end with a slash.\n\nEnding a file with a slash leads to ambiguity whether or not the path is a directory or a file.");
  }
  if (path2.includes("//")) {
    throw new Error("File path must not contain consecutive slashes.\n\nConsecutive slashes lead to ambiguity whether or not the path is a directory or a file.");
  }
  if (path2.includes("\\")) {
    throw new Error("File path must not contain backslashes.\n\nThe restriction might be loosened in the future.");
  }
}

// ../../../packages/lix-sdk/dist/file/database-schema.js
function applyFileDatabaseSchema(sqlite2) {
  sqlite2.createFunction({
    name: "is_valid_file_path",
    arity: 1,
    xFunc: (_ctx, value) => {
      return validateFilePath(value);
    },
    deterministic: true
  });
  sqlite2.exec(`
  -- file
  CREATE TABLE IF NOT EXISTS file (
    id TEXT PRIMARY KEY DEFAULT (nano_id(10)),
    path TEXT NOT NULL UNIQUE,
    data BLOB NOT NULL,
    metadata BLOB,
    CHECK (is_valid_file_path(path))
  ) STRICT;
`);
  return sqlite2;
}

// ../../../packages/lix-sdk/dist/lix/index.js
init_define_ENV_DEFINED_IN_BUILD_STEP();

// ../../../packages/lix-sdk/dist/lix/open-lix.js
init_define_ENV_DEFINED_IN_BUILD_STEP();

// ../../../packages/sqlite-wasm-kysely/dist/index.js
init_define_ENV_DEFINED_IN_BUILD_STEP();

// ../../../packages/sqlite-wasm-kysely/dist/util/index.js
init_define_ENV_DEFINED_IN_BUILD_STEP();

// ../../../packages/sqlite-wasm-kysely/dist/util/contentFromDatabase.js
init_define_ENV_DEFINED_IN_BUILD_STEP();
var contentFromDatabase = (db) => {
  return db.sqlite3.capi.sqlite3_js_db_export(db);
};

// ../../../packages/sqlite-wasm-kysely/dist/util/createInMemoryDatabase.js
init_define_ENV_DEFINED_IN_BUILD_STEP();

// ../../../node_modules/.pnpm/@sqlite.org+sqlite-wasm@3.48.0-build4/node_modules/@sqlite.org/sqlite-wasm/index.mjs
init_define_ENV_DEFINED_IN_BUILD_STEP();

// ../../../node_modules/.pnpm/@sqlite.org+sqlite-wasm@3.48.0-build4/node_modules/@sqlite.org/sqlite-wasm/sqlite-wasm/jswasm/sqlite3-bundler-friendly.mjs
init_define_ENV_DEFINED_IN_BUILD_STEP();
var sqlite3InitModule = (() => {
  var _scriptName = import.meta.url;
  return function(moduleArg = {}) {
    var moduleRtn;
    var Module2 = moduleArg;
    var readyPromiseResolve, readyPromiseReject;
    var readyPromise = new Promise((resolve2, reject) => {
      readyPromiseResolve = resolve2;
      readyPromiseReject = reject;
    });
    var ENVIRONMENT_IS_WEB = typeof window == "object";
    var ENVIRONMENT_IS_WORKER = typeof importScripts == "function";
    var ENVIRONMENT_IS_NODE = typeof process == "object" && typeof process.versions == "object" && typeof process.versions.node == "string" && process.type != "renderer";
    var ENVIRONMENT_IS_SHELL = !ENVIRONMENT_IS_WEB && !ENVIRONMENT_IS_NODE && !ENVIRONMENT_IS_WORKER;
    const sqlite3InitModuleState = globalThis.sqlite3InitModuleState || Object.assign(/* @__PURE__ */ Object.create(null), {
      debugModule: () => {
      }
    });
    delete globalThis.sqlite3InitModuleState;
    sqlite3InitModuleState.debugModule(
      "globalThis.location =",
      globalThis.location
    );
    var moduleOverrides = Object.assign({}, Module2);
    var arguments_ = [];
    var thisProgram = "./this.program";
    var quit_ = (status, toThrow) => {
      throw toThrow;
    };
    var scriptDirectory = "";
    function locateFile(path2) {
      if (Module2["locateFile"]) {
        return Module2["locateFile"](path2, scriptDirectory);
      }
      return scriptDirectory + path2;
    }
    var readAsync, readBinary;
    if (ENVIRONMENT_IS_WEB || ENVIRONMENT_IS_WORKER) {
      if (ENVIRONMENT_IS_WORKER) {
        scriptDirectory = self.location.href;
      } else if (typeof document != "undefined" && document.currentScript) {
        scriptDirectory = document.currentScript.src;
      }
      if (_scriptName) {
        scriptDirectory = _scriptName;
      }
      if (scriptDirectory.startsWith("blob:")) {
        scriptDirectory = "";
      } else {
        scriptDirectory = scriptDirectory.substr(
          0,
          scriptDirectory.replace(/[?#].*/, "").lastIndexOf("/") + 1
        );
      }
      {
        if (ENVIRONMENT_IS_WORKER) {
          readBinary = (url) => {
            var xhr = new XMLHttpRequest();
            xhr.open("GET", url, false);
            xhr.responseType = "arraybuffer";
            xhr.send(null);
            return new Uint8Array(xhr.response);
          };
        }
        readAsync = (url) => {
          return fetch(url, { credentials: "same-origin" }).then((response) => {
            if (response.ok) {
              return response.arrayBuffer();
            }
            return Promise.reject(
              new Error(response.status + " : " + response.url)
            );
          });
        };
      }
    } else {
    }
    var out = Module2["print"] || console.log.bind(console);
    var err = Module2["printErr"] || console.error.bind(console);
    Object.assign(Module2, moduleOverrides);
    moduleOverrides = null;
    if (Module2["arguments"])
      arguments_ = Module2["arguments"];
    if (Module2["thisProgram"])
      thisProgram = Module2["thisProgram"];
    var wasmBinary2 = Module2["wasmBinary"];
    var wasmMemory;
    var ABORT = false;
    var EXITSTATUS;
    function assert(condition, text) {
      if (!condition) {
        abort(text);
      }
    }
    var HEAP, HEAP8, HEAPU8, HEAP16, HEAPU16, HEAP32, HEAPU32, HEAPF32, HEAP64, HEAPU64, HEAPF64;
    function updateMemoryViews() {
      var b = wasmMemory.buffer;
      Module2["HEAP8"] = HEAP8 = new Int8Array(b);
      Module2["HEAP16"] = HEAP16 = new Int16Array(b);
      Module2["HEAPU8"] = HEAPU8 = new Uint8Array(b);
      Module2["HEAPU16"] = HEAPU16 = new Uint16Array(b);
      Module2["HEAP32"] = HEAP32 = new Int32Array(b);
      Module2["HEAPU32"] = HEAPU32 = new Uint32Array(b);
      Module2["HEAPF32"] = HEAPF32 = new Float32Array(b);
      Module2["HEAPF64"] = HEAPF64 = new Float64Array(b);
      Module2["HEAP64"] = HEAP64 = new BigInt64Array(b);
      Module2["HEAPU64"] = HEAPU64 = new BigUint64Array(b);
    }
    if (Module2["wasmMemory"]) {
      wasmMemory = Module2["wasmMemory"];
    } else {
      var INITIAL_MEMORY = Module2["INITIAL_MEMORY"] || 16777216;
      wasmMemory = new WebAssembly.Memory({
        initial: INITIAL_MEMORY / 65536,
        maximum: 32768
      });
    }
    updateMemoryViews();
    var __ATPRERUN__ = [];
    var __ATINIT__ = [];
    var __ATEXIT__ = [];
    var __ATPOSTRUN__ = [];
    var runtimeInitialized = false;
    function preRun() {
      var preRuns = Module2["preRun"];
      if (preRuns) {
        if (typeof preRuns == "function")
          preRuns = [preRuns];
        preRuns.forEach(addOnPreRun);
      }
      callRuntimeCallbacks(__ATPRERUN__);
    }
    function initRuntime() {
      runtimeInitialized = true;
      if (!Module2["noFSInit"] && !FS.initialized)
        FS.init();
      FS.ignorePermissions = false;
      TTY.init();
      callRuntimeCallbacks(__ATINIT__);
    }
    function postRun() {
      var postRuns = Module2["postRun"];
      if (postRuns) {
        if (typeof postRuns == "function")
          postRuns = [postRuns];
        postRuns.forEach(addOnPostRun);
      }
      callRuntimeCallbacks(__ATPOSTRUN__);
    }
    function addOnPreRun(cb) {
      __ATPRERUN__.unshift(cb);
    }
    function addOnInit(cb) {
      __ATINIT__.unshift(cb);
    }
    function addOnExit(cb) {
    }
    function addOnPostRun(cb) {
      __ATPOSTRUN__.unshift(cb);
    }
    var runDependencies = 0;
    var runDependencyWatcher = null;
    var dependenciesFulfilled = null;
    function getUniqueRunDependency(id) {
      return id;
    }
    function addRunDependency(id) {
      var _a8;
      runDependencies++;
      (_a8 = Module2["monitorRunDependencies"]) == null ? void 0 : _a8.call(Module2, runDependencies);
    }
    function removeRunDependency(id) {
      var _a8;
      runDependencies--;
      (_a8 = Module2["monitorRunDependencies"]) == null ? void 0 : _a8.call(Module2, runDependencies);
      if (runDependencies == 0) {
        if (runDependencyWatcher !== null) {
          clearInterval(runDependencyWatcher);
          runDependencyWatcher = null;
        }
        if (dependenciesFulfilled) {
          var callback = dependenciesFulfilled;
          dependenciesFulfilled = null;
          callback();
        }
      }
    }
    function abort(what) {
      var _a8;
      (_a8 = Module2["onAbort"]) == null ? void 0 : _a8.call(Module2, what);
      what = "Aborted(" + what + ")";
      err(what);
      ABORT = true;
      what += ". Build with -sASSERTIONS for more info.";
      var e2 = new WebAssembly.RuntimeError(what);
      readyPromiseReject(e2);
      throw e2;
    }
    var dataURIPrefix = "data:application/octet-stream;base64,";
    var isDataURI = (filename) => filename.startsWith(dataURIPrefix);
    var isFileURI = (filename) => filename.startsWith("file://");
    function findWasmBinary() {
      if (Module2["locateFile"]) {
        var f2 = "sqlite3.wasm";
        if (!isDataURI(f2)) {
          return locateFile(f2);
        }
        return f2;
      }
      return new URL("sqlite3.wasm", import.meta.url).href;
    }
    var wasmBinaryFile;
    function getBinarySync(file) {
      if (file == wasmBinaryFile && wasmBinary2) {
        return new Uint8Array(wasmBinary2);
      }
      if (readBinary) {
        return readBinary(file);
      }
      throw "both async and sync fetching of the wasm failed";
    }
    function getBinaryPromise(binaryFile) {
      if (!wasmBinary2) {
        return readAsync(binaryFile).then(
          (response) => new Uint8Array(response),
          () => getBinarySync(binaryFile)
        );
      }
      return Promise.resolve().then(() => getBinarySync(binaryFile));
    }
    function instantiateArrayBuffer(binaryFile, imports, receiver) {
      return getBinaryPromise(binaryFile).then((binary) => {
        return WebAssembly.instantiate(binary, imports);
      }).then(receiver, (reason) => {
        err(`failed to asynchronously prepare wasm: ${reason}`);
        abort(reason);
      });
    }
    function instantiateAsync(binary, binaryFile, imports, callback) {
      if (!binary && typeof WebAssembly.instantiateStreaming == "function" && !isDataURI(binaryFile) && typeof fetch == "function") {
        return fetch(binaryFile, { credentials: "same-origin" }).then(
          (response) => {
            var result = WebAssembly.instantiateStreaming(response, imports);
            return result.then(callback, function(reason) {
              err(`wasm streaming compile failed: ${reason}`);
              err("falling back to ArrayBuffer instantiation");
              return instantiateArrayBuffer(binaryFile, imports, callback);
            });
          }
        );
      }
      return instantiateArrayBuffer(binaryFile, imports, callback);
    }
    function getWasmImports() {
      return {
        env: wasmImports,
        wasi_snapshot_preview1: wasmImports
      };
    }
    function createWasm() {
      var info = getWasmImports();
      function receiveInstance(instance, module) {
        wasmExports = instance.exports;
        addOnInit(wasmExports["__wasm_call_ctors"]);
        removeRunDependency("wasm-instantiate");
        return wasmExports;
      }
      addRunDependency("wasm-instantiate");
      function receiveInstantiationResult(result) {
        receiveInstance(result["instance"]);
      }
      if (Module2["instantiateWasm"]) {
        try {
          return Module2["instantiateWasm"](info, receiveInstance);
        } catch (e2) {
          err(`Module.instantiateWasm callback failed with error: ${e2}`);
          readyPromiseReject(e2);
        }
      }
      wasmBinaryFile ??= findWasmBinary();
      instantiateAsync(
        wasmBinary2,
        wasmBinaryFile,
        info,
        receiveInstantiationResult
      ).catch(readyPromiseReject);
      return {};
    }
    function ExitStatus(status) {
      this.name = "ExitStatus";
      this.message = `Program terminated with exit(${status})`;
      this.status = status;
    }
    var callRuntimeCallbacks = (callbacks) => {
      callbacks.forEach((f2) => f2(Module2));
    };
    function getValue(ptr, type = "i8") {
      if (type.endsWith("*"))
        type = "*";
      switch (type) {
        case "i1":
          return HEAP8[ptr];
        case "i8":
          return HEAP8[ptr];
        case "i16":
          return HEAP16[ptr >> 1];
        case "i32":
          return HEAP32[ptr >> 2];
        case "i64":
          return HEAP64[ptr >> 3];
        case "float":
          return HEAPF32[ptr >> 2];
        case "double":
          return HEAPF64[ptr >> 3];
        case "*":
          return HEAPU32[ptr >> 2];
        default:
          abort(`invalid type for getValue: ${type}`);
      }
    }
    var noExitRuntime = Module2["noExitRuntime"] || true;
    function setValue(ptr, value, type = "i8") {
      if (type.endsWith("*"))
        type = "*";
      switch (type) {
        case "i1":
          HEAP8[ptr] = value;
          break;
        case "i8":
          HEAP8[ptr] = value;
          break;
        case "i16":
          HEAP16[ptr >> 1] = value;
          break;
        case "i32":
          HEAP32[ptr >> 2] = value;
          break;
        case "i64":
          HEAP64[ptr >> 3] = BigInt(value);
          break;
        case "float":
          HEAPF32[ptr >> 2] = value;
          break;
        case "double":
          HEAPF64[ptr >> 3] = value;
          break;
        case "*":
          HEAPU32[ptr >> 2] = value;
          break;
        default:
          abort(`invalid type for setValue: ${type}`);
      }
    }
    var stackRestore = (val) => __emscripten_stack_restore(val);
    var stackSave = () => _emscripten_stack_get_current();
    var PATH = {
      isAbs: (path2) => path2.charAt(0) === "/",
      splitPath: (filename) => {
        var splitPathRe = /^(\/?|)([\s\S]*?)((?:\.{1,2}|[^\/]+?|)(\.[^.\/]*|))(?:[\/]*)$/;
        return splitPathRe.exec(filename).slice(1);
      },
      normalizeArray: (parts, allowAboveRoot) => {
        var up = 0;
        for (var i2 = parts.length - 1; i2 >= 0; i2--) {
          var last = parts[i2];
          if (last === ".") {
            parts.splice(i2, 1);
          } else if (last === "..") {
            parts.splice(i2, 1);
            up++;
          } else if (up) {
            parts.splice(i2, 1);
            up--;
          }
        }
        if (allowAboveRoot) {
          for (; up; up--) {
            parts.unshift("..");
          }
        }
        return parts;
      },
      normalize: (path2) => {
        var isAbsolute = PATH.isAbs(path2), trailingSlash = path2.substr(-1) === "/";
        path2 = PATH.normalizeArray(
          path2.split("/").filter((p3) => !!p3),
          !isAbsolute
        ).join("/");
        if (!path2 && !isAbsolute) {
          path2 = ".";
        }
        if (path2 && trailingSlash) {
          path2 += "/";
        }
        return (isAbsolute ? "/" : "") + path2;
      },
      dirname: (path2) => {
        var result = PATH.splitPath(path2), root = result[0], dir = result[1];
        if (!root && !dir) {
          return ".";
        }
        if (dir) {
          dir = dir.substr(0, dir.length - 1);
        }
        return root + dir;
      },
      basename: (path2) => {
        if (path2 === "/")
          return "/";
        path2 = PATH.normalize(path2);
        path2 = path2.replace(/\/$/, "");
        var lastSlash = path2.lastIndexOf("/");
        if (lastSlash === -1)
          return path2;
        return path2.substr(lastSlash + 1);
      },
      join: (...paths) => PATH.normalize(paths.join("/")),
      join2: (l2, r3) => PATH.normalize(l2 + "/" + r3)
    };
    var initRandomFill = () => {
      if (typeof crypto == "object" && typeof crypto["getRandomValues"] == "function") {
        return (view) => crypto.getRandomValues(view);
      } else
        abort("initRandomDevice");
    };
    var randomFill = (view) => {
      return (randomFill = initRandomFill())(view);
    };
    var PATH_FS = {
      resolve: (...args) => {
        var resolvedPath = "", resolvedAbsolute = false;
        for (var i2 = args.length - 1; i2 >= -1 && !resolvedAbsolute; i2--) {
          var path2 = i2 >= 0 ? args[i2] : FS.cwd();
          if (typeof path2 != "string") {
            throw new TypeError("Arguments to path.resolve must be strings");
          } else if (!path2) {
            return "";
          }
          resolvedPath = path2 + "/" + resolvedPath;
          resolvedAbsolute = PATH.isAbs(path2);
        }
        resolvedPath = PATH.normalizeArray(
          resolvedPath.split("/").filter((p3) => !!p3),
          !resolvedAbsolute
        ).join("/");
        return (resolvedAbsolute ? "/" : "") + resolvedPath || ".";
      },
      relative: (from, to) => {
        from = PATH_FS.resolve(from).substr(1);
        to = PATH_FS.resolve(to).substr(1);
        function trim4(arr) {
          var start = 0;
          for (; start < arr.length; start++) {
            if (arr[start] !== "")
              break;
          }
          var end = arr.length - 1;
          for (; end >= 0; end--) {
            if (arr[end] !== "")
              break;
          }
          if (start > end)
            return [];
          return arr.slice(start, end - start + 1);
        }
        var fromParts = trim4(from.split("/"));
        var toParts = trim4(to.split("/"));
        var length = Math.min(fromParts.length, toParts.length);
        var samePartsLength = length;
        for (var i2 = 0; i2 < length; i2++) {
          if (fromParts[i2] !== toParts[i2]) {
            samePartsLength = i2;
            break;
          }
        }
        var outputParts = [];
        for (var i2 = samePartsLength; i2 < fromParts.length; i2++) {
          outputParts.push("..");
        }
        outputParts = outputParts.concat(toParts.slice(samePartsLength));
        return outputParts.join("/");
      }
    };
    var UTF8Decoder = typeof TextDecoder != "undefined" ? new TextDecoder() : void 0;
    var UTF8ArrayToString = (heapOrArray, idx = 0, maxBytesToRead = NaN) => {
      var endIdx = idx + maxBytesToRead;
      var endPtr = idx;
      while (heapOrArray[endPtr] && !(endPtr >= endIdx))
        ++endPtr;
      if (endPtr - idx > 16 && heapOrArray.buffer && UTF8Decoder) {
        return UTF8Decoder.decode(heapOrArray.subarray(idx, endPtr));
      }
      var str = "";
      while (idx < endPtr) {
        var u0 = heapOrArray[idx++];
        if (!(u0 & 128)) {
          str += String.fromCharCode(u0);
          continue;
        }
        var u1 = heapOrArray[idx++] & 63;
        if ((u0 & 224) == 192) {
          str += String.fromCharCode((u0 & 31) << 6 | u1);
          continue;
        }
        var u22 = heapOrArray[idx++] & 63;
        if ((u0 & 240) == 224) {
          u0 = (u0 & 15) << 12 | u1 << 6 | u22;
        } else {
          u0 = (u0 & 7) << 18 | u1 << 12 | u22 << 6 | heapOrArray[idx++] & 63;
        }
        if (u0 < 65536) {
          str += String.fromCharCode(u0);
        } else {
          var ch = u0 - 65536;
          str += String.fromCharCode(
            55296 | ch >> 10,
            56320 | ch & 1023
          );
        }
      }
      return str;
    };
    var FS_stdin_getChar_buffer = [];
    var lengthBytesUTF8 = (str) => {
      var len = 0;
      for (var i2 = 0; i2 < str.length; ++i2) {
        var c3 = str.charCodeAt(i2);
        if (c3 <= 127) {
          len++;
        } else if (c3 <= 2047) {
          len += 2;
        } else if (c3 >= 55296 && c3 <= 57343) {
          len += 4;
          ++i2;
        } else {
          len += 3;
        }
      }
      return len;
    };
    var stringToUTF8Array = (str, heap, outIdx, maxBytesToWrite) => {
      if (!(maxBytesToWrite > 0))
        return 0;
      var startIdx = outIdx;
      var endIdx = outIdx + maxBytesToWrite - 1;
      for (var i2 = 0; i2 < str.length; ++i2) {
        var u3 = str.charCodeAt(i2);
        if (u3 >= 55296 && u3 <= 57343) {
          var u1 = str.charCodeAt(++i2);
          u3 = 65536 + ((u3 & 1023) << 10) | u1 & 1023;
        }
        if (u3 <= 127) {
          if (outIdx >= endIdx)
            break;
          heap[outIdx++] = u3;
        } else if (u3 <= 2047) {
          if (outIdx + 1 >= endIdx)
            break;
          heap[outIdx++] = 192 | u3 >> 6;
          heap[outIdx++] = 128 | u3 & 63;
        } else if (u3 <= 65535) {
          if (outIdx + 2 >= endIdx)
            break;
          heap[outIdx++] = 224 | u3 >> 12;
          heap[outIdx++] = 128 | u3 >> 6 & 63;
          heap[outIdx++] = 128 | u3 & 63;
        } else {
          if (outIdx + 3 >= endIdx)
            break;
          heap[outIdx++] = 240 | u3 >> 18;
          heap[outIdx++] = 128 | u3 >> 12 & 63;
          heap[outIdx++] = 128 | u3 >> 6 & 63;
          heap[outIdx++] = 128 | u3 & 63;
        }
      }
      heap[outIdx] = 0;
      return outIdx - startIdx;
    };
    function intArrayFromString(stringy, dontAddNull, length) {
      var len = length > 0 ? length : lengthBytesUTF8(stringy) + 1;
      var u8array = new Array(len);
      var numBytesWritten = stringToUTF8Array(
        stringy,
        u8array,
        0,
        u8array.length
      );
      if (dontAddNull)
        u8array.length = numBytesWritten;
      return u8array;
    }
    var FS_stdin_getChar = () => {
      if (!FS_stdin_getChar_buffer.length) {
        var result = null;
        if (typeof window != "undefined" && typeof window.prompt == "function") {
          result = window.prompt("Input: ");
          if (result !== null) {
            result += "\n";
          }
        } else {
        }
        if (!result) {
          return null;
        }
        FS_stdin_getChar_buffer = intArrayFromString(result, true);
      }
      return FS_stdin_getChar_buffer.shift();
    };
    var TTY = {
      ttys: [],
      init() {
      },
      shutdown() {
      },
      register(dev, ops) {
        TTY.ttys[dev] = { input: [], output: [], ops };
        FS.registerDevice(dev, TTY.stream_ops);
      },
      stream_ops: {
        open(stream) {
          var tty2 = TTY.ttys[stream.node.rdev];
          if (!tty2) {
            throw new FS.ErrnoError(43);
          }
          stream.tty = tty2;
          stream.seekable = false;
        },
        close(stream) {
          stream.tty.ops.fsync(stream.tty);
        },
        fsync(stream) {
          stream.tty.ops.fsync(stream.tty);
        },
        read(stream, buffer, offset, length, pos) {
          if (!stream.tty || !stream.tty.ops.get_char) {
            throw new FS.ErrnoError(60);
          }
          var bytesRead = 0;
          for (var i2 = 0; i2 < length; i2++) {
            var result;
            try {
              result = stream.tty.ops.get_char(stream.tty);
            } catch (e2) {
              throw new FS.ErrnoError(29);
            }
            if (result === void 0 && bytesRead === 0) {
              throw new FS.ErrnoError(6);
            }
            if (result === null || result === void 0)
              break;
            bytesRead++;
            buffer[offset + i2] = result;
          }
          if (bytesRead) {
            stream.node.timestamp = Date.now();
          }
          return bytesRead;
        },
        write(stream, buffer, offset, length, pos) {
          if (!stream.tty || !stream.tty.ops.put_char) {
            throw new FS.ErrnoError(60);
          }
          try {
            for (var i2 = 0; i2 < length; i2++) {
              stream.tty.ops.put_char(stream.tty, buffer[offset + i2]);
            }
          } catch (e2) {
            throw new FS.ErrnoError(29);
          }
          if (length) {
            stream.node.timestamp = Date.now();
          }
          return i2;
        }
      },
      default_tty_ops: {
        get_char(tty2) {
          return FS_stdin_getChar();
        },
        put_char(tty2, val) {
          if (val === null || val === 10) {
            out(UTF8ArrayToString(tty2.output));
            tty2.output = [];
          } else {
            if (val != 0)
              tty2.output.push(val);
          }
        },
        fsync(tty2) {
          if (tty2.output && tty2.output.length > 0) {
            out(UTF8ArrayToString(tty2.output));
            tty2.output = [];
          }
        },
        ioctl_tcgets(tty2) {
          return {
            c_iflag: 25856,
            c_oflag: 5,
            c_cflag: 191,
            c_lflag: 35387,
            c_cc: [
              3,
              28,
              127,
              21,
              4,
              0,
              1,
              0,
              17,
              19,
              26,
              0,
              18,
              15,
              23,
              22,
              0,
              0,
              0,
              0,
              0,
              0,
              0,
              0,
              0,
              0,
              0,
              0,
              0,
              0,
              0,
              0
            ]
          };
        },
        ioctl_tcsets(tty2, optional_actions, data) {
          return 0;
        },
        ioctl_tiocgwinsz(tty2) {
          return [24, 80];
        }
      },
      default_tty1_ops: {
        put_char(tty2, val) {
          if (val === null || val === 10) {
            err(UTF8ArrayToString(tty2.output));
            tty2.output = [];
          } else {
            if (val != 0)
              tty2.output.push(val);
          }
        },
        fsync(tty2) {
          if (tty2.output && tty2.output.length > 0) {
            err(UTF8ArrayToString(tty2.output));
            tty2.output = [];
          }
        }
      }
    };
    var zeroMemory = (address, size) => {
      HEAPU8.fill(0, address, address + size);
    };
    var alignMemory = (size, alignment) => {
      return Math.ceil(size / alignment) * alignment;
    };
    var mmapAlloc = (size) => {
      size = alignMemory(size, 65536);
      var ptr = _emscripten_builtin_memalign(65536, size);
      if (ptr)
        zeroMemory(ptr, size);
      return ptr;
    };
    var MEMFS = {
      ops_table: null,
      mount(mount) {
        return MEMFS.createNode(null, "/", 16384 | 511, 0);
      },
      createNode(parent, name, mode, dev) {
        if (FS.isBlkdev(mode) || FS.isFIFO(mode)) {
          throw new FS.ErrnoError(63);
        }
        MEMFS.ops_table ||= {
          dir: {
            node: {
              getattr: MEMFS.node_ops.getattr,
              setattr: MEMFS.node_ops.setattr,
              lookup: MEMFS.node_ops.lookup,
              mknod: MEMFS.node_ops.mknod,
              rename: MEMFS.node_ops.rename,
              unlink: MEMFS.node_ops.unlink,
              rmdir: MEMFS.node_ops.rmdir,
              readdir: MEMFS.node_ops.readdir,
              symlink: MEMFS.node_ops.symlink
            },
            stream: {
              llseek: MEMFS.stream_ops.llseek
            }
          },
          file: {
            node: {
              getattr: MEMFS.node_ops.getattr,
              setattr: MEMFS.node_ops.setattr
            },
            stream: {
              llseek: MEMFS.stream_ops.llseek,
              read: MEMFS.stream_ops.read,
              write: MEMFS.stream_ops.write,
              allocate: MEMFS.stream_ops.allocate,
              mmap: MEMFS.stream_ops.mmap,
              msync: MEMFS.stream_ops.msync
            }
          },
          link: {
            node: {
              getattr: MEMFS.node_ops.getattr,
              setattr: MEMFS.node_ops.setattr,
              readlink: MEMFS.node_ops.readlink
            },
            stream: {}
          },
          chrdev: {
            node: {
              getattr: MEMFS.node_ops.getattr,
              setattr: MEMFS.node_ops.setattr
            },
            stream: FS.chrdev_stream_ops
          }
        };
        var node = FS.createNode(parent, name, mode, dev);
        if (FS.isDir(node.mode)) {
          node.node_ops = MEMFS.ops_table.dir.node;
          node.stream_ops = MEMFS.ops_table.dir.stream;
          node.contents = {};
        } else if (FS.isFile(node.mode)) {
          node.node_ops = MEMFS.ops_table.file.node;
          node.stream_ops = MEMFS.ops_table.file.stream;
          node.usedBytes = 0;
          node.contents = null;
        } else if (FS.isLink(node.mode)) {
          node.node_ops = MEMFS.ops_table.link.node;
          node.stream_ops = MEMFS.ops_table.link.stream;
        } else if (FS.isChrdev(node.mode)) {
          node.node_ops = MEMFS.ops_table.chrdev.node;
          node.stream_ops = MEMFS.ops_table.chrdev.stream;
        }
        node.timestamp = Date.now();
        if (parent) {
          parent.contents[name] = node;
          parent.timestamp = node.timestamp;
        }
        return node;
      },
      getFileDataAsTypedArray(node) {
        if (!node.contents)
          return new Uint8Array(0);
        if (node.contents.subarray)
          return node.contents.subarray(0, node.usedBytes);
        return new Uint8Array(node.contents);
      },
      expandFileStorage(node, newCapacity) {
        var prevCapacity = node.contents ? node.contents.length : 0;
        if (prevCapacity >= newCapacity)
          return;
        var CAPACITY_DOUBLING_MAX = 1024 * 1024;
        newCapacity = Math.max(
          newCapacity,
          prevCapacity * (prevCapacity < CAPACITY_DOUBLING_MAX ? 2 : 1.125) >>> 0
        );
        if (prevCapacity != 0)
          newCapacity = Math.max(newCapacity, 256);
        var oldContents = node.contents;
        node.contents = new Uint8Array(newCapacity);
        if (node.usedBytes > 0)
          node.contents.set(oldContents.subarray(0, node.usedBytes), 0);
      },
      resizeFileStorage(node, newSize) {
        if (node.usedBytes == newSize)
          return;
        if (newSize == 0) {
          node.contents = null;
          node.usedBytes = 0;
        } else {
          var oldContents = node.contents;
          node.contents = new Uint8Array(newSize);
          if (oldContents) {
            node.contents.set(
              oldContents.subarray(0, Math.min(newSize, node.usedBytes))
            );
          }
          node.usedBytes = newSize;
        }
      },
      node_ops: {
        getattr(node) {
          var attr = {};
          attr.dev = FS.isChrdev(node.mode) ? node.id : 1;
          attr.ino = node.id;
          attr.mode = node.mode;
          attr.nlink = 1;
          attr.uid = 0;
          attr.gid = 0;
          attr.rdev = node.rdev;
          if (FS.isDir(node.mode)) {
            attr.size = 4096;
          } else if (FS.isFile(node.mode)) {
            attr.size = node.usedBytes;
          } else if (FS.isLink(node.mode)) {
            attr.size = node.link.length;
          } else {
            attr.size = 0;
          }
          attr.atime = new Date(node.timestamp);
          attr.mtime = new Date(node.timestamp);
          attr.ctime = new Date(node.timestamp);
          attr.blksize = 4096;
          attr.blocks = Math.ceil(attr.size / attr.blksize);
          return attr;
        },
        setattr(node, attr) {
          if (attr.mode !== void 0) {
            node.mode = attr.mode;
          }
          if (attr.timestamp !== void 0) {
            node.timestamp = attr.timestamp;
          }
          if (attr.size !== void 0) {
            MEMFS.resizeFileStorage(node, attr.size);
          }
        },
        lookup(parent, name) {
          throw FS.genericErrors[44];
        },
        mknod(parent, name, mode, dev) {
          return MEMFS.createNode(parent, name, mode, dev);
        },
        rename(old_node, new_dir, new_name) {
          if (FS.isDir(old_node.mode)) {
            var new_node;
            try {
              new_node = FS.lookupNode(new_dir, new_name);
            } catch (e2) {
            }
            if (new_node) {
              for (var i2 in new_node.contents) {
                throw new FS.ErrnoError(55);
              }
            }
          }
          delete old_node.parent.contents[old_node.name];
          old_node.parent.timestamp = Date.now();
          old_node.name = new_name;
          new_dir.contents[new_name] = old_node;
          new_dir.timestamp = old_node.parent.timestamp;
        },
        unlink(parent, name) {
          delete parent.contents[name];
          parent.timestamp = Date.now();
        },
        rmdir(parent, name) {
          var node = FS.lookupNode(parent, name);
          for (var i2 in node.contents) {
            throw new FS.ErrnoError(55);
          }
          delete parent.contents[name];
          parent.timestamp = Date.now();
        },
        readdir(node) {
          var entries = [".", ".."];
          for (var key of Object.keys(node.contents)) {
            entries.push(key);
          }
          return entries;
        },
        symlink(parent, newname, oldpath) {
          var node = MEMFS.createNode(parent, newname, 511 | 40960, 0);
          node.link = oldpath;
          return node;
        },
        readlink(node) {
          if (!FS.isLink(node.mode)) {
            throw new FS.ErrnoError(28);
          }
          return node.link;
        }
      },
      stream_ops: {
        read(stream, buffer, offset, length, position) {
          var contents = stream.node.contents;
          if (position >= stream.node.usedBytes)
            return 0;
          var size = Math.min(stream.node.usedBytes - position, length);
          if (size > 8 && contents.subarray) {
            buffer.set(contents.subarray(position, position + size), offset);
          } else {
            for (var i2 = 0; i2 < size; i2++)
              buffer[offset + i2] = contents[position + i2];
          }
          return size;
        },
        write(stream, buffer, offset, length, position, canOwn) {
          if (buffer.buffer === HEAP8.buffer) {
            canOwn = false;
          }
          if (!length)
            return 0;
          var node = stream.node;
          node.timestamp = Date.now();
          if (buffer.subarray && (!node.contents || node.contents.subarray)) {
            if (canOwn) {
              node.contents = buffer.subarray(offset, offset + length);
              node.usedBytes = length;
              return length;
            } else if (node.usedBytes === 0 && position === 0) {
              node.contents = buffer.slice(offset, offset + length);
              node.usedBytes = length;
              return length;
            } else if (position + length <= node.usedBytes) {
              node.contents.set(
                buffer.subarray(offset, offset + length),
                position
              );
              return length;
            }
          }
          MEMFS.expandFileStorage(node, position + length);
          if (node.contents.subarray && buffer.subarray) {
            node.contents.set(
              buffer.subarray(offset, offset + length),
              position
            );
          } else {
            for (var i2 = 0; i2 < length; i2++) {
              node.contents[position + i2] = buffer[offset + i2];
            }
          }
          node.usedBytes = Math.max(node.usedBytes, position + length);
          return length;
        },
        llseek(stream, offset, whence) {
          var position = offset;
          if (whence === 1) {
            position += stream.position;
          } else if (whence === 2) {
            if (FS.isFile(stream.node.mode)) {
              position += stream.node.usedBytes;
            }
          }
          if (position < 0) {
            throw new FS.ErrnoError(28);
          }
          return position;
        },
        allocate(stream, offset, length) {
          MEMFS.expandFileStorage(stream.node, offset + length);
          stream.node.usedBytes = Math.max(
            stream.node.usedBytes,
            offset + length
          );
        },
        mmap(stream, length, position, prot, flags) {
          if (!FS.isFile(stream.node.mode)) {
            throw new FS.ErrnoError(43);
          }
          var ptr;
          var allocated;
          var contents = stream.node.contents;
          if (!(flags & 2) && contents && contents.buffer === HEAP8.buffer) {
            allocated = false;
            ptr = contents.byteOffset;
          } else {
            allocated = true;
            ptr = mmapAlloc(length);
            if (!ptr) {
              throw new FS.ErrnoError(48);
            }
            if (contents) {
              if (position > 0 || position + length < contents.length) {
                if (contents.subarray) {
                  contents = contents.subarray(position, position + length);
                } else {
                  contents = Array.prototype.slice.call(
                    contents,
                    position,
                    position + length
                  );
                }
              }
              HEAP8.set(contents, ptr);
            }
          }
          return { ptr, allocated };
        },
        msync(stream, buffer, offset, length, mmapFlags) {
          MEMFS.stream_ops.write(stream, buffer, 0, length, offset, false);
          return 0;
        }
      }
    };
    var asyncLoad = (url, onload, onerror, noRunDep) => {
      var dep = !noRunDep ? getUniqueRunDependency(`al ${url}`) : "";
      readAsync(url).then(
        (arrayBuffer) => {
          onload(new Uint8Array(arrayBuffer));
          if (dep)
            removeRunDependency(dep);
        },
        (err2) => {
          if (onerror) {
            onerror();
          } else {
            throw `Loading data file "${url}" failed.`;
          }
        }
      );
      if (dep)
        addRunDependency(dep);
    };
    var FS_createDataFile = (parent, name, fileData, canRead, canWrite, canOwn) => {
      FS.createDataFile(parent, name, fileData, canRead, canWrite, canOwn);
    };
    var preloadPlugins = Module2["preloadPlugins"] || [];
    var FS_handledByPreloadPlugin = (byteArray, fullname, finish, onerror) => {
      if (typeof Browser != "undefined")
        Browser.init();
      var handled = false;
      preloadPlugins.forEach((plugin2) => {
        if (handled)
          return;
        if (plugin2["canHandle"](fullname)) {
          plugin2["handle"](byteArray, fullname, finish, onerror);
          handled = true;
        }
      });
      return handled;
    };
    var FS_createPreloadedFile = (parent, name, url, canRead, canWrite, onload, onerror, dontCreateFile, canOwn, preFinish) => {
      var fullname = name ? PATH_FS.resolve(PATH.join2(parent, name)) : parent;
      var dep = getUniqueRunDependency(`cp ${fullname}`);
      function processData(byteArray) {
        function finish(byteArray2) {
          preFinish == null ? void 0 : preFinish();
          if (!dontCreateFile) {
            FS_createDataFile(
              parent,
              name,
              byteArray2,
              canRead,
              canWrite,
              canOwn
            );
          }
          onload == null ? void 0 : onload();
          removeRunDependency(dep);
        }
        if (FS_handledByPreloadPlugin(byteArray, fullname, finish, () => {
          onerror == null ? void 0 : onerror();
          removeRunDependency(dep);
        })) {
          return;
        }
        finish(byteArray);
      }
      addRunDependency(dep);
      if (typeof url == "string") {
        asyncLoad(url, processData, onerror);
      } else {
        processData(url);
      }
    };
    var FS_modeStringToFlags = (str) => {
      var flagModes = {
        r: 0,
        "r+": 2,
        w: 512 | 64 | 1,
        "w+": 512 | 64 | 2,
        a: 1024 | 64 | 1,
        "a+": 1024 | 64 | 2
      };
      var flags = flagModes[str];
      if (typeof flags == "undefined") {
        throw new Error(`Unknown file open mode: ${str}`);
      }
      return flags;
    };
    var FS_getMode = (canRead, canWrite) => {
      var mode = 0;
      if (canRead)
        mode |= 292 | 73;
      if (canWrite)
        mode |= 146;
      return mode;
    };
    var FS = {
      root: null,
      mounts: [],
      devices: {},
      streams: [],
      nextInode: 1,
      nameTable: null,
      currentPath: "/",
      initialized: false,
      ignorePermissions: true,
      ErrnoError: class {
        constructor(errno) {
          this.name = "ErrnoError";
          this.errno = errno;
        }
      },
      genericErrors: {},
      filesystems: null,
      syncFSRequests: 0,
      readFiles: {},
      FSStream: class {
        constructor() {
          this.shared = {};
        }
        get object() {
          return this.node;
        }
        set object(val) {
          this.node = val;
        }
        get isRead() {
          return (this.flags & 2097155) !== 1;
        }
        get isWrite() {
          return (this.flags & 2097155) !== 0;
        }
        get isAppend() {
          return this.flags & 1024;
        }
        get flags() {
          return this.shared.flags;
        }
        set flags(val) {
          this.shared.flags = val;
        }
        get position() {
          return this.shared.position;
        }
        set position(val) {
          this.shared.position = val;
        }
      },
      FSNode: class {
        constructor(parent, name, mode, rdev) {
          if (!parent) {
            parent = this;
          }
          this.parent = parent;
          this.mount = parent.mount;
          this.mounted = null;
          this.id = FS.nextInode++;
          this.name = name;
          this.mode = mode;
          this.node_ops = {};
          this.stream_ops = {};
          this.rdev = rdev;
          this.readMode = 292 | 73;
          this.writeMode = 146;
        }
        get read() {
          return (this.mode & this.readMode) === this.readMode;
        }
        set read(val) {
          val ? this.mode |= this.readMode : this.mode &= ~this.readMode;
        }
        get write() {
          return (this.mode & this.writeMode) === this.writeMode;
        }
        set write(val) {
          val ? this.mode |= this.writeMode : this.mode &= ~this.writeMode;
        }
        get isFolder() {
          return FS.isDir(this.mode);
        }
        get isDevice() {
          return FS.isChrdev(this.mode);
        }
      },
      lookupPath(path2, opts = {}) {
        path2 = PATH_FS.resolve(path2);
        if (!path2)
          return { path: "", node: null };
        var defaults = {
          follow_mount: true,
          recurse_count: 0
        };
        opts = Object.assign(defaults, opts);
        if (opts.recurse_count > 8) {
          throw new FS.ErrnoError(32);
        }
        var parts = path2.split("/").filter((p3) => !!p3);
        var current = FS.root;
        var current_path = "/";
        for (var i2 = 0; i2 < parts.length; i2++) {
          var islast = i2 === parts.length - 1;
          if (islast && opts.parent) {
            break;
          }
          current = FS.lookupNode(current, parts[i2]);
          current_path = PATH.join2(current_path, parts[i2]);
          if (FS.isMountpoint(current)) {
            if (!islast || islast && opts.follow_mount) {
              current = current.mounted.root;
            }
          }
          if (!islast || opts.follow) {
            var count = 0;
            while (FS.isLink(current.mode)) {
              var link = FS.readlink(current_path);
              current_path = PATH_FS.resolve(PATH.dirname(current_path), link);
              var lookup = FS.lookupPath(current_path, {
                recurse_count: opts.recurse_count + 1
              });
              current = lookup.node;
              if (count++ > 40) {
                throw new FS.ErrnoError(32);
              }
            }
          }
        }
        return { path: current_path, node: current };
      },
      getPath(node) {
        var path2;
        while (true) {
          if (FS.isRoot(node)) {
            var mount = node.mount.mountpoint;
            if (!path2)
              return mount;
            return mount[mount.length - 1] !== "/" ? `${mount}/${path2}` : mount + path2;
          }
          path2 = path2 ? `${node.name}/${path2}` : node.name;
          node = node.parent;
        }
      },
      hashName(parentid, name) {
        var hash = 0;
        for (var i2 = 0; i2 < name.length; i2++) {
          hash = (hash << 5) - hash + name.charCodeAt(i2) | 0;
        }
        return (parentid + hash >>> 0) % FS.nameTable.length;
      },
      hashAddNode(node) {
        var hash = FS.hashName(node.parent.id, node.name);
        node.name_next = FS.nameTable[hash];
        FS.nameTable[hash] = node;
      },
      hashRemoveNode(node) {
        var hash = FS.hashName(node.parent.id, node.name);
        if (FS.nameTable[hash] === node) {
          FS.nameTable[hash] = node.name_next;
        } else {
          var current = FS.nameTable[hash];
          while (current) {
            if (current.name_next === node) {
              current.name_next = node.name_next;
              break;
            }
            current = current.name_next;
          }
        }
      },
      lookupNode(parent, name) {
        var errCode = FS.mayLookup(parent);
        if (errCode) {
          throw new FS.ErrnoError(errCode);
        }
        var hash = FS.hashName(parent.id, name);
        for (var node = FS.nameTable[hash]; node; node = node.name_next) {
          var nodeName = node.name;
          if (node.parent.id === parent.id && nodeName === name) {
            return node;
          }
        }
        return FS.lookup(parent, name);
      },
      createNode(parent, name, mode, rdev) {
        var node = new FS.FSNode(parent, name, mode, rdev);
        FS.hashAddNode(node);
        return node;
      },
      destroyNode(node) {
        FS.hashRemoveNode(node);
      },
      isRoot(node) {
        return node === node.parent;
      },
      isMountpoint(node) {
        return !!node.mounted;
      },
      isFile(mode) {
        return (mode & 61440) === 32768;
      },
      isDir(mode) {
        return (mode & 61440) === 16384;
      },
      isLink(mode) {
        return (mode & 61440) === 40960;
      },
      isChrdev(mode) {
        return (mode & 61440) === 8192;
      },
      isBlkdev(mode) {
        return (mode & 61440) === 24576;
      },
      isFIFO(mode) {
        return (mode & 61440) === 4096;
      },
      isSocket(mode) {
        return (mode & 49152) === 49152;
      },
      flagsToPermissionString(flag) {
        var perms = ["r", "w", "rw"][flag & 3];
        if (flag & 512) {
          perms += "w";
        }
        return perms;
      },
      nodePermissions(node, perms) {
        if (FS.ignorePermissions) {
          return 0;
        }
        if (perms.includes("r") && !(node.mode & 292)) {
          return 2;
        } else if (perms.includes("w") && !(node.mode & 146)) {
          return 2;
        } else if (perms.includes("x") && !(node.mode & 73)) {
          return 2;
        }
        return 0;
      },
      mayLookup(dir) {
        if (!FS.isDir(dir.mode))
          return 54;
        var errCode = FS.nodePermissions(dir, "x");
        if (errCode)
          return errCode;
        if (!dir.node_ops.lookup)
          return 2;
        return 0;
      },
      mayCreate(dir, name) {
        try {
          var node = FS.lookupNode(dir, name);
          return 20;
        } catch (e2) {
        }
        return FS.nodePermissions(dir, "wx");
      },
      mayDelete(dir, name, isdir) {
        var node;
        try {
          node = FS.lookupNode(dir, name);
        } catch (e2) {
          return e2.errno;
        }
        var errCode = FS.nodePermissions(dir, "wx");
        if (errCode) {
          return errCode;
        }
        if (isdir) {
          if (!FS.isDir(node.mode)) {
            return 54;
          }
          if (FS.isRoot(node) || FS.getPath(node) === FS.cwd()) {
            return 10;
          }
        } else {
          if (FS.isDir(node.mode)) {
            return 31;
          }
        }
        return 0;
      },
      mayOpen(node, flags) {
        if (!node) {
          return 44;
        }
        if (FS.isLink(node.mode)) {
          return 32;
        } else if (FS.isDir(node.mode)) {
          if (FS.flagsToPermissionString(flags) !== "r" || flags & 512) {
            return 31;
          }
        }
        return FS.nodePermissions(node, FS.flagsToPermissionString(flags));
      },
      MAX_OPEN_FDS: 4096,
      nextfd() {
        for (var fd = 0; fd <= FS.MAX_OPEN_FDS; fd++) {
          if (!FS.streams[fd]) {
            return fd;
          }
        }
        throw new FS.ErrnoError(33);
      },
      getStreamChecked(fd) {
        var stream = FS.getStream(fd);
        if (!stream) {
          throw new FS.ErrnoError(8);
        }
        return stream;
      },
      getStream: (fd) => FS.streams[fd],
      createStream(stream, fd = -1) {
        stream = Object.assign(new FS.FSStream(), stream);
        if (fd == -1) {
          fd = FS.nextfd();
        }
        stream.fd = fd;
        FS.streams[fd] = stream;
        return stream;
      },
      closeStream(fd) {
        FS.streams[fd] = null;
      },
      dupStream(origStream, fd = -1) {
        var _a8, _b5;
        var stream = FS.createStream(origStream, fd);
        (_b5 = (_a8 = stream.stream_ops) == null ? void 0 : _a8.dup) == null ? void 0 : _b5.call(_a8, stream);
        return stream;
      },
      chrdev_stream_ops: {
        open(stream) {
          var _a8, _b5;
          var device = FS.getDevice(stream.node.rdev);
          stream.stream_ops = device.stream_ops;
          (_b5 = (_a8 = stream.stream_ops).open) == null ? void 0 : _b5.call(_a8, stream);
        },
        llseek() {
          throw new FS.ErrnoError(70);
        }
      },
      major: (dev) => dev >> 8,
      minor: (dev) => dev & 255,
      makedev: (ma, mi) => ma << 8 | mi,
      registerDevice(dev, ops) {
        FS.devices[dev] = { stream_ops: ops };
      },
      getDevice: (dev) => FS.devices[dev],
      getMounts(mount) {
        var mounts = [];
        var check = [mount];
        while (check.length) {
          var m2 = check.pop();
          mounts.push(m2);
          check.push(...m2.mounts);
        }
        return mounts;
      },
      syncfs(populate, callback) {
        if (typeof populate == "function") {
          callback = populate;
          populate = false;
        }
        FS.syncFSRequests++;
        if (FS.syncFSRequests > 1) {
          err(
            `warning: ${FS.syncFSRequests} FS.syncfs operations in flight at once, probably just doing extra work`
          );
        }
        var mounts = FS.getMounts(FS.root.mount);
        var completed = 0;
        function doCallback(errCode) {
          FS.syncFSRequests--;
          return callback(errCode);
        }
        function done(errCode) {
          if (errCode) {
            if (!done.errored) {
              done.errored = true;
              return doCallback(errCode);
            }
            return;
          }
          if (++completed >= mounts.length) {
            doCallback(null);
          }
        }
        mounts.forEach((mount) => {
          if (!mount.type.syncfs) {
            return done(null);
          }
          mount.type.syncfs(mount, populate, done);
        });
      },
      mount(type, opts, mountpoint) {
        var root = mountpoint === "/";
        var pseudo = !mountpoint;
        var node;
        if (root && FS.root) {
          throw new FS.ErrnoError(10);
        } else if (!root && !pseudo) {
          var lookup = FS.lookupPath(mountpoint, { follow_mount: false });
          mountpoint = lookup.path;
          node = lookup.node;
          if (FS.isMountpoint(node)) {
            throw new FS.ErrnoError(10);
          }
          if (!FS.isDir(node.mode)) {
            throw new FS.ErrnoError(54);
          }
        }
        var mount = {
          type,
          opts,
          mountpoint,
          mounts: []
        };
        var mountRoot = type.mount(mount);
        mountRoot.mount = mount;
        mount.root = mountRoot;
        if (root) {
          FS.root = mountRoot;
        } else if (node) {
          node.mounted = mount;
          if (node.mount) {
            node.mount.mounts.push(mount);
          }
        }
        return mountRoot;
      },
      unmount(mountpoint) {
        var lookup = FS.lookupPath(mountpoint, { follow_mount: false });
        if (!FS.isMountpoint(lookup.node)) {
          throw new FS.ErrnoError(28);
        }
        var node = lookup.node;
        var mount = node.mounted;
        var mounts = FS.getMounts(mount);
        Object.keys(FS.nameTable).forEach((hash) => {
          var current = FS.nameTable[hash];
          while (current) {
            var next = current.name_next;
            if (mounts.includes(current.mount)) {
              FS.destroyNode(current);
            }
            current = next;
          }
        });
        node.mounted = null;
        var idx = node.mount.mounts.indexOf(mount);
        node.mount.mounts.splice(idx, 1);
      },
      lookup(parent, name) {
        return parent.node_ops.lookup(parent, name);
      },
      mknod(path2, mode, dev) {
        var lookup = FS.lookupPath(path2, { parent: true });
        var parent = lookup.node;
        var name = PATH.basename(path2);
        if (!name || name === "." || name === "..") {
          throw new FS.ErrnoError(28);
        }
        var errCode = FS.mayCreate(parent, name);
        if (errCode) {
          throw new FS.ErrnoError(errCode);
        }
        if (!parent.node_ops.mknod) {
          throw new FS.ErrnoError(63);
        }
        return parent.node_ops.mknod(parent, name, mode, dev);
      },
      create(path2, mode) {
        mode = mode !== void 0 ? mode : 438;
        mode &= 4095;
        mode |= 32768;
        return FS.mknod(path2, mode, 0);
      },
      mkdir(path2, mode) {
        mode = mode !== void 0 ? mode : 511;
        mode &= 511 | 512;
        mode |= 16384;
        return FS.mknod(path2, mode, 0);
      },
      mkdirTree(path2, mode) {
        var dirs = path2.split("/");
        var d2 = "";
        for (var i2 = 0; i2 < dirs.length; ++i2) {
          if (!dirs[i2])
            continue;
          d2 += "/" + dirs[i2];
          try {
            FS.mkdir(d2, mode);
          } catch (e2) {
            if (e2.errno != 20)
              throw e2;
          }
        }
      },
      mkdev(path2, mode, dev) {
        if (typeof dev == "undefined") {
          dev = mode;
          mode = 438;
        }
        mode |= 8192;
        return FS.mknod(path2, mode, dev);
      },
      symlink(oldpath, newpath) {
        if (!PATH_FS.resolve(oldpath)) {
          throw new FS.ErrnoError(44);
        }
        var lookup = FS.lookupPath(newpath, { parent: true });
        var parent = lookup.node;
        if (!parent) {
          throw new FS.ErrnoError(44);
        }
        var newname = PATH.basename(newpath);
        var errCode = FS.mayCreate(parent, newname);
        if (errCode) {
          throw new FS.ErrnoError(errCode);
        }
        if (!parent.node_ops.symlink) {
          throw new FS.ErrnoError(63);
        }
        return parent.node_ops.symlink(parent, newname, oldpath);
      },
      rename(old_path, new_path) {
        var old_dirname = PATH.dirname(old_path);
        var new_dirname = PATH.dirname(new_path);
        var old_name = PATH.basename(old_path);
        var new_name = PATH.basename(new_path);
        var lookup, old_dir, new_dir;
        lookup = FS.lookupPath(old_path, { parent: true });
        old_dir = lookup.node;
        lookup = FS.lookupPath(new_path, { parent: true });
        new_dir = lookup.node;
        if (!old_dir || !new_dir)
          throw new FS.ErrnoError(44);
        if (old_dir.mount !== new_dir.mount) {
          throw new FS.ErrnoError(75);
        }
        var old_node = FS.lookupNode(old_dir, old_name);
        var relative = PATH_FS.relative(old_path, new_dirname);
        if (relative.charAt(0) !== ".") {
          throw new FS.ErrnoError(28);
        }
        relative = PATH_FS.relative(new_path, old_dirname);
        if (relative.charAt(0) !== ".") {
          throw new FS.ErrnoError(55);
        }
        var new_node;
        try {
          new_node = FS.lookupNode(new_dir, new_name);
        } catch (e2) {
        }
        if (old_node === new_node) {
          return;
        }
        var isdir = FS.isDir(old_node.mode);
        var errCode = FS.mayDelete(old_dir, old_name, isdir);
        if (errCode) {
          throw new FS.ErrnoError(errCode);
        }
        errCode = new_node ? FS.mayDelete(new_dir, new_name, isdir) : FS.mayCreate(new_dir, new_name);
        if (errCode) {
          throw new FS.ErrnoError(errCode);
        }
        if (!old_dir.node_ops.rename) {
          throw new FS.ErrnoError(63);
        }
        if (FS.isMountpoint(old_node) || new_node && FS.isMountpoint(new_node)) {
          throw new FS.ErrnoError(10);
        }
        if (new_dir !== old_dir) {
          errCode = FS.nodePermissions(old_dir, "w");
          if (errCode) {
            throw new FS.ErrnoError(errCode);
          }
        }
        FS.hashRemoveNode(old_node);
        try {
          old_dir.node_ops.rename(old_node, new_dir, new_name);
          old_node.parent = new_dir;
        } catch (e2) {
          throw e2;
        } finally {
          FS.hashAddNode(old_node);
        }
      },
      rmdir(path2) {
        var lookup = FS.lookupPath(path2, { parent: true });
        var parent = lookup.node;
        var name = PATH.basename(path2);
        var node = FS.lookupNode(parent, name);
        var errCode = FS.mayDelete(parent, name, true);
        if (errCode) {
          throw new FS.ErrnoError(errCode);
        }
        if (!parent.node_ops.rmdir) {
          throw new FS.ErrnoError(63);
        }
        if (FS.isMountpoint(node)) {
          throw new FS.ErrnoError(10);
        }
        parent.node_ops.rmdir(parent, name);
        FS.destroyNode(node);
      },
      readdir(path2) {
        var lookup = FS.lookupPath(path2, { follow: true });
        var node = lookup.node;
        if (!node.node_ops.readdir) {
          throw new FS.ErrnoError(54);
        }
        return node.node_ops.readdir(node);
      },
      unlink(path2) {
        var lookup = FS.lookupPath(path2, { parent: true });
        var parent = lookup.node;
        if (!parent) {
          throw new FS.ErrnoError(44);
        }
        var name = PATH.basename(path2);
        var node = FS.lookupNode(parent, name);
        var errCode = FS.mayDelete(parent, name, false);
        if (errCode) {
          throw new FS.ErrnoError(errCode);
        }
        if (!parent.node_ops.unlink) {
          throw new FS.ErrnoError(63);
        }
        if (FS.isMountpoint(node)) {
          throw new FS.ErrnoError(10);
        }
        parent.node_ops.unlink(parent, name);
        FS.destroyNode(node);
      },
      readlink(path2) {
        var lookup = FS.lookupPath(path2);
        var link = lookup.node;
        if (!link) {
          throw new FS.ErrnoError(44);
        }
        if (!link.node_ops.readlink) {
          throw new FS.ErrnoError(28);
        }
        return PATH_FS.resolve(
          FS.getPath(link.parent),
          link.node_ops.readlink(link)
        );
      },
      stat(path2, dontFollow) {
        var lookup = FS.lookupPath(path2, { follow: !dontFollow });
        var node = lookup.node;
        if (!node) {
          throw new FS.ErrnoError(44);
        }
        if (!node.node_ops.getattr) {
          throw new FS.ErrnoError(63);
        }
        return node.node_ops.getattr(node);
      },
      lstat(path2) {
        return FS.stat(path2, true);
      },
      chmod(path2, mode, dontFollow) {
        var node;
        if (typeof path2 == "string") {
          var lookup = FS.lookupPath(path2, { follow: !dontFollow });
          node = lookup.node;
        } else {
          node = path2;
        }
        if (!node.node_ops.setattr) {
          throw new FS.ErrnoError(63);
        }
        node.node_ops.setattr(node, {
          mode: mode & 4095 | node.mode & ~4095,
          timestamp: Date.now()
        });
      },
      lchmod(path2, mode) {
        FS.chmod(path2, mode, true);
      },
      fchmod(fd, mode) {
        var stream = FS.getStreamChecked(fd);
        FS.chmod(stream.node, mode);
      },
      chown(path2, uid, gid, dontFollow) {
        var node;
        if (typeof path2 == "string") {
          var lookup = FS.lookupPath(path2, { follow: !dontFollow });
          node = lookup.node;
        } else {
          node = path2;
        }
        if (!node.node_ops.setattr) {
          throw new FS.ErrnoError(63);
        }
        node.node_ops.setattr(node, {
          timestamp: Date.now()
        });
      },
      lchown(path2, uid, gid) {
        FS.chown(path2, uid, gid, true);
      },
      fchown(fd, uid, gid) {
        var stream = FS.getStreamChecked(fd);
        FS.chown(stream.node, uid, gid);
      },
      truncate(path2, len) {
        if (len < 0) {
          throw new FS.ErrnoError(28);
        }
        var node;
        if (typeof path2 == "string") {
          var lookup = FS.lookupPath(path2, { follow: true });
          node = lookup.node;
        } else {
          node = path2;
        }
        if (!node.node_ops.setattr) {
          throw new FS.ErrnoError(63);
        }
        if (FS.isDir(node.mode)) {
          throw new FS.ErrnoError(31);
        }
        if (!FS.isFile(node.mode)) {
          throw new FS.ErrnoError(28);
        }
        var errCode = FS.nodePermissions(node, "w");
        if (errCode) {
          throw new FS.ErrnoError(errCode);
        }
        node.node_ops.setattr(node, {
          size: len,
          timestamp: Date.now()
        });
      },
      ftruncate(fd, len) {
        var stream = FS.getStreamChecked(fd);
        if ((stream.flags & 2097155) === 0) {
          throw new FS.ErrnoError(28);
        }
        FS.truncate(stream.node, len);
      },
      utime(path2, atime, mtime) {
        var lookup = FS.lookupPath(path2, { follow: true });
        var node = lookup.node;
        node.node_ops.setattr(node, {
          timestamp: Math.max(atime, mtime)
        });
      },
      open(path2, flags, mode) {
        if (path2 === "") {
          throw new FS.ErrnoError(44);
        }
        flags = typeof flags == "string" ? FS_modeStringToFlags(flags) : flags;
        if (flags & 64) {
          mode = typeof mode == "undefined" ? 438 : mode;
          mode = mode & 4095 | 32768;
        } else {
          mode = 0;
        }
        var node;
        if (typeof path2 == "object") {
          node = path2;
        } else {
          path2 = PATH.normalize(path2);
          try {
            var lookup = FS.lookupPath(path2, {
              follow: !(flags & 131072)
            });
            node = lookup.node;
          } catch (e2) {
          }
        }
        var created = false;
        if (flags & 64) {
          if (node) {
            if (flags & 128) {
              throw new FS.ErrnoError(20);
            }
          } else {
            node = FS.mknod(path2, mode, 0);
            created = true;
          }
        }
        if (!node) {
          throw new FS.ErrnoError(44);
        }
        if (FS.isChrdev(node.mode)) {
          flags &= ~512;
        }
        if (flags & 65536 && !FS.isDir(node.mode)) {
          throw new FS.ErrnoError(54);
        }
        if (!created) {
          var errCode = FS.mayOpen(node, flags);
          if (errCode) {
            throw new FS.ErrnoError(errCode);
          }
        }
        if (flags & 512 && !created) {
          FS.truncate(node, 0);
        }
        flags &= ~(128 | 512 | 131072);
        var stream = FS.createStream({
          node,
          path: FS.getPath(node),
          flags,
          seekable: true,
          position: 0,
          stream_ops: node.stream_ops,
          ungotten: [],
          error: false
        });
        if (stream.stream_ops.open) {
          stream.stream_ops.open(stream);
        }
        if (Module2["logReadFiles"] && !(flags & 1)) {
          if (!(path2 in FS.readFiles)) {
            FS.readFiles[path2] = 1;
          }
        }
        return stream;
      },
      close(stream) {
        if (FS.isClosed(stream)) {
          throw new FS.ErrnoError(8);
        }
        if (stream.getdents)
          stream.getdents = null;
        try {
          if (stream.stream_ops.close) {
            stream.stream_ops.close(stream);
          }
        } catch (e2) {
          throw e2;
        } finally {
          FS.closeStream(stream.fd);
        }
        stream.fd = null;
      },
      isClosed(stream) {
        return stream.fd === null;
      },
      llseek(stream, offset, whence) {
        if (FS.isClosed(stream)) {
          throw new FS.ErrnoError(8);
        }
        if (!stream.seekable || !stream.stream_ops.llseek) {
          throw new FS.ErrnoError(70);
        }
        if (whence != 0 && whence != 1 && whence != 2) {
          throw new FS.ErrnoError(28);
        }
        stream.position = stream.stream_ops.llseek(stream, offset, whence);
        stream.ungotten = [];
        return stream.position;
      },
      read(stream, buffer, offset, length, position) {
        if (length < 0 || position < 0) {
          throw new FS.ErrnoError(28);
        }
        if (FS.isClosed(stream)) {
          throw new FS.ErrnoError(8);
        }
        if ((stream.flags & 2097155) === 1) {
          throw new FS.ErrnoError(8);
        }
        if (FS.isDir(stream.node.mode)) {
          throw new FS.ErrnoError(31);
        }
        if (!stream.stream_ops.read) {
          throw new FS.ErrnoError(28);
        }
        var seeking = typeof position != "undefined";
        if (!seeking) {
          position = stream.position;
        } else if (!stream.seekable) {
          throw new FS.ErrnoError(70);
        }
        var bytesRead = stream.stream_ops.read(
          stream,
          buffer,
          offset,
          length,
          position
        );
        if (!seeking)
          stream.position += bytesRead;
        return bytesRead;
      },
      write(stream, buffer, offset, length, position, canOwn) {
        if (length < 0 || position < 0) {
          throw new FS.ErrnoError(28);
        }
        if (FS.isClosed(stream)) {
          throw new FS.ErrnoError(8);
        }
        if ((stream.flags & 2097155) === 0) {
          throw new FS.ErrnoError(8);
        }
        if (FS.isDir(stream.node.mode)) {
          throw new FS.ErrnoError(31);
        }
        if (!stream.stream_ops.write) {
          throw new FS.ErrnoError(28);
        }
        if (stream.seekable && stream.flags & 1024) {
          FS.llseek(stream, 0, 2);
        }
        var seeking = typeof position != "undefined";
        if (!seeking) {
          position = stream.position;
        } else if (!stream.seekable) {
          throw new FS.ErrnoError(70);
        }
        var bytesWritten = stream.stream_ops.write(
          stream,
          buffer,
          offset,
          length,
          position,
          canOwn
        );
        if (!seeking)
          stream.position += bytesWritten;
        return bytesWritten;
      },
      allocate(stream, offset, length) {
        if (FS.isClosed(stream)) {
          throw new FS.ErrnoError(8);
        }
        if (offset < 0 || length <= 0) {
          throw new FS.ErrnoError(28);
        }
        if ((stream.flags & 2097155) === 0) {
          throw new FS.ErrnoError(8);
        }
        if (!FS.isFile(stream.node.mode) && !FS.isDir(stream.node.mode)) {
          throw new FS.ErrnoError(43);
        }
        if (!stream.stream_ops.allocate) {
          throw new FS.ErrnoError(138);
        }
        stream.stream_ops.allocate(stream, offset, length);
      },
      mmap(stream, length, position, prot, flags) {
        if ((prot & 2) !== 0 && (flags & 2) === 0 && (stream.flags & 2097155) !== 2) {
          throw new FS.ErrnoError(2);
        }
        if ((stream.flags & 2097155) === 1) {
          throw new FS.ErrnoError(2);
        }
        if (!stream.stream_ops.mmap) {
          throw new FS.ErrnoError(43);
        }
        if (!length) {
          throw new FS.ErrnoError(28);
        }
        return stream.stream_ops.mmap(stream, length, position, prot, flags);
      },
      msync(stream, buffer, offset, length, mmapFlags) {
        if (!stream.stream_ops.msync) {
          return 0;
        }
        return stream.stream_ops.msync(
          stream,
          buffer,
          offset,
          length,
          mmapFlags
        );
      },
      ioctl(stream, cmd, arg) {
        if (!stream.stream_ops.ioctl) {
          throw new FS.ErrnoError(59);
        }
        return stream.stream_ops.ioctl(stream, cmd, arg);
      },
      readFile(path2, opts = {}) {
        opts.flags = opts.flags || 0;
        opts.encoding = opts.encoding || "binary";
        if (opts.encoding !== "utf8" && opts.encoding !== "binary") {
          throw new Error(`Invalid encoding type "${opts.encoding}"`);
        }
        var ret;
        var stream = FS.open(path2, opts.flags);
        var stat = FS.stat(path2);
        var length = stat.size;
        var buf = new Uint8Array(length);
        FS.read(stream, buf, 0, length, 0);
        if (opts.encoding === "utf8") {
          ret = UTF8ArrayToString(buf);
        } else if (opts.encoding === "binary") {
          ret = buf;
        }
        FS.close(stream);
        return ret;
      },
      writeFile(path2, data, opts = {}) {
        opts.flags = opts.flags || 577;
        var stream = FS.open(path2, opts.flags, opts.mode);
        if (typeof data == "string") {
          var buf = new Uint8Array(lengthBytesUTF8(data) + 1);
          var actualNumBytes = stringToUTF8Array(data, buf, 0, buf.length);
          FS.write(stream, buf, 0, actualNumBytes, void 0, opts.canOwn);
        } else if (ArrayBuffer.isView(data)) {
          FS.write(stream, data, 0, data.byteLength, void 0, opts.canOwn);
        } else {
          throw new Error("Unsupported data type");
        }
        FS.close(stream);
      },
      cwd: () => FS.currentPath,
      chdir(path2) {
        var lookup = FS.lookupPath(path2, { follow: true });
        if (lookup.node === null) {
          throw new FS.ErrnoError(44);
        }
        if (!FS.isDir(lookup.node.mode)) {
          throw new FS.ErrnoError(54);
        }
        var errCode = FS.nodePermissions(lookup.node, "x");
        if (errCode) {
          throw new FS.ErrnoError(errCode);
        }
        FS.currentPath = lookup.path;
      },
      createDefaultDirectories() {
        FS.mkdir("/tmp");
        FS.mkdir("/home");
        FS.mkdir("/home/web_user");
      },
      createDefaultDevices() {
        FS.mkdir("/dev");
        FS.registerDevice(FS.makedev(1, 3), {
          read: () => 0,
          write: (stream, buffer, offset, length, pos) => length
        });
        FS.mkdev("/dev/null", FS.makedev(1, 3));
        TTY.register(FS.makedev(5, 0), TTY.default_tty_ops);
        TTY.register(FS.makedev(6, 0), TTY.default_tty1_ops);
        FS.mkdev("/dev/tty", FS.makedev(5, 0));
        FS.mkdev("/dev/tty1", FS.makedev(6, 0));
        var randomBuffer = new Uint8Array(1024), randomLeft = 0;
        var randomByte = () => {
          if (randomLeft === 0) {
            randomLeft = randomFill(randomBuffer).byteLength;
          }
          return randomBuffer[--randomLeft];
        };
        FS.createDevice("/dev", "random", randomByte);
        FS.createDevice("/dev", "urandom", randomByte);
        FS.mkdir("/dev/shm");
        FS.mkdir("/dev/shm/tmp");
      },
      createSpecialDirectories() {
        FS.mkdir("/proc");
        var proc_self = FS.mkdir("/proc/self");
        FS.mkdir("/proc/self/fd");
        FS.mount(
          {
            mount() {
              var node = FS.createNode(proc_self, "fd", 16384 | 511, 73);
              node.node_ops = {
                lookup(parent, name) {
                  var fd = +name;
                  var stream = FS.getStreamChecked(fd);
                  var ret = {
                    parent: null,
                    mount: { mountpoint: "fake" },
                    node_ops: { readlink: () => stream.path }
                  };
                  ret.parent = ret;
                  return ret;
                }
              };
              return node;
            }
          },
          {},
          "/proc/self/fd"
        );
      },
      createStandardStreams(input, output, error) {
        if (input) {
          FS.createDevice("/dev", "stdin", input);
        } else {
          FS.symlink("/dev/tty", "/dev/stdin");
        }
        if (output) {
          FS.createDevice("/dev", "stdout", null, output);
        } else {
          FS.symlink("/dev/tty", "/dev/stdout");
        }
        if (error) {
          FS.createDevice("/dev", "stderr", null, error);
        } else {
          FS.symlink("/dev/tty1", "/dev/stderr");
        }
        var stdin2 = FS.open("/dev/stdin", 0);
        var stdout2 = FS.open("/dev/stdout", 1);
        var stderr = FS.open("/dev/stderr", 1);
      },
      staticInit() {
        [44].forEach((code) => {
          FS.genericErrors[code] = new FS.ErrnoError(code);
          FS.genericErrors[code].stack = "<generic error, no stack>";
        });
        FS.nameTable = new Array(4096);
        FS.mount(MEMFS, {}, "/");
        FS.createDefaultDirectories();
        FS.createDefaultDevices();
        FS.createSpecialDirectories();
        FS.filesystems = {
          MEMFS
        };
      },
      init(input, output, error) {
        FS.initialized = true;
        input ??= Module2["stdin"];
        output ??= Module2["stdout"];
        error ??= Module2["stderr"];
        FS.createStandardStreams(input, output, error);
      },
      quit() {
        FS.initialized = false;
        for (var i2 = 0; i2 < FS.streams.length; i2++) {
          var stream = FS.streams[i2];
          if (!stream) {
            continue;
          }
          FS.close(stream);
        }
      },
      findObject(path2, dontResolveLastLink) {
        var ret = FS.analyzePath(path2, dontResolveLastLink);
        if (!ret.exists) {
          return null;
        }
        return ret.object;
      },
      analyzePath(path2, dontResolveLastLink) {
        try {
          var lookup = FS.lookupPath(path2, { follow: !dontResolveLastLink });
          path2 = lookup.path;
        } catch (e2) {
        }
        var ret = {
          isRoot: false,
          exists: false,
          error: 0,
          name: null,
          path: null,
          object: null,
          parentExists: false,
          parentPath: null,
          parentObject: null
        };
        try {
          var lookup = FS.lookupPath(path2, { parent: true });
          ret.parentExists = true;
          ret.parentPath = lookup.path;
          ret.parentObject = lookup.node;
          ret.name = PATH.basename(path2);
          lookup = FS.lookupPath(path2, { follow: !dontResolveLastLink });
          ret.exists = true;
          ret.path = lookup.path;
          ret.object = lookup.node;
          ret.name = lookup.node.name;
          ret.isRoot = lookup.path === "/";
        } catch (e2) {
          ret.error = e2.errno;
        }
        return ret;
      },
      createPath(parent, path2, canRead, canWrite) {
        parent = typeof parent == "string" ? parent : FS.getPath(parent);
        var parts = path2.split("/").reverse();
        while (parts.length) {
          var part = parts.pop();
          if (!part)
            continue;
          var current = PATH.join2(parent, part);
          try {
            FS.mkdir(current);
          } catch (e2) {
          }
          parent = current;
        }
        return current;
      },
      createFile(parent, name, properties, canRead, canWrite) {
        var path2 = PATH.join2(
          typeof parent == "string" ? parent : FS.getPath(parent),
          name
        );
        var mode = FS_getMode(canRead, canWrite);
        return FS.create(path2, mode);
      },
      createDataFile(parent, name, data, canRead, canWrite, canOwn) {
        var path2 = name;
        if (parent) {
          parent = typeof parent == "string" ? parent : FS.getPath(parent);
          path2 = name ? PATH.join2(parent, name) : parent;
        }
        var mode = FS_getMode(canRead, canWrite);
        var node = FS.create(path2, mode);
        if (data) {
          if (typeof data == "string") {
            var arr = new Array(data.length);
            for (var i2 = 0, len = data.length; i2 < len; ++i2)
              arr[i2] = data.charCodeAt(i2);
            data = arr;
          }
          FS.chmod(node, mode | 146);
          var stream = FS.open(node, 577);
          FS.write(stream, data, 0, data.length, 0, canOwn);
          FS.close(stream);
          FS.chmod(node, mode);
        }
      },
      createDevice(parent, name, input, output) {
        var path2 = PATH.join2(
          typeof parent == "string" ? parent : FS.getPath(parent),
          name
        );
        var mode = FS_getMode(!!input, !!output);
        FS.createDevice.major ??= 64;
        var dev = FS.makedev(FS.createDevice.major++, 0);
        FS.registerDevice(dev, {
          open(stream) {
            stream.seekable = false;
          },
          close(stream) {
            var _a8;
            if ((_a8 = output == null ? void 0 : output.buffer) == null ? void 0 : _a8.length) {
              output(10);
            }
          },
          read(stream, buffer, offset, length, pos) {
            var bytesRead = 0;
            for (var i2 = 0; i2 < length; i2++) {
              var result;
              try {
                result = input();
              } catch (e2) {
                throw new FS.ErrnoError(29);
              }
              if (result === void 0 && bytesRead === 0) {
                throw new FS.ErrnoError(6);
              }
              if (result === null || result === void 0)
                break;
              bytesRead++;
              buffer[offset + i2] = result;
            }
            if (bytesRead) {
              stream.node.timestamp = Date.now();
            }
            return bytesRead;
          },
          write(stream, buffer, offset, length, pos) {
            for (var i2 = 0; i2 < length; i2++) {
              try {
                output(buffer[offset + i2]);
              } catch (e2) {
                throw new FS.ErrnoError(29);
              }
            }
            if (length) {
              stream.node.timestamp = Date.now();
            }
            return i2;
          }
        });
        return FS.mkdev(path2, mode, dev);
      },
      forceLoadFile(obj) {
        if (obj.isDevice || obj.isFolder || obj.link || obj.contents)
          return true;
        if (typeof XMLHttpRequest != "undefined") {
          throw new Error(
            "Lazy loading should have been performed (contents set) in createLazyFile, but it was not. Lazy loading only works in web workers. Use --embed-file or --preload-file in emcc on the main thread."
          );
        } else {
          try {
            obj.contents = readBinary(obj.url);
            obj.usedBytes = obj.contents.length;
          } catch (e2) {
            throw new FS.ErrnoError(29);
          }
        }
      },
      createLazyFile(parent, name, url, canRead, canWrite) {
        class LazyUint8Array {
          constructor() {
            this.lengthKnown = false;
            this.chunks = [];
          }
          get(idx) {
            if (idx > this.length - 1 || idx < 0) {
              return void 0;
            }
            var chunkOffset = idx % this.chunkSize;
            var chunkNum = idx / this.chunkSize | 0;
            return this.getter(chunkNum)[chunkOffset];
          }
          setDataGetter(getter) {
            this.getter = getter;
          }
          cacheLength() {
            var xhr = new XMLHttpRequest();
            xhr.open("HEAD", url, false);
            xhr.send(null);
            if (!(xhr.status >= 200 && xhr.status < 300 || xhr.status === 304))
              throw new Error(
                "Couldn't load " + url + ". Status: " + xhr.status
              );
            var datalength = Number(xhr.getResponseHeader("Content-length"));
            var header;
            var hasByteServing = (header = xhr.getResponseHeader("Accept-Ranges")) && header === "bytes";
            var usesGzip = (header = xhr.getResponseHeader("Content-Encoding")) && header === "gzip";
            var chunkSize = 1024 * 1024;
            if (!hasByteServing)
              chunkSize = datalength;
            var doXHR = (from, to) => {
              if (from > to)
                throw new Error(
                  "invalid range (" + from + ", " + to + ") or no bytes requested!"
                );
              if (to > datalength - 1)
                throw new Error(
                  "only " + datalength + " bytes available! programmer error!"
                );
              var xhr2 = new XMLHttpRequest();
              xhr2.open("GET", url, false);
              if (datalength !== chunkSize)
                xhr2.setRequestHeader("Range", "bytes=" + from + "-" + to);
              xhr2.responseType = "arraybuffer";
              if (xhr2.overrideMimeType) {
                xhr2.overrideMimeType("text/plain; charset=x-user-defined");
              }
              xhr2.send(null);
              if (!(xhr2.status >= 200 && xhr2.status < 300 || xhr2.status === 304))
                throw new Error(
                  "Couldn't load " + url + ". Status: " + xhr2.status
                );
              if (xhr2.response !== void 0) {
                return new Uint8Array(xhr2.response || []);
              }
              return intArrayFromString(xhr2.responseText || "", true);
            };
            var lazyArray2 = this;
            lazyArray2.setDataGetter((chunkNum) => {
              var start = chunkNum * chunkSize;
              var end = (chunkNum + 1) * chunkSize - 1;
              end = Math.min(end, datalength - 1);
              if (typeof lazyArray2.chunks[chunkNum] == "undefined") {
                lazyArray2.chunks[chunkNum] = doXHR(start, end);
              }
              if (typeof lazyArray2.chunks[chunkNum] == "undefined")
                throw new Error("doXHR failed!");
              return lazyArray2.chunks[chunkNum];
            });
            if (usesGzip || !datalength) {
              chunkSize = datalength = 1;
              datalength = this.getter(0).length;
              chunkSize = datalength;
              out(
                "LazyFiles on gzip forces download of the whole file when length is accessed"
              );
            }
            this._length = datalength;
            this._chunkSize = chunkSize;
            this.lengthKnown = true;
          }
          get length() {
            if (!this.lengthKnown) {
              this.cacheLength();
            }
            return this._length;
          }
          get chunkSize() {
            if (!this.lengthKnown) {
              this.cacheLength();
            }
            return this._chunkSize;
          }
        }
        if (typeof XMLHttpRequest != "undefined") {
          if (!ENVIRONMENT_IS_WORKER)
            throw "Cannot do synchronous binary XHRs outside webworkers in modern browsers. Use --embed-file or --preload-file in emcc";
          var lazyArray = new LazyUint8Array();
          var properties = { isDevice: false, contents: lazyArray };
        } else {
          var properties = { isDevice: false, url };
        }
        var node = FS.createFile(parent, name, properties, canRead, canWrite);
        if (properties.contents) {
          node.contents = properties.contents;
        } else if (properties.url) {
          node.contents = null;
          node.url = properties.url;
        }
        Object.defineProperties(node, {
          usedBytes: {
            get: function() {
              return this.contents.length;
            }
          }
        });
        var stream_ops = {};
        var keys = Object.keys(node.stream_ops);
        keys.forEach((key) => {
          var fn = node.stream_ops[key];
          stream_ops[key] = (...args) => {
            FS.forceLoadFile(node);
            return fn(...args);
          };
        });
        function writeChunks(stream, buffer, offset, length, position) {
          var contents = stream.node.contents;
          if (position >= contents.length)
            return 0;
          var size = Math.min(contents.length - position, length);
          if (contents.slice) {
            for (var i2 = 0; i2 < size; i2++) {
              buffer[offset + i2] = contents[position + i2];
            }
          } else {
            for (var i2 = 0; i2 < size; i2++) {
              buffer[offset + i2] = contents.get(position + i2);
            }
          }
          return size;
        }
        stream_ops.read = (stream, buffer, offset, length, position) => {
          FS.forceLoadFile(node);
          return writeChunks(stream, buffer, offset, length, position);
        };
        stream_ops.mmap = (stream, length, position, prot, flags) => {
          FS.forceLoadFile(node);
          var ptr = mmapAlloc(length);
          if (!ptr) {
            throw new FS.ErrnoError(48);
          }
          writeChunks(stream, HEAP8, ptr, length, position);
          return { ptr, allocated: true };
        };
        node.stream_ops = stream_ops;
        return node;
      }
    };
    var UTF8ToString = (ptr, maxBytesToRead) => {
      return ptr ? UTF8ArrayToString(HEAPU8, ptr, maxBytesToRead) : "";
    };
    var SYSCALLS = {
      DEFAULT_POLLMASK: 5,
      calculateAt(dirfd, path2, allowEmpty) {
        if (PATH.isAbs(path2)) {
          return path2;
        }
        var dir;
        if (dirfd === -100) {
          dir = FS.cwd();
        } else {
          var dirstream = SYSCALLS.getStreamFromFD(dirfd);
          dir = dirstream.path;
        }
        if (path2.length == 0) {
          if (!allowEmpty) {
            throw new FS.ErrnoError(44);
          }
          return dir;
        }
        return PATH.join2(dir, path2);
      },
      doStat(func, path2, buf) {
        var stat = func(path2);
        HEAP32[buf >> 2] = stat.dev;
        HEAP32[buf + 4 >> 2] = stat.mode;
        HEAPU32[buf + 8 >> 2] = stat.nlink;
        HEAP32[buf + 12 >> 2] = stat.uid;
        HEAP32[buf + 16 >> 2] = stat.gid;
        HEAP32[buf + 20 >> 2] = stat.rdev;
        HEAP64[buf + 24 >> 3] = BigInt(stat.size);
        HEAP32[buf + 32 >> 2] = 4096;
        HEAP32[buf + 36 >> 2] = stat.blocks;
        var atime = stat.atime.getTime();
        var mtime = stat.mtime.getTime();
        var ctime = stat.ctime.getTime();
        HEAP64[buf + 40 >> 3] = BigInt(Math.floor(atime / 1e3));
        HEAPU32[buf + 48 >> 2] = atime % 1e3 * 1e3 * 1e3;
        HEAP64[buf + 56 >> 3] = BigInt(Math.floor(mtime / 1e3));
        HEAPU32[buf + 64 >> 2] = mtime % 1e3 * 1e3 * 1e3;
        HEAP64[buf + 72 >> 3] = BigInt(Math.floor(ctime / 1e3));
        HEAPU32[buf + 80 >> 2] = ctime % 1e3 * 1e3 * 1e3;
        HEAP64[buf + 88 >> 3] = BigInt(stat.ino);
        return 0;
      },
      doMsync(addr, stream, len, flags, offset) {
        if (!FS.isFile(stream.node.mode)) {
          throw new FS.ErrnoError(43);
        }
        if (flags & 2) {
          return 0;
        }
        var buffer = HEAPU8.slice(addr, addr + len);
        FS.msync(stream, buffer, offset, len, flags);
      },
      getStreamFromFD(fd) {
        var stream = FS.getStreamChecked(fd);
        return stream;
      },
      varargs: void 0,
      getStr(ptr) {
        var ret = UTF8ToString(ptr);
        return ret;
      }
    };
    function ___syscall_chmod(path2, mode) {
      try {
        path2 = SYSCALLS.getStr(path2);
        FS.chmod(path2, mode);
        return 0;
      } catch (e2) {
        if (typeof FS == "undefined" || !(e2.name === "ErrnoError"))
          throw e2;
        return -e2.errno;
      }
    }
    function ___syscall_faccessat(dirfd, path2, amode, flags) {
      try {
        path2 = SYSCALLS.getStr(path2);
        path2 = SYSCALLS.calculateAt(dirfd, path2);
        if (amode & ~7) {
          return -28;
        }
        var lookup = FS.lookupPath(path2, { follow: true });
        var node = lookup.node;
        if (!node) {
          return -44;
        }
        var perms = "";
        if (amode & 4)
          perms += "r";
        if (amode & 2)
          perms += "w";
        if (amode & 1)
          perms += "x";
        if (perms && FS.nodePermissions(node, perms)) {
          return -2;
        }
        return 0;
      } catch (e2) {
        if (typeof FS == "undefined" || !(e2.name === "ErrnoError"))
          throw e2;
        return -e2.errno;
      }
    }
    function ___syscall_fchmod(fd, mode) {
      try {
        FS.fchmod(fd, mode);
        return 0;
      } catch (e2) {
        if (typeof FS == "undefined" || !(e2.name === "ErrnoError"))
          throw e2;
        return -e2.errno;
      }
    }
    function ___syscall_fchown32(fd, owner, group) {
      try {
        FS.fchown(fd, owner, group);
        return 0;
      } catch (e2) {
        if (typeof FS == "undefined" || !(e2.name === "ErrnoError"))
          throw e2;
        return -e2.errno;
      }
    }
    function syscallGetVarargI() {
      var ret = HEAP32[+SYSCALLS.varargs >> 2];
      SYSCALLS.varargs += 4;
      return ret;
    }
    var syscallGetVarargP = syscallGetVarargI;
    function ___syscall_fcntl64(fd, cmd, varargs) {
      SYSCALLS.varargs = varargs;
      try {
        var stream = SYSCALLS.getStreamFromFD(fd);
        switch (cmd) {
          case 0: {
            var arg = syscallGetVarargI();
            if (arg < 0) {
              return -28;
            }
            while (FS.streams[arg]) {
              arg++;
            }
            var newStream;
            newStream = FS.dupStream(stream, arg);
            return newStream.fd;
          }
          case 1:
          case 2:
            return 0;
          case 3:
            return stream.flags;
          case 4: {
            var arg = syscallGetVarargI();
            stream.flags |= arg;
            return 0;
          }
          case 12: {
            var arg = syscallGetVarargP();
            var offset = 0;
            HEAP16[arg + offset >> 1] = 2;
            return 0;
          }
          case 13:
          case 14:
            return 0;
        }
        return -28;
      } catch (e2) {
        if (typeof FS == "undefined" || !(e2.name === "ErrnoError"))
          throw e2;
        return -e2.errno;
      }
    }
    function ___syscall_fstat64(fd, buf) {
      try {
        var stream = SYSCALLS.getStreamFromFD(fd);
        return SYSCALLS.doStat(FS.stat, stream.path, buf);
      } catch (e2) {
        if (typeof FS == "undefined" || !(e2.name === "ErrnoError"))
          throw e2;
        return -e2.errno;
      }
    }
    var INT53_MAX = 9007199254740992;
    var INT53_MIN = -9007199254740992;
    var bigintToI53Checked = (num) => num < INT53_MIN || num > INT53_MAX ? NaN : Number(num);
    function ___syscall_ftruncate64(fd, length) {
      length = bigintToI53Checked(length);
      try {
        if (isNaN(length))
          return 61;
        FS.ftruncate(fd, length);
        return 0;
      } catch (e2) {
        if (typeof FS == "undefined" || !(e2.name === "ErrnoError"))
          throw e2;
        return -e2.errno;
      }
    }
    var stringToUTF8 = (str, outPtr, maxBytesToWrite) => {
      return stringToUTF8Array(str, HEAPU8, outPtr, maxBytesToWrite);
    };
    function ___syscall_getcwd(buf, size) {
      try {
        if (size === 0)
          return -28;
        var cwd = FS.cwd();
        var cwdLengthInBytes = lengthBytesUTF8(cwd) + 1;
        if (size < cwdLengthInBytes)
          return -68;
        stringToUTF8(cwd, buf, size);
        return cwdLengthInBytes;
      } catch (e2) {
        if (typeof FS == "undefined" || !(e2.name === "ErrnoError"))
          throw e2;
        return -e2.errno;
      }
    }
    function ___syscall_ioctl(fd, op, varargs) {
      SYSCALLS.varargs = varargs;
      try {
        var stream = SYSCALLS.getStreamFromFD(fd);
        switch (op) {
          case 21509: {
            if (!stream.tty)
              return -59;
            return 0;
          }
          case 21505: {
            if (!stream.tty)
              return -59;
            if (stream.tty.ops.ioctl_tcgets) {
              var termios = stream.tty.ops.ioctl_tcgets(stream);
              var argp = syscallGetVarargP();
              HEAP32[argp >> 2] = termios.c_iflag || 0;
              HEAP32[argp + 4 >> 2] = termios.c_oflag || 0;
              HEAP32[argp + 8 >> 2] = termios.c_cflag || 0;
              HEAP32[argp + 12 >> 2] = termios.c_lflag || 0;
              for (var i2 = 0; i2 < 32; i2++) {
                HEAP8[argp + i2 + 17] = termios.c_cc[i2] || 0;
              }
              return 0;
            }
            return 0;
          }
          case 21510:
          case 21511:
          case 21512: {
            if (!stream.tty)
              return -59;
            return 0;
          }
          case 21506:
          case 21507:
          case 21508: {
            if (!stream.tty)
              return -59;
            if (stream.tty.ops.ioctl_tcsets) {
              var argp = syscallGetVarargP();
              var c_iflag = HEAP32[argp >> 2];
              var c_oflag = HEAP32[argp + 4 >> 2];
              var c_cflag = HEAP32[argp + 8 >> 2];
              var c_lflag = HEAP32[argp + 12 >> 2];
              var c_cc = [];
              for (var i2 = 0; i2 < 32; i2++) {
                c_cc.push(HEAP8[argp + i2 + 17]);
              }
              return stream.tty.ops.ioctl_tcsets(stream.tty, op, {
                c_iflag,
                c_oflag,
                c_cflag,
                c_lflag,
                c_cc
              });
            }
            return 0;
          }
          case 21519: {
            if (!stream.tty)
              return -59;
            var argp = syscallGetVarargP();
            HEAP32[argp >> 2] = 0;
            return 0;
          }
          case 21520: {
            if (!stream.tty)
              return -59;
            return -28;
          }
          case 21531: {
            var argp = syscallGetVarargP();
            return FS.ioctl(stream, op, argp);
          }
          case 21523: {
            if (!stream.tty)
              return -59;
            if (stream.tty.ops.ioctl_tiocgwinsz) {
              var winsize = stream.tty.ops.ioctl_tiocgwinsz(stream.tty);
              var argp = syscallGetVarargP();
              HEAP16[argp >> 1] = winsize[0];
              HEAP16[argp + 2 >> 1] = winsize[1];
            }
            return 0;
          }
          case 21524: {
            if (!stream.tty)
              return -59;
            return 0;
          }
          case 21515: {
            if (!stream.tty)
              return -59;
            return 0;
          }
          default:
            return -28;
        }
      } catch (e2) {
        if (typeof FS == "undefined" || !(e2.name === "ErrnoError"))
          throw e2;
        return -e2.errno;
      }
    }
    function ___syscall_lstat64(path2, buf) {
      try {
        path2 = SYSCALLS.getStr(path2);
        return SYSCALLS.doStat(FS.lstat, path2, buf);
      } catch (e2) {
        if (typeof FS == "undefined" || !(e2.name === "ErrnoError"))
          throw e2;
        return -e2.errno;
      }
    }
    function ___syscall_mkdirat(dirfd, path2, mode) {
      try {
        path2 = SYSCALLS.getStr(path2);
        path2 = SYSCALLS.calculateAt(dirfd, path2);
        path2 = PATH.normalize(path2);
        if (path2[path2.length - 1] === "/")
          path2 = path2.substr(0, path2.length - 1);
        FS.mkdir(path2, mode, 0);
        return 0;
      } catch (e2) {
        if (typeof FS == "undefined" || !(e2.name === "ErrnoError"))
          throw e2;
        return -e2.errno;
      }
    }
    function ___syscall_newfstatat(dirfd, path2, buf, flags) {
      try {
        path2 = SYSCALLS.getStr(path2);
        var nofollow = flags & 256;
        var allowEmpty = flags & 4096;
        flags = flags & ~6400;
        path2 = SYSCALLS.calculateAt(dirfd, path2, allowEmpty);
        return SYSCALLS.doStat(nofollow ? FS.lstat : FS.stat, path2, buf);
      } catch (e2) {
        if (typeof FS == "undefined" || !(e2.name === "ErrnoError"))
          throw e2;
        return -e2.errno;
      }
    }
    function ___syscall_openat(dirfd, path2, flags, varargs) {
      SYSCALLS.varargs = varargs;
      try {
        path2 = SYSCALLS.getStr(path2);
        path2 = SYSCALLS.calculateAt(dirfd, path2);
        var mode = varargs ? syscallGetVarargI() : 0;
        return FS.open(path2, flags, mode).fd;
      } catch (e2) {
        if (typeof FS == "undefined" || !(e2.name === "ErrnoError"))
          throw e2;
        return -e2.errno;
      }
    }
    function ___syscall_readlinkat(dirfd, path2, buf, bufsize) {
      try {
        path2 = SYSCALLS.getStr(path2);
        path2 = SYSCALLS.calculateAt(dirfd, path2);
        if (bufsize <= 0)
          return -28;
        var ret = FS.readlink(path2);
        var len = Math.min(bufsize, lengthBytesUTF8(ret));
        var endChar = HEAP8[buf + len];
        stringToUTF8(ret, buf, bufsize + 1);
        HEAP8[buf + len] = endChar;
        return len;
      } catch (e2) {
        if (typeof FS == "undefined" || !(e2.name === "ErrnoError"))
          throw e2;
        return -e2.errno;
      }
    }
    function ___syscall_rmdir(path2) {
      try {
        path2 = SYSCALLS.getStr(path2);
        FS.rmdir(path2);
        return 0;
      } catch (e2) {
        if (typeof FS == "undefined" || !(e2.name === "ErrnoError"))
          throw e2;
        return -e2.errno;
      }
    }
    function ___syscall_stat64(path2, buf) {
      try {
        path2 = SYSCALLS.getStr(path2);
        return SYSCALLS.doStat(FS.stat, path2, buf);
      } catch (e2) {
        if (typeof FS == "undefined" || !(e2.name === "ErrnoError"))
          throw e2;
        return -e2.errno;
      }
    }
    function ___syscall_unlinkat(dirfd, path2, flags) {
      try {
        path2 = SYSCALLS.getStr(path2);
        path2 = SYSCALLS.calculateAt(dirfd, path2);
        if (flags === 0) {
          FS.unlink(path2);
        } else if (flags === 512) {
          FS.rmdir(path2);
        } else {
          abort("Invalid flags passed to unlinkat");
        }
        return 0;
      } catch (e2) {
        if (typeof FS == "undefined" || !(e2.name === "ErrnoError"))
          throw e2;
        return -e2.errno;
      }
    }
    var readI53FromI64 = (ptr) => {
      return HEAPU32[ptr >> 2] + HEAP32[ptr + 4 >> 2] * 4294967296;
    };
    function ___syscall_utimensat(dirfd, path2, times, flags) {
      try {
        path2 = SYSCALLS.getStr(path2);
        path2 = SYSCALLS.calculateAt(dirfd, path2, true);
        var now = Date.now(), atime, mtime;
        if (!times) {
          atime = now;
          mtime = now;
        } else {
          var seconds = readI53FromI64(times);
          var nanoseconds = HEAP32[times + 8 >> 2];
          if (nanoseconds == 1073741823) {
            atime = now;
          } else if (nanoseconds == 1073741822) {
            atime = -1;
          } else {
            atime = seconds * 1e3 + nanoseconds / (1e3 * 1e3);
          }
          times += 16;
          seconds = readI53FromI64(times);
          nanoseconds = HEAP32[times + 8 >> 2];
          if (nanoseconds == 1073741823) {
            mtime = now;
          } else if (nanoseconds == 1073741822) {
            mtime = -1;
          } else {
            mtime = seconds * 1e3 + nanoseconds / (1e3 * 1e3);
          }
        }
        if (mtime != -1 || atime != -1) {
          FS.utime(path2, atime, mtime);
        }
        return 0;
      } catch (e2) {
        if (typeof FS == "undefined" || !(e2.name === "ErrnoError"))
          throw e2;
        return -e2.errno;
      }
    }
    var nowIsMonotonic = 1;
    var __emscripten_get_now_is_monotonic = () => nowIsMonotonic;
    var isLeapYear = (year) => year % 4 === 0 && (year % 100 !== 0 || year % 400 === 0);
    var MONTH_DAYS_LEAP_CUMULATIVE = [
      0,
      31,
      60,
      91,
      121,
      152,
      182,
      213,
      244,
      274,
      305,
      335
    ];
    var MONTH_DAYS_REGULAR_CUMULATIVE = [
      0,
      31,
      59,
      90,
      120,
      151,
      181,
      212,
      243,
      273,
      304,
      334
    ];
    var ydayFromDate = (date) => {
      var leap = isLeapYear(date.getFullYear());
      var monthDaysCumulative = leap ? MONTH_DAYS_LEAP_CUMULATIVE : MONTH_DAYS_REGULAR_CUMULATIVE;
      var yday = monthDaysCumulative[date.getMonth()] + date.getDate() - 1;
      return yday;
    };
    function __localtime_js(time, tmPtr) {
      time = bigintToI53Checked(time);
      var date = new Date(time * 1e3);
      HEAP32[tmPtr >> 2] = date.getSeconds();
      HEAP32[tmPtr + 4 >> 2] = date.getMinutes();
      HEAP32[tmPtr + 8 >> 2] = date.getHours();
      HEAP32[tmPtr + 12 >> 2] = date.getDate();
      HEAP32[tmPtr + 16 >> 2] = date.getMonth();
      HEAP32[tmPtr + 20 >> 2] = date.getFullYear() - 1900;
      HEAP32[tmPtr + 24 >> 2] = date.getDay();
      var yday = ydayFromDate(date) | 0;
      HEAP32[tmPtr + 28 >> 2] = yday;
      HEAP32[tmPtr + 36 >> 2] = -(date.getTimezoneOffset() * 60);
      var start = new Date(date.getFullYear(), 0, 1);
      var summerOffset = new Date(date.getFullYear(), 6, 1).getTimezoneOffset();
      var winterOffset = start.getTimezoneOffset();
      var dst = (summerOffset != winterOffset && date.getTimezoneOffset() == Math.min(winterOffset, summerOffset)) | 0;
      HEAP32[tmPtr + 32 >> 2] = dst;
    }
    function __mmap_js(len, prot, flags, fd, offset, allocated, addr) {
      offset = bigintToI53Checked(offset);
      try {
        if (isNaN(offset))
          return 61;
        var stream = SYSCALLS.getStreamFromFD(fd);
        var res = FS.mmap(stream, len, offset, prot, flags);
        var ptr = res.ptr;
        HEAP32[allocated >> 2] = res.allocated;
        HEAPU32[addr >> 2] = ptr;
        return 0;
      } catch (e2) {
        if (typeof FS == "undefined" || !(e2.name === "ErrnoError"))
          throw e2;
        return -e2.errno;
      }
    }
    function __munmap_js(addr, len, prot, flags, fd, offset) {
      offset = bigintToI53Checked(offset);
      try {
        var stream = SYSCALLS.getStreamFromFD(fd);
        if (prot & 2) {
          SYSCALLS.doMsync(addr, stream, len, flags, offset);
        }
      } catch (e2) {
        if (typeof FS == "undefined" || !(e2.name === "ErrnoError"))
          throw e2;
        return -e2.errno;
      }
    }
    var __tzset_js = (timezone, daylight, std_name, dst_name) => {
      var currentYear = (/* @__PURE__ */ new Date()).getFullYear();
      var winter = new Date(currentYear, 0, 1);
      var summer = new Date(currentYear, 6, 1);
      var winterOffset = winter.getTimezoneOffset();
      var summerOffset = summer.getTimezoneOffset();
      var stdTimezoneOffset = Math.max(winterOffset, summerOffset);
      HEAPU32[timezone >> 2] = stdTimezoneOffset * 60;
      HEAP32[daylight >> 2] = Number(winterOffset != summerOffset);
      var extractZone = (timezoneOffset) => {
        var sign = timezoneOffset >= 0 ? "-" : "+";
        var absOffset = Math.abs(timezoneOffset);
        var hours = String(Math.floor(absOffset / 60)).padStart(2, "0");
        var minutes = String(absOffset % 60).padStart(2, "0");
        return `UTC${sign}${hours}${minutes}`;
      };
      var winterName = extractZone(winterOffset);
      var summerName = extractZone(summerOffset);
      if (summerOffset < winterOffset) {
        stringToUTF8(winterName, std_name, 17);
        stringToUTF8(summerName, dst_name, 17);
      } else {
        stringToUTF8(winterName, dst_name, 17);
        stringToUTF8(summerName, std_name, 17);
      }
    };
    var _emscripten_date_now = () => Date.now();
    var _emscripten_get_now = () => performance.now();
    var getHeapMax = () => 2147483648;
    var growMemory = (size) => {
      var b = wasmMemory.buffer;
      var pages = (size - b.byteLength + 65535) / 65536 | 0;
      try {
        wasmMemory.grow(pages);
        updateMemoryViews();
        return 1;
      } catch (e2) {
      }
    };
    var _emscripten_resize_heap = (requestedSize) => {
      var oldSize = HEAPU8.length;
      requestedSize >>>= 0;
      var maxHeapSize = getHeapMax();
      if (requestedSize > maxHeapSize) {
        return false;
      }
      for (var cutDown = 1; cutDown <= 4; cutDown *= 2) {
        var overGrownHeapSize = oldSize * (1 + 0.2 / cutDown);
        overGrownHeapSize = Math.min(
          overGrownHeapSize,
          requestedSize + 100663296
        );
        var newSize = Math.min(
          maxHeapSize,
          alignMemory(Math.max(requestedSize, overGrownHeapSize), 65536)
        );
        var replacement = growMemory(newSize);
        if (replacement) {
          return true;
        }
      }
      return false;
    };
    var ENV = {};
    var getExecutableName = () => {
      return thisProgram || "./this.program";
    };
    var getEnvStrings = () => {
      if (!getEnvStrings.strings) {
        var lang = (typeof navigator == "object" && navigator.languages && navigator.languages[0] || "C").replace("-", "_") + ".UTF-8";
        var env2 = {
          USER: "web_user",
          LOGNAME: "web_user",
          PATH: "/",
          PWD: "/",
          HOME: "/home/web_user",
          LANG: lang,
          _: getExecutableName()
        };
        for (var x2 in ENV) {
          if (ENV[x2] === void 0)
            delete env2[x2];
          else
            env2[x2] = ENV[x2];
        }
        var strings = [];
        for (var x2 in env2) {
          strings.push(`${x2}=${env2[x2]}`);
        }
        getEnvStrings.strings = strings;
      }
      return getEnvStrings.strings;
    };
    var stringToAscii = (str, buffer) => {
      for (var i2 = 0; i2 < str.length; ++i2) {
        HEAP8[buffer++] = str.charCodeAt(i2);
      }
      HEAP8[buffer] = 0;
    };
    var _environ_get = (__environ, environ_buf) => {
      var bufSize = 0;
      getEnvStrings().forEach((string, i2) => {
        var ptr = environ_buf + bufSize;
        HEAPU32[__environ + i2 * 4 >> 2] = ptr;
        stringToAscii(string, ptr);
        bufSize += string.length + 1;
      });
      return 0;
    };
    var _environ_sizes_get = (penviron_count, penviron_buf_size) => {
      var strings = getEnvStrings();
      HEAPU32[penviron_count >> 2] = strings.length;
      var bufSize = 0;
      strings.forEach((string) => bufSize += string.length + 1);
      HEAPU32[penviron_buf_size >> 2] = bufSize;
      return 0;
    };
    function _fd_close(fd) {
      try {
        var stream = SYSCALLS.getStreamFromFD(fd);
        FS.close(stream);
        return 0;
      } catch (e2) {
        if (typeof FS == "undefined" || !(e2.name === "ErrnoError"))
          throw e2;
        return e2.errno;
      }
    }
    function _fd_fdstat_get(fd, pbuf) {
      try {
        var rightsBase = 0;
        var rightsInheriting = 0;
        var flags = 0;
        {
          var stream = SYSCALLS.getStreamFromFD(fd);
          var type = stream.tty ? 2 : FS.isDir(stream.mode) ? 3 : FS.isLink(stream.mode) ? 7 : 4;
        }
        HEAP8[pbuf] = type;
        HEAP16[pbuf + 2 >> 1] = flags;
        HEAP64[pbuf + 8 >> 3] = BigInt(rightsBase);
        HEAP64[pbuf + 16 >> 3] = BigInt(rightsInheriting);
        return 0;
      } catch (e2) {
        if (typeof FS == "undefined" || !(e2.name === "ErrnoError"))
          throw e2;
        return e2.errno;
      }
    }
    var doReadv = (stream, iov, iovcnt, offset) => {
      var ret = 0;
      for (var i2 = 0; i2 < iovcnt; i2++) {
        var ptr = HEAPU32[iov >> 2];
        var len = HEAPU32[iov + 4 >> 2];
        iov += 8;
        var curr = FS.read(stream, HEAP8, ptr, len, offset);
        if (curr < 0)
          return -1;
        ret += curr;
        if (curr < len)
          break;
        if (typeof offset != "undefined") {
          offset += curr;
        }
      }
      return ret;
    };
    function _fd_read(fd, iov, iovcnt, pnum) {
      try {
        var stream = SYSCALLS.getStreamFromFD(fd);
        var num = doReadv(stream, iov, iovcnt);
        HEAPU32[pnum >> 2] = num;
        return 0;
      } catch (e2) {
        if (typeof FS == "undefined" || !(e2.name === "ErrnoError"))
          throw e2;
        return e2.errno;
      }
    }
    function _fd_seek(fd, offset, whence, newOffset) {
      offset = bigintToI53Checked(offset);
      try {
        if (isNaN(offset))
          return 61;
        var stream = SYSCALLS.getStreamFromFD(fd);
        FS.llseek(stream, offset, whence);
        HEAP64[newOffset >> 3] = BigInt(stream.position);
        if (stream.getdents && offset === 0 && whence === 0)
          stream.getdents = null;
        return 0;
      } catch (e2) {
        if (typeof FS == "undefined" || !(e2.name === "ErrnoError"))
          throw e2;
        return e2.errno;
      }
    }
    function _fd_sync(fd) {
      var _a8;
      try {
        var stream = SYSCALLS.getStreamFromFD(fd);
        if ((_a8 = stream.stream_ops) == null ? void 0 : _a8.fsync) {
          return stream.stream_ops.fsync(stream);
        }
        return 0;
      } catch (e2) {
        if (typeof FS == "undefined" || !(e2.name === "ErrnoError"))
          throw e2;
        return e2.errno;
      }
    }
    var doWritev = (stream, iov, iovcnt, offset) => {
      var ret = 0;
      for (var i2 = 0; i2 < iovcnt; i2++) {
        var ptr = HEAPU32[iov >> 2];
        var len = HEAPU32[iov + 4 >> 2];
        iov += 8;
        var curr = FS.write(stream, HEAP8, ptr, len, offset);
        if (curr < 0)
          return -1;
        ret += curr;
        if (curr < len) {
          break;
        }
        if (typeof offset != "undefined") {
          offset += curr;
        }
      }
      return ret;
    };
    function _fd_write(fd, iov, iovcnt, pnum) {
      try {
        var stream = SYSCALLS.getStreamFromFD(fd);
        var num = doWritev(stream, iov, iovcnt);
        HEAPU32[pnum >> 2] = num;
        return 0;
      } catch (e2) {
        if (typeof FS == "undefined" || !(e2.name === "ErrnoError"))
          throw e2;
        return e2.errno;
      }
    }
    FS.createPreloadedFile = FS_createPreloadedFile;
    FS.staticInit();
    var wasmImports = {
      __syscall_chmod: ___syscall_chmod,
      __syscall_faccessat: ___syscall_faccessat,
      __syscall_fchmod: ___syscall_fchmod,
      __syscall_fchown32: ___syscall_fchown32,
      __syscall_fcntl64: ___syscall_fcntl64,
      __syscall_fstat64: ___syscall_fstat64,
      __syscall_ftruncate64: ___syscall_ftruncate64,
      __syscall_getcwd: ___syscall_getcwd,
      __syscall_ioctl: ___syscall_ioctl,
      __syscall_lstat64: ___syscall_lstat64,
      __syscall_mkdirat: ___syscall_mkdirat,
      __syscall_newfstatat: ___syscall_newfstatat,
      __syscall_openat: ___syscall_openat,
      __syscall_readlinkat: ___syscall_readlinkat,
      __syscall_rmdir: ___syscall_rmdir,
      __syscall_stat64: ___syscall_stat64,
      __syscall_unlinkat: ___syscall_unlinkat,
      __syscall_utimensat: ___syscall_utimensat,
      _emscripten_get_now_is_monotonic: __emscripten_get_now_is_monotonic,
      _localtime_js: __localtime_js,
      _mmap_js: __mmap_js,
      _munmap_js: __munmap_js,
      _tzset_js: __tzset_js,
      emscripten_date_now: _emscripten_date_now,
      emscripten_get_now: _emscripten_get_now,
      emscripten_resize_heap: _emscripten_resize_heap,
      environ_get: _environ_get,
      environ_sizes_get: _environ_sizes_get,
      fd_close: _fd_close,
      fd_fdstat_get: _fd_fdstat_get,
      fd_read: _fd_read,
      fd_seek: _fd_seek,
      fd_sync: _fd_sync,
      fd_write: _fd_write,
      memory: wasmMemory
    };
    var wasmExports = createWasm();
    var ___wasm_call_ctors = () => (___wasm_call_ctors = wasmExports["__wasm_call_ctors"])();
    var _sqlite3_status64 = Module2["_sqlite3_status64"] = (a0, a1, a22, a3) => (_sqlite3_status64 = Module2["_sqlite3_status64"] = wasmExports["sqlite3_status64"])(a0, a1, a22, a3);
    var _sqlite3_status = Module2["_sqlite3_status"] = (a0, a1, a22, a3) => (_sqlite3_status = Module2["_sqlite3_status"] = wasmExports["sqlite3_status"])(a0, a1, a22, a3);
    var _sqlite3_db_status = Module2["_sqlite3_db_status"] = (a0, a1, a22, a3, a4) => (_sqlite3_db_status = Module2["_sqlite3_db_status"] = wasmExports["sqlite3_db_status"])(a0, a1, a22, a3, a4);
    var _sqlite3_msize = Module2["_sqlite3_msize"] = (a0) => (_sqlite3_msize = Module2["_sqlite3_msize"] = wasmExports["sqlite3_msize"])(a0);
    var _sqlite3_vfs_find = Module2["_sqlite3_vfs_find"] = (a0) => (_sqlite3_vfs_find = Module2["_sqlite3_vfs_find"] = wasmExports["sqlite3_vfs_find"])(a0);
    var _sqlite3_initialize = Module2["_sqlite3_initialize"] = () => (_sqlite3_initialize = Module2["_sqlite3_initialize"] = wasmExports["sqlite3_initialize"])();
    var _sqlite3_malloc = Module2["_sqlite3_malloc"] = (a0) => (_sqlite3_malloc = Module2["_sqlite3_malloc"] = wasmExports["sqlite3_malloc"])(a0);
    var _sqlite3_free = Module2["_sqlite3_free"] = (a0) => (_sqlite3_free = Module2["_sqlite3_free"] = wasmExports["sqlite3_free"])(
      a0
    );
    var _sqlite3_vfs_register = Module2["_sqlite3_vfs_register"] = (a0, a1) => (_sqlite3_vfs_register = Module2["_sqlite3_vfs_register"] = wasmExports["sqlite3_vfs_register"])(a0, a1);
    var _sqlite3_vfs_unregister = Module2["_sqlite3_vfs_unregister"] = (a0) => (_sqlite3_vfs_unregister = Module2["_sqlite3_vfs_unregister"] = wasmExports["sqlite3_vfs_unregister"])(a0);
    var _sqlite3_malloc64 = Module2["_sqlite3_malloc64"] = (a0) => (_sqlite3_malloc64 = Module2["_sqlite3_malloc64"] = wasmExports["sqlite3_malloc64"])(a0);
    var _sqlite3_realloc = Module2["_sqlite3_realloc"] = (a0, a1) => (_sqlite3_realloc = Module2["_sqlite3_realloc"] = wasmExports["sqlite3_realloc"])(a0, a1);
    var _sqlite3_realloc64 = Module2["_sqlite3_realloc64"] = (a0, a1) => (_sqlite3_realloc64 = Module2["_sqlite3_realloc64"] = wasmExports["sqlite3_realloc64"])(a0, a1);
    var _sqlite3_value_text = Module2["_sqlite3_value_text"] = (a0) => (_sqlite3_value_text = Module2["_sqlite3_value_text"] = wasmExports["sqlite3_value_text"])(a0);
    var _sqlite3_randomness = Module2["_sqlite3_randomness"] = (a0, a1) => (_sqlite3_randomness = Module2["_sqlite3_randomness"] = wasmExports["sqlite3_randomness"])(a0, a1);
    var _sqlite3_stricmp = Module2["_sqlite3_stricmp"] = (a0, a1) => (_sqlite3_stricmp = Module2["_sqlite3_stricmp"] = wasmExports["sqlite3_stricmp"])(a0, a1);
    var _sqlite3_strnicmp = Module2["_sqlite3_strnicmp"] = (a0, a1, a22) => (_sqlite3_strnicmp = Module2["_sqlite3_strnicmp"] = wasmExports["sqlite3_strnicmp"])(a0, a1, a22);
    var _sqlite3_uri_parameter = Module2["_sqlite3_uri_parameter"] = (a0, a1) => (_sqlite3_uri_parameter = Module2["_sqlite3_uri_parameter"] = wasmExports["sqlite3_uri_parameter"])(a0, a1);
    var _sqlite3_uri_boolean = Module2["_sqlite3_uri_boolean"] = (a0, a1, a22) => (_sqlite3_uri_boolean = Module2["_sqlite3_uri_boolean"] = wasmExports["sqlite3_uri_boolean"])(a0, a1, a22);
    var _sqlite3_serialize = Module2["_sqlite3_serialize"] = (a0, a1, a22, a3) => (_sqlite3_serialize = Module2["_sqlite3_serialize"] = wasmExports["sqlite3_serialize"])(a0, a1, a22, a3);
    var _sqlite3_prepare_v2 = Module2["_sqlite3_prepare_v2"] = (a0, a1, a22, a3, a4) => (_sqlite3_prepare_v2 = Module2["_sqlite3_prepare_v2"] = wasmExports["sqlite3_prepare_v2"])(a0, a1, a22, a3, a4);
    var _sqlite3_step = Module2["_sqlite3_step"] = (a0) => (_sqlite3_step = Module2["_sqlite3_step"] = wasmExports["sqlite3_step"])(
      a0
    );
    var _sqlite3_column_int64 = Module2["_sqlite3_column_int64"] = (a0, a1) => (_sqlite3_column_int64 = Module2["_sqlite3_column_int64"] = wasmExports["sqlite3_column_int64"])(a0, a1);
    var _sqlite3_reset = Module2["_sqlite3_reset"] = (a0) => (_sqlite3_reset = Module2["_sqlite3_reset"] = wasmExports["sqlite3_reset"])(a0);
    var _sqlite3_exec = Module2["_sqlite3_exec"] = (a0, a1, a22, a3, a4) => (_sqlite3_exec = Module2["_sqlite3_exec"] = wasmExports["sqlite3_exec"])(
      a0,
      a1,
      a22,
      a3,
      a4
    );
    var _sqlite3_column_int = Module2["_sqlite3_column_int"] = (a0, a1) => (_sqlite3_column_int = Module2["_sqlite3_column_int"] = wasmExports["sqlite3_column_int"])(a0, a1);
    var _sqlite3_finalize = Module2["_sqlite3_finalize"] = (a0) => (_sqlite3_finalize = Module2["_sqlite3_finalize"] = wasmExports["sqlite3_finalize"])(a0);
    var _sqlite3_file_control = Module2["_sqlite3_file_control"] = (a0, a1, a22, a3) => (_sqlite3_file_control = Module2["_sqlite3_file_control"] = wasmExports["sqlite3_file_control"])(a0, a1, a22, a3);
    var _sqlite3_column_name = Module2["_sqlite3_column_name"] = (a0, a1) => (_sqlite3_column_name = Module2["_sqlite3_column_name"] = wasmExports["sqlite3_column_name"])(a0, a1);
    var _sqlite3_column_text = Module2["_sqlite3_column_text"] = (a0, a1) => (_sqlite3_column_text = Module2["_sqlite3_column_text"] = wasmExports["sqlite3_column_text"])(a0, a1);
    var _sqlite3_column_type = Module2["_sqlite3_column_type"] = (a0, a1) => (_sqlite3_column_type = Module2["_sqlite3_column_type"] = wasmExports["sqlite3_column_type"])(a0, a1);
    var _sqlite3_errmsg = Module2["_sqlite3_errmsg"] = (a0) => (_sqlite3_errmsg = Module2["_sqlite3_errmsg"] = wasmExports["sqlite3_errmsg"])(a0);
    var _sqlite3_deserialize = Module2["_sqlite3_deserialize"] = (a0, a1, a22, a3, a4, a5) => (_sqlite3_deserialize = Module2["_sqlite3_deserialize"] = wasmExports["sqlite3_deserialize"])(a0, a1, a22, a3, a4, a5);
    var _sqlite3_clear_bindings = Module2["_sqlite3_clear_bindings"] = (a0) => (_sqlite3_clear_bindings = Module2["_sqlite3_clear_bindings"] = wasmExports["sqlite3_clear_bindings"])(a0);
    var _sqlite3_value_blob = Module2["_sqlite3_value_blob"] = (a0) => (_sqlite3_value_blob = Module2["_sqlite3_value_blob"] = wasmExports["sqlite3_value_blob"])(a0);
    var _sqlite3_value_bytes = Module2["_sqlite3_value_bytes"] = (a0) => (_sqlite3_value_bytes = Module2["_sqlite3_value_bytes"] = wasmExports["sqlite3_value_bytes"])(a0);
    var _sqlite3_value_double = Module2["_sqlite3_value_double"] = (a0) => (_sqlite3_value_double = Module2["_sqlite3_value_double"] = wasmExports["sqlite3_value_double"])(a0);
    var _sqlite3_value_int = Module2["_sqlite3_value_int"] = (a0) => (_sqlite3_value_int = Module2["_sqlite3_value_int"] = wasmExports["sqlite3_value_int"])(a0);
    var _sqlite3_value_int64 = Module2["_sqlite3_value_int64"] = (a0) => (_sqlite3_value_int64 = Module2["_sqlite3_value_int64"] = wasmExports["sqlite3_value_int64"])(a0);
    var _sqlite3_value_subtype = Module2["_sqlite3_value_subtype"] = (a0) => (_sqlite3_value_subtype = Module2["_sqlite3_value_subtype"] = wasmExports["sqlite3_value_subtype"])(a0);
    var _sqlite3_value_pointer = Module2["_sqlite3_value_pointer"] = (a0, a1) => (_sqlite3_value_pointer = Module2["_sqlite3_value_pointer"] = wasmExports["sqlite3_value_pointer"])(a0, a1);
    var _sqlite3_value_type = Module2["_sqlite3_value_type"] = (a0) => (_sqlite3_value_type = Module2["_sqlite3_value_type"] = wasmExports["sqlite3_value_type"])(a0);
    var _sqlite3_value_nochange = Module2["_sqlite3_value_nochange"] = (a0) => (_sqlite3_value_nochange = Module2["_sqlite3_value_nochange"] = wasmExports["sqlite3_value_nochange"])(a0);
    var _sqlite3_value_frombind = Module2["_sqlite3_value_frombind"] = (a0) => (_sqlite3_value_frombind = Module2["_sqlite3_value_frombind"] = wasmExports["sqlite3_value_frombind"])(a0);
    var _sqlite3_value_dup = Module2["_sqlite3_value_dup"] = (a0) => (_sqlite3_value_dup = Module2["_sqlite3_value_dup"] = wasmExports["sqlite3_value_dup"])(a0);
    var _sqlite3_value_free = Module2["_sqlite3_value_free"] = (a0) => (_sqlite3_value_free = Module2["_sqlite3_value_free"] = wasmExports["sqlite3_value_free"])(a0);
    var _sqlite3_result_blob = Module2["_sqlite3_result_blob"] = (a0, a1, a22, a3) => (_sqlite3_result_blob = Module2["_sqlite3_result_blob"] = wasmExports["sqlite3_result_blob"])(a0, a1, a22, a3);
    var _sqlite3_result_error_toobig = Module2["_sqlite3_result_error_toobig"] = (a0) => (_sqlite3_result_error_toobig = Module2["_sqlite3_result_error_toobig"] = wasmExports["sqlite3_result_error_toobig"])(a0);
    var _sqlite3_result_error_nomem = Module2["_sqlite3_result_error_nomem"] = (a0) => (_sqlite3_result_error_nomem = Module2["_sqlite3_result_error_nomem"] = wasmExports["sqlite3_result_error_nomem"])(a0);
    var _sqlite3_result_double = Module2["_sqlite3_result_double"] = (a0, a1) => (_sqlite3_result_double = Module2["_sqlite3_result_double"] = wasmExports["sqlite3_result_double"])(a0, a1);
    var _sqlite3_result_error = Module2["_sqlite3_result_error"] = (a0, a1, a22) => (_sqlite3_result_error = Module2["_sqlite3_result_error"] = wasmExports["sqlite3_result_error"])(a0, a1, a22);
    var _sqlite3_result_int = Module2["_sqlite3_result_int"] = (a0, a1) => (_sqlite3_result_int = Module2["_sqlite3_result_int"] = wasmExports["sqlite3_result_int"])(a0, a1);
    var _sqlite3_result_int64 = Module2["_sqlite3_result_int64"] = (a0, a1) => (_sqlite3_result_int64 = Module2["_sqlite3_result_int64"] = wasmExports["sqlite3_result_int64"])(a0, a1);
    var _sqlite3_result_null = Module2["_sqlite3_result_null"] = (a0) => (_sqlite3_result_null = Module2["_sqlite3_result_null"] = wasmExports["sqlite3_result_null"])(a0);
    var _sqlite3_result_pointer = Module2["_sqlite3_result_pointer"] = (a0, a1, a22, a3) => (_sqlite3_result_pointer = Module2["_sqlite3_result_pointer"] = wasmExports["sqlite3_result_pointer"])(a0, a1, a22, a3);
    var _sqlite3_result_subtype = Module2["_sqlite3_result_subtype"] = (a0, a1) => (_sqlite3_result_subtype = Module2["_sqlite3_result_subtype"] = wasmExports["sqlite3_result_subtype"])(a0, a1);
    var _sqlite3_result_text = Module2["_sqlite3_result_text"] = (a0, a1, a22, a3) => (_sqlite3_result_text = Module2["_sqlite3_result_text"] = wasmExports["sqlite3_result_text"])(a0, a1, a22, a3);
    var _sqlite3_result_zeroblob = Module2["_sqlite3_result_zeroblob"] = (a0, a1) => (_sqlite3_result_zeroblob = Module2["_sqlite3_result_zeroblob"] = wasmExports["sqlite3_result_zeroblob"])(a0, a1);
    var _sqlite3_result_zeroblob64 = Module2["_sqlite3_result_zeroblob64"] = (a0, a1) => (_sqlite3_result_zeroblob64 = Module2["_sqlite3_result_zeroblob64"] = wasmExports["sqlite3_result_zeroblob64"])(a0, a1);
    var _sqlite3_result_error_code = Module2["_sqlite3_result_error_code"] = (a0, a1) => (_sqlite3_result_error_code = Module2["_sqlite3_result_error_code"] = wasmExports["sqlite3_result_error_code"])(a0, a1);
    var _sqlite3_user_data = Module2["_sqlite3_user_data"] = (a0) => (_sqlite3_user_data = Module2["_sqlite3_user_data"] = wasmExports["sqlite3_user_data"])(a0);
    var _sqlite3_context_db_handle = Module2["_sqlite3_context_db_handle"] = (a0) => (_sqlite3_context_db_handle = Module2["_sqlite3_context_db_handle"] = wasmExports["sqlite3_context_db_handle"])(a0);
    var _sqlite3_vtab_nochange = Module2["_sqlite3_vtab_nochange"] = (a0) => (_sqlite3_vtab_nochange = Module2["_sqlite3_vtab_nochange"] = wasmExports["sqlite3_vtab_nochange"])(a0);
    var _sqlite3_vtab_in_first = Module2["_sqlite3_vtab_in_first"] = (a0, a1) => (_sqlite3_vtab_in_first = Module2["_sqlite3_vtab_in_first"] = wasmExports["sqlite3_vtab_in_first"])(a0, a1);
    var _sqlite3_vtab_in_next = Module2["_sqlite3_vtab_in_next"] = (a0, a1) => (_sqlite3_vtab_in_next = Module2["_sqlite3_vtab_in_next"] = wasmExports["sqlite3_vtab_in_next"])(a0, a1);
    var _sqlite3_aggregate_context = Module2["_sqlite3_aggregate_context"] = (a0, a1) => (_sqlite3_aggregate_context = Module2["_sqlite3_aggregate_context"] = wasmExports["sqlite3_aggregate_context"])(a0, a1);
    var _sqlite3_get_auxdata = Module2["_sqlite3_get_auxdata"] = (a0, a1) => (_sqlite3_get_auxdata = Module2["_sqlite3_get_auxdata"] = wasmExports["sqlite3_get_auxdata"])(a0, a1);
    var _sqlite3_set_auxdata = Module2["_sqlite3_set_auxdata"] = (a0, a1, a22, a3) => (_sqlite3_set_auxdata = Module2["_sqlite3_set_auxdata"] = wasmExports["sqlite3_set_auxdata"])(a0, a1, a22, a3);
    var _sqlite3_column_count = Module2["_sqlite3_column_count"] = (a0) => (_sqlite3_column_count = Module2["_sqlite3_column_count"] = wasmExports["sqlite3_column_count"])(a0);
    var _sqlite3_data_count = Module2["_sqlite3_data_count"] = (a0) => (_sqlite3_data_count = Module2["_sqlite3_data_count"] = wasmExports["sqlite3_data_count"])(a0);
    var _sqlite3_column_blob = Module2["_sqlite3_column_blob"] = (a0, a1) => (_sqlite3_column_blob = Module2["_sqlite3_column_blob"] = wasmExports["sqlite3_column_blob"])(a0, a1);
    var _sqlite3_column_bytes = Module2["_sqlite3_column_bytes"] = (a0, a1) => (_sqlite3_column_bytes = Module2["_sqlite3_column_bytes"] = wasmExports["sqlite3_column_bytes"])(a0, a1);
    var _sqlite3_column_double = Module2["_sqlite3_column_double"] = (a0, a1) => (_sqlite3_column_double = Module2["_sqlite3_column_double"] = wasmExports["sqlite3_column_double"])(a0, a1);
    var _sqlite3_column_value = Module2["_sqlite3_column_value"] = (a0, a1) => (_sqlite3_column_value = Module2["_sqlite3_column_value"] = wasmExports["sqlite3_column_value"])(a0, a1);
    var _sqlite3_column_decltype = Module2["_sqlite3_column_decltype"] = (a0, a1) => (_sqlite3_column_decltype = Module2["_sqlite3_column_decltype"] = wasmExports["sqlite3_column_decltype"])(a0, a1);
    var _sqlite3_bind_blob = Module2["_sqlite3_bind_blob"] = (a0, a1, a22, a3, a4) => (_sqlite3_bind_blob = Module2["_sqlite3_bind_blob"] = wasmExports["sqlite3_bind_blob"])(a0, a1, a22, a3, a4);
    var _sqlite3_bind_double = Module2["_sqlite3_bind_double"] = (a0, a1, a22) => (_sqlite3_bind_double = Module2["_sqlite3_bind_double"] = wasmExports["sqlite3_bind_double"])(a0, a1, a22);
    var _sqlite3_bind_int = Module2["_sqlite3_bind_int"] = (a0, a1, a22) => (_sqlite3_bind_int = Module2["_sqlite3_bind_int"] = wasmExports["sqlite3_bind_int"])(a0, a1, a22);
    var _sqlite3_bind_int64 = Module2["_sqlite3_bind_int64"] = (a0, a1, a22) => (_sqlite3_bind_int64 = Module2["_sqlite3_bind_int64"] = wasmExports["sqlite3_bind_int64"])(a0, a1, a22);
    var _sqlite3_bind_null = Module2["_sqlite3_bind_null"] = (a0, a1) => (_sqlite3_bind_null = Module2["_sqlite3_bind_null"] = wasmExports["sqlite3_bind_null"])(a0, a1);
    var _sqlite3_bind_pointer = Module2["_sqlite3_bind_pointer"] = (a0, a1, a22, a3, a4) => (_sqlite3_bind_pointer = Module2["_sqlite3_bind_pointer"] = wasmExports["sqlite3_bind_pointer"])(a0, a1, a22, a3, a4);
    var _sqlite3_bind_text = Module2["_sqlite3_bind_text"] = (a0, a1, a22, a3, a4) => (_sqlite3_bind_text = Module2["_sqlite3_bind_text"] = wasmExports["sqlite3_bind_text"])(a0, a1, a22, a3, a4);
    var _sqlite3_bind_parameter_count = Module2["_sqlite3_bind_parameter_count"] = (a0) => (_sqlite3_bind_parameter_count = Module2["_sqlite3_bind_parameter_count"] = wasmExports["sqlite3_bind_parameter_count"])(a0);
    var _sqlite3_bind_parameter_name = Module2["_sqlite3_bind_parameter_name"] = (a0, a1) => (_sqlite3_bind_parameter_name = Module2["_sqlite3_bind_parameter_name"] = wasmExports["sqlite3_bind_parameter_name"])(a0, a1);
    var _sqlite3_bind_parameter_index = Module2["_sqlite3_bind_parameter_index"] = (a0, a1) => (_sqlite3_bind_parameter_index = Module2["_sqlite3_bind_parameter_index"] = wasmExports["sqlite3_bind_parameter_index"])(a0, a1);
    var _sqlite3_db_handle = Module2["_sqlite3_db_handle"] = (a0) => (_sqlite3_db_handle = Module2["_sqlite3_db_handle"] = wasmExports["sqlite3_db_handle"])(a0);
    var _sqlite3_stmt_readonly = Module2["_sqlite3_stmt_readonly"] = (a0) => (_sqlite3_stmt_readonly = Module2["_sqlite3_stmt_readonly"] = wasmExports["sqlite3_stmt_readonly"])(a0);
    var _sqlite3_stmt_isexplain = Module2["_sqlite3_stmt_isexplain"] = (a0) => (_sqlite3_stmt_isexplain = Module2["_sqlite3_stmt_isexplain"] = wasmExports["sqlite3_stmt_isexplain"])(a0);
    var _sqlite3_stmt_explain = Module2["_sqlite3_stmt_explain"] = (a0, a1) => (_sqlite3_stmt_explain = Module2["_sqlite3_stmt_explain"] = wasmExports["sqlite3_stmt_explain"])(a0, a1);
    var _sqlite3_stmt_busy = Module2["_sqlite3_stmt_busy"] = (a0) => (_sqlite3_stmt_busy = Module2["_sqlite3_stmt_busy"] = wasmExports["sqlite3_stmt_busy"])(a0);
    var _sqlite3_stmt_status = Module2["_sqlite3_stmt_status"] = (a0, a1, a22) => (_sqlite3_stmt_status = Module2["_sqlite3_stmt_status"] = wasmExports["sqlite3_stmt_status"])(a0, a1, a22);
    var _sqlite3_sql = Module2["_sqlite3_sql"] = (a0) => (_sqlite3_sql = Module2["_sqlite3_sql"] = wasmExports["sqlite3_sql"])(a0);
    var _sqlite3_expanded_sql = Module2["_sqlite3_expanded_sql"] = (a0) => (_sqlite3_expanded_sql = Module2["_sqlite3_expanded_sql"] = wasmExports["sqlite3_expanded_sql"])(a0);
    var _sqlite3_preupdate_old = Module2["_sqlite3_preupdate_old"] = (a0, a1, a22) => (_sqlite3_preupdate_old = Module2["_sqlite3_preupdate_old"] = wasmExports["sqlite3_preupdate_old"])(a0, a1, a22);
    var _sqlite3_preupdate_count = Module2["_sqlite3_preupdate_count"] = (a0) => (_sqlite3_preupdate_count = Module2["_sqlite3_preupdate_count"] = wasmExports["sqlite3_preupdate_count"])(a0);
    var _sqlite3_preupdate_depth = Module2["_sqlite3_preupdate_depth"] = (a0) => (_sqlite3_preupdate_depth = Module2["_sqlite3_preupdate_depth"] = wasmExports["sqlite3_preupdate_depth"])(a0);
    var _sqlite3_preupdate_blobwrite = Module2["_sqlite3_preupdate_blobwrite"] = (a0) => (_sqlite3_preupdate_blobwrite = Module2["_sqlite3_preupdate_blobwrite"] = wasmExports["sqlite3_preupdate_blobwrite"])(a0);
    var _sqlite3_preupdate_new = Module2["_sqlite3_preupdate_new"] = (a0, a1, a22) => (_sqlite3_preupdate_new = Module2["_sqlite3_preupdate_new"] = wasmExports["sqlite3_preupdate_new"])(a0, a1, a22);
    var _sqlite3_value_numeric_type = Module2["_sqlite3_value_numeric_type"] = (a0) => (_sqlite3_value_numeric_type = Module2["_sqlite3_value_numeric_type"] = wasmExports["sqlite3_value_numeric_type"])(a0);
    var _sqlite3_set_authorizer = Module2["_sqlite3_set_authorizer"] = (a0, a1, a22) => (_sqlite3_set_authorizer = Module2["_sqlite3_set_authorizer"] = wasmExports["sqlite3_set_authorizer"])(a0, a1, a22);
    var _sqlite3_strglob = Module2["_sqlite3_strglob"] = (a0, a1) => (_sqlite3_strglob = Module2["_sqlite3_strglob"] = wasmExports["sqlite3_strglob"])(a0, a1);
    var _sqlite3_strlike = Module2["_sqlite3_strlike"] = (a0, a1, a22) => (_sqlite3_strlike = Module2["_sqlite3_strlike"] = wasmExports["sqlite3_strlike"])(a0, a1, a22);
    var _sqlite3_auto_extension = Module2["_sqlite3_auto_extension"] = (a0) => (_sqlite3_auto_extension = Module2["_sqlite3_auto_extension"] = wasmExports["sqlite3_auto_extension"])(a0);
    var _sqlite3_cancel_auto_extension = Module2["_sqlite3_cancel_auto_extension"] = (a0) => (_sqlite3_cancel_auto_extension = Module2["_sqlite3_cancel_auto_extension"] = wasmExports["sqlite3_cancel_auto_extension"])(a0);
    var _sqlite3_reset_auto_extension = Module2["_sqlite3_reset_auto_extension"] = () => (_sqlite3_reset_auto_extension = Module2["_sqlite3_reset_auto_extension"] = wasmExports["sqlite3_reset_auto_extension"])();
    var _sqlite3_prepare_v3 = Module2["_sqlite3_prepare_v3"] = (a0, a1, a22, a3, a4, a5) => (_sqlite3_prepare_v3 = Module2["_sqlite3_prepare_v3"] = wasmExports["sqlite3_prepare_v3"])(a0, a1, a22, a3, a4, a5);
    var _sqlite3_create_module = Module2["_sqlite3_create_module"] = (a0, a1, a22, a3) => (_sqlite3_create_module = Module2["_sqlite3_create_module"] = wasmExports["sqlite3_create_module"])(a0, a1, a22, a3);
    var _sqlite3_create_module_v2 = Module2["_sqlite3_create_module_v2"] = (a0, a1, a22, a3, a4) => (_sqlite3_create_module_v2 = Module2["_sqlite3_create_module_v2"] = wasmExports["sqlite3_create_module_v2"])(a0, a1, a22, a3, a4);
    var _sqlite3_drop_modules = Module2["_sqlite3_drop_modules"] = (a0, a1) => (_sqlite3_drop_modules = Module2["_sqlite3_drop_modules"] = wasmExports["sqlite3_drop_modules"])(a0, a1);
    var _sqlite3_declare_vtab = Module2["_sqlite3_declare_vtab"] = (a0, a1) => (_sqlite3_declare_vtab = Module2["_sqlite3_declare_vtab"] = wasmExports["sqlite3_declare_vtab"])(a0, a1);
    var _sqlite3_vtab_on_conflict = Module2["_sqlite3_vtab_on_conflict"] = (a0) => (_sqlite3_vtab_on_conflict = Module2["_sqlite3_vtab_on_conflict"] = wasmExports["sqlite3_vtab_on_conflict"])(a0);
    var _sqlite3_vtab_collation = Module2["_sqlite3_vtab_collation"] = (a0, a1) => (_sqlite3_vtab_collation = Module2["_sqlite3_vtab_collation"] = wasmExports["sqlite3_vtab_collation"])(a0, a1);
    var _sqlite3_vtab_in = Module2["_sqlite3_vtab_in"] = (a0, a1, a22) => (_sqlite3_vtab_in = Module2["_sqlite3_vtab_in"] = wasmExports["sqlite3_vtab_in"])(a0, a1, a22);
    var _sqlite3_vtab_rhs_value = Module2["_sqlite3_vtab_rhs_value"] = (a0, a1, a22) => (_sqlite3_vtab_rhs_value = Module2["_sqlite3_vtab_rhs_value"] = wasmExports["sqlite3_vtab_rhs_value"])(a0, a1, a22);
    var _sqlite3_vtab_distinct = Module2["_sqlite3_vtab_distinct"] = (a0) => (_sqlite3_vtab_distinct = Module2["_sqlite3_vtab_distinct"] = wasmExports["sqlite3_vtab_distinct"])(a0);
    var _sqlite3_keyword_name = Module2["_sqlite3_keyword_name"] = (a0, a1, a22) => (_sqlite3_keyword_name = Module2["_sqlite3_keyword_name"] = wasmExports["sqlite3_keyword_name"])(a0, a1, a22);
    var _sqlite3_keyword_count = Module2["_sqlite3_keyword_count"] = () => (_sqlite3_keyword_count = Module2["_sqlite3_keyword_count"] = wasmExports["sqlite3_keyword_count"])();
    var _sqlite3_keyword_check = Module2["_sqlite3_keyword_check"] = (a0, a1) => (_sqlite3_keyword_check = Module2["_sqlite3_keyword_check"] = wasmExports["sqlite3_keyword_check"])(a0, a1);
    var _sqlite3_complete = Module2["_sqlite3_complete"] = (a0) => (_sqlite3_complete = Module2["_sqlite3_complete"] = wasmExports["sqlite3_complete"])(a0);
    var _sqlite3_libversion = Module2["_sqlite3_libversion"] = () => (_sqlite3_libversion = Module2["_sqlite3_libversion"] = wasmExports["sqlite3_libversion"])();
    var _sqlite3_libversion_number = Module2["_sqlite3_libversion_number"] = () => (_sqlite3_libversion_number = Module2["_sqlite3_libversion_number"] = wasmExports["sqlite3_libversion_number"])();
    var _sqlite3_shutdown = Module2["_sqlite3_shutdown"] = () => (_sqlite3_shutdown = Module2["_sqlite3_shutdown"] = wasmExports["sqlite3_shutdown"])();
    var _sqlite3_last_insert_rowid = Module2["_sqlite3_last_insert_rowid"] = (a0) => (_sqlite3_last_insert_rowid = Module2["_sqlite3_last_insert_rowid"] = wasmExports["sqlite3_last_insert_rowid"])(a0);
    var _sqlite3_set_last_insert_rowid = Module2["_sqlite3_set_last_insert_rowid"] = (a0, a1) => (_sqlite3_set_last_insert_rowid = Module2["_sqlite3_set_last_insert_rowid"] = wasmExports["sqlite3_set_last_insert_rowid"])(a0, a1);
    var _sqlite3_changes64 = Module2["_sqlite3_changes64"] = (a0) => (_sqlite3_changes64 = Module2["_sqlite3_changes64"] = wasmExports["sqlite3_changes64"])(a0);
    var _sqlite3_changes = Module2["_sqlite3_changes"] = (a0) => (_sqlite3_changes = Module2["_sqlite3_changes"] = wasmExports["sqlite3_changes"])(a0);
    var _sqlite3_total_changes64 = Module2["_sqlite3_total_changes64"] = (a0) => (_sqlite3_total_changes64 = Module2["_sqlite3_total_changes64"] = wasmExports["sqlite3_total_changes64"])(a0);
    var _sqlite3_total_changes = Module2["_sqlite3_total_changes"] = (a0) => (_sqlite3_total_changes = Module2["_sqlite3_total_changes"] = wasmExports["sqlite3_total_changes"])(a0);
    var _sqlite3_txn_state = Module2["_sqlite3_txn_state"] = (a0, a1) => (_sqlite3_txn_state = Module2["_sqlite3_txn_state"] = wasmExports["sqlite3_txn_state"])(a0, a1);
    var _sqlite3_close_v2 = Module2["_sqlite3_close_v2"] = (a0) => (_sqlite3_close_v2 = Module2["_sqlite3_close_v2"] = wasmExports["sqlite3_close_v2"])(a0);
    var _sqlite3_busy_handler = Module2["_sqlite3_busy_handler"] = (a0, a1, a22) => (_sqlite3_busy_handler = Module2["_sqlite3_busy_handler"] = wasmExports["sqlite3_busy_handler"])(a0, a1, a22);
    var _sqlite3_progress_handler = Module2["_sqlite3_progress_handler"] = (a0, a1, a22, a3) => (_sqlite3_progress_handler = Module2["_sqlite3_progress_handler"] = wasmExports["sqlite3_progress_handler"])(a0, a1, a22, a3);
    var _sqlite3_busy_timeout = Module2["_sqlite3_busy_timeout"] = (a0, a1) => (_sqlite3_busy_timeout = Module2["_sqlite3_busy_timeout"] = wasmExports["sqlite3_busy_timeout"])(a0, a1);
    var _sqlite3_interrupt = Module2["_sqlite3_interrupt"] = (a0) => (_sqlite3_interrupt = Module2["_sqlite3_interrupt"] = wasmExports["sqlite3_interrupt"])(a0);
    var _sqlite3_is_interrupted = Module2["_sqlite3_is_interrupted"] = (a0) => (_sqlite3_is_interrupted = Module2["_sqlite3_is_interrupted"] = wasmExports["sqlite3_is_interrupted"])(a0);
    var _sqlite3_create_function = Module2["_sqlite3_create_function"] = (a0, a1, a22, a3, a4, a5, a6, a7) => (_sqlite3_create_function = Module2["_sqlite3_create_function"] = wasmExports["sqlite3_create_function"])(
      a0,
      a1,
      a22,
      a3,
      a4,
      a5,
      a6,
      a7
    );
    var _sqlite3_create_function_v2 = Module2["_sqlite3_create_function_v2"] = (a0, a1, a22, a3, a4, a5, a6, a7, a8) => (_sqlite3_create_function_v2 = Module2["_sqlite3_create_function_v2"] = wasmExports["sqlite3_create_function_v2"])(
      a0,
      a1,
      a22,
      a3,
      a4,
      a5,
      a6,
      a7,
      a8
    );
    var _sqlite3_create_window_function = Module2["_sqlite3_create_window_function"] = (a0, a1, a22, a3, a4, a5, a6, a7, a8, a9) => (_sqlite3_create_window_function = Module2["_sqlite3_create_window_function"] = wasmExports["sqlite3_create_window_function"])(
      a0,
      a1,
      a22,
      a3,
      a4,
      a5,
      a6,
      a7,
      a8,
      a9
    );
    var _sqlite3_overload_function = Module2["_sqlite3_overload_function"] = (a0, a1, a22) => (_sqlite3_overload_function = Module2["_sqlite3_overload_function"] = wasmExports["sqlite3_overload_function"])(a0, a1, a22);
    var _sqlite3_trace_v2 = Module2["_sqlite3_trace_v2"] = (a0, a1, a22, a3) => (_sqlite3_trace_v2 = Module2["_sqlite3_trace_v2"] = wasmExports["sqlite3_trace_v2"])(a0, a1, a22, a3);
    var _sqlite3_commit_hook = Module2["_sqlite3_commit_hook"] = (a0, a1, a22) => (_sqlite3_commit_hook = Module2["_sqlite3_commit_hook"] = wasmExports["sqlite3_commit_hook"])(a0, a1, a22);
    var _sqlite3_update_hook = Module2["_sqlite3_update_hook"] = (a0, a1, a22) => (_sqlite3_update_hook = Module2["_sqlite3_update_hook"] = wasmExports["sqlite3_update_hook"])(a0, a1, a22);
    var _sqlite3_rollback_hook = Module2["_sqlite3_rollback_hook"] = (a0, a1, a22) => (_sqlite3_rollback_hook = Module2["_sqlite3_rollback_hook"] = wasmExports["sqlite3_rollback_hook"])(a0, a1, a22);
    var _sqlite3_preupdate_hook = Module2["_sqlite3_preupdate_hook"] = (a0, a1, a22) => (_sqlite3_preupdate_hook = Module2["_sqlite3_preupdate_hook"] = wasmExports["sqlite3_preupdate_hook"])(a0, a1, a22);
    var _sqlite3_error_offset = Module2["_sqlite3_error_offset"] = (a0) => (_sqlite3_error_offset = Module2["_sqlite3_error_offset"] = wasmExports["sqlite3_error_offset"])(a0);
    var _sqlite3_errcode = Module2["_sqlite3_errcode"] = (a0) => (_sqlite3_errcode = Module2["_sqlite3_errcode"] = wasmExports["sqlite3_errcode"])(a0);
    var _sqlite3_extended_errcode = Module2["_sqlite3_extended_errcode"] = (a0) => (_sqlite3_extended_errcode = Module2["_sqlite3_extended_errcode"] = wasmExports["sqlite3_extended_errcode"])(a0);
    var _sqlite3_errstr = Module2["_sqlite3_errstr"] = (a0) => (_sqlite3_errstr = Module2["_sqlite3_errstr"] = wasmExports["sqlite3_errstr"])(a0);
    var _sqlite3_limit = Module2["_sqlite3_limit"] = (a0, a1, a22) => (_sqlite3_limit = Module2["_sqlite3_limit"] = wasmExports["sqlite3_limit"])(a0, a1, a22);
    var _sqlite3_open = Module2["_sqlite3_open"] = (a0, a1) => (_sqlite3_open = Module2["_sqlite3_open"] = wasmExports["sqlite3_open"])(
      a0,
      a1
    );
    var _sqlite3_open_v2 = Module2["_sqlite3_open_v2"] = (a0, a1, a22, a3) => (_sqlite3_open_v2 = Module2["_sqlite3_open_v2"] = wasmExports["sqlite3_open_v2"])(a0, a1, a22, a3);
    var _sqlite3_create_collation = Module2["_sqlite3_create_collation"] = (a0, a1, a22, a3, a4) => (_sqlite3_create_collation = Module2["_sqlite3_create_collation"] = wasmExports["sqlite3_create_collation"])(a0, a1, a22, a3, a4);
    var _sqlite3_create_collation_v2 = Module2["_sqlite3_create_collation_v2"] = (a0, a1, a22, a3, a4, a5) => (_sqlite3_create_collation_v2 = Module2["_sqlite3_create_collation_v2"] = wasmExports["sqlite3_create_collation_v2"])(a0, a1, a22, a3, a4, a5);
    var _sqlite3_collation_needed = Module2["_sqlite3_collation_needed"] = (a0, a1, a22) => (_sqlite3_collation_needed = Module2["_sqlite3_collation_needed"] = wasmExports["sqlite3_collation_needed"])(a0, a1, a22);
    var _sqlite3_get_autocommit = Module2["_sqlite3_get_autocommit"] = (a0) => (_sqlite3_get_autocommit = Module2["_sqlite3_get_autocommit"] = wasmExports["sqlite3_get_autocommit"])(a0);
    var _sqlite3_table_column_metadata = Module2["_sqlite3_table_column_metadata"] = (a0, a1, a22, a3, a4, a5, a6, a7, a8) => (_sqlite3_table_column_metadata = Module2["_sqlite3_table_column_metadata"] = wasmExports["sqlite3_table_column_metadata"])(
      a0,
      a1,
      a22,
      a3,
      a4,
      a5,
      a6,
      a7,
      a8
    );
    var _sqlite3_extended_result_codes = Module2["_sqlite3_extended_result_codes"] = (a0, a1) => (_sqlite3_extended_result_codes = Module2["_sqlite3_extended_result_codes"] = wasmExports["sqlite3_extended_result_codes"])(a0, a1);
    var _sqlite3_uri_key = Module2["_sqlite3_uri_key"] = (a0, a1) => (_sqlite3_uri_key = Module2["_sqlite3_uri_key"] = wasmExports["sqlite3_uri_key"])(a0, a1);
    var _sqlite3_uri_int64 = Module2["_sqlite3_uri_int64"] = (a0, a1, a22) => (_sqlite3_uri_int64 = Module2["_sqlite3_uri_int64"] = wasmExports["sqlite3_uri_int64"])(a0, a1, a22);
    var _sqlite3_db_name = Module2["_sqlite3_db_name"] = (a0, a1) => (_sqlite3_db_name = Module2["_sqlite3_db_name"] = wasmExports["sqlite3_db_name"])(a0, a1);
    var _sqlite3_db_filename = Module2["_sqlite3_db_filename"] = (a0, a1) => (_sqlite3_db_filename = Module2["_sqlite3_db_filename"] = wasmExports["sqlite3_db_filename"])(a0, a1);
    var _sqlite3_db_readonly = Module2["_sqlite3_db_readonly"] = (a0, a1) => (_sqlite3_db_readonly = Module2["_sqlite3_db_readonly"] = wasmExports["sqlite3_db_readonly"])(a0, a1);
    var _sqlite3_compileoption_used = Module2["_sqlite3_compileoption_used"] = (a0) => (_sqlite3_compileoption_used = Module2["_sqlite3_compileoption_used"] = wasmExports["sqlite3_compileoption_used"])(a0);
    var _sqlite3_compileoption_get = Module2["_sqlite3_compileoption_get"] = (a0) => (_sqlite3_compileoption_get = Module2["_sqlite3_compileoption_get"] = wasmExports["sqlite3_compileoption_get"])(a0);
    var _sqlite3session_diff = Module2["_sqlite3session_diff"] = (a0, a1, a22, a3) => (_sqlite3session_diff = Module2["_sqlite3session_diff"] = wasmExports["sqlite3session_diff"])(a0, a1, a22, a3);
    var _sqlite3session_attach = Module2["_sqlite3session_attach"] = (a0, a1) => (_sqlite3session_attach = Module2["_sqlite3session_attach"] = wasmExports["sqlite3session_attach"])(a0, a1);
    var _sqlite3session_create = Module2["_sqlite3session_create"] = (a0, a1, a22) => (_sqlite3session_create = Module2["_sqlite3session_create"] = wasmExports["sqlite3session_create"])(a0, a1, a22);
    var _sqlite3session_delete = Module2["_sqlite3session_delete"] = (a0) => (_sqlite3session_delete = Module2["_sqlite3session_delete"] = wasmExports["sqlite3session_delete"])(a0);
    var _sqlite3session_table_filter = Module2["_sqlite3session_table_filter"] = (a0, a1, a22) => (_sqlite3session_table_filter = Module2["_sqlite3session_table_filter"] = wasmExports["sqlite3session_table_filter"])(a0, a1, a22);
    var _sqlite3session_changeset = Module2["_sqlite3session_changeset"] = (a0, a1, a22) => (_sqlite3session_changeset = Module2["_sqlite3session_changeset"] = wasmExports["sqlite3session_changeset"])(a0, a1, a22);
    var _sqlite3session_changeset_strm = Module2["_sqlite3session_changeset_strm"] = (a0, a1, a22) => (_sqlite3session_changeset_strm = Module2["_sqlite3session_changeset_strm"] = wasmExports["sqlite3session_changeset_strm"])(a0, a1, a22);
    var _sqlite3session_patchset_strm = Module2["_sqlite3session_patchset_strm"] = (a0, a1, a22) => (_sqlite3session_patchset_strm = Module2["_sqlite3session_patchset_strm"] = wasmExports["sqlite3session_patchset_strm"])(a0, a1, a22);
    var _sqlite3session_patchset = Module2["_sqlite3session_patchset"] = (a0, a1, a22) => (_sqlite3session_patchset = Module2["_sqlite3session_patchset"] = wasmExports["sqlite3session_patchset"])(a0, a1, a22);
    var _sqlite3session_enable = Module2["_sqlite3session_enable"] = (a0, a1) => (_sqlite3session_enable = Module2["_sqlite3session_enable"] = wasmExports["sqlite3session_enable"])(a0, a1);
    var _sqlite3session_indirect = Module2["_sqlite3session_indirect"] = (a0, a1) => (_sqlite3session_indirect = Module2["_sqlite3session_indirect"] = wasmExports["sqlite3session_indirect"])(a0, a1);
    var _sqlite3session_isempty = Module2["_sqlite3session_isempty"] = (a0) => (_sqlite3session_isempty = Module2["_sqlite3session_isempty"] = wasmExports["sqlite3session_isempty"])(a0);
    var _sqlite3session_memory_used = Module2["_sqlite3session_memory_used"] = (a0) => (_sqlite3session_memory_used = Module2["_sqlite3session_memory_used"] = wasmExports["sqlite3session_memory_used"])(a0);
    var _sqlite3session_object_config = Module2["_sqlite3session_object_config"] = (a0, a1, a22) => (_sqlite3session_object_config = Module2["_sqlite3session_object_config"] = wasmExports["sqlite3session_object_config"])(a0, a1, a22);
    var _sqlite3session_changeset_size = Module2["_sqlite3session_changeset_size"] = (a0) => (_sqlite3session_changeset_size = Module2["_sqlite3session_changeset_size"] = wasmExports["sqlite3session_changeset_size"])(a0);
    var _sqlite3changeset_start = Module2["_sqlite3changeset_start"] = (a0, a1, a22) => (_sqlite3changeset_start = Module2["_sqlite3changeset_start"] = wasmExports["sqlite3changeset_start"])(a0, a1, a22);
    var _sqlite3changeset_start_v2 = Module2["_sqlite3changeset_start_v2"] = (a0, a1, a22, a3) => (_sqlite3changeset_start_v2 = Module2["_sqlite3changeset_start_v2"] = wasmExports["sqlite3changeset_start_v2"])(a0, a1, a22, a3);
    var _sqlite3changeset_start_strm = Module2["_sqlite3changeset_start_strm"] = (a0, a1, a22) => (_sqlite3changeset_start_strm = Module2["_sqlite3changeset_start_strm"] = wasmExports["sqlite3changeset_start_strm"])(a0, a1, a22);
    var _sqlite3changeset_start_v2_strm = Module2["_sqlite3changeset_start_v2_strm"] = (a0, a1, a22, a3) => (_sqlite3changeset_start_v2_strm = Module2["_sqlite3changeset_start_v2_strm"] = wasmExports["sqlite3changeset_start_v2_strm"])(a0, a1, a22, a3);
    var _sqlite3changeset_next = Module2["_sqlite3changeset_next"] = (a0) => (_sqlite3changeset_next = Module2["_sqlite3changeset_next"] = wasmExports["sqlite3changeset_next"])(a0);
    var _sqlite3changeset_op = Module2["_sqlite3changeset_op"] = (a0, a1, a22, a3, a4) => (_sqlite3changeset_op = Module2["_sqlite3changeset_op"] = wasmExports["sqlite3changeset_op"])(a0, a1, a22, a3, a4);
    var _sqlite3changeset_pk = Module2["_sqlite3changeset_pk"] = (a0, a1, a22) => (_sqlite3changeset_pk = Module2["_sqlite3changeset_pk"] = wasmExports["sqlite3changeset_pk"])(a0, a1, a22);
    var _sqlite3changeset_old = Module2["_sqlite3changeset_old"] = (a0, a1, a22) => (_sqlite3changeset_old = Module2["_sqlite3changeset_old"] = wasmExports["sqlite3changeset_old"])(a0, a1, a22);
    var _sqlite3changeset_new = Module2["_sqlite3changeset_new"] = (a0, a1, a22) => (_sqlite3changeset_new = Module2["_sqlite3changeset_new"] = wasmExports["sqlite3changeset_new"])(a0, a1, a22);
    var _sqlite3changeset_conflict = Module2["_sqlite3changeset_conflict"] = (a0, a1, a22) => (_sqlite3changeset_conflict = Module2["_sqlite3changeset_conflict"] = wasmExports["sqlite3changeset_conflict"])(a0, a1, a22);
    var _sqlite3changeset_fk_conflicts = Module2["_sqlite3changeset_fk_conflicts"] = (a0, a1) => (_sqlite3changeset_fk_conflicts = Module2["_sqlite3changeset_fk_conflicts"] = wasmExports["sqlite3changeset_fk_conflicts"])(a0, a1);
    var _sqlite3changeset_finalize = Module2["_sqlite3changeset_finalize"] = (a0) => (_sqlite3changeset_finalize = Module2["_sqlite3changeset_finalize"] = wasmExports["sqlite3changeset_finalize"])(a0);
    var _sqlite3changeset_invert = Module2["_sqlite3changeset_invert"] = (a0, a1, a22, a3) => (_sqlite3changeset_invert = Module2["_sqlite3changeset_invert"] = wasmExports["sqlite3changeset_invert"])(a0, a1, a22, a3);
    var _sqlite3changeset_invert_strm = Module2["_sqlite3changeset_invert_strm"] = (a0, a1, a22, a3) => (_sqlite3changeset_invert_strm = Module2["_sqlite3changeset_invert_strm"] = wasmExports["sqlite3changeset_invert_strm"])(a0, a1, a22, a3);
    var _sqlite3changeset_apply_v2 = Module2["_sqlite3changeset_apply_v2"] = (a0, a1, a22, a3, a4, a5, a6, a7, a8) => (_sqlite3changeset_apply_v2 = Module2["_sqlite3changeset_apply_v2"] = wasmExports["sqlite3changeset_apply_v2"])(
      a0,
      a1,
      a22,
      a3,
      a4,
      a5,
      a6,
      a7,
      a8
    );
    var _sqlite3changeset_apply = Module2["_sqlite3changeset_apply"] = (a0, a1, a22, a3, a4, a5) => (_sqlite3changeset_apply = Module2["_sqlite3changeset_apply"] = wasmExports["sqlite3changeset_apply"])(a0, a1, a22, a3, a4, a5);
    var _sqlite3changeset_apply_v2_strm = Module2["_sqlite3changeset_apply_v2_strm"] = (a0, a1, a22, a3, a4, a5, a6, a7, a8) => (_sqlite3changeset_apply_v2_strm = Module2["_sqlite3changeset_apply_v2_strm"] = wasmExports["sqlite3changeset_apply_v2_strm"])(
      a0,
      a1,
      a22,
      a3,
      a4,
      a5,
      a6,
      a7,
      a8
    );
    var _sqlite3changeset_apply_strm = Module2["_sqlite3changeset_apply_strm"] = (a0, a1, a22, a3, a4, a5) => (_sqlite3changeset_apply_strm = Module2["_sqlite3changeset_apply_strm"] = wasmExports["sqlite3changeset_apply_strm"])(a0, a1, a22, a3, a4, a5);
    var _sqlite3changegroup_new = Module2["_sqlite3changegroup_new"] = (a0) => (_sqlite3changegroup_new = Module2["_sqlite3changegroup_new"] = wasmExports["sqlite3changegroup_new"])(a0);
    var _sqlite3changegroup_add = Module2["_sqlite3changegroup_add"] = (a0, a1, a22) => (_sqlite3changegroup_add = Module2["_sqlite3changegroup_add"] = wasmExports["sqlite3changegroup_add"])(a0, a1, a22);
    var _sqlite3changegroup_output = Module2["_sqlite3changegroup_output"] = (a0, a1, a22) => (_sqlite3changegroup_output = Module2["_sqlite3changegroup_output"] = wasmExports["sqlite3changegroup_output"])(a0, a1, a22);
    var _sqlite3changegroup_add_strm = Module2["_sqlite3changegroup_add_strm"] = (a0, a1, a22) => (_sqlite3changegroup_add_strm = Module2["_sqlite3changegroup_add_strm"] = wasmExports["sqlite3changegroup_add_strm"])(a0, a1, a22);
    var _sqlite3changegroup_output_strm = Module2["_sqlite3changegroup_output_strm"] = (a0, a1, a22) => (_sqlite3changegroup_output_strm = Module2["_sqlite3changegroup_output_strm"] = wasmExports["sqlite3changegroup_output_strm"])(a0, a1, a22);
    var _sqlite3changegroup_delete = Module2["_sqlite3changegroup_delete"] = (a0) => (_sqlite3changegroup_delete = Module2["_sqlite3changegroup_delete"] = wasmExports["sqlite3changegroup_delete"])(a0);
    var _sqlite3changeset_concat = Module2["_sqlite3changeset_concat"] = (a0, a1, a22, a3, a4, a5) => (_sqlite3changeset_concat = Module2["_sqlite3changeset_concat"] = wasmExports["sqlite3changeset_concat"])(a0, a1, a22, a3, a4, a5);
    var _sqlite3changeset_concat_strm = Module2["_sqlite3changeset_concat_strm"] = (a0, a1, a22, a3, a4, a5) => (_sqlite3changeset_concat_strm = Module2["_sqlite3changeset_concat_strm"] = wasmExports["sqlite3changeset_concat_strm"])(a0, a1, a22, a3, a4, a5);
    var _sqlite3session_config = Module2["_sqlite3session_config"] = (a0, a1) => (_sqlite3session_config = Module2["_sqlite3session_config"] = wasmExports["sqlite3session_config"])(a0, a1);
    var _sqlite3_sourceid = Module2["_sqlite3_sourceid"] = () => (_sqlite3_sourceid = Module2["_sqlite3_sourceid"] = wasmExports["sqlite3_sourceid"])();
    var _sqlite3__wasm_pstack_ptr = Module2["_sqlite3__wasm_pstack_ptr"] = () => (_sqlite3__wasm_pstack_ptr = Module2["_sqlite3__wasm_pstack_ptr"] = wasmExports["sqlite3__wasm_pstack_ptr"])();
    var _sqlite3__wasm_pstack_restore = Module2["_sqlite3__wasm_pstack_restore"] = (a0) => (_sqlite3__wasm_pstack_restore = Module2["_sqlite3__wasm_pstack_restore"] = wasmExports["sqlite3__wasm_pstack_restore"])(a0);
    var _sqlite3__wasm_pstack_alloc = Module2["_sqlite3__wasm_pstack_alloc"] = (a0) => (_sqlite3__wasm_pstack_alloc = Module2["_sqlite3__wasm_pstack_alloc"] = wasmExports["sqlite3__wasm_pstack_alloc"])(a0);
    var _sqlite3__wasm_pstack_remaining = Module2["_sqlite3__wasm_pstack_remaining"] = () => (_sqlite3__wasm_pstack_remaining = Module2["_sqlite3__wasm_pstack_remaining"] = wasmExports["sqlite3__wasm_pstack_remaining"])();
    var _sqlite3__wasm_pstack_quota = Module2["_sqlite3__wasm_pstack_quota"] = () => (_sqlite3__wasm_pstack_quota = Module2["_sqlite3__wasm_pstack_quota"] = wasmExports["sqlite3__wasm_pstack_quota"])();
    var _sqlite3__wasm_db_error = Module2["_sqlite3__wasm_db_error"] = (a0, a1, a22) => (_sqlite3__wasm_db_error = Module2["_sqlite3__wasm_db_error"] = wasmExports["sqlite3__wasm_db_error"])(a0, a1, a22);
    var _sqlite3__wasm_test_struct = Module2["_sqlite3__wasm_test_struct"] = (a0) => (_sqlite3__wasm_test_struct = Module2["_sqlite3__wasm_test_struct"] = wasmExports["sqlite3__wasm_test_struct"])(a0);
    var _sqlite3__wasm_enum_json = Module2["_sqlite3__wasm_enum_json"] = () => (_sqlite3__wasm_enum_json = Module2["_sqlite3__wasm_enum_json"] = wasmExports["sqlite3__wasm_enum_json"])();
    var _sqlite3__wasm_vfs_unlink = Module2["_sqlite3__wasm_vfs_unlink"] = (a0, a1) => (_sqlite3__wasm_vfs_unlink = Module2["_sqlite3__wasm_vfs_unlink"] = wasmExports["sqlite3__wasm_vfs_unlink"])(a0, a1);
    var _sqlite3__wasm_db_vfs = Module2["_sqlite3__wasm_db_vfs"] = (a0, a1) => (_sqlite3__wasm_db_vfs = Module2["_sqlite3__wasm_db_vfs"] = wasmExports["sqlite3__wasm_db_vfs"])(a0, a1);
    var _sqlite3__wasm_db_reset = Module2["_sqlite3__wasm_db_reset"] = (a0) => (_sqlite3__wasm_db_reset = Module2["_sqlite3__wasm_db_reset"] = wasmExports["sqlite3__wasm_db_reset"])(a0);
    var _sqlite3__wasm_db_export_chunked = Module2["_sqlite3__wasm_db_export_chunked"] = (a0, a1) => (_sqlite3__wasm_db_export_chunked = Module2["_sqlite3__wasm_db_export_chunked"] = wasmExports["sqlite3__wasm_db_export_chunked"])(a0, a1);
    var _sqlite3__wasm_db_serialize = Module2["_sqlite3__wasm_db_serialize"] = (a0, a1, a22, a3, a4) => (_sqlite3__wasm_db_serialize = Module2["_sqlite3__wasm_db_serialize"] = wasmExports["sqlite3__wasm_db_serialize"])(a0, a1, a22, a3, a4);
    var _sqlite3__wasm_vfs_create_file = Module2["_sqlite3__wasm_vfs_create_file"] = (a0, a1, a22, a3) => (_sqlite3__wasm_vfs_create_file = Module2["_sqlite3__wasm_vfs_create_file"] = wasmExports["sqlite3__wasm_vfs_create_file"])(a0, a1, a22, a3);
    var _sqlite3__wasm_posix_create_file = Module2["_sqlite3__wasm_posix_create_file"] = (a0, a1, a22) => (_sqlite3__wasm_posix_create_file = Module2["_sqlite3__wasm_posix_create_file"] = wasmExports["sqlite3__wasm_posix_create_file"])(a0, a1, a22);
    var _sqlite3__wasm_kvvfsMakeKeyOnPstack = Module2["_sqlite3__wasm_kvvfsMakeKeyOnPstack"] = (a0, a1) => (_sqlite3__wasm_kvvfsMakeKeyOnPstack = Module2["_sqlite3__wasm_kvvfsMakeKeyOnPstack"] = wasmExports["sqlite3__wasm_kvvfsMakeKeyOnPstack"])(a0, a1);
    var _sqlite3__wasm_kvvfs_methods = Module2["_sqlite3__wasm_kvvfs_methods"] = () => (_sqlite3__wasm_kvvfs_methods = Module2["_sqlite3__wasm_kvvfs_methods"] = wasmExports["sqlite3__wasm_kvvfs_methods"])();
    var _sqlite3__wasm_vtab_config = Module2["_sqlite3__wasm_vtab_config"] = (a0, a1, a22) => (_sqlite3__wasm_vtab_config = Module2["_sqlite3__wasm_vtab_config"] = wasmExports["sqlite3__wasm_vtab_config"])(a0, a1, a22);
    var _sqlite3__wasm_db_config_ip = Module2["_sqlite3__wasm_db_config_ip"] = (a0, a1, a22, a3) => (_sqlite3__wasm_db_config_ip = Module2["_sqlite3__wasm_db_config_ip"] = wasmExports["sqlite3__wasm_db_config_ip"])(a0, a1, a22, a3);
    var _sqlite3__wasm_db_config_pii = Module2["_sqlite3__wasm_db_config_pii"] = (a0, a1, a22, a3, a4) => (_sqlite3__wasm_db_config_pii = Module2["_sqlite3__wasm_db_config_pii"] = wasmExports["sqlite3__wasm_db_config_pii"])(a0, a1, a22, a3, a4);
    var _sqlite3__wasm_db_config_s = Module2["_sqlite3__wasm_db_config_s"] = (a0, a1, a22) => (_sqlite3__wasm_db_config_s = Module2["_sqlite3__wasm_db_config_s"] = wasmExports["sqlite3__wasm_db_config_s"])(a0, a1, a22);
    var _sqlite3__wasm_config_i = Module2["_sqlite3__wasm_config_i"] = (a0, a1) => (_sqlite3__wasm_config_i = Module2["_sqlite3__wasm_config_i"] = wasmExports["sqlite3__wasm_config_i"])(a0, a1);
    var _sqlite3__wasm_config_ii = Module2["_sqlite3__wasm_config_ii"] = (a0, a1, a22) => (_sqlite3__wasm_config_ii = Module2["_sqlite3__wasm_config_ii"] = wasmExports["sqlite3__wasm_config_ii"])(a0, a1, a22);
    var _sqlite3__wasm_config_j = Module2["_sqlite3__wasm_config_j"] = (a0, a1) => (_sqlite3__wasm_config_j = Module2["_sqlite3__wasm_config_j"] = wasmExports["sqlite3__wasm_config_j"])(a0, a1);
    var _sqlite3__wasm_qfmt_token = Module2["_sqlite3__wasm_qfmt_token"] = (a0, a1) => (_sqlite3__wasm_qfmt_token = Module2["_sqlite3__wasm_qfmt_token"] = wasmExports["sqlite3__wasm_qfmt_token"])(a0, a1);
    var _sqlite3__wasm_init_wasmfs = Module2["_sqlite3__wasm_init_wasmfs"] = (a0) => (_sqlite3__wasm_init_wasmfs = Module2["_sqlite3__wasm_init_wasmfs"] = wasmExports["sqlite3__wasm_init_wasmfs"])(a0);
    var _sqlite3__wasm_test_intptr = Module2["_sqlite3__wasm_test_intptr"] = (a0) => (_sqlite3__wasm_test_intptr = Module2["_sqlite3__wasm_test_intptr"] = wasmExports["sqlite3__wasm_test_intptr"])(a0);
    var _sqlite3__wasm_test_voidptr = Module2["_sqlite3__wasm_test_voidptr"] = (a0) => (_sqlite3__wasm_test_voidptr = Module2["_sqlite3__wasm_test_voidptr"] = wasmExports["sqlite3__wasm_test_voidptr"])(a0);
    var _sqlite3__wasm_test_int64_max = Module2["_sqlite3__wasm_test_int64_max"] = () => (_sqlite3__wasm_test_int64_max = Module2["_sqlite3__wasm_test_int64_max"] = wasmExports["sqlite3__wasm_test_int64_max"])();
    var _sqlite3__wasm_test_int64_min = Module2["_sqlite3__wasm_test_int64_min"] = () => (_sqlite3__wasm_test_int64_min = Module2["_sqlite3__wasm_test_int64_min"] = wasmExports["sqlite3__wasm_test_int64_min"])();
    var _sqlite3__wasm_test_int64_times2 = Module2["_sqlite3__wasm_test_int64_times2"] = (a0) => (_sqlite3__wasm_test_int64_times2 = Module2["_sqlite3__wasm_test_int64_times2"] = wasmExports["sqlite3__wasm_test_int64_times2"])(a0);
    var _sqlite3__wasm_test_int64_minmax = Module2["_sqlite3__wasm_test_int64_minmax"] = (a0, a1) => (_sqlite3__wasm_test_int64_minmax = Module2["_sqlite3__wasm_test_int64_minmax"] = wasmExports["sqlite3__wasm_test_int64_minmax"])(a0, a1);
    var _sqlite3__wasm_test_int64ptr = Module2["_sqlite3__wasm_test_int64ptr"] = (a0) => (_sqlite3__wasm_test_int64ptr = Module2["_sqlite3__wasm_test_int64ptr"] = wasmExports["sqlite3__wasm_test_int64ptr"])(a0);
    var _sqlite3__wasm_test_stack_overflow = Module2["_sqlite3__wasm_test_stack_overflow"] = (a0) => (_sqlite3__wasm_test_stack_overflow = Module2["_sqlite3__wasm_test_stack_overflow"] = wasmExports["sqlite3__wasm_test_stack_overflow"])(a0);
    var _sqlite3__wasm_test_str_hello = Module2["_sqlite3__wasm_test_str_hello"] = (a0) => (_sqlite3__wasm_test_str_hello = Module2["_sqlite3__wasm_test_str_hello"] = wasmExports["sqlite3__wasm_test_str_hello"])(a0);
    var _sqlite3__wasm_SQLTester_strglob = Module2["_sqlite3__wasm_SQLTester_strglob"] = (a0, a1) => (_sqlite3__wasm_SQLTester_strglob = Module2["_sqlite3__wasm_SQLTester_strglob"] = wasmExports["sqlite3__wasm_SQLTester_strglob"])(a0, a1);
    var _malloc = Module2["_malloc"] = (a0) => (_malloc = Module2["_malloc"] = wasmExports["malloc"])(a0);
    var _free = Module2["_free"] = (a0) => (_free = Module2["_free"] = wasmExports["free"])(a0);
    var _realloc = Module2["_realloc"] = (a0, a1) => (_realloc = Module2["_realloc"] = wasmExports["realloc"])(a0, a1);
    var _emscripten_builtin_memalign = (a0, a1) => (_emscripten_builtin_memalign = wasmExports["emscripten_builtin_memalign"])(a0, a1);
    var __emscripten_stack_restore = (a0) => (__emscripten_stack_restore = wasmExports["_emscripten_stack_restore"])(
      a0
    );
    var __emscripten_stack_alloc = (a0) => (__emscripten_stack_alloc = wasmExports["_emscripten_stack_alloc"])(a0);
    var _emscripten_stack_get_current = () => (_emscripten_stack_get_current = wasmExports["emscripten_stack_get_current"])();
    Module2["wasmMemory"] = wasmMemory;
    var calledRun;
    var calledPrerun;
    dependenciesFulfilled = function runCaller() {
      if (!calledRun)
        run();
      if (!calledRun)
        dependenciesFulfilled = runCaller;
    };
    function run() {
      if (runDependencies > 0) {
        return;
      }
      if (!calledPrerun) {
        calledPrerun = 1;
        preRun();
        if (runDependencies > 0) {
          return;
        }
      }
      function doRun() {
        var _a8;
        if (calledRun)
          return;
        calledRun = 1;
        Module2["calledRun"] = 1;
        if (ABORT)
          return;
        initRuntime();
        readyPromiseResolve(Module2);
        (_a8 = Module2["onRuntimeInitialized"]) == null ? void 0 : _a8.call(Module2);
        postRun();
      }
      if (Module2["setStatus"]) {
        Module2["setStatus"]("Running...");
        setTimeout(() => {
          setTimeout(() => Module2["setStatus"](""), 1);
          doRun();
        }, 1);
      } else {
        doRun();
      }
    }
    if (Module2["preInit"]) {
      if (typeof Module2["preInit"] == "function")
        Module2["preInit"] = [Module2["preInit"]];
      while (Module2["preInit"].length > 0) {
        Module2["preInit"].pop()();
      }
    }
    run();
    if (!Module2.postRun)
      Module2.postRun = [];
    Module2.postRun.push(function(Module3) {
      "use strict";
      "use strict";
      globalThis.sqlite3ApiBootstrap = function sqlite3ApiBootstrap(apiConfig = globalThis.sqlite3ApiConfig || sqlite3ApiBootstrap.defaultConfig) {
        if (sqlite3ApiBootstrap.sqlite3) {
          (sqlite3ApiBootstrap.sqlite3.config || console).warn(
            "sqlite3ApiBootstrap() called multiple times.",
            "Config and external initializers are ignored on calls after the first."
          );
          return sqlite3ApiBootstrap.sqlite3;
        }
        const config = Object.assign(
          /* @__PURE__ */ Object.create(null),
          {
            exports: void 0,
            memory: void 0,
            bigIntEnabled: (() => {
              if ("undefined" !== typeof Module3) {
                if (!!Module3.HEAPU64)
                  return true;
              }
              return !!globalThis.BigInt64Array;
            })(),
            debug: console.debug.bind(console),
            warn: console.warn.bind(console),
            error: console.error.bind(console),
            log: console.log.bind(console),
            wasmfsOpfsDir: "/opfs",
            useStdAlloc: false
          },
          apiConfig || {}
        );
        Object.assign(
          config,
          {
            allocExportName: config.useStdAlloc ? "malloc" : "sqlite3_malloc",
            deallocExportName: config.useStdAlloc ? "free" : "sqlite3_free",
            reallocExportName: config.useStdAlloc ? "realloc" : "sqlite3_realloc"
          },
          config
        );
        ["exports", "memory", "wasmfsOpfsDir"].forEach((k2) => {
          if ("function" === typeof config[k2]) {
            config[k2] = config[k2]();
          }
        });
        delete globalThis.sqlite3ApiConfig;
        delete sqlite3ApiBootstrap.defaultConfig;
        const capi = /* @__PURE__ */ Object.create(null);
        const wasm = /* @__PURE__ */ Object.create(null);
        const __rcStr = (rc) => {
          return capi.sqlite3_js_rc_str && capi.sqlite3_js_rc_str(rc) || "Unknown result code #" + rc;
        };
        const __isInt = (n2) => "number" === typeof n2 && n2 === (n2 | 0);
        class SQLite3Error extends Error {
          constructor(...args) {
            let rc;
            if (args.length) {
              if (__isInt(args[0])) {
                rc = args[0];
                if (1 === args.length) {
                  super(__rcStr(args[0]));
                } else {
                  const rcStr = __rcStr(rc);
                  if ("object" === typeof args[1]) {
                    super(rcStr, args[1]);
                  } else {
                    args[0] = rcStr + ":";
                    super(args.join(" "));
                  }
                }
              } else {
                if (2 === args.length && "object" === typeof args[1]) {
                  super(...args);
                } else {
                  super(args.join(" "));
                }
              }
            }
            this.resultCode = rc || capi.SQLITE_ERROR;
            this.name = "SQLite3Error";
          }
        }
        SQLite3Error.toss = (...args) => {
          throw new SQLite3Error(...args);
        };
        const toss3 = SQLite3Error.toss;
        if (config.wasmfsOpfsDir && !/^\/[^/]+$/.test(config.wasmfsOpfsDir)) {
          toss3(
            "config.wasmfsOpfsDir must be falsy or in the form '/dir-name'."
          );
        }
        const isInt32 = (n2) => {
          return "bigint" !== typeof n2 && !!(n2 === (n2 | 0) && n2 <= 2147483647 && n2 >= -2147483648);
        };
        const bigIntFits64 = function f2(b) {
          if (!f2._max) {
            f2._max = BigInt("0x7fffffffffffffff");
            f2._min = ~f2._max;
          }
          return b >= f2._min && b <= f2._max;
        };
        const bigIntFits32 = (b) => b >= -0x7fffffffn - 1n && b <= 0x7fffffffn;
        const bigIntFitsDouble = function f2(b) {
          if (!f2._min) {
            f2._min = Number.MIN_SAFE_INTEGER;
            f2._max = Number.MAX_SAFE_INTEGER;
          }
          return b >= f2._min && b <= f2._max;
        };
        const isTypedArray = (v3) => {
          return v3 && v3.constructor && isInt32(v3.constructor.BYTES_PER_ELEMENT) ? v3 : false;
        };
        const __SAB = "undefined" === typeof SharedArrayBuffer ? function() {
        } : SharedArrayBuffer;
        const isSharedTypedArray = (aTypedArray) => aTypedArray.buffer instanceof __SAB;
        const typedArrayPart = (aTypedArray, begin, end) => {
          return isSharedTypedArray(aTypedArray) ? aTypedArray.slice(begin, end) : aTypedArray.subarray(begin, end);
        };
        const isBindableTypedArray = (v3) => {
          return v3 && (v3 instanceof Uint8Array || v3 instanceof Int8Array || v3 instanceof ArrayBuffer);
        };
        const isSQLableTypedArray = (v3) => {
          return v3 && (v3 instanceof Uint8Array || v3 instanceof Int8Array || v3 instanceof ArrayBuffer);
        };
        const affirmBindableTypedArray = (v3) => {
          return isBindableTypedArray(v3) || toss3("Value is not of a supported TypedArray type.");
        };
        const utf8Decoder = new TextDecoder("utf-8");
        const typedArrayToString = function(typedArray, begin, end) {
          return utf8Decoder.decode(typedArrayPart(typedArray, begin, end));
        };
        const flexibleString = function(v3) {
          if (isSQLableTypedArray(v3)) {
            return typedArrayToString(
              v3 instanceof ArrayBuffer ? new Uint8Array(v3) : v3
            );
          } else if (Array.isArray(v3))
            return v3.join("");
          else if (wasm.isPtr(v3))
            v3 = wasm.cstrToJs(v3);
          return v3;
        };
        class WasmAllocError extends Error {
          constructor(...args) {
            if (2 === args.length && "object" === typeof args[1]) {
              super(...args);
            } else if (args.length) {
              super(args.join(" "));
            } else {
              super("Allocation failed.");
            }
            this.resultCode = capi.SQLITE_NOMEM;
            this.name = "WasmAllocError";
          }
        }
        WasmAllocError.toss = (...args) => {
          throw new WasmAllocError(...args);
        };
        Object.assign(capi, {
          sqlite3_bind_blob: void 0,
          sqlite3_bind_text: void 0,
          sqlite3_create_function_v2: (pDb2, funcName, nArg, eTextRep, pApp, xFunc, xStep, xFinal, xDestroy) => {
          },
          sqlite3_create_function: (pDb2, funcName, nArg, eTextRep, pApp, xFunc, xStep, xFinal) => {
          },
          sqlite3_create_window_function: (pDb2, funcName, nArg, eTextRep, pApp, xStep, xFinal, xValue, xInverse, xDestroy) => {
          },
          sqlite3_prepare_v3: (dbPtr, sql2, sqlByteLen, prepFlags, stmtPtrPtr, strPtrPtr) => {
          },
          sqlite3_prepare_v2: (dbPtr, sql2, sqlByteLen, stmtPtrPtr, strPtrPtr) => {
          },
          sqlite3_exec: (pDb2, sql2, callback, pVoid, pErrMsg) => {
          },
          sqlite3_randomness: (n2, outPtr) => {
          }
        });
        const util = {
          affirmBindableTypedArray,
          flexibleString,
          bigIntFits32,
          bigIntFits64,
          bigIntFitsDouble,
          isBindableTypedArray,
          isInt32,
          isSQLableTypedArray,
          isTypedArray,
          typedArrayToString,
          isUIThread: () => globalThis.window === globalThis && !!globalThis.document,
          isSharedTypedArray,
          toss: function(...args) {
            throw new Error(args.join(" "));
          },
          toss3,
          typedArrayPart,
          affirmDbHeader: function(bytes) {
            if (bytes instanceof ArrayBuffer)
              bytes = new Uint8Array(bytes);
            const header = "SQLite format 3";
            if (header.length > bytes.byteLength) {
              toss3("Input does not contain an SQLite3 database header.");
            }
            for (let i2 = 0; i2 < header.length; ++i2) {
              if (header.charCodeAt(i2) !== bytes[i2]) {
                toss3("Input does not contain an SQLite3 database header.");
              }
            }
          },
          affirmIsDb: function(bytes) {
            if (bytes instanceof ArrayBuffer)
              bytes = new Uint8Array(bytes);
            const n2 = bytes.byteLength;
            if (n2 < 512 || n2 % 512 !== 0) {
              toss3("Byte array size", n2, "is invalid for an SQLite3 db.");
            }
            util.affirmDbHeader(bytes);
          }
        };
        Object.assign(wasm, {
          ptrSizeof: config.wasmPtrSizeof || 4,
          ptrIR: config.wasmPtrIR || "i32",
          bigIntEnabled: !!config.bigIntEnabled,
          exports: config.exports || toss3("Missing API config.exports (WASM module exports)."),
          memory: config.memory || config.exports["memory"] || toss3(
            "API config object requires a WebAssembly.Memory object",
            "in either config.exports.memory (exported)",
            "or config.memory (imported)."
          ),
          alloc: void 0,
          realloc: void 0,
          dealloc: void 0
        });
        wasm.allocFromTypedArray = function(srcTypedArray) {
          if (srcTypedArray instanceof ArrayBuffer) {
            srcTypedArray = new Uint8Array(srcTypedArray);
          }
          affirmBindableTypedArray(srcTypedArray);
          const pRet = wasm.alloc(srcTypedArray.byteLength || 1);
          wasm.heapForSize(srcTypedArray.constructor).set(srcTypedArray.byteLength ? srcTypedArray : [0], pRet);
          return pRet;
        };
        {
          const keyAlloc = config.allocExportName, keyDealloc = config.deallocExportName, keyRealloc = config.reallocExportName;
          for (const key of [keyAlloc, keyDealloc, keyRealloc]) {
            const f2 = wasm.exports[key];
            if (!(f2 instanceof Function))
              toss3("Missing required exports[", key, "] function.");
          }
          wasm.alloc = function f2(n2) {
            return f2.impl(n2) || WasmAllocError.toss("Failed to allocate", n2, " bytes.");
          };
          wasm.alloc.impl = wasm.exports[keyAlloc];
          wasm.realloc = function f2(m2, n2) {
            const m22 = f2.impl(m2, n2);
            return n2 ? m22 || WasmAllocError.toss("Failed to reallocate", n2, " bytes.") : 0;
          };
          wasm.realloc.impl = wasm.exports[keyRealloc];
          wasm.dealloc = wasm.exports[keyDealloc];
        }
        wasm.compileOptionUsed = function f2(optName) {
          if (!arguments.length) {
            if (f2._result)
              return f2._result;
            else if (!f2._opt) {
              f2._rx = /^([^=]+)=(.+)/;
              f2._rxInt = /^-?\d+$/;
              f2._opt = function(opt, rv) {
                const m2 = f2._rx.exec(opt);
                rv[0] = m2 ? m2[1] : opt;
                rv[1] = m2 ? f2._rxInt.test(m2[2]) ? +m2[2] : m2[2] : true;
              };
            }
            const rc = {}, ov = [0, 0];
            let i2 = 0, k2;
            while (k2 = capi.sqlite3_compileoption_get(i2++)) {
              f2._opt(k2, ov);
              rc[ov[0]] = ov[1];
            }
            return f2._result = rc;
          } else if (Array.isArray(optName)) {
            const rc = {};
            optName.forEach((v3) => {
              rc[v3] = capi.sqlite3_compileoption_used(v3);
            });
            return rc;
          } else if ("object" === typeof optName) {
            Object.keys(optName).forEach((k2) => {
              optName[k2] = capi.sqlite3_compileoption_used(k2);
            });
            return optName;
          }
          return "string" === typeof optName ? !!capi.sqlite3_compileoption_used(optName) : false;
        };
        wasm.pstack = Object.assign(/* @__PURE__ */ Object.create(null), {
          restore: wasm.exports.sqlite3__wasm_pstack_restore,
          alloc: function(n2) {
            if ("string" === typeof n2 && !(n2 = wasm.sizeofIR(n2))) {
              WasmAllocError.toss(
                "Invalid value for pstack.alloc(",
                arguments[0],
                ")"
              );
            }
            return wasm.exports.sqlite3__wasm_pstack_alloc(n2) || WasmAllocError.toss(
              "Could not allocate",
              n2,
              "bytes from the pstack."
            );
          },
          allocChunks: function(n2, sz) {
            if ("string" === typeof sz && !(sz = wasm.sizeofIR(sz))) {
              WasmAllocError.toss(
                "Invalid size value for allocChunks(",
                arguments[1],
                ")"
              );
            }
            const mem = wasm.pstack.alloc(n2 * sz);
            const rc = [];
            let i2 = 0, offset = 0;
            for (; i2 < n2; ++i2, offset += sz)
              rc.push(mem + offset);
            return rc;
          },
          allocPtr: (n2 = 1, safePtrSize = true) => {
            return 1 === n2 ? wasm.pstack.alloc(safePtrSize ? 8 : wasm.ptrSizeof) : wasm.pstack.allocChunks(n2, safePtrSize ? 8 : wasm.ptrSizeof);
          },
          call: function(f2) {
            const stackPos = wasm.pstack.pointer;
            try {
              return f2(sqlite32);
            } finally {
              wasm.pstack.restore(stackPos);
            }
          }
        });
        Object.defineProperties(wasm.pstack, {
          pointer: {
            configurable: false,
            iterable: true,
            writeable: false,
            get: wasm.exports.sqlite3__wasm_pstack_ptr
          },
          quota: {
            configurable: false,
            iterable: true,
            writeable: false,
            get: wasm.exports.sqlite3__wasm_pstack_quota
          },
          remaining: {
            configurable: false,
            iterable: true,
            writeable: false,
            get: wasm.exports.sqlite3__wasm_pstack_remaining
          }
        });
        capi.sqlite3_randomness = (...args) => {
          if (1 === args.length && util.isTypedArray(args[0]) && 1 === args[0].BYTES_PER_ELEMENT) {
            const ta = args[0];
            if (0 === ta.byteLength) {
              wasm.exports.sqlite3_randomness(0, 0);
              return ta;
            }
            const stack = wasm.pstack.pointer;
            try {
              let n2 = ta.byteLength, offset = 0;
              const r3 = wasm.exports.sqlite3_randomness;
              const heap = wasm.heap8u();
              const nAlloc = n2 < 512 ? n2 : 512;
              const ptr = wasm.pstack.alloc(nAlloc);
              do {
                const j2 = n2 > nAlloc ? nAlloc : n2;
                r3(j2, ptr);
                ta.set(typedArrayPart(heap, ptr, ptr + j2), offset);
                n2 -= j2;
                offset += j2;
              } while (n2 > 0);
            } catch (e2) {
              console.error(
                "Highly unexpected (and ignored!) exception in sqlite3_randomness():",
                e2
              );
            } finally {
              wasm.pstack.restore(stack);
            }
            return ta;
          }
          wasm.exports.sqlite3_randomness(...args);
        };
        let __wasmfsOpfsDir = void 0;
        capi.sqlite3_wasmfs_opfs_dir = function() {
          if (void 0 !== __wasmfsOpfsDir)
            return __wasmfsOpfsDir;
          const pdir = config.wasmfsOpfsDir;
          if (!pdir || !globalThis.FileSystemHandle || !globalThis.FileSystemDirectoryHandle || !globalThis.FileSystemFileHandle) {
            return __wasmfsOpfsDir = "";
          }
          try {
            if (pdir && 0 === wasm.xCallWrapped(
              "sqlite3__wasm_init_wasmfs",
              "i32",
              ["string"],
              pdir
            )) {
              return __wasmfsOpfsDir = pdir;
            } else {
              return __wasmfsOpfsDir = "";
            }
          } catch (e2) {
            return __wasmfsOpfsDir = "";
          }
        };
        capi.sqlite3_wasmfs_filename_is_persistent = function(name) {
          const p3 = capi.sqlite3_wasmfs_opfs_dir();
          return p3 && name ? name.startsWith(p3 + "/") : false;
        };
        capi.sqlite3_js_db_uses_vfs = function(pDb2, vfsName, dbName = 0) {
          try {
            const pK = capi.sqlite3_vfs_find(vfsName);
            if (!pK)
              return false;
            else if (!pDb2) {
              return pK === capi.sqlite3_vfs_find(0) ? pK : false;
            } else {
              return pK === capi.sqlite3_js_db_vfs(pDb2, dbName) ? pK : false;
            }
          } catch (e2) {
            return false;
          }
        };
        capi.sqlite3_js_vfs_list = function() {
          const rc = [];
          let pVfs = capi.sqlite3_vfs_find(0);
          while (pVfs) {
            const oVfs = new capi.sqlite3_vfs(pVfs);
            rc.push(wasm.cstrToJs(oVfs.$zName));
            pVfs = oVfs.$pNext;
            oVfs.dispose();
          }
          return rc;
        };
        capi.sqlite3_js_db_export = function(pDb2, schema = 0) {
          pDb2 = wasm.xWrap.testConvertArg("sqlite3*", pDb2);
          if (!pDb2)
            toss3("Invalid sqlite3* argument.");
          if (!wasm.bigIntEnabled)
            toss3("BigInt64 support is not enabled.");
          const scope = wasm.scopedAllocPush();
          let pOut;
          try {
            const pSize = wasm.scopedAlloc(8 + wasm.ptrSizeof);
            const ppOut = pSize + 8;
            const zSchema = schema ? wasm.isPtr(schema) ? schema : wasm.scopedAllocCString("" + schema) : 0;
            let rc = wasm.exports.sqlite3__wasm_db_serialize(
              pDb2,
              zSchema,
              ppOut,
              pSize,
              0
            );
            if (rc) {
              toss3(
                "Database serialization failed with code",
                sqlite32.capi.sqlite3_js_rc_str(rc)
              );
            }
            pOut = wasm.peekPtr(ppOut);
            const nOut = wasm.peek(pSize, "i64");
            rc = nOut ? wasm.heap8u().slice(pOut, pOut + Number(nOut)) : new Uint8Array();
            return rc;
          } finally {
            if (pOut)
              wasm.exports.sqlite3_free(pOut);
            wasm.scopedAllocPop(scope);
          }
        };
        capi.sqlite3_js_db_vfs = (dbPointer, dbName = 0) => util.sqlite3__wasm_db_vfs(dbPointer, dbName);
        capi.sqlite3_js_aggregate_context = (pCtx, n2) => {
          return capi.sqlite3_aggregate_context(pCtx, n2) || (n2 ? WasmAllocError.toss(
            "Cannot allocate",
            n2,
            "bytes for sqlite3_aggregate_context()"
          ) : 0);
        };
        capi.sqlite3_js_posix_create_file = function(filename, data, dataLen) {
          let pData;
          if (data && wasm.isPtr(data)) {
            pData = data;
          } else if (data instanceof ArrayBuffer || data instanceof Uint8Array) {
            pData = wasm.allocFromTypedArray(data);
            if (arguments.length < 3 || !util.isInt32(dataLen) || dataLen < 0) {
              dataLen = data.byteLength;
            }
          } else {
            SQLite3Error.toss(
              "Invalid 2nd argument for sqlite3_js_posix_create_file()."
            );
          }
          try {
            if (!util.isInt32(dataLen) || dataLen < 0) {
              SQLite3Error.toss(
                "Invalid 3rd argument for sqlite3_js_posix_create_file()."
              );
            }
            const rc = util.sqlite3__wasm_posix_create_file(
              filename,
              pData,
              dataLen
            );
            if (rc)
              SQLite3Error.toss(
                "Creation of file failed with sqlite3 result code",
                capi.sqlite3_js_rc_str(rc)
              );
          } finally {
            wasm.dealloc(pData);
          }
        };
        capi.sqlite3_js_vfs_create_file = function(vfs, filename, data, dataLen) {
          config.warn(
            "sqlite3_js_vfs_create_file() is deprecated and",
            "should be avoided because it can lead to C-level crashes.",
            "See its documentation for alternative options."
          );
          let pData;
          if (data) {
            if (wasm.isPtr(data)) {
              pData = data;
            } else if (data instanceof ArrayBuffer) {
              data = new Uint8Array(data);
            }
            if (data instanceof Uint8Array) {
              pData = wasm.allocFromTypedArray(data);
              if (arguments.length < 4 || !util.isInt32(dataLen) || dataLen < 0) {
                dataLen = data.byteLength;
              }
            } else {
              SQLite3Error.toss(
                "Invalid 3rd argument type for sqlite3_js_vfs_create_file()."
              );
            }
          } else {
            pData = 0;
          }
          if (!util.isInt32(dataLen) || dataLen < 0) {
            wasm.dealloc(pData);
            SQLite3Error.toss(
              "Invalid 4th argument for sqlite3_js_vfs_create_file()."
            );
          }
          try {
            const rc = util.sqlite3__wasm_vfs_create_file(
              vfs,
              filename,
              pData,
              dataLen
            );
            if (rc)
              SQLite3Error.toss(
                "Creation of file failed with sqlite3 result code",
                capi.sqlite3_js_rc_str(rc)
              );
          } finally {
            wasm.dealloc(pData);
          }
        };
        capi.sqlite3_js_sql_to_string = (sql2) => {
          if ("string" === typeof sql2) {
            return sql2;
          }
          const x2 = flexibleString(v);
          return x2 === v ? void 0 : x2;
        };
        if (util.isUIThread()) {
          const __kvvfsInfo = function(which) {
            const rc = /* @__PURE__ */ Object.create(null);
            rc.prefix = "kvvfs-" + which;
            rc.stores = [];
            if ("session" === which || "" === which)
              rc.stores.push(globalThis.sessionStorage);
            if ("local" === which || "" === which)
              rc.stores.push(globalThis.localStorage);
            return rc;
          };
          capi.sqlite3_js_kvvfs_clear = function(which = "") {
            let rc = 0;
            const kvinfo = __kvvfsInfo(which);
            kvinfo.stores.forEach((s2) => {
              const toRm = [];
              let i2;
              for (i2 = 0; i2 < s2.length; ++i2) {
                const k2 = s2.key(i2);
                if (k2.startsWith(kvinfo.prefix))
                  toRm.push(k2);
              }
              toRm.forEach((kk) => s2.removeItem(kk));
              rc += toRm.length;
            });
            return rc;
          };
          capi.sqlite3_js_kvvfs_size = function(which = "") {
            let sz = 0;
            const kvinfo = __kvvfsInfo(which);
            kvinfo.stores.forEach((s2) => {
              let i2;
              for (i2 = 0; i2 < s2.length; ++i2) {
                const k2 = s2.key(i2);
                if (k2.startsWith(kvinfo.prefix)) {
                  sz += k2.length;
                  sz += s2.getItem(k2).length;
                }
              }
            });
            return sz * 2;
          };
        }
        capi.sqlite3_db_config = function(pDb2, op, ...args) {
          if (!this.s) {
            this.s = wasm.xWrap("sqlite3__wasm_db_config_s", "int", [
              "sqlite3*",
              "int",
              "string:static"
            ]);
            this.pii = wasm.xWrap("sqlite3__wasm_db_config_pii", "int", [
              "sqlite3*",
              "int",
              "*",
              "int",
              "int"
            ]);
            this.ip = wasm.xWrap("sqlite3__wasm_db_config_ip", "int", [
              "sqlite3*",
              "int",
              "int",
              "*"
            ]);
          }
          switch (op) {
            case capi.SQLITE_DBCONFIG_ENABLE_FKEY:
            case capi.SQLITE_DBCONFIG_ENABLE_TRIGGER:
            case capi.SQLITE_DBCONFIG_ENABLE_FTS3_TOKENIZER:
            case capi.SQLITE_DBCONFIG_ENABLE_LOAD_EXTENSION:
            case capi.SQLITE_DBCONFIG_NO_CKPT_ON_CLOSE:
            case capi.SQLITE_DBCONFIG_ENABLE_QPSG:
            case capi.SQLITE_DBCONFIG_TRIGGER_EQP:
            case capi.SQLITE_DBCONFIG_RESET_DATABASE:
            case capi.SQLITE_DBCONFIG_DEFENSIVE:
            case capi.SQLITE_DBCONFIG_WRITABLE_SCHEMA:
            case capi.SQLITE_DBCONFIG_LEGACY_ALTER_TABLE:
            case capi.SQLITE_DBCONFIG_DQS_DML:
            case capi.SQLITE_DBCONFIG_DQS_DDL:
            case capi.SQLITE_DBCONFIG_ENABLE_VIEW:
            case capi.SQLITE_DBCONFIG_LEGACY_FILE_FORMAT:
            case capi.SQLITE_DBCONFIG_TRUSTED_SCHEMA:
            case capi.SQLITE_DBCONFIG_STMT_SCANSTATUS:
            case capi.SQLITE_DBCONFIG_REVERSE_SCANORDER:
              return this.ip(pDb2, op, args[0], args[1] || 0);
            case capi.SQLITE_DBCONFIG_LOOKASIDE:
              return this.pii(pDb2, op, args[0], args[1], args[2]);
            case capi.SQLITE_DBCONFIG_MAINDBNAME:
              return this.s(pDb2, op, args[0]);
            default:
              return capi.SQLITE_MISUSE;
          }
        }.bind(/* @__PURE__ */ Object.create(null));
        capi.sqlite3_value_to_js = function(pVal, throwIfCannotConvert = true) {
          let arg;
          const valType = capi.sqlite3_value_type(pVal);
          switch (valType) {
            case capi.SQLITE_INTEGER:
              if (wasm.bigIntEnabled) {
                arg = capi.sqlite3_value_int64(pVal);
                if (util.bigIntFitsDouble(arg))
                  arg = Number(arg);
              } else
                arg = capi.sqlite3_value_double(pVal);
              break;
            case capi.SQLITE_FLOAT:
              arg = capi.sqlite3_value_double(pVal);
              break;
            case capi.SQLITE_TEXT:
              arg = capi.sqlite3_value_text(pVal);
              break;
            case capi.SQLITE_BLOB: {
              const n2 = capi.sqlite3_value_bytes(pVal);
              const pBlob = capi.sqlite3_value_blob(pVal);
              if (n2 && !pBlob)
                sqlite32.WasmAllocError.toss(
                  "Cannot allocate memory for blob argument of",
                  n2,
                  "byte(s)"
                );
              arg = n2 ? wasm.heap8u().slice(pBlob, pBlob + Number(n2)) : null;
              break;
            }
            case capi.SQLITE_NULL:
              arg = null;
              break;
            default:
              if (throwIfCannotConvert) {
                toss3(
                  capi.SQLITE_MISMATCH,
                  "Unhandled sqlite3_value_type():",
                  valType
                );
              }
              arg = void 0;
          }
          return arg;
        };
        capi.sqlite3_values_to_js = function(argc, pArgv, throwIfCannotConvert = true) {
          let i2;
          const tgt = [];
          for (i2 = 0; i2 < argc; ++i2) {
            tgt.push(
              capi.sqlite3_value_to_js(
                wasm.peekPtr(pArgv + wasm.ptrSizeof * i2),
                throwIfCannotConvert
              )
            );
          }
          return tgt;
        };
        capi.sqlite3_result_error_js = function(pCtx, e2) {
          if (e2 instanceof WasmAllocError) {
            capi.sqlite3_result_error_nomem(pCtx);
          } else {
            capi.sqlite3_result_error(pCtx, "" + e2, -1);
          }
        };
        capi.sqlite3_result_js = function(pCtx, val) {
          if (val instanceof Error) {
            capi.sqlite3_result_error_js(pCtx, val);
            return;
          }
          try {
            switch (typeof val) {
              case "undefined":
                break;
              case "boolean":
                capi.sqlite3_result_int(pCtx, val ? 1 : 0);
                break;
              case "bigint":
                if (util.bigIntFits32(val)) {
                  capi.sqlite3_result_int(pCtx, Number(val));
                } else if (util.bigIntFitsDouble(val)) {
                  capi.sqlite3_result_double(pCtx, Number(val));
                } else if (wasm.bigIntEnabled) {
                  if (util.bigIntFits64(val))
                    capi.sqlite3_result_int64(pCtx, val);
                  else
                    toss3(
                      "BigInt value",
                      val.toString(),
                      "is too BigInt for int64."
                    );
                } else {
                  toss3("BigInt value", val.toString(), "is too BigInt.");
                }
                break;
              case "number": {
                let f2;
                if (util.isInt32(val)) {
                  f2 = capi.sqlite3_result_int;
                } else if (wasm.bigIntEnabled && Number.isInteger(val) && util.bigIntFits64(BigInt(val))) {
                  f2 = capi.sqlite3_result_int64;
                } else {
                  f2 = capi.sqlite3_result_double;
                }
                f2(pCtx, val);
                break;
              }
              case "string": {
                const [p3, n2] = wasm.allocCString(val, true);
                capi.sqlite3_result_text(pCtx, p3, n2, capi.SQLITE_WASM_DEALLOC);
                break;
              }
              case "object":
                if (null === val) {
                  capi.sqlite3_result_null(pCtx);
                  break;
                } else if (util.isBindableTypedArray(val)) {
                  const pBlob = wasm.allocFromTypedArray(val);
                  capi.sqlite3_result_blob(
                    pCtx,
                    pBlob,
                    val.byteLength,
                    capi.SQLITE_WASM_DEALLOC
                  );
                  break;
                }
              default:
                toss3(
                  "Don't not how to handle this UDF result value:",
                  typeof val,
                  val
                );
            }
          } catch (e2) {
            capi.sqlite3_result_error_js(pCtx, e2);
          }
        };
        capi.sqlite3_column_js = function(pStmt, iCol, throwIfCannotConvert = true) {
          const v3 = capi.sqlite3_column_value(pStmt, iCol);
          return 0 === v3 ? void 0 : capi.sqlite3_value_to_js(v3, throwIfCannotConvert);
        };
        const __newOldValue = function(pObj, iCol, impl) {
          impl = capi[impl];
          if (!this.ptr)
            this.ptr = wasm.allocPtr();
          else
            wasm.pokePtr(this.ptr, 0);
          const rc = impl(pObj, iCol, this.ptr);
          if (rc)
            return SQLite3Error.toss(
              rc,
              arguments[2] + "() failed with code " + rc
            );
          const pv = wasm.peekPtr(this.ptr);
          return pv ? capi.sqlite3_value_to_js(pv, true) : void 0;
        }.bind(/* @__PURE__ */ Object.create(null));
        capi.sqlite3_preupdate_new_js = (pDb2, iCol) => __newOldValue(pDb2, iCol, "sqlite3_preupdate_new");
        capi.sqlite3_preupdate_old_js = (pDb2, iCol) => __newOldValue(pDb2, iCol, "sqlite3_preupdate_old");
        capi.sqlite3changeset_new_js = (pChangesetIter, iCol) => __newOldValue(pChangesetIter, iCol, "sqlite3changeset_new");
        capi.sqlite3changeset_old_js = (pChangesetIter, iCol) => __newOldValue(pChangesetIter, iCol, "sqlite3changeset_old");
        const sqlite32 = {
          WasmAllocError,
          SQLite3Error,
          capi,
          util,
          wasm,
          config,
          version: /* @__PURE__ */ Object.create(null),
          client: void 0,
          asyncPostInit: async function ff() {
            if (ff.isReady instanceof Promise)
              return ff.isReady;
            let lia = sqlite3ApiBootstrap.initializersAsync;
            delete sqlite3ApiBootstrap.initializersAsync;
            const postInit = async () => {
              if (!sqlite32.__isUnderTest) {
                delete sqlite32.util;
                delete sqlite32.StructBinder;
              }
              return sqlite32;
            };
            const catcher = (e2) => {
              config.error("an async sqlite3 initializer failed:", e2);
              throw e2;
            };
            if (!lia || !lia.length) {
              return ff.isReady = postInit().catch(catcher);
            }
            lia = lia.map((f2) => {
              return f2 instanceof Function ? async (x2) => f2(sqlite32) : f2;
            });
            lia.push(postInit);
            let p3 = Promise.resolve(sqlite32);
            while (lia.length)
              p3 = p3.then(lia.shift());
            return ff.isReady = p3.catch(catcher);
          },
          scriptInfo: void 0
        };
        try {
          sqlite3ApiBootstrap.initializers.forEach((f2) => {
            f2(sqlite32);
          });
        } catch (e2) {
          console.error("sqlite3 bootstrap initializer threw:", e2);
          throw e2;
        }
        delete sqlite3ApiBootstrap.initializers;
        sqlite3ApiBootstrap.sqlite3 = sqlite32;
        return sqlite32;
      };
      globalThis.sqlite3ApiBootstrap.initializers = [];
      globalThis.sqlite3ApiBootstrap.initializersAsync = [];
      globalThis.sqlite3ApiBootstrap.defaultConfig = /* @__PURE__ */ Object.create(null);
      globalThis.sqlite3ApiBootstrap.sqlite3 = void 0;
      globalThis.WhWasmUtilInstaller = function(target) {
        "use strict";
        if (void 0 === target.bigIntEnabled) {
          target.bigIntEnabled = !!globalThis["BigInt64Array"];
        }
        const toss = (...args) => {
          throw new Error(args.join(" "));
        };
        if (!target.exports) {
          Object.defineProperty(target, "exports", {
            enumerable: true,
            configurable: true,
            get: () => target.instance && target.instance.exports
          });
        }
        const ptrIR = target.pointerIR || "i32";
        const ptrSizeof = target.ptrSizeof = "i32" === ptrIR ? 4 : "i64" === ptrIR ? 8 : toss("Unhandled ptrSizeof:", ptrIR);
        const cache = /* @__PURE__ */ Object.create(null);
        cache.heapSize = 0;
        cache.memory = null;
        cache.freeFuncIndexes = [];
        cache.scopedAlloc = [];
        cache.utf8Decoder = new TextDecoder();
        cache.utf8Encoder = new TextEncoder("utf-8");
        target.sizeofIR = (n2) => {
          switch (n2) {
            case "i8":
              return 1;
            case "i16":
              return 2;
            case "i32":
            case "f32":
            case "float":
              return 4;
            case "i64":
            case "f64":
            case "double":
              return 8;
            case "*":
              return ptrSizeof;
            default:
              return ("" + n2).endsWith("*") ? ptrSizeof : void 0;
          }
        };
        const heapWrappers = function() {
          if (!cache.memory) {
            cache.memory = target.memory instanceof WebAssembly.Memory ? target.memory : target.exports.memory;
          } else if (cache.heapSize === cache.memory.buffer.byteLength) {
            return cache;
          }
          const b = cache.memory.buffer;
          cache.HEAP8 = new Int8Array(b);
          cache.HEAP8U = new Uint8Array(b);
          cache.HEAP16 = new Int16Array(b);
          cache.HEAP16U = new Uint16Array(b);
          cache.HEAP32 = new Int32Array(b);
          cache.HEAP32U = new Uint32Array(b);
          if (target.bigIntEnabled) {
            cache.HEAP64 = new BigInt64Array(b);
            cache.HEAP64U = new BigUint64Array(b);
          }
          cache.HEAP32F = new Float32Array(b);
          cache.HEAP64F = new Float64Array(b);
          cache.heapSize = b.byteLength;
          return cache;
        };
        target.heap8 = () => heapWrappers().HEAP8;
        target.heap8u = () => heapWrappers().HEAP8U;
        target.heap16 = () => heapWrappers().HEAP16;
        target.heap16u = () => heapWrappers().HEAP16U;
        target.heap32 = () => heapWrappers().HEAP32;
        target.heap32u = () => heapWrappers().HEAP32U;
        target.heapForSize = function(n2, unsigned = true) {
          let ctor;
          const c3 = cache.memory && cache.heapSize === cache.memory.buffer.byteLength ? cache : heapWrappers();
          switch (n2) {
            case Int8Array:
              return c3.HEAP8;
            case Uint8Array:
              return c3.HEAP8U;
            case Int16Array:
              return c3.HEAP16;
            case Uint16Array:
              return c3.HEAP16U;
            case Int32Array:
              return c3.HEAP32;
            case Uint32Array:
              return c3.HEAP32U;
            case 8:
              return unsigned ? c3.HEAP8U : c3.HEAP8;
            case 16:
              return unsigned ? c3.HEAP16U : c3.HEAP16;
            case 32:
              return unsigned ? c3.HEAP32U : c3.HEAP32;
            case 64:
              if (c3.HEAP64)
                return unsigned ? c3.HEAP64U : c3.HEAP64;
              break;
            default:
              if (target.bigIntEnabled) {
                if (n2 === globalThis["BigUint64Array"])
                  return c3.HEAP64U;
                else if (n2 === globalThis["BigInt64Array"])
                  return c3.HEAP64;
                break;
              }
          }
          toss(
            "Invalid heapForSize() size: expecting 8, 16, 32,",
            "or (if BigInt is enabled) 64."
          );
        };
        target.functionTable = function() {
          return target.exports.__indirect_function_table;
        };
        target.functionEntry = function(fptr) {
          const ft = target.functionTable();
          return fptr < ft.length ? ft.get(fptr) : void 0;
        };
        target.jsFuncToWasm = function f2(func, sig) {
          if (!f2._) {
            f2._ = {
              sigTypes: Object.assign(/* @__PURE__ */ Object.create(null), {
                i: "i32",
                p: "i32",
                P: "i32",
                s: "i32",
                j: "i64",
                f: "f32",
                d: "f64"
              }),
              typeCodes: Object.assign(/* @__PURE__ */ Object.create(null), {
                f64: 124,
                f32: 125,
                i64: 126,
                i32: 127
              }),
              uleb128Encode: function(tgt, method, n2) {
                if (n2 < 128)
                  tgt[method](n2);
                else
                  tgt[method](n2 % 128 | 128, n2 >> 7);
              },
              rxJSig: /^(\w)\((\w*)\)$/,
              sigParams: function(sig2) {
                const m2 = f2._.rxJSig.exec(sig2);
                return m2 ? m2[2] : sig2.substr(1);
              },
              letterType: (x2) => f2._.sigTypes[x2] || toss("Invalid signature letter:", x2),
              pushSigType: (dest, letter) => dest.push(f2._.typeCodes[f2._.letterType(letter)])
            };
          }
          if ("string" === typeof func) {
            const x2 = sig;
            sig = func;
            func = x2;
          }
          const sigParams = f2._.sigParams(sig);
          const wasmCode = [1, 96];
          f2._.uleb128Encode(wasmCode, "push", sigParams.length);
          for (const x2 of sigParams)
            f2._.pushSigType(wasmCode, x2);
          if ("v" === sig[0])
            wasmCode.push(0);
          else {
            wasmCode.push(1);
            f2._.pushSigType(wasmCode, sig[0]);
          }
          f2._.uleb128Encode(wasmCode, "unshift", wasmCode.length);
          wasmCode.unshift(
            0,
            97,
            115,
            109,
            1,
            0,
            0,
            0,
            1
          );
          wasmCode.push(
            2,
            7,
            1,
            1,
            101,
            1,
            102,
            0,
            0,
            7,
            5,
            1,
            1,
            102,
            0,
            0
          );
          return new WebAssembly.Instance(
            new WebAssembly.Module(new Uint8Array(wasmCode)),
            {
              e: { f: func }
            }
          ).exports["f"];
        };
        const __installFunction = function f2(func, sig, scoped) {
          if (scoped && !cache.scopedAlloc.length) {
            toss("No scopedAllocPush() scope is active.");
          }
          if ("string" === typeof func) {
            const x2 = sig;
            sig = func;
            func = x2;
          }
          if ("string" !== typeof sig || !(func instanceof Function)) {
            toss(
              "Invalid arguments: expecting (function,signature) or (signature,function)."
            );
          }
          const ft = target.functionTable();
          const oldLen = ft.length;
          let ptr;
          while (cache.freeFuncIndexes.length) {
            ptr = cache.freeFuncIndexes.pop();
            if (ft.get(ptr)) {
              ptr = null;
              continue;
            } else {
              break;
            }
          }
          if (!ptr) {
            ptr = oldLen;
            ft.grow(1);
          }
          try {
            ft.set(ptr, func);
            if (scoped) {
              cache.scopedAlloc[cache.scopedAlloc.length - 1].push(ptr);
            }
            return ptr;
          } catch (e2) {
            if (!(e2 instanceof TypeError)) {
              if (ptr === oldLen)
                cache.freeFuncIndexes.push(oldLen);
              throw e2;
            }
          }
          try {
            const fptr = target.jsFuncToWasm(func, sig);
            ft.set(ptr, fptr);
            if (scoped) {
              cache.scopedAlloc[cache.scopedAlloc.length - 1].push(ptr);
            }
          } catch (e2) {
            if (ptr === oldLen)
              cache.freeFuncIndexes.push(oldLen);
            throw e2;
          }
          return ptr;
        };
        target.installFunction = (func, sig) => __installFunction(func, sig, false);
        target.scopedInstallFunction = (func, sig) => __installFunction(func, sig, true);
        target.uninstallFunction = function(ptr) {
          if (!ptr && 0 !== ptr)
            return void 0;
          const fi = cache.freeFuncIndexes;
          const ft = target.functionTable();
          fi.push(ptr);
          const rc = ft.get(ptr);
          ft.set(ptr, null);
          return rc;
        };
        target.peek = function f2(ptr, type = "i8") {
          if (type.endsWith("*"))
            type = ptrIR;
          const c3 = cache.memory && cache.heapSize === cache.memory.buffer.byteLength ? cache : heapWrappers();
          const list = Array.isArray(ptr) ? [] : void 0;
          let rc;
          do {
            if (list)
              ptr = arguments[0].shift();
            switch (type) {
              case "i1":
              case "i8":
                rc = c3.HEAP8[ptr >> 0];
                break;
              case "i16":
                rc = c3.HEAP16[ptr >> 1];
                break;
              case "i32":
                rc = c3.HEAP32[ptr >> 2];
                break;
              case "float":
              case "f32":
                rc = c3.HEAP32F[ptr >> 2];
                break;
              case "double":
              case "f64":
                rc = Number(c3.HEAP64F[ptr >> 3]);
                break;
              case "i64":
                if (target.bigIntEnabled) {
                  rc = BigInt(c3.HEAP64[ptr >> 3]);
                  break;
                }
              default:
                toss("Invalid type for peek():", type);
            }
            if (list)
              list.push(rc);
          } while (list && arguments[0].length);
          return list || rc;
        };
        target.poke = function(ptr, value, type = "i8") {
          if (type.endsWith("*"))
            type = ptrIR;
          const c3 = cache.memory && cache.heapSize === cache.memory.buffer.byteLength ? cache : heapWrappers();
          for (const p3 of Array.isArray(ptr) ? ptr : [ptr]) {
            switch (type) {
              case "i1":
              case "i8":
                c3.HEAP8[p3 >> 0] = value;
                continue;
              case "i16":
                c3.HEAP16[p3 >> 1] = value;
                continue;
              case "i32":
                c3.HEAP32[p3 >> 2] = value;
                continue;
              case "float":
              case "f32":
                c3.HEAP32F[p3 >> 2] = value;
                continue;
              case "double":
              case "f64":
                c3.HEAP64F[p3 >> 3] = value;
                continue;
              case "i64":
                if (c3.HEAP64) {
                  c3.HEAP64[p3 >> 3] = BigInt(value);
                  continue;
                }
              default:
                toss("Invalid type for poke(): " + type);
            }
          }
          return this;
        };
        target.peekPtr = (...ptr) => target.peek(1 === ptr.length ? ptr[0] : ptr, ptrIR);
        target.pokePtr = (ptr, value = 0) => target.poke(ptr, value, ptrIR);
        target.peek8 = (...ptr) => target.peek(1 === ptr.length ? ptr[0] : ptr, "i8");
        target.poke8 = (ptr, value) => target.poke(ptr, value, "i8");
        target.peek16 = (...ptr) => target.peek(1 === ptr.length ? ptr[0] : ptr, "i16");
        target.poke16 = (ptr, value) => target.poke(ptr, value, "i16");
        target.peek32 = (...ptr) => target.peek(1 === ptr.length ? ptr[0] : ptr, "i32");
        target.poke32 = (ptr, value) => target.poke(ptr, value, "i32");
        target.peek64 = (...ptr) => target.peek(1 === ptr.length ? ptr[0] : ptr, "i64");
        target.poke64 = (ptr, value) => target.poke(ptr, value, "i64");
        target.peek32f = (...ptr) => target.peek(1 === ptr.length ? ptr[0] : ptr, "f32");
        target.poke32f = (ptr, value) => target.poke(ptr, value, "f32");
        target.peek64f = (...ptr) => target.peek(1 === ptr.length ? ptr[0] : ptr, "f64");
        target.poke64f = (ptr, value) => target.poke(ptr, value, "f64");
        target.getMemValue = target.peek;
        target.getPtrValue = target.peekPtr;
        target.setMemValue = target.poke;
        target.setPtrValue = target.pokePtr;
        target.isPtr32 = (ptr) => "number" === typeof ptr && ptr === (ptr | 0) && ptr >= 0;
        target.isPtr = target.isPtr32;
        target.cstrlen = function(ptr) {
          if (!ptr || !target.isPtr(ptr))
            return null;
          const h2 = heapWrappers().HEAP8U;
          let pos = ptr;
          for (; h2[pos] !== 0; ++pos) {
          }
          return pos - ptr;
        };
        const __SAB = "undefined" === typeof SharedArrayBuffer ? function() {
        } : SharedArrayBuffer;
        const __utf8Decode = function(arrayBuffer, begin, end) {
          return cache.utf8Decoder.decode(
            arrayBuffer.buffer instanceof __SAB ? arrayBuffer.slice(begin, end) : arrayBuffer.subarray(begin, end)
          );
        };
        target.cstrToJs = function(ptr) {
          const n2 = target.cstrlen(ptr);
          return n2 ? __utf8Decode(heapWrappers().HEAP8U, ptr, ptr + n2) : null === n2 ? n2 : "";
        };
        target.jstrlen = function(str) {
          if ("string" !== typeof str)
            return null;
          const n2 = str.length;
          let len = 0;
          for (let i2 = 0; i2 < n2; ++i2) {
            let u3 = str.charCodeAt(i2);
            if (u3 >= 55296 && u3 <= 57343) {
              u3 = 65536 + ((u3 & 1023) << 10) | str.charCodeAt(++i2) & 1023;
            }
            if (u3 <= 127)
              ++len;
            else if (u3 <= 2047)
              len += 2;
            else if (u3 <= 65535)
              len += 3;
            else
              len += 4;
          }
          return len;
        };
        target.jstrcpy = function(jstr, tgt, offset = 0, maxBytes = -1, addNul = true) {
          if (!tgt || !(tgt instanceof Int8Array) && !(tgt instanceof Uint8Array)) {
            toss("jstrcpy() target must be an Int8Array or Uint8Array.");
          }
          if (maxBytes < 0)
            maxBytes = tgt.length - offset;
          if (!(maxBytes > 0) || !(offset >= 0))
            return 0;
          let i2 = 0, max = jstr.length;
          const begin = offset, end = offset + maxBytes - (addNul ? 1 : 0);
          for (; i2 < max && offset < end; ++i2) {
            let u3 = jstr.charCodeAt(i2);
            if (u3 >= 55296 && u3 <= 57343) {
              u3 = 65536 + ((u3 & 1023) << 10) | jstr.charCodeAt(++i2) & 1023;
            }
            if (u3 <= 127) {
              if (offset >= end)
                break;
              tgt[offset++] = u3;
            } else if (u3 <= 2047) {
              if (offset + 1 >= end)
                break;
              tgt[offset++] = 192 | u3 >> 6;
              tgt[offset++] = 128 | u3 & 63;
            } else if (u3 <= 65535) {
              if (offset + 2 >= end)
                break;
              tgt[offset++] = 224 | u3 >> 12;
              tgt[offset++] = 128 | u3 >> 6 & 63;
              tgt[offset++] = 128 | u3 & 63;
            } else {
              if (offset + 3 >= end)
                break;
              tgt[offset++] = 240 | u3 >> 18;
              tgt[offset++] = 128 | u3 >> 12 & 63;
              tgt[offset++] = 128 | u3 >> 6 & 63;
              tgt[offset++] = 128 | u3 & 63;
            }
          }
          if (addNul)
            tgt[offset++] = 0;
          return offset - begin;
        };
        target.cstrncpy = function(tgtPtr, srcPtr, n2) {
          if (!tgtPtr || !srcPtr)
            toss("cstrncpy() does not accept NULL strings.");
          if (n2 < 0)
            n2 = target.cstrlen(strPtr) + 1;
          else if (!(n2 > 0))
            return 0;
          const heap = target.heap8u();
          let i2 = 0, ch;
          for (; i2 < n2 && (ch = heap[srcPtr + i2]); ++i2) {
            heap[tgtPtr + i2] = ch;
          }
          if (i2 < n2)
            heap[tgtPtr + i2++] = 0;
          return i2;
        };
        target.jstrToUintArray = (str, addNul = false) => {
          return cache.utf8Encoder.encode(addNul ? str + "\0" : str);
        };
        const __affirmAlloc = (obj, funcName) => {
          if (!(obj.alloc instanceof Function) || !(obj.dealloc instanceof Function)) {
            toss(
              "Object is missing alloc() and/or dealloc() function(s)",
              "required by",
              funcName + "()."
            );
          }
        };
        const __allocCStr = function(jstr, returnWithLength, allocator, funcName) {
          __affirmAlloc(target, funcName);
          if ("string" !== typeof jstr)
            return null;
          if (0) {
            const n2 = target.jstrlen(jstr), ptr = allocator(n2 + 1);
            target.jstrcpy(jstr, target.heap8u(), ptr, n2 + 1, true);
            return returnWithLength ? [ptr, n2] : ptr;
          } else {
            const u3 = cache.utf8Encoder.encode(jstr), ptr = allocator(u3.length + 1), heap = heapWrappers().HEAP8U;
            heap.set(u3, ptr);
            heap[ptr + u3.length] = 0;
            return returnWithLength ? [ptr, u3.length] : ptr;
          }
        };
        target.allocCString = (jstr, returnWithLength = false) => __allocCStr(jstr, returnWithLength, target.alloc, "allocCString()");
        target.scopedAllocPush = function() {
          __affirmAlloc(target, "scopedAllocPush");
          const a3 = [];
          cache.scopedAlloc.push(a3);
          return a3;
        };
        target.scopedAllocPop = function(state) {
          __affirmAlloc(target, "scopedAllocPop");
          const n2 = arguments.length ? cache.scopedAlloc.indexOf(state) : cache.scopedAlloc.length - 1;
          if (n2 < 0)
            toss("Invalid state object for scopedAllocPop().");
          if (0 === arguments.length)
            state = cache.scopedAlloc[n2];
          cache.scopedAlloc.splice(n2, 1);
          for (let p3; p3 = state.pop(); ) {
            if (target.functionEntry(p3)) {
              target.uninstallFunction(p3);
            } else
              target.dealloc(p3);
          }
        };
        target.scopedAlloc = function(n2) {
          if (!cache.scopedAlloc.length) {
            toss("No scopedAllocPush() scope is active.");
          }
          const p3 = target.alloc(n2);
          cache.scopedAlloc[cache.scopedAlloc.length - 1].push(p3);
          return p3;
        };
        Object.defineProperty(target.scopedAlloc, "level", {
          configurable: false,
          enumerable: false,
          get: () => cache.scopedAlloc.length,
          set: () => toss("The 'active' property is read-only.")
        });
        target.scopedAllocCString = (jstr, returnWithLength = false) => __allocCStr(
          jstr,
          returnWithLength,
          target.scopedAlloc,
          "scopedAllocCString()"
        );
        const __allocMainArgv = function(isScoped, list) {
          const pList = target[isScoped ? "scopedAlloc" : "alloc"](
            (list.length + 1) * target.ptrSizeof
          );
          let i2 = 0;
          list.forEach((e2) => {
            target.pokePtr(
              pList + target.ptrSizeof * i2++,
              target[isScoped ? "scopedAllocCString" : "allocCString"]("" + e2)
            );
          });
          target.pokePtr(pList + target.ptrSizeof * i2, 0);
          return pList;
        };
        target.scopedAllocMainArgv = (list) => __allocMainArgv(true, list);
        target.allocMainArgv = (list) => __allocMainArgv(false, list);
        target.cArgvToJs = (argc, pArgv) => {
          const list = [];
          for (let i2 = 0; i2 < argc; ++i2) {
            const arg = target.peekPtr(pArgv + target.ptrSizeof * i2);
            list.push(arg ? target.cstrToJs(arg) : null);
          }
          return list;
        };
        target.scopedAllocCall = function(func) {
          target.scopedAllocPush();
          try {
            return func();
          } finally {
            target.scopedAllocPop();
          }
        };
        const __allocPtr = function(howMany, safePtrSize, method) {
          __affirmAlloc(target, method);
          const pIr = safePtrSize ? "i64" : ptrIR;
          let m2 = target[method](howMany * (safePtrSize ? 8 : ptrSizeof));
          target.poke(m2, 0, pIr);
          if (1 === howMany) {
            return m2;
          }
          const a3 = [m2];
          for (let i2 = 1; i2 < howMany; ++i2) {
            m2 += safePtrSize ? 8 : ptrSizeof;
            a3[i2] = m2;
            target.poke(m2, 0, pIr);
          }
          return a3;
        };
        target.allocPtr = (howMany = 1, safePtrSize = true) => __allocPtr(howMany, safePtrSize, "alloc");
        target.scopedAllocPtr = (howMany = 1, safePtrSize = true) => __allocPtr(howMany, safePtrSize, "scopedAlloc");
        target.xGet = function(name) {
          return target.exports[name] || toss("Cannot find exported symbol:", name);
        };
        const __argcMismatch = (f2, n2) => toss(f2 + "() requires", n2, "argument(s).");
        target.xCall = function(fname, ...args) {
          const f2 = fname instanceof Function ? fname : target.xGet(fname);
          if (!(f2 instanceof Function))
            toss("Exported symbol", fname, "is not a function.");
          if (f2.length !== args.length)
            __argcMismatch(f2 === fname ? f2.name : fname, f2.length);
          return 2 === arguments.length && Array.isArray(arguments[1]) ? f2.apply(null, arguments[1]) : f2.apply(null, args);
        };
        cache.xWrap = /* @__PURE__ */ Object.create(null);
        cache.xWrap.convert = /* @__PURE__ */ Object.create(null);
        cache.xWrap.convert.arg = /* @__PURE__ */ new Map();
        cache.xWrap.convert.result = /* @__PURE__ */ new Map();
        const xArg = cache.xWrap.convert.arg, xResult = cache.xWrap.convert.result;
        if (target.bigIntEnabled) {
          xArg.set("i64", (i2) => BigInt(i2));
        }
        const __xArgPtr = "i32" === ptrIR ? (i2) => i2 | 0 : (i2) => BigInt(i2) | BigInt(0);
        xArg.set("i32", __xArgPtr).set("i16", (i2) => (i2 | 0) & 65535).set("i8", (i2) => (i2 | 0) & 255).set("f32", (i2) => Number(i2).valueOf()).set("float", xArg.get("f32")).set("f64", xArg.get("f32")).set("double", xArg.get("f64")).set("int", xArg.get("i32")).set("null", (i2) => i2).set(null, xArg.get("null")).set("**", __xArgPtr).set("*", __xArgPtr);
        xResult.set("*", __xArgPtr).set("pointer", __xArgPtr).set("number", (v3) => Number(v3)).set("void", (v3) => void 0).set("null", (v3) => v3).set(null, xResult.get("null"));
        {
          const copyToResult = [
            "i8",
            "i16",
            "i32",
            "int",
            "f32",
            "float",
            "f64",
            "double"
          ];
          if (target.bigIntEnabled)
            copyToResult.push("i64");
          const adaptPtr = xArg.get(ptrIR);
          for (const t2 of copyToResult) {
            xArg.set(t2 + "*", adaptPtr);
            xResult.set(t2 + "*", adaptPtr);
            xResult.set(t2, xArg.get(t2) || toss("Missing arg converter:", t2));
          }
        }
        const __xArgString = function(v3) {
          if ("string" === typeof v3)
            return target.scopedAllocCString(v3);
          return v3 ? __xArgPtr(v3) : null;
        };
        xArg.set("string", __xArgString).set("utf8", __xArgString).set("pointer", __xArgString);
        xResult.set("string", (i2) => target.cstrToJs(i2)).set("utf8", xResult.get("string")).set("string:dealloc", (i2) => {
          try {
            return i2 ? target.cstrToJs(i2) : null;
          } finally {
            target.dealloc(i2);
          }
        }).set("utf8:dealloc", xResult.get("string:dealloc")).set("json", (i2) => JSON.parse(target.cstrToJs(i2))).set("json:dealloc", (i2) => {
          try {
            return i2 ? JSON.parse(target.cstrToJs(i2)) : null;
          } finally {
            target.dealloc(i2);
          }
        });
        const AbstractArgAdapter = class {
          constructor(opt) {
            this.name = opt.name || "unnamed adapter";
          }
          convertArg(v3, argv2, argIndex) {
            toss("AbstractArgAdapter must be subclassed.");
          }
        };
        xArg.FuncPtrAdapter = class FuncPtrAdapter extends AbstractArgAdapter {
          constructor(opt) {
            super(opt);
            if (xArg.FuncPtrAdapter.warnOnUse) {
              console.warn(
                "xArg.FuncPtrAdapter is an internal-only API",
                "and is not intended to be invoked from",
                "client-level code. Invoked with:",
                opt
              );
            }
            this.name = opt.name || "unnamed";
            this.signature = opt.signature;
            if (opt.contextKey instanceof Function) {
              this.contextKey = opt.contextKey;
              if (!opt.bindScope)
                opt.bindScope = "context";
            }
            this.bindScope = opt.bindScope || toss(
              "FuncPtrAdapter options requires a bindScope (explicit or implied)."
            );
            if (FuncPtrAdapter.bindScopes.indexOf(opt.bindScope) < 0) {
              toss(
                "Invalid options.bindScope (" + opt.bindMod + ") for FuncPtrAdapter. Expecting one of: (" + FuncPtrAdapter.bindScopes.join(", ") + ")"
              );
            }
            this.isTransient = "transient" === this.bindScope;
            this.isContext = "context" === this.bindScope;
            this.isPermanent = "permanent" === this.bindScope;
            this.singleton = "singleton" === this.bindScope ? [] : void 0;
            this.callProxy = opt.callProxy instanceof Function ? opt.callProxy : void 0;
          }
          contextKey(argv2, argIndex) {
            return this;
          }
          contextMap(key) {
            const cm = this.__cmap || (this.__cmap = /* @__PURE__ */ new Map());
            let rc = cm.get(key);
            if (void 0 === rc)
              cm.set(key, rc = []);
            return rc;
          }
          convertArg(v3, argv2, argIndex) {
            let pair = this.singleton;
            if (!pair && this.isContext) {
              pair = this.contextMap(this.contextKey(argv2, argIndex));
            }
            if (pair && pair[0] === v3)
              return pair[1];
            if (v3 instanceof Function) {
              if (this.callProxy)
                v3 = this.callProxy(v3);
              const fp = __installFunction(v3, this.signature, this.isTransient);
              if (FuncPtrAdapter.debugFuncInstall) {
                FuncPtrAdapter.debugOut(
                  "FuncPtrAdapter installed",
                  this,
                  this.contextKey(argv2, argIndex),
                  "@" + fp,
                  v3
                );
              }
              if (pair) {
                if (pair[1]) {
                  if (FuncPtrAdapter.debugFuncInstall) {
                    FuncPtrAdapter.debugOut(
                      "FuncPtrAdapter uninstalling",
                      this,
                      this.contextKey(argv2, argIndex),
                      "@" + pair[1],
                      v3
                    );
                  }
                  try {
                    cache.scopedAlloc[cache.scopedAlloc.length - 1].push(
                      pair[1]
                    );
                  } catch (e2) {
                  }
                }
                pair[0] = v3;
                pair[1] = fp;
              }
              return fp;
            } else if (target.isPtr(v3) || null === v3 || void 0 === v3) {
              if (pair && pair[1] && pair[1] !== v3) {
                if (FuncPtrAdapter.debugFuncInstall) {
                  FuncPtrAdapter.debugOut(
                    "FuncPtrAdapter uninstalling",
                    this,
                    this.contextKey(argv2, argIndex),
                    "@" + pair[1],
                    v3
                  );
                }
                try {
                  cache.scopedAlloc[cache.scopedAlloc.length - 1].push(pair[1]);
                } catch (e2) {
                }
                pair[0] = pair[1] = v3 | 0;
              }
              return v3 || 0;
            } else {
              throw new TypeError(
                "Invalid FuncPtrAdapter argument type. Expecting a function pointer or a " + (this.name ? this.name + " " : "") + "function matching signature " + this.signature + "."
              );
            }
          }
        };
        xArg.FuncPtrAdapter.warnOnUse = false;
        xArg.FuncPtrAdapter.debugFuncInstall = false;
        xArg.FuncPtrAdapter.debugOut = console.debug.bind(console);
        xArg.FuncPtrAdapter.bindScopes = [
          "transient",
          "context",
          "singleton",
          "permanent"
        ];
        const __xArgAdapterCheck = (t2) => xArg.get(t2) || toss("Argument adapter not found:", t2);
        const __xResultAdapterCheck = (t2) => xResult.get(t2) || toss("Result adapter not found:", t2);
        cache.xWrap.convertArg = (t2, ...args) => __xArgAdapterCheck(t2)(...args);
        cache.xWrap.convertArgNoCheck = (t2, ...args) => xArg.get(t2)(...args);
        cache.xWrap.convertResult = (t2, v3) => null === t2 ? v3 : t2 ? __xResultAdapterCheck(t2)(v3) : void 0;
        cache.xWrap.convertResultNoCheck = (t2, v3) => null === t2 ? v3 : t2 ? xResult.get(t2)(v3) : void 0;
        target.xWrap = function(fArg, resultType, ...argTypes) {
          if (3 === arguments.length && Array.isArray(arguments[2])) {
            argTypes = arguments[2];
          }
          if (target.isPtr(fArg)) {
            fArg = target.functionEntry(fArg) || toss("Function pointer not found in WASM function table.");
          }
          const fIsFunc = fArg instanceof Function;
          const xf = fIsFunc ? fArg : target.xGet(fArg);
          if (fIsFunc)
            fArg = xf.name || "unnamed function";
          if (argTypes.length !== xf.length)
            __argcMismatch(fArg, xf.length);
          if (null === resultType && 0 === xf.length) {
            return xf;
          }
          if (void 0 !== resultType && null !== resultType)
            __xResultAdapterCheck(resultType);
          for (const t2 of argTypes) {
            if (t2 instanceof AbstractArgAdapter)
              xArg.set(t2, (...args) => t2.convertArg(...args));
            else
              __xArgAdapterCheck(t2);
          }
          const cxw = cache.xWrap;
          if (0 === xf.length) {
            return (...args) => args.length ? __argcMismatch(fArg, xf.length) : cxw.convertResult(resultType, xf.call(null));
          }
          return function(...args) {
            if (args.length !== xf.length)
              __argcMismatch(fArg, xf.length);
            const scope = target.scopedAllocPush();
            try {
              let i2 = 0;
              for (; i2 < args.length; ++i2)
                args[i2] = cxw.convertArgNoCheck(argTypes[i2], args[i2], args, i2);
              return cxw.convertResultNoCheck(resultType, xf.apply(null, args));
            } finally {
              target.scopedAllocPop(scope);
            }
          };
        };
        const __xAdapter = function(func, argc, typeName, adapter, modeName, xcvPart) {
          if ("string" === typeof typeName) {
            if (1 === argc)
              return xcvPart.get(typeName);
            else if (2 === argc) {
              if (!adapter) {
                xcvPart.delete(typeName);
                return func;
              } else if (!(adapter instanceof Function)) {
                toss(modeName, "requires a function argument.");
              }
              xcvPart.set(typeName, adapter);
              return func;
            }
          }
          toss("Invalid arguments to", modeName);
        };
        target.xWrap.resultAdapter = function f2(typeName, adapter) {
          return __xAdapter(
            f2,
            arguments.length,
            typeName,
            adapter,
            "resultAdapter()",
            xResult
          );
        };
        target.xWrap.argAdapter = function f2(typeName, adapter) {
          return __xAdapter(
            f2,
            arguments.length,
            typeName,
            adapter,
            "argAdapter()",
            xArg
          );
        };
        target.xWrap.FuncPtrAdapter = xArg.FuncPtrAdapter;
        target.xCallWrapped = function(fArg, resultType, argTypes, ...args) {
          if (Array.isArray(arguments[3]))
            args = arguments[3];
          return target.xWrap(fArg, resultType, argTypes || []).apply(null, args || []);
        };
        target.xWrap.testConvertArg = cache.xWrap.convertArg;
        target.xWrap.testConvertResult = cache.xWrap.convertResult;
        return target;
      };
      globalThis.WhWasmUtilInstaller.yawl = function(config) {
        const wfetch = () => fetch(config.uri, { credentials: "same-origin" });
        const wui = this;
        const finalThen = function(arg) {
          if (config.wasmUtilTarget) {
            const toss = (...args) => {
              throw new Error(args.join(" "));
            };
            const tgt = config.wasmUtilTarget;
            tgt.module = arg.module;
            tgt.instance = arg.instance;
            if (!tgt.instance.exports.memory) {
              tgt.memory = config.imports && config.imports.env && config.imports.env.memory || toss("Missing 'memory' object!");
            }
            if (!tgt.alloc && arg.instance.exports.malloc) {
              const exports = arg.instance.exports;
              tgt.alloc = function(n2) {
                return exports.malloc(n2) || toss("Allocation of", n2, "bytes failed.");
              };
              tgt.dealloc = function(m2) {
                exports.free(m2);
              };
            }
            wui(tgt);
          }
          if (config.onload)
            config.onload(arg, config);
          return arg;
        };
        const loadWasm = WebAssembly.instantiateStreaming ? function loadWasmStreaming() {
          return WebAssembly.instantiateStreaming(
            wfetch(),
            config.imports || {}
          ).then(finalThen);
        } : function loadWasmOldSchool() {
          return wfetch().then((response) => response.arrayBuffer()).then(
            (bytes) => WebAssembly.instantiate(bytes, config.imports || {})
          ).then(finalThen);
        };
        return loadWasm;
      }.bind(globalThis.WhWasmUtilInstaller);
      "use strict";
      globalThis.Jaccwabyt = function StructBinderFactory(config) {
        const toss = (...args) => {
          throw new Error(args.join(" "));
        };
        if (!(config.heap instanceof WebAssembly.Memory) && !(config.heap instanceof Function)) {
          toss(
            "config.heap must be WebAssembly.Memory instance or a function."
          );
        }
        ["alloc", "dealloc"].forEach(function(k2) {
          config[k2] instanceof Function || toss("Config option '" + k2 + "' must be a function.");
        });
        const SBF = StructBinderFactory;
        const heap = config.heap instanceof Function ? config.heap : () => new Uint8Array(config.heap.buffer), alloc = config.alloc, dealloc = config.dealloc, log2 = config.log || console.log.bind(console), memberPrefix = config.memberPrefix || "", memberSuffix = config.memberSuffix || "", bigIntEnabled = void 0 === config.bigIntEnabled ? !!globalThis["BigInt64Array"] : !!config.bigIntEnabled, BigInt3 = globalThis["BigInt"], BigInt64Array2 = globalThis["BigInt64Array"], ptrSizeof = config.ptrSizeof || 4, ptrIR = config.ptrIR || "i32";
        if (!SBF.debugFlags) {
          SBF.__makeDebugFlags = function(deriveFrom = null) {
            if (deriveFrom && deriveFrom.__flags)
              deriveFrom = deriveFrom.__flags;
            const f2 = function f3(flags) {
              if (0 === arguments.length) {
                return f3.__flags;
              }
              if (flags < 0) {
                delete f3.__flags.getter;
                delete f3.__flags.setter;
                delete f3.__flags.alloc;
                delete f3.__flags.dealloc;
              } else {
                f3.__flags.getter = 0 !== (1 & flags);
                f3.__flags.setter = 0 !== (2 & flags);
                f3.__flags.alloc = 0 !== (4 & flags);
                f3.__flags.dealloc = 0 !== (8 & flags);
              }
              return f3._flags;
            };
            Object.defineProperty(f2, "__flags", {
              iterable: false,
              writable: false,
              value: Object.create(deriveFrom)
            });
            if (!deriveFrom)
              f2(0);
            return f2;
          };
          SBF.debugFlags = SBF.__makeDebugFlags();
        }
        const isLittleEndian = function() {
          const buffer = new ArrayBuffer(2);
          new DataView(buffer).setInt16(0, 256, true);
          return new Int16Array(buffer)[0] === 256;
        }();
        const isFuncSig = (s2) => "(" === s2[1];
        const isPtrSig = (s2) => "p" === s2 || "P" === s2;
        const isAutoPtrSig = (s2) => "P" === s2;
        const sigLetter = (s2) => isFuncSig(s2) ? "p" : s2[0];
        const sigIR = function(s2) {
          switch (sigLetter(s2)) {
            case "c":
            case "C":
              return "i8";
            case "i":
              return "i32";
            case "p":
            case "P":
            case "s":
              return ptrIR;
            case "j":
              return "i64";
            case "f":
              return "float";
            case "d":
              return "double";
          }
          toss("Unhandled signature IR:", s2);
        };
        const affirmBigIntArray = BigInt64Array2 ? () => true : () => toss("BigInt64Array is not available.");
        const sigDVGetter = function(s2) {
          switch (sigLetter(s2)) {
            case "p":
            case "P":
            case "s": {
              switch (ptrSizeof) {
                case 4:
                  return "getInt32";
                case 8:
                  return affirmBigIntArray() && "getBigInt64";
              }
              break;
            }
            case "i":
              return "getInt32";
            case "c":
              return "getInt8";
            case "C":
              return "getUint8";
            case "j":
              return affirmBigIntArray() && "getBigInt64";
            case "f":
              return "getFloat32";
            case "d":
              return "getFloat64";
          }
          toss("Unhandled DataView getter for signature:", s2);
        };
        const sigDVSetter = function(s2) {
          switch (sigLetter(s2)) {
            case "p":
            case "P":
            case "s": {
              switch (ptrSizeof) {
                case 4:
                  return "setInt32";
                case 8:
                  return affirmBigIntArray() && "setBigInt64";
              }
              break;
            }
            case "i":
              return "setInt32";
            case "c":
              return "setInt8";
            case "C":
              return "setUint8";
            case "j":
              return affirmBigIntArray() && "setBigInt64";
            case "f":
              return "setFloat32";
            case "d":
              return "setFloat64";
          }
          toss("Unhandled DataView setter for signature:", s2);
        };
        const sigDVSetWrapper = function(s2) {
          switch (sigLetter(s2)) {
            case "i":
            case "f":
            case "c":
            case "C":
            case "d":
              return Number;
            case "j":
              return affirmBigIntArray() && BigInt3;
            case "p":
            case "P":
            case "s":
              switch (ptrSizeof) {
                case 4:
                  return Number;
                case 8:
                  return affirmBigIntArray() && BigInt3;
              }
              break;
          }
          toss("Unhandled DataView set wrapper for signature:", s2);
        };
        const sPropName = (s2, k2) => s2 + "::" + k2;
        const __propThrowOnSet = function(structName, propName) {
          return () => toss(sPropName(structName, propName), "is read-only.");
        };
        const __instancePointerMap = /* @__PURE__ */ new WeakMap();
        const xPtrPropName = "(pointer-is-external)";
        const __freeStruct = function(ctor, obj, m2) {
          if (!m2)
            m2 = __instancePointerMap.get(obj);
          if (m2) {
            __instancePointerMap.delete(obj);
            if (Array.isArray(obj.ondispose)) {
              let x2;
              while (x2 = obj.ondispose.shift()) {
                try {
                  if (x2 instanceof Function)
                    x2.call(obj);
                  else if (x2 instanceof StructType)
                    x2.dispose();
                  else if ("number" === typeof x2)
                    dealloc(x2);
                } catch (e2) {
                  console.warn(
                    "ondispose() for",
                    ctor.structName,
                    "@",
                    m2,
                    "threw. NOT propagating it.",
                    e2
                  );
                }
              }
            } else if (obj.ondispose instanceof Function) {
              try {
                obj.ondispose();
              } catch (e2) {
                console.warn(
                  "ondispose() for",
                  ctor.structName,
                  "@",
                  m2,
                  "threw. NOT propagating it.",
                  e2
                );
              }
            }
            delete obj.ondispose;
            if (ctor.debugFlags.__flags.dealloc) {
              log2(
                "debug.dealloc:",
                obj[xPtrPropName] ? "EXTERNAL" : "",
                ctor.structName,
                "instance:",
                ctor.structInfo.sizeof,
                "bytes @" + m2
              );
            }
            if (!obj[xPtrPropName])
              dealloc(m2);
          }
        };
        const rop = (v3) => {
          return {
            configurable: false,
            writable: false,
            iterable: false,
            value: v3
          };
        };
        const __allocStruct = function(ctor, obj, m2) {
          let fill = !m2;
          if (m2)
            Object.defineProperty(obj, xPtrPropName, rop(m2));
          else {
            m2 = alloc(ctor.structInfo.sizeof);
            if (!m2)
              toss("Allocation of", ctor.structName, "structure failed.");
          }
          try {
            if (ctor.debugFlags.__flags.alloc) {
              log2(
                "debug.alloc:",
                fill ? "" : "EXTERNAL",
                ctor.structName,
                "instance:",
                ctor.structInfo.sizeof,
                "bytes @" + m2
              );
            }
            if (fill)
              heap().fill(0, m2, m2 + ctor.structInfo.sizeof);
            __instancePointerMap.set(obj, m2);
          } catch (e2) {
            __freeStruct(ctor, obj, m2);
            throw e2;
          }
        };
        const __memoryDump = function() {
          const p3 = this.pointer;
          return p3 ? new Uint8Array(heap().slice(p3, p3 + this.structInfo.sizeof)) : null;
        };
        const __memberKey = (k2) => memberPrefix + k2 + memberSuffix;
        const __memberKeyProp = rop(__memberKey);
        const __lookupMember = function(structInfo, memberName, tossIfNotFound = true) {
          let m2 = structInfo.members[memberName];
          if (!m2 && (memberPrefix || memberSuffix)) {
            for (const v3 of Object.values(structInfo.members)) {
              if (v3.key === memberName) {
                m2 = v3;
                break;
              }
            }
            if (!m2 && tossIfNotFound) {
              toss(
                sPropName(structInfo.name, memberName),
                "is not a mapped struct member."
              );
            }
          }
          return m2;
        };
        const __memberSignature = function f2(obj, memberName, emscriptenFormat = false) {
          if (!f2._)
            f2._ = (x2) => x2.replace(/[^vipPsjrdcC]/g, "").replace(/[pPscC]/g, "i");
          const m2 = __lookupMember(obj.structInfo, memberName, true);
          return emscriptenFormat ? f2._(m2.signature) : m2.signature;
        };
        const __ptrPropDescriptor = {
          configurable: false,
          enumerable: false,
          get: function() {
            return __instancePointerMap.get(this);
          },
          set: () => toss("Cannot assign the 'pointer' property of a struct.")
        };
        const __structMemberKeys = rop(function() {
          const a3 = [];
          for (const k2 of Object.keys(this.structInfo.members)) {
            a3.push(this.memberKey(k2));
          }
          return a3;
        });
        const __utf8Decoder = new TextDecoder("utf-8");
        const __utf8Encoder = new TextEncoder();
        const __SAB = "undefined" === typeof SharedArrayBuffer ? function() {
        } : SharedArrayBuffer;
        const __utf8Decode = function(arrayBuffer, begin, end) {
          return __utf8Decoder.decode(
            arrayBuffer.buffer instanceof __SAB ? arrayBuffer.slice(begin, end) : arrayBuffer.subarray(begin, end)
          );
        };
        const __memberIsString = function(obj, memberName, tossIfNotFound = false) {
          const m2 = __lookupMember(obj.structInfo, memberName, tossIfNotFound);
          return m2 && 1 === m2.signature.length && "s" === m2.signature[0] ? m2 : false;
        };
        const __affirmCStringSignature = function(member) {
          if ("s" === member.signature)
            return;
          toss(
            "Invalid member type signature for C-string value:",
            JSON.stringify(member)
          );
        };
        const __memberToJsString = function f2(obj, memberName) {
          const m2 = __lookupMember(obj.structInfo, memberName, true);
          __affirmCStringSignature(m2);
          const addr = obj[m2.key];
          if (!addr)
            return null;
          let pos = addr;
          const mem = heap();
          for (; mem[pos] !== 0; ++pos) {
          }
          return addr === pos ? "" : __utf8Decode(mem, addr, pos);
        };
        const __addOnDispose = function(obj, ...v3) {
          if (obj.ondispose) {
            if (!Array.isArray(obj.ondispose)) {
              obj.ondispose = [obj.ondispose];
            }
          } else {
            obj.ondispose = [];
          }
          obj.ondispose.push(...v3);
        };
        const __allocCString = function(str) {
          const u3 = __utf8Encoder.encode(str);
          const mem = alloc(u3.length + 1);
          if (!mem)
            toss("Allocation error while duplicating string:", str);
          const h2 = heap();
          h2.set(u3, mem);
          h2[mem + u3.length] = 0;
          return mem;
        };
        const __setMemberCString = function(obj, memberName, str) {
          const m2 = __lookupMember(obj.structInfo, memberName, true);
          __affirmCStringSignature(m2);
          const mem = __allocCString(str);
          obj[m2.key] = mem;
          __addOnDispose(obj, mem);
          return obj;
        };
        const StructType = function ctor(structName, structInfo) {
          if (arguments[2] !== rop) {
            toss(
              "Do not call the StructType constructor",
              "from client-level code."
            );
          }
          Object.defineProperties(this, {
            structName: rop(structName),
            structInfo: rop(structInfo)
          });
        };
        StructType.prototype = Object.create(null, {
          dispose: rop(function() {
            __freeStruct(this.constructor, this);
          }),
          lookupMember: rop(function(memberName, tossIfNotFound = true) {
            return __lookupMember(this.structInfo, memberName, tossIfNotFound);
          }),
          memberToJsString: rop(function(memberName) {
            return __memberToJsString(this, memberName);
          }),
          memberIsString: rop(function(memberName, tossIfNotFound = true) {
            return __memberIsString(this, memberName, tossIfNotFound);
          }),
          memberKey: __memberKeyProp,
          memberKeys: __structMemberKeys,
          memberSignature: rop(function(memberName, emscriptenFormat = false) {
            return __memberSignature(this, memberName, emscriptenFormat);
          }),
          memoryDump: rop(__memoryDump),
          pointer: __ptrPropDescriptor,
          setMemberCString: rop(function(memberName, str) {
            return __setMemberCString(this, memberName, str);
          })
        });
        Object.assign(StructType.prototype, {
          addOnDispose: function(...v3) {
            __addOnDispose(this, ...v3);
            return this;
          }
        });
        Object.defineProperties(StructType, {
          allocCString: rop(__allocCString),
          isA: rop((v3) => v3 instanceof StructType),
          hasExternalPointer: rop(
            (v3) => v3 instanceof StructType && !!v3[xPtrPropName]
          ),
          memberKey: __memberKeyProp
        });
        const isNumericValue = (v3) => Number.isFinite(v3) || v3 instanceof (BigInt3 || Number);
        const makeMemberWrapper = function f2(ctor, name, descr) {
          if (!f2._) {
            f2._ = { getters: {}, setters: {}, sw: {} };
            const a3 = ["i", "c", "C", "p", "P", "s", "f", "d", "v()"];
            if (bigIntEnabled)
              a3.push("j");
            a3.forEach(function(v3) {
              f2._.getters[v3] = sigDVGetter(v3);
              f2._.setters[v3] = sigDVSetter(v3);
              f2._.sw[v3] = sigDVSetWrapper(v3);
            });
            const rxSig1 = /^[ipPsjfdcC]$/, rxSig2 = /^[vipPsjfdcC]\([ipPsjfdcC]*\)$/;
            f2.sigCheck = function(obj, name2, key2, sig) {
              if (Object.prototype.hasOwnProperty.call(obj, key2)) {
                toss(obj.structName, "already has a property named", key2 + ".");
              }
              rxSig1.test(sig) || rxSig2.test(sig) || toss(
                "Malformed signature for",
                sPropName(obj.structName, name2) + ":",
                sig
              );
            };
          }
          const key = ctor.memberKey(name);
          f2.sigCheck(ctor.prototype, name, key, descr.signature);
          descr.key = key;
          descr.name = name;
          const sigGlyph = sigLetter(descr.signature);
          const xPropName = sPropName(ctor.prototype.structName, key);
          const dbg = ctor.prototype.debugFlags.__flags;
          const prop = /* @__PURE__ */ Object.create(null);
          prop.configurable = false;
          prop.enumerable = false;
          prop.get = function() {
            if (dbg.getter) {
              log2(
                "debug.getter:",
                f2._.getters[sigGlyph],
                "for",
                sigIR(sigGlyph),
                xPropName,
                "@",
                this.pointer,
                "+",
                descr.offset,
                "sz",
                descr.sizeof
              );
            }
            let rc = new DataView(
              heap().buffer,
              this.pointer + descr.offset,
              descr.sizeof
            )[f2._.getters[sigGlyph]](0, isLittleEndian);
            if (dbg.getter)
              log2("debug.getter:", xPropName, "result =", rc);
            return rc;
          };
          if (descr.readOnly) {
            prop.set = __propThrowOnSet(ctor.prototype.structName, key);
          } else {
            prop.set = function(v3) {
              if (dbg.setter) {
                log2(
                  "debug.setter:",
                  f2._.setters[sigGlyph],
                  "for",
                  sigIR(sigGlyph),
                  xPropName,
                  "@",
                  this.pointer,
                  "+",
                  descr.offset,
                  "sz",
                  descr.sizeof,
                  v3
                );
              }
              if (!this.pointer) {
                toss("Cannot set struct property on disposed instance.");
              }
              if (null === v3)
                v3 = 0;
              else
                while (!isNumericValue(v3)) {
                  if (isAutoPtrSig(descr.signature) && v3 instanceof StructType) {
                    v3 = v3.pointer || 0;
                    if (dbg.setter)
                      log2("debug.setter:", xPropName, "resolved to", v3);
                    break;
                  }
                  toss("Invalid value for pointer-type", xPropName + ".");
                }
              new DataView(
                heap().buffer,
                this.pointer + descr.offset,
                descr.sizeof
              )[f2._.setters[sigGlyph]](0, f2._.sw[sigGlyph](v3), isLittleEndian);
            };
          }
          Object.defineProperty(ctor.prototype, key, prop);
        };
        const StructBinder = function StructBinder2(structName, structInfo) {
          if (1 === arguments.length) {
            structInfo = structName;
            structName = structInfo.name;
          } else if (!structInfo.name) {
            structInfo.name = structName;
          }
          if (!structName)
            toss("Struct name is required.");
          let lastMember = false;
          Object.keys(structInfo.members).forEach((k2) => {
            const m2 = structInfo.members[k2];
            if (!m2.sizeof)
              toss(structName, "member", k2, "is missing sizeof.");
            else if (m2.sizeof === 1) {
              m2.signature === "c" || m2.signature === "C" || toss(
                "Unexpected sizeof==1 member",
                sPropName(structInfo.name, k2),
                "with signature",
                m2.signature
              );
            } else {
              if (0 !== m2.sizeof % 4) {
                console.warn(
                  "Invalid struct member description =",
                  m2,
                  "from",
                  structInfo
                );
                toss(
                  structName,
                  "member",
                  k2,
                  "sizeof is not aligned. sizeof=" + m2.sizeof
                );
              }
              if (0 !== m2.offset % 4) {
                console.warn(
                  "Invalid struct member description =",
                  m2,
                  "from",
                  structInfo
                );
                toss(
                  structName,
                  "member",
                  k2,
                  "offset is not aligned. offset=" + m2.offset
                );
              }
            }
            if (!lastMember || lastMember.offset < m2.offset)
              lastMember = m2;
          });
          if (!lastMember)
            toss("No member property descriptions found.");
          else if (structInfo.sizeof < lastMember.offset + lastMember.sizeof) {
            toss(
              "Invalid struct config:",
              structName,
              "max member offset (" + lastMember.offset + ") ",
              "extends past end of struct (sizeof=" + structInfo.sizeof + ")."
            );
          }
          const debugFlags = rop(SBF.__makeDebugFlags(StructBinder2.debugFlags));
          const StructCtor = function StructCtor2(externalMemory) {
            if (!(this instanceof StructCtor2)) {
              toss(
                "The",
                structName,
                "constructor may only be called via 'new'."
              );
            } else if (arguments.length) {
              if (externalMemory !== (externalMemory | 0) || externalMemory <= 0) {
                toss("Invalid pointer value for", structName, "constructor.");
              }
              __allocStruct(StructCtor2, this, externalMemory);
            } else {
              __allocStruct(StructCtor2, this);
            }
          };
          Object.defineProperties(StructCtor, {
            debugFlags,
            isA: rop((v3) => v3 instanceof StructCtor),
            memberKey: __memberKeyProp,
            memberKeys: __structMemberKeys,
            methodInfoForKey: rop(function(mKey) {
            }),
            structInfo: rop(structInfo),
            structName: rop(structName)
          });
          StructCtor.prototype = new StructType(structName, structInfo, rop);
          Object.defineProperties(StructCtor.prototype, {
            debugFlags,
            constructor: rop(StructCtor)
          });
          Object.keys(structInfo.members).forEach(
            (name) => makeMemberWrapper(StructCtor, name, structInfo.members[name])
          );
          return StructCtor;
        };
        StructBinder.StructType = StructType;
        StructBinder.config = config;
        StructBinder.allocCString = __allocCString;
        if (!StructBinder.debugFlags) {
          StructBinder.debugFlags = SBF.__makeDebugFlags(SBF.debugFlags);
        }
        return StructBinder;
      };
      globalThis.sqlite3ApiBootstrap.initializers.push(function(sqlite32) {
        "use strict";
        const toss = (...args) => {
          throw new Error(args.join(" "));
        };
        const toss3 = sqlite32.SQLite3Error.toss;
        const capi = sqlite32.capi, wasm = sqlite32.wasm, util = sqlite32.util;
        globalThis.WhWasmUtilInstaller(wasm);
        delete globalThis.WhWasmUtilInstaller;
        if (0) {
          const dealloc = wasm.exports[sqlite32.config.deallocExportName];
          const nFunc = wasm.functionTable().length;
          let i2;
          for (i2 = 0; i2 < nFunc; ++i2) {
            const e2 = wasm.functionEntry(i2);
            if (dealloc === e2) {
              capi.SQLITE_WASM_DEALLOC = i2;
              break;
            }
          }
          if (dealloc !== wasm.functionEntry(capi.SQLITE_WASM_DEALLOC)) {
            toss(
              "Internal error: cannot find function pointer for SQLITE_WASM_DEALLOC."
            );
          }
        }
        wasm.bindingSignatures = [
          ["sqlite3_aggregate_context", "void*", "sqlite3_context*", "int"],
          ["sqlite3_bind_double", "int", "sqlite3_stmt*", "int", "f64"],
          ["sqlite3_bind_int", "int", "sqlite3_stmt*", "int", "int"],
          ["sqlite3_bind_null", void 0, "sqlite3_stmt*", "int"],
          ["sqlite3_bind_parameter_count", "int", "sqlite3_stmt*"],
          ["sqlite3_bind_parameter_index", "int", "sqlite3_stmt*", "string"],
          ["sqlite3_bind_parameter_name", "string", "sqlite3_stmt*", "int"],
          [
            "sqlite3_bind_pointer",
            "int",
            "sqlite3_stmt*",
            "int",
            "*",
            "string:static",
            "*"
          ],
          [
            "sqlite3_busy_handler",
            "int",
            [
              "sqlite3*",
              new wasm.xWrap.FuncPtrAdapter({
                signature: "i(pi)",
                contextKey: (argv2, argIndex) => argv2[0]
              }),
              "*"
            ]
          ],
          ["sqlite3_busy_timeout", "int", "sqlite3*", "int"],
          ["sqlite3_changes", "int", "sqlite3*"],
          ["sqlite3_clear_bindings", "int", "sqlite3_stmt*"],
          ["sqlite3_collation_needed", "int", "sqlite3*", "*", "*"],
          ["sqlite3_column_blob", "*", "sqlite3_stmt*", "int"],
          ["sqlite3_column_bytes", "int", "sqlite3_stmt*", "int"],
          ["sqlite3_column_count", "int", "sqlite3_stmt*"],
          ["sqlite3_column_decltype", "string", "sqlite3_stmt*", "int"],
          ["sqlite3_column_double", "f64", "sqlite3_stmt*", "int"],
          ["sqlite3_column_int", "int", "sqlite3_stmt*", "int"],
          ["sqlite3_column_name", "string", "sqlite3_stmt*", "int"],
          ["sqlite3_column_text", "string", "sqlite3_stmt*", "int"],
          ["sqlite3_column_type", "int", "sqlite3_stmt*", "int"],
          ["sqlite3_column_value", "sqlite3_value*", "sqlite3_stmt*", "int"],
          [
            "sqlite3_commit_hook",
            "void*",
            [
              "sqlite3*",
              new wasm.xWrap.FuncPtrAdapter({
                name: "sqlite3_commit_hook",
                signature: "i(p)",
                contextKey: (argv2) => argv2[0]
              }),
              "*"
            ]
          ],
          ["sqlite3_compileoption_get", "string", "int"],
          ["sqlite3_compileoption_used", "int", "string"],
          ["sqlite3_complete", "int", "string:flexible"],
          ["sqlite3_context_db_handle", "sqlite3*", "sqlite3_context*"],
          ["sqlite3_data_count", "int", "sqlite3_stmt*"],
          ["sqlite3_db_filename", "string", "sqlite3*", "string"],
          ["sqlite3_db_handle", "sqlite3*", "sqlite3_stmt*"],
          ["sqlite3_db_name", "string", "sqlite3*", "int"],
          ["sqlite3_db_readonly", "int", "sqlite3*", "string"],
          ["sqlite3_db_status", "int", "sqlite3*", "int", "*", "*", "int"],
          ["sqlite3_errcode", "int", "sqlite3*"],
          ["sqlite3_errmsg", "string", "sqlite3*"],
          ["sqlite3_error_offset", "int", "sqlite3*"],
          ["sqlite3_errstr", "string", "int"],
          [
            "sqlite3_exec",
            "int",
            [
              "sqlite3*",
              "string:flexible",
              new wasm.xWrap.FuncPtrAdapter({
                signature: "i(pipp)",
                bindScope: "transient",
                callProxy: (callback) => {
                  let aNames;
                  return (pVoid, nCols, pColVals, pColNames) => {
                    try {
                      const aVals = wasm.cArgvToJs(nCols, pColVals);
                      if (!aNames)
                        aNames = wasm.cArgvToJs(nCols, pColNames);
                      return callback(aVals, aNames) | 0;
                    } catch (e2) {
                      return e2.resultCode || capi.SQLITE_ERROR;
                    }
                  };
                }
              }),
              "*",
              "**"
            ]
          ],
          ["sqlite3_expanded_sql", "string", "sqlite3_stmt*"],
          ["sqlite3_extended_errcode", "int", "sqlite3*"],
          ["sqlite3_extended_result_codes", "int", "sqlite3*", "int"],
          ["sqlite3_file_control", "int", "sqlite3*", "string", "int", "*"],
          ["sqlite3_finalize", "int", "sqlite3_stmt*"],
          ["sqlite3_free", void 0, "*"],
          ["sqlite3_get_autocommit", "int", "sqlite3*"],
          ["sqlite3_get_auxdata", "*", "sqlite3_context*", "int"],
          ["sqlite3_initialize", void 0],
          ["sqlite3_interrupt", void 0, "sqlite3*"],
          ["sqlite3_is_interrupted", "int", "sqlite3*"],
          ["sqlite3_keyword_count", "int"],
          ["sqlite3_keyword_name", "int", ["int", "**", "*"]],
          ["sqlite3_keyword_check", "int", ["string", "int"]],
          ["sqlite3_libversion", "string"],
          ["sqlite3_libversion_number", "int"],
          ["sqlite3_limit", "int", ["sqlite3*", "int", "int"]],
          ["sqlite3_malloc", "*", "int"],
          ["sqlite3_open", "int", "string", "*"],
          ["sqlite3_open_v2", "int", "string", "*", "int", "string"],
          ["sqlite3_realloc", "*", "*", "int"],
          ["sqlite3_reset", "int", "sqlite3_stmt*"],
          [
            "sqlite3_result_blob",
            void 0,
            "sqlite3_context*",
            "*",
            "int",
            "*"
          ],
          ["sqlite3_result_double", void 0, "sqlite3_context*", "f64"],
          [
            "sqlite3_result_error",
            void 0,
            "sqlite3_context*",
            "string",
            "int"
          ],
          ["sqlite3_result_error_code", void 0, "sqlite3_context*", "int"],
          ["sqlite3_result_error_nomem", void 0, "sqlite3_context*"],
          ["sqlite3_result_error_toobig", void 0, "sqlite3_context*"],
          ["sqlite3_result_int", void 0, "sqlite3_context*", "int"],
          ["sqlite3_result_null", void 0, "sqlite3_context*"],
          [
            "sqlite3_result_pointer",
            void 0,
            "sqlite3_context*",
            "*",
            "string:static",
            "*"
          ],
          ["sqlite3_result_subtype", void 0, "sqlite3_value*", "int"],
          [
            "sqlite3_result_text",
            void 0,
            "sqlite3_context*",
            "string",
            "int",
            "*"
          ],
          ["sqlite3_result_zeroblob", void 0, "sqlite3_context*", "int"],
          [
            "sqlite3_rollback_hook",
            "void*",
            [
              "sqlite3*",
              new wasm.xWrap.FuncPtrAdapter({
                name: "sqlite3_rollback_hook",
                signature: "v(p)",
                contextKey: (argv2) => argv2[0]
              }),
              "*"
            ]
          ],
          [
            "sqlite3_set_auxdata",
            void 0,
            [
              "sqlite3_context*",
              "int",
              "*",
              new wasm.xWrap.FuncPtrAdapter({
                name: "xDestroyAuxData",
                signature: "v(*)",
                contextKey: (argv2, argIndex) => argv2[0]
              })
            ]
          ],
          ["sqlite3_shutdown", void 0],
          ["sqlite3_sourceid", "string"],
          ["sqlite3_sql", "string", "sqlite3_stmt*"],
          ["sqlite3_status", "int", "int", "*", "*", "int"],
          ["sqlite3_step", "int", "sqlite3_stmt*"],
          ["sqlite3_stmt_busy", "int", "sqlite3_stmt*"],
          ["sqlite3_stmt_readonly", "int", "sqlite3_stmt*"],
          ["sqlite3_stmt_status", "int", "sqlite3_stmt*", "int", "int"],
          ["sqlite3_strglob", "int", "string", "string"],
          ["sqlite3_stricmp", "int", "string", "string"],
          ["sqlite3_strlike", "int", "string", "string", "int"],
          ["sqlite3_strnicmp", "int", "string", "string", "int"],
          [
            "sqlite3_table_column_metadata",
            "int",
            "sqlite3*",
            "string",
            "string",
            "string",
            "**",
            "**",
            "*",
            "*",
            "*"
          ],
          ["sqlite3_total_changes", "int", "sqlite3*"],
          [
            "sqlite3_trace_v2",
            "int",
            [
              "sqlite3*",
              "int",
              new wasm.xWrap.FuncPtrAdapter({
                name: "sqlite3_trace_v2::callback",
                signature: "i(ippp)",
                contextKey: (argv2, argIndex) => argv2[0]
              }),
              "*"
            ]
          ],
          ["sqlite3_txn_state", "int", ["sqlite3*", "string"]],
          ["sqlite3_uri_boolean", "int", "sqlite3_filename", "string", "int"],
          ["sqlite3_uri_key", "string", "sqlite3_filename", "int"],
          ["sqlite3_uri_parameter", "string", "sqlite3_filename", "string"],
          ["sqlite3_user_data", "void*", "sqlite3_context*"],
          ["sqlite3_value_blob", "*", "sqlite3_value*"],
          ["sqlite3_value_bytes", "int", "sqlite3_value*"],
          ["sqlite3_value_double", "f64", "sqlite3_value*"],
          ["sqlite3_value_dup", "sqlite3_value*", "sqlite3_value*"],
          ["sqlite3_value_free", void 0, "sqlite3_value*"],
          ["sqlite3_value_frombind", "int", "sqlite3_value*"],
          ["sqlite3_value_int", "int", "sqlite3_value*"],
          ["sqlite3_value_nochange", "int", "sqlite3_value*"],
          ["sqlite3_value_numeric_type", "int", "sqlite3_value*"],
          ["sqlite3_value_pointer", "*", "sqlite3_value*", "string:static"],
          ["sqlite3_value_subtype", "int", "sqlite3_value*"],
          ["sqlite3_value_text", "string", "sqlite3_value*"],
          ["sqlite3_value_type", "int", "sqlite3_value*"],
          ["sqlite3_vfs_find", "*", "string"],
          ["sqlite3_vfs_register", "int", "sqlite3_vfs*", "int"],
          ["sqlite3_vfs_unregister", "int", "sqlite3_vfs*"]
        ];
        if (!!wasm.exports.sqlite3_progress_handler) {
          wasm.bindingSignatures.push([
            "sqlite3_progress_handler",
            void 0,
            [
              "sqlite3*",
              "int",
              new wasm.xWrap.FuncPtrAdapter({
                name: "xProgressHandler",
                signature: "i(p)",
                bindScope: "context",
                contextKey: (argv2, argIndex) => argv2[0]
              }),
              "*"
            ]
          ]);
        }
        if (!!wasm.exports.sqlite3_stmt_explain) {
          wasm.bindingSignatures.push(
            ["sqlite3_stmt_explain", "int", "sqlite3_stmt*", "int"],
            ["sqlite3_stmt_isexplain", "int", "sqlite3_stmt*"]
          );
        }
        if (!!wasm.exports.sqlite3_set_authorizer) {
          wasm.bindingSignatures.push([
            "sqlite3_set_authorizer",
            "int",
            [
              "sqlite3*",
              new wasm.xWrap.FuncPtrAdapter({
                name: "sqlite3_set_authorizer::xAuth",
                signature: "i(pissss)",
                contextKey: (argv2, argIndex) => argv2[0],
                callProxy: (callback) => {
                  return (pV, iCode, s0, s1, s2, s3) => {
                    try {
                      s0 = s0 && wasm.cstrToJs(s0);
                      s1 = s1 && wasm.cstrToJs(s1);
                      s2 = s2 && wasm.cstrToJs(s2);
                      s3 = s3 && wasm.cstrToJs(s3);
                      return callback(pV, iCode, s0, s1, s2, s3) || 0;
                    } catch (e2) {
                      return e2.resultCode || capi.SQLITE_ERROR;
                    }
                  };
                }
              }),
              "*"
            ]
          ]);
        }
        if (false) {
          wasm.bindingSignatures.push([
            "sqlite3_normalized_sql",
            "string",
            "sqlite3_stmt*"
          ]);
        }
        wasm.bindingSignatures.int64 = [
          ["sqlite3_bind_int64", "int", ["sqlite3_stmt*", "int", "i64"]],
          ["sqlite3_changes64", "i64", ["sqlite3*"]],
          ["sqlite3_column_int64", "i64", ["sqlite3_stmt*", "int"]],
          [
            "sqlite3_deserialize",
            "int",
            "sqlite3*",
            "string",
            "*",
            "i64",
            "i64",
            "int"
          ],
          ["sqlite3_last_insert_rowid", "i64", ["sqlite3*"]],
          ["sqlite3_malloc64", "*", "i64"],
          ["sqlite3_msize", "i64", "*"],
          ["sqlite3_overload_function", "int", ["sqlite3*", "string", "int"]],
          ["sqlite3_realloc64", "*", "*", "i64"],
          ["sqlite3_result_int64", void 0, "*", "i64"],
          ["sqlite3_result_zeroblob64", "int", "*", "i64"],
          ["sqlite3_serialize", "*", "sqlite3*", "string", "*", "int"],
          ["sqlite3_set_last_insert_rowid", void 0, ["sqlite3*", "i64"]],
          ["sqlite3_status64", "int", "int", "*", "*", "int"],
          ["sqlite3_total_changes64", "i64", ["sqlite3*"]],
          [
            "sqlite3_update_hook",
            "*",
            [
              "sqlite3*",
              new wasm.xWrap.FuncPtrAdapter({
                name: "sqlite3_update_hook",
                signature: "v(iippj)",
                contextKey: (argv2) => argv2[0],
                callProxy: (callback) => {
                  return (p3, op, z0, z1, rowid) => {
                    callback(
                      p3,
                      op,
                      wasm.cstrToJs(z0),
                      wasm.cstrToJs(z1),
                      rowid
                    );
                  };
                }
              }),
              "*"
            ]
          ],
          ["sqlite3_uri_int64", "i64", ["sqlite3_filename", "string", "i64"]],
          ["sqlite3_value_int64", "i64", "sqlite3_value*"]
        ];
        if (wasm.bigIntEnabled && !!wasm.exports.sqlite3_declare_vtab) {
          wasm.bindingSignatures.int64.push(
            [
              "sqlite3_create_module",
              "int",
              ["sqlite3*", "string", "sqlite3_module*", "*"]
            ],
            [
              "sqlite3_create_module_v2",
              "int",
              ["sqlite3*", "string", "sqlite3_module*", "*", "*"]
            ],
            ["sqlite3_declare_vtab", "int", ["sqlite3*", "string:flexible"]],
            ["sqlite3_drop_modules", "int", ["sqlite3*", "**"]],
            ["sqlite3_vtab_collation", "string", "sqlite3_index_info*", "int"],
            ["sqlite3_vtab_distinct", "int", "sqlite3_index_info*"],
            ["sqlite3_vtab_in", "int", "sqlite3_index_info*", "int", "int"],
            ["sqlite3_vtab_in_first", "int", "sqlite3_value*", "**"],
            ["sqlite3_vtab_in_next", "int", "sqlite3_value*", "**"],
            ["sqlite3_vtab_nochange", "int", "sqlite3_context*"],
            ["sqlite3_vtab_on_conflict", "int", "sqlite3*"],
            [
              "sqlite3_vtab_rhs_value",
              "int",
              "sqlite3_index_info*",
              "int",
              "**"
            ]
          );
        }
        if (wasm.bigIntEnabled && !!wasm.exports.sqlite3_preupdate_hook) {
          wasm.bindingSignatures.int64.push(
            ["sqlite3_preupdate_blobwrite", "int", "sqlite3*"],
            ["sqlite3_preupdate_count", "int", "sqlite3*"],
            ["sqlite3_preupdate_depth", "int", "sqlite3*"],
            [
              "sqlite3_preupdate_hook",
              "*",
              [
                "sqlite3*",
                new wasm.xWrap.FuncPtrAdapter({
                  name: "sqlite3_preupdate_hook",
                  signature: "v(ppippjj)",
                  contextKey: (argv2) => argv2[0],
                  callProxy: (callback) => {
                    return (p3, db, op, zDb, zTbl, iKey1, iKey2) => {
                      callback(
                        p3,
                        db,
                        op,
                        wasm.cstrToJs(zDb),
                        wasm.cstrToJs(zTbl),
                        iKey1,
                        iKey2
                      );
                    };
                  }
                }),
                "*"
              ]
            ],
            ["sqlite3_preupdate_new", "int", ["sqlite3*", "int", "**"]],
            ["sqlite3_preupdate_old", "int", ["sqlite3*", "int", "**"]]
          );
        }
        if (wasm.bigIntEnabled && !!wasm.exports.sqlite3changegroup_add && !!wasm.exports.sqlite3session_create && !!wasm.exports.sqlite3_preupdate_hook) {
          const __ipsProxy = {
            signature: "i(ps)",
            callProxy: (callback) => {
              return (p3, s2) => {
                try {
                  return callback(p3, wasm.cstrToJs(s2)) | 0;
                } catch (e2) {
                  return e2.resultCode || capi.SQLITE_ERROR;
                }
              };
            }
          };
          wasm.bindingSignatures.int64.push(
            ...[
              [
                "sqlite3changegroup_add",
                "int",
                ["sqlite3_changegroup*", "int", "void*"]
              ],
              [
                "sqlite3changegroup_add_strm",
                "int",
                [
                  "sqlite3_changegroup*",
                  new wasm.xWrap.FuncPtrAdapter({
                    name: "xInput",
                    signature: "i(ppp)",
                    bindScope: "transient"
                  }),
                  "void*"
                ]
              ],
              [
                "sqlite3changegroup_delete",
                void 0,
                ["sqlite3_changegroup*"]
              ],
              ["sqlite3changegroup_new", "int", ["**"]],
              [
                "sqlite3changegroup_output",
                "int",
                ["sqlite3_changegroup*", "int*", "**"]
              ],
              [
                "sqlite3changegroup_output_strm",
                "int",
                [
                  "sqlite3_changegroup*",
                  new wasm.xWrap.FuncPtrAdapter({
                    name: "xOutput",
                    signature: "i(ppi)",
                    bindScope: "transient"
                  }),
                  "void*"
                ]
              ],
              [
                "sqlite3changeset_apply",
                "int",
                [
                  "sqlite3*",
                  "int",
                  "void*",
                  new wasm.xWrap.FuncPtrAdapter({
                    name: "xFilter",
                    bindScope: "transient",
                    ...__ipsProxy
                  }),
                  new wasm.xWrap.FuncPtrAdapter({
                    name: "xConflict",
                    signature: "i(pip)",
                    bindScope: "transient"
                  }),
                  "void*"
                ]
              ],
              [
                "sqlite3changeset_apply_strm",
                "int",
                [
                  "sqlite3*",
                  new wasm.xWrap.FuncPtrAdapter({
                    name: "xInput",
                    signature: "i(ppp)",
                    bindScope: "transient"
                  }),
                  "void*",
                  new wasm.xWrap.FuncPtrAdapter({
                    name: "xFilter",
                    bindScope: "transient",
                    ...__ipsProxy
                  }),
                  new wasm.xWrap.FuncPtrAdapter({
                    name: "xConflict",
                    signature: "i(pip)",
                    bindScope: "transient"
                  }),
                  "void*"
                ]
              ],
              [
                "sqlite3changeset_apply_v2",
                "int",
                [
                  "sqlite3*",
                  "int",
                  "void*",
                  new wasm.xWrap.FuncPtrAdapter({
                    name: "xFilter",
                    bindScope: "transient",
                    ...__ipsProxy
                  }),
                  new wasm.xWrap.FuncPtrAdapter({
                    name: "xConflict",
                    signature: "i(pip)",
                    bindScope: "transient"
                  }),
                  "void*",
                  "**",
                  "int*",
                  "int"
                ]
              ],
              [
                "sqlite3changeset_apply_v2_strm",
                "int",
                [
                  "sqlite3*",
                  new wasm.xWrap.FuncPtrAdapter({
                    name: "xInput",
                    signature: "i(ppp)",
                    bindScope: "transient"
                  }),
                  "void*",
                  new wasm.xWrap.FuncPtrAdapter({
                    name: "xFilter",
                    bindScope: "transient",
                    ...__ipsProxy
                  }),
                  new wasm.xWrap.FuncPtrAdapter({
                    name: "xConflict",
                    signature: "i(pip)",
                    bindScope: "transient"
                  }),
                  "void*",
                  "**",
                  "int*",
                  "int"
                ]
              ],
              [
                "sqlite3changeset_concat",
                "int",
                ["int", "void*", "int", "void*", "int*", "**"]
              ],
              [
                "sqlite3changeset_concat_strm",
                "int",
                [
                  new wasm.xWrap.FuncPtrAdapter({
                    name: "xInputA",
                    signature: "i(ppp)",
                    bindScope: "transient"
                  }),
                  "void*",
                  new wasm.xWrap.FuncPtrAdapter({
                    name: "xInputB",
                    signature: "i(ppp)",
                    bindScope: "transient"
                  }),
                  "void*",
                  new wasm.xWrap.FuncPtrAdapter({
                    name: "xOutput",
                    signature: "i(ppi)",
                    bindScope: "transient"
                  }),
                  "void*"
                ]
              ],
              [
                "sqlite3changeset_conflict",
                "int",
                ["sqlite3_changeset_iter*", "int", "**"]
              ],
              ["sqlite3changeset_finalize", "int", ["sqlite3_changeset_iter*"]],
              [
                "sqlite3changeset_fk_conflicts",
                "int",
                ["sqlite3_changeset_iter*", "int*"]
              ],
              [
                "sqlite3changeset_invert",
                "int",
                ["int", "void*", "int*", "**"]
              ],
              [
                "sqlite3changeset_invert_strm",
                "int",
                [
                  new wasm.xWrap.FuncPtrAdapter({
                    name: "xInput",
                    signature: "i(ppp)",
                    bindScope: "transient"
                  }),
                  "void*",
                  new wasm.xWrap.FuncPtrAdapter({
                    name: "xOutput",
                    signature: "i(ppi)",
                    bindScope: "transient"
                  }),
                  "void*"
                ]
              ],
              [
                "sqlite3changeset_new",
                "int",
                ["sqlite3_changeset_iter*", "int", "**"]
              ],
              ["sqlite3changeset_next", "int", ["sqlite3_changeset_iter*"]],
              [
                "sqlite3changeset_old",
                "int",
                ["sqlite3_changeset_iter*", "int", "**"]
              ],
              [
                "sqlite3changeset_op",
                "int",
                ["sqlite3_changeset_iter*", "**", "int*", "int*", "int*"]
              ],
              [
                "sqlite3changeset_pk",
                "int",
                ["sqlite3_changeset_iter*", "**", "int*"]
              ],
              ["sqlite3changeset_start", "int", ["**", "int", "*"]],
              [
                "sqlite3changeset_start_strm",
                "int",
                [
                  "**",
                  new wasm.xWrap.FuncPtrAdapter({
                    name: "xInput",
                    signature: "i(ppp)",
                    bindScope: "transient"
                  }),
                  "void*"
                ]
              ],
              ["sqlite3changeset_start_v2", "int", ["**", "int", "*", "int"]],
              [
                "sqlite3changeset_start_v2_strm",
                "int",
                [
                  "**",
                  new wasm.xWrap.FuncPtrAdapter({
                    name: "xInput",
                    signature: "i(ppp)",
                    bindScope: "transient"
                  }),
                  "void*",
                  "int"
                ]
              ],
              ["sqlite3session_attach", "int", ["sqlite3_session*", "string"]],
              [
                "sqlite3session_changeset",
                "int",
                ["sqlite3_session*", "int*", "**"]
              ],
              ["sqlite3session_changeset_size", "i64", ["sqlite3_session*"]],
              [
                "sqlite3session_changeset_strm",
                "int",
                [
                  "sqlite3_session*",
                  new wasm.xWrap.FuncPtrAdapter({
                    name: "xOutput",
                    signature: "i(ppp)",
                    bindScope: "transient"
                  }),
                  "void*"
                ]
              ],
              ["sqlite3session_config", "int", ["int", "void*"]],
              ["sqlite3session_create", "int", ["sqlite3*", "string", "**"]],
              [
                "sqlite3session_diff",
                "int",
                ["sqlite3_session*", "string", "string", "**"]
              ],
              ["sqlite3session_enable", "int", ["sqlite3_session*", "int"]],
              ["sqlite3session_indirect", "int", ["sqlite3_session*", "int"]],
              ["sqlite3session_isempty", "int", ["sqlite3_session*"]],
              ["sqlite3session_memory_used", "i64", ["sqlite3_session*"]],
              [
                "sqlite3session_object_config",
                "int",
                ["sqlite3_session*", "int", "void*"]
              ],
              [
                "sqlite3session_patchset",
                "int",
                ["sqlite3_session*", "*", "**"]
              ],
              [
                "sqlite3session_patchset_strm",
                "int",
                [
                  "sqlite3_session*",
                  new wasm.xWrap.FuncPtrAdapter({
                    name: "xOutput",
                    signature: "i(ppp)",
                    bindScope: "transient"
                  }),
                  "void*"
                ]
              ],
              [
                "sqlite3session_table_filter",
                void 0,
                [
                  "sqlite3_session*",
                  new wasm.xWrap.FuncPtrAdapter({
                    name: "xFilter",
                    ...__ipsProxy,
                    contextKey: (argv2, argIndex) => argv2[0]
                  }),
                  "*"
                ]
              ]
            ]
          );
        }
        wasm.bindingSignatures.wasmInternal = [
          ["sqlite3__wasm_db_reset", "int", "sqlite3*"],
          ["sqlite3__wasm_db_vfs", "sqlite3_vfs*", "sqlite3*", "string"],
          [
            "sqlite3__wasm_vfs_create_file",
            "int",
            "sqlite3_vfs*",
            "string",
            "*",
            "int"
          ],
          ["sqlite3__wasm_posix_create_file", "int", "string", "*", "int"],
          ["sqlite3__wasm_vfs_unlink", "int", "sqlite3_vfs*", "string"],
          ["sqlite3__wasm_qfmt_token", "string:dealloc", "string", "int"]
        ];
        sqlite32.StructBinder = globalThis.Jaccwabyt({
          heap: 0 ? wasm.memory : wasm.heap8u,
          alloc: wasm.alloc,
          dealloc: wasm.dealloc,
          bigIntEnabled: wasm.bigIntEnabled,
          memberPrefix: "$"
        });
        delete globalThis.Jaccwabyt;
        {
          const __xString = wasm.xWrap.argAdapter("string");
          wasm.xWrap.argAdapter(
            "string:flexible",
            (v3) => __xString(util.flexibleString(v3))
          );
          wasm.xWrap.argAdapter(
            "string:static",
            function(v3) {
              if (wasm.isPtr(v3))
                return v3;
              v3 = "" + v3;
              let rc = this[v3];
              return rc || (this[v3] = wasm.allocCString(v3));
            }.bind(/* @__PURE__ */ Object.create(null))
          );
          const __xArgPtr = wasm.xWrap.argAdapter("*");
          const nilType = function() {
          };
          wasm.xWrap.argAdapter("sqlite3_filename", __xArgPtr)(
            "sqlite3_context*",
            __xArgPtr
          )("sqlite3_value*", __xArgPtr)("void*", __xArgPtr)(
            "sqlite3_changegroup*",
            __xArgPtr
          )("sqlite3_changeset_iter*", __xArgPtr)(
            "sqlite3_session*",
            __xArgPtr
          )(
            "sqlite3_stmt*",
            (v3) => {
              var _a8;
              return __xArgPtr(
                v3 instanceof (((_a8 = sqlite32 == null ? void 0 : sqlite32.oo1) == null ? void 0 : _a8.Stmt) || nilType) ? v3.pointer : v3
              );
            }
          )(
            "sqlite3*",
            (v3) => {
              var _a8;
              return __xArgPtr(
                v3 instanceof (((_a8 = sqlite32 == null ? void 0 : sqlite32.oo1) == null ? void 0 : _a8.DB) || nilType) ? v3.pointer : v3
              );
            }
          )("sqlite3_vfs*", (v3) => {
            if ("string" === typeof v3) {
              return capi.sqlite3_vfs_find(v3) || sqlite32.SQLite3Error.toss(
                capi.SQLITE_NOTFOUND,
                "Unknown sqlite3_vfs name:",
                v3
              );
            }
            return __xArgPtr(
              v3 instanceof (capi.sqlite3_vfs || nilType) ? v3.pointer : v3
            );
          });
          if (wasm.exports.sqlite3_declare_vtab) {
            wasm.xWrap.argAdapter(
              "sqlite3_index_info*",
              (v3) => __xArgPtr(
                v3 instanceof (capi.sqlite3_index_info || nilType) ? v3.pointer : v3
              )
            )(
              "sqlite3_module*",
              (v3) => __xArgPtr(
                v3 instanceof (capi.sqlite3_module || nilType) ? v3.pointer : v3
              )
            );
          }
          const __xRcPtr = wasm.xWrap.resultAdapter("*");
          wasm.xWrap.resultAdapter("sqlite3*", __xRcPtr)(
            "sqlite3_context*",
            __xRcPtr
          )("sqlite3_stmt*", __xRcPtr)("sqlite3_value*", __xRcPtr)(
            "sqlite3_vfs*",
            __xRcPtr
          )("void*", __xRcPtr);
          if (0 === wasm.exports.sqlite3_step.length) {
            wasm.xWrap.doArgcCheck = false;
            sqlite32.config.warn(
              "Disabling sqlite3.wasm.xWrap.doArgcCheck due to environmental quirks."
            );
          }
          for (const e2 of wasm.bindingSignatures) {
            capi[e2[0]] = wasm.xWrap.apply(null, e2);
          }
          for (const e2 of wasm.bindingSignatures.wasmInternal) {
            util[e2[0]] = wasm.xWrap.apply(null, e2);
          }
          const fI64Disabled = function(fname) {
            return () => toss(
              fname + "() is unavailable due to lack",
              "of BigInt support in this build."
            );
          };
          for (const e2 of wasm.bindingSignatures.int64) {
            capi[e2[0]] = wasm.bigIntEnabled ? wasm.xWrap.apply(null, e2) : fI64Disabled(e2[0]);
          }
          delete wasm.bindingSignatures;
          if (wasm.exports.sqlite3__wasm_db_error) {
            const __db_err = wasm.xWrap(
              "sqlite3__wasm_db_error",
              "int",
              "sqlite3*",
              "int",
              "string"
            );
            util.sqlite3__wasm_db_error = function(pDb2, resultCode, message) {
              if (resultCode instanceof sqlite32.WasmAllocError) {
                resultCode = capi.SQLITE_NOMEM;
                message = 0;
              } else if (resultCode instanceof Error) {
                message = message || "" + resultCode;
                resultCode = resultCode.resultCode || capi.SQLITE_ERROR;
              }
              return pDb2 ? __db_err(pDb2, resultCode, message) : resultCode;
            };
          } else {
            util.sqlite3__wasm_db_error = function(pDb2, errCode, msg) {
              console.warn(
                "sqlite3__wasm_db_error() is not exported.",
                arguments
              );
              return errCode;
            };
          }
        }
        {
          const cJson = wasm.xCall("sqlite3__wasm_enum_json");
          if (!cJson) {
            toss(
              "Maintenance required: increase sqlite3__wasm_enum_json()'s",
              "static buffer size!"
            );
          }
          wasm.ctype = JSON.parse(wasm.cstrToJs(cJson));
          const defineGroups = [
            "access",
            "authorizer",
            "blobFinalizers",
            "changeset",
            "config",
            "dataTypes",
            "dbConfig",
            "dbStatus",
            "encodings",
            "fcntl",
            "flock",
            "ioCap",
            "limits",
            "openFlags",
            "prepareFlags",
            "resultCodes",
            "sqlite3Status",
            "stmtStatus",
            "syncFlags",
            "trace",
            "txnState",
            "udfFlags",
            "version"
          ];
          if (wasm.bigIntEnabled) {
            defineGroups.push("serialize", "session", "vtab");
          }
          for (const t2 of defineGroups) {
            for (const e2 of Object.entries(wasm.ctype[t2])) {
              capi[e2[0]] = e2[1];
            }
          }
          if (!wasm.functionEntry(capi.SQLITE_WASM_DEALLOC)) {
            toss(
              "Internal error: cannot resolve exported function",
              "entry SQLITE_WASM_DEALLOC (==" + capi.SQLITE_WASM_DEALLOC + ")."
            );
          }
          const __rcMap = /* @__PURE__ */ Object.create(null);
          for (const t2 of ["resultCodes"]) {
            for (const e2 of Object.entries(wasm.ctype[t2])) {
              __rcMap[e2[1]] = e2[0];
            }
          }
          capi.sqlite3_js_rc_str = (rc) => __rcMap[rc];
          const notThese = Object.assign(/* @__PURE__ */ Object.create(null), {
            WasmTestStruct: true,
            sqlite3_kvvfs_methods: !util.isUIThread(),
            sqlite3_index_info: !wasm.bigIntEnabled,
            sqlite3_index_constraint: !wasm.bigIntEnabled,
            sqlite3_index_orderby: !wasm.bigIntEnabled,
            sqlite3_index_constraint_usage: !wasm.bigIntEnabled
          });
          for (const s2 of wasm.ctype.structs) {
            if (!notThese[s2.name]) {
              capi[s2.name] = sqlite32.StructBinder(s2);
            }
          }
          if (capi.sqlite3_index_info) {
            for (const k2 of [
              "sqlite3_index_constraint",
              "sqlite3_index_orderby",
              "sqlite3_index_constraint_usage"
            ]) {
              capi.sqlite3_index_info[k2] = capi[k2];
              delete capi[k2];
            }
            capi.sqlite3_vtab_config = wasm.xWrap(
              "sqlite3__wasm_vtab_config",
              "int",
              ["sqlite3*", "int", "int"]
            );
          }
        }
        const __dbArgcMismatch = (pDb2, f2, n2) => {
          return util.sqlite3__wasm_db_error(
            pDb2,
            capi.SQLITE_MISUSE,
            f2 + "() requires " + n2 + " argument" + (1 === n2 ? "" : "s") + "."
          );
        };
        const __errEncoding = (pDb2) => {
          return util.sqlite3__wasm_db_error(
            pDb2,
            capi.SQLITE_FORMAT,
            "SQLITE_UTF8 is the only supported encoding."
          );
        };
        const __argPDb = (pDb2) => wasm.xWrap.argAdapter("sqlite3*")(pDb2);
        const __argStr = (str) => wasm.isPtr(str) ? wasm.cstrToJs(str) : str;
        const __dbCleanupMap = function(pDb2, mode) {
          pDb2 = __argPDb(pDb2);
          let m2 = this.dbMap.get(pDb2);
          if (!mode) {
            this.dbMap.delete(pDb2);
            return m2;
          } else if (!m2 && mode > 0) {
            this.dbMap.set(pDb2, m2 = /* @__PURE__ */ Object.create(null));
          }
          return m2;
        }.bind(
          Object.assign(/* @__PURE__ */ Object.create(null), {
            dbMap: /* @__PURE__ */ new Map()
          })
        );
        __dbCleanupMap.addCollation = function(pDb2, name) {
          const m2 = __dbCleanupMap(pDb2, 1);
          if (!m2.collation)
            m2.collation = /* @__PURE__ */ new Set();
          m2.collation.add(__argStr(name).toLowerCase());
        };
        __dbCleanupMap._addUDF = function(pDb2, name, arity, map3) {
          name = __argStr(name).toLowerCase();
          let u3 = map3.get(name);
          if (!u3)
            map3.set(name, u3 = /* @__PURE__ */ new Set());
          u3.add(arity < 0 ? -1 : arity);
        };
        __dbCleanupMap.addFunction = function(pDb2, name, arity) {
          const m2 = __dbCleanupMap(pDb2, 1);
          if (!m2.udf)
            m2.udf = /* @__PURE__ */ new Map();
          this._addUDF(pDb2, name, arity, m2.udf);
        };
        if (wasm.exports.sqlite3_create_window_function) {
          __dbCleanupMap.addWindowFunc = function(pDb2, name, arity) {
            const m2 = __dbCleanupMap(pDb2, 1);
            if (!m2.wudf)
              m2.wudf = /* @__PURE__ */ new Map();
            this._addUDF(pDb2, name, arity, m2.wudf);
          };
        }
        __dbCleanupMap.cleanup = function(pDb2) {
          pDb2 = __argPDb(pDb2);
          const closeArgs = [pDb2];
          for (const name of [
            "sqlite3_busy_handler",
            "sqlite3_commit_hook",
            "sqlite3_preupdate_hook",
            "sqlite3_progress_handler",
            "sqlite3_rollback_hook",
            "sqlite3_set_authorizer",
            "sqlite3_trace_v2",
            "sqlite3_update_hook"
          ]) {
            const x2 = wasm.exports[name];
            if (!x2) {
              continue;
            }
            closeArgs.length = x2.length;
            try {
              capi[name](...closeArgs);
            } catch (e2) {
              sqlite32.config.warn(
                "close-time call of",
                name + "(",
                closeArgs,
                ") threw:",
                e2
              );
            }
          }
          const m2 = __dbCleanupMap(pDb2, 0);
          if (!m2)
            return;
          if (m2.collation) {
            for (const name of m2.collation) {
              try {
                capi.sqlite3_create_collation_v2(
                  pDb2,
                  name,
                  capi.SQLITE_UTF8,
                  0,
                  0,
                  0
                );
              } catch (e2) {
              }
            }
            delete m2.collation;
          }
          let i2;
          for (i2 = 0; i2 < 2; ++i2) {
            const fmap = i2 ? m2.wudf : m2.udf;
            if (!fmap)
              continue;
            const func = i2 ? capi.sqlite3_create_window_function : capi.sqlite3_create_function_v2;
            for (const e2 of fmap) {
              const name = e2[0], arities = e2[1];
              const fargs = [pDb2, name, 0, capi.SQLITE_UTF8, 0, 0, 0, 0, 0];
              if (i2)
                fargs.push(0);
              for (const arity of arities) {
                try {
                  fargs[2] = arity;
                  func.apply(null, fargs);
                } catch (e3) {
                }
              }
              arities.clear();
            }
            fmap.clear();
          }
          delete m2.udf;
          delete m2.wudf;
        };
        {
          const __sqlite3CloseV2 = wasm.xWrap(
            "sqlite3_close_v2",
            "int",
            "sqlite3*"
          );
          capi.sqlite3_close_v2 = function(pDb2) {
            if (1 !== arguments.length)
              return __dbArgcMismatch(pDb2, "sqlite3_close_v2", 1);
            if (pDb2) {
              try {
                __dbCleanupMap.cleanup(pDb2);
              } catch (e2) {
              }
            }
            return __sqlite3CloseV2(pDb2);
          };
        }
        if (capi.sqlite3session_create) {
          const __sqlite3SessionDelete = wasm.xWrap(
            "sqlite3session_delete",
            void 0,
            ["sqlite3_session*"]
          );
          capi.sqlite3session_delete = function(pSession) {
            if (1 !== arguments.length) {
              return __dbArgcMismatch(pDb, "sqlite3session_delete", 1);
            } else if (pSession) {
              capi.sqlite3session_table_filter(pSession, 0, 0);
            }
            __sqlite3SessionDelete(pSession);
          };
        }
        {
          const contextKey = (argv2, argIndex) => {
            return "argv[" + argIndex + "]:" + argv2[0] + ":" + wasm.cstrToJs(argv2[1]).toLowerCase();
          };
          const __sqlite3CreateCollationV2 = wasm.xWrap(
            "sqlite3_create_collation_v2",
            "int",
            [
              "sqlite3*",
              "string",
              "int",
              "*",
              new wasm.xWrap.FuncPtrAdapter({
                name: "xCompare",
                signature: "i(pipip)",
                contextKey
              }),
              new wasm.xWrap.FuncPtrAdapter({
                name: "xDestroy",
                signature: "v(p)",
                contextKey
              })
            ]
          );
          capi.sqlite3_create_collation_v2 = function(pDb2, zName, eTextRep, pArg, xCompare, xDestroy) {
            if (6 !== arguments.length)
              return __dbArgcMismatch(pDb2, "sqlite3_create_collation_v2", 6);
            else if (0 === (eTextRep & 15)) {
              eTextRep |= capi.SQLITE_UTF8;
            } else if (capi.SQLITE_UTF8 !== (eTextRep & 15)) {
              return __errEncoding(pDb2);
            }
            try {
              const rc = __sqlite3CreateCollationV2(
                pDb2,
                zName,
                eTextRep,
                pArg,
                xCompare,
                xDestroy
              );
              if (0 === rc && xCompare instanceof Function) {
                __dbCleanupMap.addCollation(pDb2, zName);
              }
              return rc;
            } catch (e2) {
              return util.sqlite3__wasm_db_error(pDb2, e2);
            }
          };
          capi.sqlite3_create_collation = (pDb2, zName, eTextRep, pArg, xCompare) => {
            return 5 === arguments.length ? capi.sqlite3_create_collation_v2(
              pDb2,
              zName,
              eTextRep,
              pArg,
              xCompare,
              0
            ) : __dbArgcMismatch(pDb2, "sqlite3_create_collation", 5);
          };
        }
        {
          const contextKey = function(argv2, argIndex) {
            return argv2[0] + ":" + (argv2[2] < 0 ? -1 : argv2[2]) + ":" + argIndex + ":" + wasm.cstrToJs(argv2[1]).toLowerCase();
          };
          const __cfProxy = Object.assign(/* @__PURE__ */ Object.create(null), {
            xInverseAndStep: {
              signature: "v(pip)",
              contextKey,
              callProxy: (callback) => {
                return (pCtx, argc, pArgv) => {
                  try {
                    callback(pCtx, ...capi.sqlite3_values_to_js(argc, pArgv));
                  } catch (e2) {
                    capi.sqlite3_result_error_js(pCtx, e2);
                  }
                };
              }
            },
            xFinalAndValue: {
              signature: "v(p)",
              contextKey,
              callProxy: (callback) => {
                return (pCtx) => {
                  try {
                    capi.sqlite3_result_js(pCtx, callback(pCtx));
                  } catch (e2) {
                    capi.sqlite3_result_error_js(pCtx, e2);
                  }
                };
              }
            },
            xFunc: {
              signature: "v(pip)",
              contextKey,
              callProxy: (callback) => {
                return (pCtx, argc, pArgv) => {
                  try {
                    capi.sqlite3_result_js(
                      pCtx,
                      callback(pCtx, ...capi.sqlite3_values_to_js(argc, pArgv))
                    );
                  } catch (e2) {
                    capi.sqlite3_result_error_js(pCtx, e2);
                  }
                };
              }
            },
            xDestroy: {
              signature: "v(p)",
              contextKey,
              callProxy: (callback) => {
                return (pVoid) => {
                  try {
                    callback(pVoid);
                  } catch (e2) {
                    console.error("UDF xDestroy method threw:", e2);
                  }
                };
              }
            }
          });
          const __sqlite3CreateFunction = wasm.xWrap(
            "sqlite3_create_function_v2",
            "int",
            [
              "sqlite3*",
              "string",
              "int",
              "int",
              "*",
              new wasm.xWrap.FuncPtrAdapter({
                name: "xFunc",
                ...__cfProxy.xFunc
              }),
              new wasm.xWrap.FuncPtrAdapter({
                name: "xStep",
                ...__cfProxy.xInverseAndStep
              }),
              new wasm.xWrap.FuncPtrAdapter({
                name: "xFinal",
                ...__cfProxy.xFinalAndValue
              }),
              new wasm.xWrap.FuncPtrAdapter({
                name: "xDestroy",
                ...__cfProxy.xDestroy
              })
            ]
          );
          const __sqlite3CreateWindowFunction = wasm.exports.sqlite3_create_window_function ? wasm.xWrap("sqlite3_create_window_function", "int", [
            "sqlite3*",
            "string",
            "int",
            "int",
            "*",
            new wasm.xWrap.FuncPtrAdapter({
              name: "xStep",
              ...__cfProxy.xInverseAndStep
            }),
            new wasm.xWrap.FuncPtrAdapter({
              name: "xFinal",
              ...__cfProxy.xFinalAndValue
            }),
            new wasm.xWrap.FuncPtrAdapter({
              name: "xValue",
              ...__cfProxy.xFinalAndValue
            }),
            new wasm.xWrap.FuncPtrAdapter({
              name: "xInverse",
              ...__cfProxy.xInverseAndStep
            }),
            new wasm.xWrap.FuncPtrAdapter({
              name: "xDestroy",
              ...__cfProxy.xDestroy
            })
          ]) : void 0;
          capi.sqlite3_create_function_v2 = function f2(pDb2, funcName, nArg, eTextRep, pApp, xFunc, xStep, xFinal, xDestroy) {
            if (f2.length !== arguments.length) {
              return __dbArgcMismatch(
                pDb2,
                "sqlite3_create_function_v2",
                f2.length
              );
            } else if (0 === (eTextRep & 15)) {
              eTextRep |= capi.SQLITE_UTF8;
            } else if (capi.SQLITE_UTF8 !== (eTextRep & 15)) {
              return __errEncoding(pDb2);
            }
            try {
              const rc = __sqlite3CreateFunction(
                pDb2,
                funcName,
                nArg,
                eTextRep,
                pApp,
                xFunc,
                xStep,
                xFinal,
                xDestroy
              );
              if (0 === rc && (xFunc instanceof Function || xStep instanceof Function || xFinal instanceof Function || xDestroy instanceof Function)) {
                __dbCleanupMap.addFunction(pDb2, funcName, nArg);
              }
              return rc;
            } catch (e2) {
              console.error("sqlite3_create_function_v2() setup threw:", e2);
              return util.sqlite3__wasm_db_error(
                pDb2,
                e2,
                "Creation of UDF threw: " + e2
              );
            }
          };
          capi.sqlite3_create_function = function f2(pDb2, funcName, nArg, eTextRep, pApp, xFunc, xStep, xFinal) {
            return f2.length === arguments.length ? capi.sqlite3_create_function_v2(
              pDb2,
              funcName,
              nArg,
              eTextRep,
              pApp,
              xFunc,
              xStep,
              xFinal,
              0
            ) : __dbArgcMismatch(pDb2, "sqlite3_create_function", f2.length);
          };
          if (__sqlite3CreateWindowFunction) {
            capi.sqlite3_create_window_function = function f2(pDb2, funcName, nArg, eTextRep, pApp, xStep, xFinal, xValue, xInverse, xDestroy) {
              if (f2.length !== arguments.length) {
                return __dbArgcMismatch(
                  pDb2,
                  "sqlite3_create_window_function",
                  f2.length
                );
              } else if (0 === (eTextRep & 15)) {
                eTextRep |= capi.SQLITE_UTF8;
              } else if (capi.SQLITE_UTF8 !== (eTextRep & 15)) {
                return __errEncoding(pDb2);
              }
              try {
                const rc = __sqlite3CreateWindowFunction(
                  pDb2,
                  funcName,
                  nArg,
                  eTextRep,
                  pApp,
                  xStep,
                  xFinal,
                  xValue,
                  xInverse,
                  xDestroy
                );
                if (0 === rc && (xStep instanceof Function || xFinal instanceof Function || xValue instanceof Function || xInverse instanceof Function || xDestroy instanceof Function)) {
                  __dbCleanupMap.addWindowFunc(pDb2, funcName, nArg);
                }
                return rc;
              } catch (e2) {
                console.error(
                  "sqlite3_create_window_function() setup threw:",
                  e2
                );
                return util.sqlite3__wasm_db_error(
                  pDb2,
                  e2,
                  "Creation of UDF threw: " + e2
                );
              }
            };
          } else {
            delete capi.sqlite3_create_window_function;
          }
          capi.sqlite3_create_function_v2.udfSetResult = capi.sqlite3_create_function.udfSetResult = capi.sqlite3_result_js;
          if (capi.sqlite3_create_window_function) {
            capi.sqlite3_create_window_function.udfSetResult = capi.sqlite3_result_js;
          }
          capi.sqlite3_create_function_v2.udfConvertArgs = capi.sqlite3_create_function.udfConvertArgs = capi.sqlite3_values_to_js;
          if (capi.sqlite3_create_window_function) {
            capi.sqlite3_create_window_function.udfConvertArgs = capi.sqlite3_values_to_js;
          }
          capi.sqlite3_create_function_v2.udfSetError = capi.sqlite3_create_function.udfSetError = capi.sqlite3_result_error_js;
          if (capi.sqlite3_create_window_function) {
            capi.sqlite3_create_window_function.udfSetError = capi.sqlite3_result_error_js;
          }
        }
        {
          const __flexiString = (v3, n2) => {
            if ("string" === typeof v3) {
              n2 = -1;
            } else if (util.isSQLableTypedArray(v3)) {
              n2 = v3.byteLength;
              v3 = util.typedArrayToString(
                v3 instanceof ArrayBuffer ? new Uint8Array(v3) : v3
              );
            } else if (Array.isArray(v3)) {
              v3 = v3.join("");
              n2 = -1;
            }
            return [v3, n2];
          };
          const __prepare = {
            basic: wasm.xWrap("sqlite3_prepare_v3", "int", [
              "sqlite3*",
              "string",
              "int",
              "int",
              "**",
              "**"
            ]),
            full: wasm.xWrap("sqlite3_prepare_v3", "int", [
              "sqlite3*",
              "*",
              "int",
              "int",
              "**",
              "**"
            ])
          };
          capi.sqlite3_prepare_v3 = function f2(pDb2, sql2, sqlLen, prepFlags, ppStmt, pzTail) {
            if (f2.length !== arguments.length) {
              return __dbArgcMismatch(pDb2, "sqlite3_prepare_v3", f2.length);
            }
            const [xSql, xSqlLen] = __flexiString(sql2, sqlLen);
            switch (typeof xSql) {
              case "string":
                return __prepare.basic(
                  pDb2,
                  xSql,
                  xSqlLen,
                  prepFlags,
                  ppStmt,
                  null
                );
              case "number":
                return __prepare.full(
                  pDb2,
                  xSql,
                  xSqlLen,
                  prepFlags,
                  ppStmt,
                  pzTail
                );
              default:
                return util.sqlite3__wasm_db_error(
                  pDb2,
                  capi.SQLITE_MISUSE,
                  "Invalid SQL argument type for sqlite3_prepare_v2/v3()."
                );
            }
          };
          capi.sqlite3_prepare_v2 = function f2(pDb2, sql2, sqlLen, ppStmt, pzTail) {
            return f2.length === arguments.length ? capi.sqlite3_prepare_v3(pDb2, sql2, sqlLen, 0, ppStmt, pzTail) : __dbArgcMismatch(pDb2, "sqlite3_prepare_v2", f2.length);
          };
        }
        {
          const __bindText = wasm.xWrap("sqlite3_bind_text", "int", [
            "sqlite3_stmt*",
            "int",
            "string",
            "int",
            "*"
          ]);
          const __bindBlob = wasm.xWrap("sqlite3_bind_blob", "int", [
            "sqlite3_stmt*",
            "int",
            "*",
            "int",
            "*"
          ]);
          capi.sqlite3_bind_text = function f2(pStmt, iCol, text, nText, xDestroy) {
            if (f2.length !== arguments.length) {
              return __dbArgcMismatch(
                capi.sqlite3_db_handle(pStmt),
                "sqlite3_bind_text",
                f2.length
              );
            } else if (wasm.isPtr(text) || null === text) {
              return __bindText(pStmt, iCol, text, nText, xDestroy);
            } else if (text instanceof ArrayBuffer) {
              text = new Uint8Array(text);
            } else if (Array.isArray(pMem)) {
              text = pMem.join("");
            }
            let p3, n2;
            try {
              if (util.isSQLableTypedArray(text)) {
                p3 = wasm.allocFromTypedArray(text);
                n2 = text.byteLength;
              } else if ("string" === typeof text) {
                [p3, n2] = wasm.allocCString(text);
              } else {
                return util.sqlite3__wasm_db_error(
                  capi.sqlite3_db_handle(pStmt),
                  capi.SQLITE_MISUSE,
                  "Invalid 3rd argument type for sqlite3_bind_text()."
                );
              }
              return __bindText(pStmt, iCol, p3, n2, capi.SQLITE_WASM_DEALLOC);
            } catch (e2) {
              wasm.dealloc(p3);
              return util.sqlite3__wasm_db_error(
                capi.sqlite3_db_handle(pStmt),
                e2
              );
            }
          };
          capi.sqlite3_bind_blob = function f2(pStmt, iCol, pMem2, nMem, xDestroy) {
            if (f2.length !== arguments.length) {
              return __dbArgcMismatch(
                capi.sqlite3_db_handle(pStmt),
                "sqlite3_bind_blob",
                f2.length
              );
            } else if (wasm.isPtr(pMem2) || null === pMem2) {
              return __bindBlob(pStmt, iCol, pMem2, nMem, xDestroy);
            } else if (pMem2 instanceof ArrayBuffer) {
              pMem2 = new Uint8Array(pMem2);
            } else if (Array.isArray(pMem2)) {
              pMem2 = pMem2.join("");
            }
            let p3, n2;
            try {
              if (util.isBindableTypedArray(pMem2)) {
                p3 = wasm.allocFromTypedArray(pMem2);
                n2 = nMem >= 0 ? nMem : pMem2.byteLength;
              } else if ("string" === typeof pMem2) {
                [p3, n2] = wasm.allocCString(pMem2);
              } else {
                return util.sqlite3__wasm_db_error(
                  capi.sqlite3_db_handle(pStmt),
                  capi.SQLITE_MISUSE,
                  "Invalid 3rd argument type for sqlite3_bind_blob()."
                );
              }
              return __bindBlob(pStmt, iCol, p3, n2, capi.SQLITE_WASM_DEALLOC);
            } catch (e2) {
              wasm.dealloc(p3);
              return util.sqlite3__wasm_db_error(
                capi.sqlite3_db_handle(pStmt),
                e2
              );
            }
          };
        }
        {
          capi.sqlite3_config = function(op, ...args) {
            if (arguments.length < 2)
              return capi.SQLITE_MISUSE;
            switch (op) {
              case capi.SQLITE_CONFIG_COVERING_INDEX_SCAN:
              case capi.SQLITE_CONFIG_MEMSTATUS:
              case capi.SQLITE_CONFIG_SMALL_MALLOC:
              case capi.SQLITE_CONFIG_SORTERREF_SIZE:
              case capi.SQLITE_CONFIG_STMTJRNL_SPILL:
              case capi.SQLITE_CONFIG_URI:
                return wasm.exports.sqlite3__wasm_config_i(op, args[0]);
              case capi.SQLITE_CONFIG_LOOKASIDE:
                return wasm.exports.sqlite3__wasm_config_ii(
                  op,
                  args[0],
                  args[1]
                );
              case capi.SQLITE_CONFIG_MEMDB_MAXSIZE:
                return wasm.exports.sqlite3__wasm_config_j(op, args[0]);
              case capi.SQLITE_CONFIG_GETMALLOC:
              case capi.SQLITE_CONFIG_GETMUTEX:
              case capi.SQLITE_CONFIG_GETPCACHE2:
              case capi.SQLITE_CONFIG_GETPCACHE:
              case capi.SQLITE_CONFIG_HEAP:
              case capi.SQLITE_CONFIG_LOG:
              case capi.SQLITE_CONFIG_MALLOC:
              case capi.SQLITE_CONFIG_MMAP_SIZE:
              case capi.SQLITE_CONFIG_MULTITHREAD:
              case capi.SQLITE_CONFIG_MUTEX:
              case capi.SQLITE_CONFIG_PAGECACHE:
              case capi.SQLITE_CONFIG_PCACHE2:
              case capi.SQLITE_CONFIG_PCACHE:
              case capi.SQLITE_CONFIG_PCACHE_HDRSZ:
              case capi.SQLITE_CONFIG_PMASZ:
              case capi.SQLITE_CONFIG_SERIALIZED:
              case capi.SQLITE_CONFIG_SINGLETHREAD:
              case capi.SQLITE_CONFIG_SQLLOG:
              case capi.SQLITE_CONFIG_WIN32_HEAPSIZE:
              default:
                return capi.SQLITE_NOTFOUND;
            }
          };
        }
        {
          const __autoExtFptr = /* @__PURE__ */ new Set();
          capi.sqlite3_auto_extension = function(fPtr) {
            if (fPtr instanceof Function) {
              fPtr = wasm.installFunction("i(ppp)", fPtr);
            } else if (1 !== arguments.length || !wasm.isPtr(fPtr)) {
              return capi.SQLITE_MISUSE;
            }
            const rc = wasm.exports.sqlite3_auto_extension(fPtr);
            if (fPtr !== arguments[0]) {
              if (0 === rc)
                __autoExtFptr.add(fPtr);
              else
                wasm.uninstallFunction(fPtr);
            }
            return rc;
          };
          capi.sqlite3_cancel_auto_extension = function(fPtr) {
            if (!fPtr || 1 !== arguments.length || !wasm.isPtr(fPtr))
              return 0;
            return wasm.exports.sqlite3_cancel_auto_extension(fPtr);
          };
          capi.sqlite3_reset_auto_extension = function() {
            wasm.exports.sqlite3_reset_auto_extension();
            for (const fp of __autoExtFptr)
              wasm.uninstallFunction(fp);
            __autoExtFptr.clear();
          };
        }
        const pKvvfs = capi.sqlite3_vfs_find("kvvfs");
        if (pKvvfs) {
          if (util.isUIThread()) {
            const kvvfsMethods = new capi.sqlite3_kvvfs_methods(
              wasm.exports.sqlite3__wasm_kvvfs_methods()
            );
            delete capi.sqlite3_kvvfs_methods;
            const kvvfsMakeKey = wasm.exports.sqlite3__wasm_kvvfsMakeKeyOnPstack, pstack = wasm.pstack;
            const kvvfsStorage = (zClass) => 115 === wasm.peek(zClass) ? sessionStorage : localStorage;
            const kvvfsImpls = {
              xRead: (zClass, zKey, zBuf, nBuf) => {
                const stack = pstack.pointer, astack = wasm.scopedAllocPush();
                try {
                  const zXKey = kvvfsMakeKey(zClass, zKey);
                  if (!zXKey)
                    return -3;
                  const jKey = wasm.cstrToJs(zXKey);
                  const jV = kvvfsStorage(zClass).getItem(jKey);
                  if (!jV)
                    return -1;
                  const nV = jV.length;
                  if (nBuf <= 0)
                    return nV;
                  else if (1 === nBuf) {
                    wasm.poke(zBuf, 0);
                    return nV;
                  }
                  const zV = wasm.scopedAllocCString(jV);
                  if (nBuf > nV + 1)
                    nBuf = nV + 1;
                  wasm.heap8u().copyWithin(zBuf, zV, zV + nBuf - 1);
                  wasm.poke(zBuf + nBuf - 1, 0);
                  return nBuf - 1;
                } catch (e2) {
                  console.error("kvstorageRead()", e2);
                  return -2;
                } finally {
                  pstack.restore(stack);
                  wasm.scopedAllocPop(astack);
                }
              },
              xWrite: (zClass, zKey, zData) => {
                const stack = pstack.pointer;
                try {
                  const zXKey = kvvfsMakeKey(zClass, zKey);
                  if (!zXKey)
                    return 1;
                  const jKey = wasm.cstrToJs(zXKey);
                  kvvfsStorage(zClass).setItem(jKey, wasm.cstrToJs(zData));
                  return 0;
                } catch (e2) {
                  console.error("kvstorageWrite()", e2);
                  return capi.SQLITE_IOERR;
                } finally {
                  pstack.restore(stack);
                }
              },
              xDelete: (zClass, zKey) => {
                const stack = pstack.pointer;
                try {
                  const zXKey = kvvfsMakeKey(zClass, zKey);
                  if (!zXKey)
                    return 1;
                  kvvfsStorage(zClass).removeItem(wasm.cstrToJs(zXKey));
                  return 0;
                } catch (e2) {
                  console.error("kvstorageDelete()", e2);
                  return capi.SQLITE_IOERR;
                } finally {
                  pstack.restore(stack);
                }
              }
            };
            for (const k2 of Object.keys(kvvfsImpls)) {
              kvvfsMethods[kvvfsMethods.memberKey(k2)] = wasm.installFunction(
                kvvfsMethods.memberSignature(k2),
                kvvfsImpls[k2]
              );
            }
          } else {
            capi.sqlite3_vfs_unregister(pKvvfs);
          }
        }
        wasm.xWrap.FuncPtrAdapter.warnOnUse = true;
        const StructBinder = sqlite32.StructBinder;
        const installMethod = function callee2(tgt, name, func, applyArgcCheck = callee2.installMethodArgcCheck) {
          if (!(tgt instanceof StructBinder.StructType)) {
            toss("Usage error: target object is-not-a StructType.");
          } else if (!(func instanceof Function) && !wasm.isPtr(func)) {
            toss("Usage errror: expecting a Function or WASM pointer to one.");
          }
          if (1 === arguments.length) {
            return (n2, f2) => callee2(tgt, n2, f2, applyArgcCheck);
          }
          if (!callee2.argcProxy) {
            callee2.argcProxy = function(tgt2, funcName, func2, sig) {
              return function(...args) {
                if (func2.length !== arguments.length) {
                  toss(
                    "Argument mismatch for",
                    tgt2.structInfo.name + "::" + funcName + ": Native signature is:",
                    sig
                  );
                }
                return func2.apply(this, args);
              };
            };
            callee2.removeFuncList = function() {
              if (this.ondispose.__removeFuncList) {
                this.ondispose.__removeFuncList.forEach((v3, ndx) => {
                  if ("number" === typeof v3) {
                    try {
                      wasm.uninstallFunction(v3);
                    } catch (e2) {
                    }
                  }
                });
                delete this.ondispose.__removeFuncList;
              }
            };
          }
          const sigN = tgt.memberSignature(name);
          if (sigN.length < 2) {
            toss(
              "Member",
              name,
              "does not have a function pointer signature:",
              sigN
            );
          }
          const memKey = tgt.memberKey(name);
          const fProxy = applyArgcCheck && !wasm.isPtr(func) ? callee2.argcProxy(tgt, memKey, func, sigN) : func;
          if (wasm.isPtr(fProxy)) {
            if (fProxy && !wasm.functionEntry(fProxy)) {
              toss("Pointer", fProxy, "is not a WASM function table entry.");
            }
            tgt[memKey] = fProxy;
          } else {
            const pFunc = wasm.installFunction(
              fProxy,
              tgt.memberSignature(name, true)
            );
            tgt[memKey] = pFunc;
            if (!tgt.ondispose || !tgt.ondispose.__removeFuncList) {
              tgt.addOnDispose(
                "ondispose.__removeFuncList handler",
                callee2.removeFuncList
              );
              tgt.ondispose.__removeFuncList = [];
            }
            tgt.ondispose.__removeFuncList.push(memKey, pFunc);
          }
          return (n2, f2) => callee2(tgt, n2, f2, applyArgcCheck);
        };
        installMethod.installMethodArgcCheck = false;
        const installMethods = function(structInstance, methods, applyArgcCheck = installMethod.installMethodArgcCheck) {
          const seen = /* @__PURE__ */ new Map();
          for (const k2 of Object.keys(methods)) {
            const m2 = methods[k2];
            const prior = seen.get(m2);
            if (prior) {
              const mkey = structInstance.memberKey(k2);
              structInstance[mkey] = structInstance[structInstance.memberKey(prior)];
            } else {
              installMethod(structInstance, k2, m2, applyArgcCheck);
              seen.set(m2, k2);
            }
          }
          return structInstance;
        };
        StructBinder.StructType.prototype.installMethod = function callee2(name, func, applyArgcCheck = installMethod.installMethodArgcCheck) {
          return arguments.length < 3 && name && "object" === typeof name ? installMethods(this, ...arguments) : installMethod(this, ...arguments);
        };
        StructBinder.StructType.prototype.installMethods = function(methods, applyArgcCheck = installMethod.installMethodArgcCheck) {
          return installMethods(this, methods, applyArgcCheck);
        };
      });
      globalThis.sqlite3ApiBootstrap.initializers.push(function(sqlite32) {
        sqlite32.version = {
          libVersion: "3.48.0",
          libVersionNumber: 3048e3,
          sourceId: "2025-01-14 11:05:00 d2fe6b05f38d9d7cd78c5d252e99ac59f1aea071d669830c1ffe4e8966e84010",
          downloadVersion: 348e4
        };
      });
      globalThis.sqlite3ApiBootstrap.initializers.push(function(sqlite32) {
        const toss = (...args) => {
          throw new Error(args.join(" "));
        };
        const toss3 = (...args) => {
          throw new sqlite32.SQLite3Error(...args);
        };
        const capi = sqlite32.capi, wasm = sqlite32.wasm, util = sqlite32.util;
        const __ptrMap = /* @__PURE__ */ new WeakMap();
        const __stmtMap = /* @__PURE__ */ new WeakMap();
        const getOwnOption = (opts, p3, dflt) => {
          const d2 = Object.getOwnPropertyDescriptor(opts, p3);
          return d2 ? d2.value : dflt;
        };
        const checkSqlite3Rc = function(dbPtr, sqliteResultCode) {
          if (sqliteResultCode) {
            if (dbPtr instanceof DB)
              dbPtr = dbPtr.pointer;
            toss3(
              sqliteResultCode,
              "sqlite3 result code",
              sqliteResultCode + ":",
              dbPtr ? capi.sqlite3_errmsg(dbPtr) : capi.sqlite3_errstr(sqliteResultCode)
            );
          }
          return arguments[0];
        };
        const __dbTraceToConsole = wasm.installFunction(
          "i(ippp)",
          function(t2, c3, p3, x2) {
            if (capi.SQLITE_TRACE_STMT === t2) {
              console.log(
                "SQL TRACE #" + ++this.counter + " via sqlite3@" + c3 + ":",
                wasm.cstrToJs(x2)
              );
            }
          }.bind({ counter: 0 })
        );
        const __vfsPostOpenCallback = /* @__PURE__ */ Object.create(null);
        const dbCtorHelper = function ctor(...args) {
          if (!ctor._name2vfs) {
            ctor._name2vfs = /* @__PURE__ */ Object.create(null);
            const isWorkerThread = "function" === typeof importScripts ? (n2) => toss3(
              "The VFS for",
              n2,
              "is only available in the main window thread."
            ) : false;
            ctor._name2vfs[":localStorage:"] = {
              vfs: "kvvfs",
              filename: isWorkerThread || (() => "local")
            };
            ctor._name2vfs[":sessionStorage:"] = {
              vfs: "kvvfs",
              filename: isWorkerThread || (() => "session")
            };
          }
          const opt = ctor.normalizeArgs(...args);
          let fn = opt.filename, vfsName = opt.vfs, flagsStr = opt.flags;
          if ("string" !== typeof fn && "number" !== typeof fn || "string" !== typeof flagsStr || vfsName && "string" !== typeof vfsName && "number" !== typeof vfsName) {
            sqlite32.config.error("Invalid DB ctor args", opt, arguments);
            toss3("Invalid arguments for DB constructor.");
          }
          let fnJs = "number" === typeof fn ? wasm.cstrToJs(fn) : fn;
          const vfsCheck = ctor._name2vfs[fnJs];
          if (vfsCheck) {
            vfsName = vfsCheck.vfs;
            fn = fnJs = vfsCheck.filename(fnJs);
          }
          let pDb2, oflags = 0;
          if (flagsStr.indexOf("c") >= 0) {
            oflags |= capi.SQLITE_OPEN_CREATE | capi.SQLITE_OPEN_READWRITE;
          }
          if (flagsStr.indexOf("w") >= 0)
            oflags |= capi.SQLITE_OPEN_READWRITE;
          if (0 === oflags)
            oflags |= capi.SQLITE_OPEN_READONLY;
          oflags |= capi.SQLITE_OPEN_EXRESCODE;
          const stack = wasm.pstack.pointer;
          try {
            const pPtr = wasm.pstack.allocPtr();
            let rc = capi.sqlite3_open_v2(fn, pPtr, oflags, vfsName || 0);
            pDb2 = wasm.peekPtr(pPtr);
            checkSqlite3Rc(pDb2, rc);
            capi.sqlite3_extended_result_codes(pDb2, 1);
            if (flagsStr.indexOf("t") >= 0) {
              capi.sqlite3_trace_v2(
                pDb2,
                capi.SQLITE_TRACE_STMT,
                __dbTraceToConsole,
                pDb2
              );
            }
          } catch (e2) {
            if (pDb2)
              capi.sqlite3_close_v2(pDb2);
            throw e2;
          } finally {
            wasm.pstack.restore(stack);
          }
          this.filename = fnJs;
          __ptrMap.set(this, pDb2);
          __stmtMap.set(this, /* @__PURE__ */ Object.create(null));
          try {
            const pVfs = capi.sqlite3_js_db_vfs(pDb2) || toss3("Internal error: cannot get VFS for new db handle.");
            const postInitSql = __vfsPostOpenCallback[pVfs];
            if (postInitSql) {
              if (postInitSql instanceof Function) {
                postInitSql(this, sqlite32);
              } else {
                checkSqlite3Rc(
                  pDb2,
                  capi.sqlite3_exec(pDb2, postInitSql, 0, 0, 0)
                );
              }
            }
          } catch (e2) {
            this.close();
            throw e2;
          }
        };
        dbCtorHelper.setVfsPostOpenCallback = function(pVfs, callback) {
          if (!(callback instanceof Function)) {
            toss3(
              "dbCtorHelper.setVfsPostOpenCallback() should not be used with a non-function argument.",
              arguments
            );
          }
          __vfsPostOpenCallback[pVfs] = callback;
        };
        dbCtorHelper.normalizeArgs = function(filename = ":memory:", flags = "c", vfs = null) {
          const arg = {};
          if (1 === arguments.length && arguments[0] && "object" === typeof arguments[0]) {
            Object.assign(arg, arguments[0]);
            if (void 0 === arg.flags)
              arg.flags = "c";
            if (void 0 === arg.vfs)
              arg.vfs = null;
            if (void 0 === arg.filename)
              arg.filename = ":memory:";
          } else {
            arg.filename = filename;
            arg.flags = flags;
            arg.vfs = vfs;
          }
          return arg;
        };
        const DB = function(...args) {
          dbCtorHelper.apply(this, args);
        };
        DB.dbCtorHelper = dbCtorHelper;
        const BindTypes = {
          null: 1,
          number: 2,
          string: 3,
          boolean: 4,
          blob: 5
        };
        BindTypes["undefined"] == BindTypes.null;
        if (wasm.bigIntEnabled) {
          BindTypes.bigint = BindTypes.number;
        }
        const Stmt = function() {
          if (BindTypes !== arguments[2]) {
            toss3(
              capi.SQLITE_MISUSE,
              "Do not call the Stmt constructor directly. Use DB.prepare()."
            );
          }
          this.db = arguments[0];
          __ptrMap.set(this, arguments[1]);
          this.parameterCount = capi.sqlite3_bind_parameter_count(this.pointer);
        };
        const affirmDbOpen = function(db) {
          if (!db.pointer)
            toss3("DB has been closed.");
          return db;
        };
        const affirmColIndex = function(stmt, ndx) {
          if (ndx !== (ndx | 0) || ndx < 0 || ndx >= stmt.columnCount) {
            toss3("Column index", ndx, "is out of range.");
          }
          return stmt;
        };
        const parseExecArgs = function(db, args) {
          const out2 = /* @__PURE__ */ Object.create(null);
          out2.opt = /* @__PURE__ */ Object.create(null);
          switch (args.length) {
            case 1:
              if ("string" === typeof args[0] || util.isSQLableTypedArray(args[0])) {
                out2.sql = args[0];
              } else if (Array.isArray(args[0])) {
                out2.sql = args[0];
              } else if (args[0] && "object" === typeof args[0]) {
                out2.opt = args[0];
                out2.sql = out2.opt.sql;
              }
              break;
            case 2:
              out2.sql = args[0];
              out2.opt = args[1];
              break;
            default:
              toss3("Invalid argument count for exec().");
          }
          out2.sql = util.flexibleString(out2.sql);
          if ("string" !== typeof out2.sql) {
            toss3("Missing SQL argument or unsupported SQL value type.");
          }
          const opt = out2.opt;
          switch (opt.returnValue) {
            case "resultRows":
              if (!opt.resultRows)
                opt.resultRows = [];
              out2.returnVal = () => opt.resultRows;
              break;
            case "saveSql":
              if (!opt.saveSql)
                opt.saveSql = [];
              out2.returnVal = () => opt.saveSql;
              break;
            case void 0:
            case "this":
              out2.returnVal = () => db;
              break;
            default:
              toss3("Invalid returnValue value:", opt.returnValue);
          }
          if (!opt.callback && !opt.returnValue && void 0 !== opt.rowMode) {
            if (!opt.resultRows)
              opt.resultRows = [];
            out2.returnVal = () => opt.resultRows;
          }
          if (opt.callback || opt.resultRows) {
            switch (void 0 === opt.rowMode ? "array" : opt.rowMode) {
              case "object":
                out2.cbArg = (stmt, cache) => {
                  if (!cache.columnNames)
                    cache.columnNames = stmt.getColumnNames([]);
                  const row = stmt.get([]);
                  const rv = /* @__PURE__ */ Object.create(null);
                  for (const i2 in cache.columnNames)
                    rv[cache.columnNames[i2]] = row[i2];
                  return rv;
                };
                break;
              case "array":
                out2.cbArg = (stmt) => stmt.get([]);
                break;
              case "stmt":
                if (Array.isArray(opt.resultRows)) {
                  toss3(
                    "exec(): invalid rowMode for a resultRows array: must",
                    "be one of 'array', 'object',",
                    "a result column number, or column name reference."
                  );
                }
                out2.cbArg = (stmt) => stmt;
                break;
              default:
                if (util.isInt32(opt.rowMode)) {
                  out2.cbArg = (stmt) => stmt.get(opt.rowMode);
                  break;
                } else if ("string" === typeof opt.rowMode && opt.rowMode.length > 1 && "$" === opt.rowMode[0]) {
                  const $colName = opt.rowMode.substr(1);
                  out2.cbArg = (stmt) => {
                    const rc = stmt.get(/* @__PURE__ */ Object.create(null))[$colName];
                    return void 0 === rc ? toss3(
                      capi.SQLITE_NOTFOUND,
                      "exec(): unknown result column:",
                      $colName
                    ) : rc;
                  };
                  break;
                }
                toss3("Invalid rowMode:", opt.rowMode);
            }
          }
          return out2;
        };
        const __selectFirstRow = (db, sql2, bind, ...getArgs) => {
          const stmt = db.prepare(sql2);
          try {
            const rc = stmt.bind(bind).step() ? stmt.get(...getArgs) : void 0;
            stmt.reset();
            return rc;
          } finally {
            stmt.finalize();
          }
        };
        const __selectAll = (db, sql2, bind, rowMode) => db.exec({
          sql: sql2,
          bind,
          rowMode,
          returnValue: "resultRows"
        });
        DB.checkRc = (db, resultCode) => checkSqlite3Rc(db, resultCode);
        DB.prototype = {
          isOpen: function() {
            return !!this.pointer;
          },
          affirmOpen: function() {
            return affirmDbOpen(this);
          },
          close: function() {
            if (this.pointer) {
              if (this.onclose && this.onclose.before instanceof Function) {
                try {
                  this.onclose.before(this);
                } catch (e2) {
                }
              }
              const pDb2 = this.pointer;
              Object.keys(__stmtMap.get(this)).forEach((k2, s2) => {
                if (s2 && s2.pointer) {
                  try {
                    s2.finalize();
                  } catch (e2) {
                  }
                }
              });
              __ptrMap.delete(this);
              __stmtMap.delete(this);
              capi.sqlite3_close_v2(pDb2);
              if (this.onclose && this.onclose.after instanceof Function) {
                try {
                  this.onclose.after(this);
                } catch (e2) {
                }
              }
              delete this.filename;
            }
          },
          changes: function(total = false, sixtyFour = false) {
            const p3 = affirmDbOpen(this).pointer;
            if (total) {
              return sixtyFour ? capi.sqlite3_total_changes64(p3) : capi.sqlite3_total_changes(p3);
            } else {
              return sixtyFour ? capi.sqlite3_changes64(p3) : capi.sqlite3_changes(p3);
            }
          },
          dbFilename: function(dbName = "main") {
            return capi.sqlite3_db_filename(affirmDbOpen(this).pointer, dbName);
          },
          dbName: function(dbNumber = 0) {
            return capi.sqlite3_db_name(affirmDbOpen(this).pointer, dbNumber);
          },
          dbVfsName: function(dbName = 0) {
            let rc;
            const pVfs = capi.sqlite3_js_db_vfs(
              affirmDbOpen(this).pointer,
              dbName
            );
            if (pVfs) {
              const v3 = new capi.sqlite3_vfs(pVfs);
              try {
                rc = wasm.cstrToJs(v3.$zName);
              } finally {
                v3.dispose();
              }
            }
            return rc;
          },
          prepare: function(sql2) {
            affirmDbOpen(this);
            const stack = wasm.pstack.pointer;
            let ppStmt, pStmt;
            try {
              ppStmt = wasm.pstack.alloc(8);
              DB.checkRc(
                this,
                capi.sqlite3_prepare_v2(this.pointer, sql2, -1, ppStmt, null)
              );
              pStmt = wasm.peekPtr(ppStmt);
            } finally {
              wasm.pstack.restore(stack);
            }
            if (!pStmt)
              toss3("Cannot prepare empty SQL.");
            const stmt = new Stmt(this, pStmt, BindTypes);
            __stmtMap.get(this)[pStmt] = stmt;
            return stmt;
          },
          exec: function() {
            affirmDbOpen(this);
            const arg = parseExecArgs(this, arguments);
            if (!arg.sql) {
              return toss3("exec() requires an SQL string.");
            }
            const opt = arg.opt;
            const callback = opt.callback;
            const resultRows = Array.isArray(opt.resultRows) ? opt.resultRows : void 0;
            let stmt;
            let bind = opt.bind;
            let evalFirstResult = !!(arg.cbArg || opt.columnNames || resultRows);
            const stack = wasm.scopedAllocPush();
            const saveSql = Array.isArray(opt.saveSql) ? opt.saveSql : void 0;
            try {
              const isTA = util.isSQLableTypedArray(arg.sql);
              let sqlByteLen = isTA ? arg.sql.byteLength : wasm.jstrlen(arg.sql);
              const ppStmt = wasm.scopedAlloc(
                2 * wasm.ptrSizeof + (sqlByteLen + 1)
              );
              const pzTail = ppStmt + wasm.ptrSizeof;
              let pSql = pzTail + wasm.ptrSizeof;
              const pSqlEnd = pSql + sqlByteLen;
              if (isTA)
                wasm.heap8().set(arg.sql, pSql);
              else
                wasm.jstrcpy(arg.sql, wasm.heap8(), pSql, sqlByteLen, false);
              wasm.poke(pSql + sqlByteLen, 0);
              while (pSql && wasm.peek(pSql, "i8")) {
                wasm.pokePtr([ppStmt, pzTail], 0);
                DB.checkRc(
                  this,
                  capi.sqlite3_prepare_v3(
                    this.pointer,
                    pSql,
                    sqlByteLen,
                    0,
                    ppStmt,
                    pzTail
                  )
                );
                const pStmt = wasm.peekPtr(ppStmt);
                pSql = wasm.peekPtr(pzTail);
                sqlByteLen = pSqlEnd - pSql;
                if (!pStmt)
                  continue;
                if (saveSql)
                  saveSql.push(capi.sqlite3_sql(pStmt).trim());
                stmt = new Stmt(this, pStmt, BindTypes);
                if (bind && stmt.parameterCount) {
                  stmt.bind(bind);
                  bind = null;
                }
                if (evalFirstResult && stmt.columnCount) {
                  let gotColNames = Array.isArray(opt.columnNames) ? 0 : 1;
                  evalFirstResult = false;
                  if (arg.cbArg || resultRows) {
                    const cbArgCache = /* @__PURE__ */ Object.create(null);
                    for (; stmt.step(); stmt._lockedByExec = false) {
                      if (0 === gotColNames++) {
                        stmt.getColumnNames(
                          cbArgCache.columnNames = opt.columnNames || []
                        );
                      }
                      stmt._lockedByExec = true;
                      const row = arg.cbArg(stmt, cbArgCache);
                      if (resultRows)
                        resultRows.push(row);
                      if (callback && false === callback.call(opt, row, stmt)) {
                        break;
                      }
                    }
                    stmt._lockedByExec = false;
                  }
                  if (0 === gotColNames) {
                    stmt.getColumnNames(opt.columnNames);
                  }
                } else {
                  stmt.step();
                }
                stmt.reset().finalize();
                stmt = null;
              }
            } finally {
              wasm.scopedAllocPop(stack);
              if (stmt) {
                delete stmt._lockedByExec;
                stmt.finalize();
              }
            }
            return arg.returnVal();
          },
          createFunction: function f2(name, xFunc, opt) {
            const isFunc = (f3) => f3 instanceof Function;
            switch (arguments.length) {
              case 1:
                opt = name;
                name = opt.name;
                xFunc = opt.xFunc || 0;
                break;
              case 2:
                if (!isFunc(xFunc)) {
                  opt = xFunc;
                  xFunc = opt.xFunc || 0;
                }
                break;
              case 3:
                break;
              default:
                break;
            }
            if (!opt)
              opt = {};
            if ("string" !== typeof name) {
              toss3("Invalid arguments: missing function name.");
            }
            let xStep = opt.xStep || 0;
            let xFinal = opt.xFinal || 0;
            const xValue = opt.xValue || 0;
            const xInverse = opt.xInverse || 0;
            let isWindow = void 0;
            if (isFunc(xFunc)) {
              isWindow = false;
              if (isFunc(xStep) || isFunc(xFinal)) {
                toss3("Ambiguous arguments: scalar or aggregate?");
              }
              xStep = xFinal = null;
            } else if (isFunc(xStep)) {
              if (!isFunc(xFinal)) {
                toss3("Missing xFinal() callback for aggregate or window UDF.");
              }
              xFunc = null;
            } else if (isFunc(xFinal)) {
              toss3("Missing xStep() callback for aggregate or window UDF.");
            } else {
              toss3("Missing function-type properties.");
            }
            if (false === isWindow) {
              if (isFunc(xValue) || isFunc(xInverse)) {
                toss3(
                  "xValue and xInverse are not permitted for non-window UDFs."
                );
              }
            } else if (isFunc(xValue)) {
              if (!isFunc(xInverse)) {
                toss3("xInverse must be provided if xValue is.");
              }
              isWindow = true;
            } else if (isFunc(xInverse)) {
              toss3("xValue must be provided if xInverse is.");
            }
            const pApp = opt.pApp;
            if (void 0 !== pApp && null !== pApp && ("number" !== typeof pApp || !util.isInt32(pApp))) {
              toss3(
                "Invalid value for pApp property. Must be a legal WASM pointer value."
              );
            }
            const xDestroy = opt.xDestroy || 0;
            if (xDestroy && !isFunc(xDestroy)) {
              toss3("xDestroy property must be a function.");
            }
            let fFlags = 0;
            if (getOwnOption(opt, "deterministic"))
              fFlags |= capi.SQLITE_DETERMINISTIC;
            if (getOwnOption(opt, "directOnly"))
              fFlags |= capi.SQLITE_DIRECTONLY;
            if (getOwnOption(opt, "innocuous"))
              fFlags |= capi.SQLITE_INNOCUOUS;
            name = name.toLowerCase();
            const xArity = xFunc || xStep;
            const arity = getOwnOption(opt, "arity");
            const arityArg = "number" === typeof arity ? arity : xArity.length ? xArity.length - 1 : 0;
            let rc;
            if (isWindow) {
              rc = capi.sqlite3_create_window_function(
                this.pointer,
                name,
                arityArg,
                capi.SQLITE_UTF8 | fFlags,
                pApp || 0,
                xStep,
                xFinal,
                xValue,
                xInverse,
                xDestroy
              );
            } else {
              rc = capi.sqlite3_create_function_v2(
                this.pointer,
                name,
                arityArg,
                capi.SQLITE_UTF8 | fFlags,
                pApp || 0,
                xFunc,
                xStep,
                xFinal,
                xDestroy
              );
            }
            DB.checkRc(this, rc);
            return this;
          },
          selectValue: function(sql2, bind, asType) {
            return __selectFirstRow(this, sql2, bind, 0, asType);
          },
          selectValues: function(sql2, bind, asType) {
            const stmt = this.prepare(sql2), rc = [];
            try {
              stmt.bind(bind);
              while (stmt.step())
                rc.push(stmt.get(0, asType));
              stmt.reset();
            } finally {
              stmt.finalize();
            }
            return rc;
          },
          selectArray: function(sql2, bind) {
            return __selectFirstRow(this, sql2, bind, []);
          },
          selectObject: function(sql2, bind) {
            return __selectFirstRow(this, sql2, bind, {});
          },
          selectArrays: function(sql2, bind) {
            return __selectAll(this, sql2, bind, "array");
          },
          selectObjects: function(sql2, bind) {
            return __selectAll(this, sql2, bind, "object");
          },
          openStatementCount: function() {
            return this.pointer ? Object.keys(__stmtMap.get(this)).length : 0;
          },
          transaction: function(callback) {
            let opener = "BEGIN";
            if (arguments.length > 1) {
              if (/[^a-zA-Z]/.test(arguments[0])) {
                toss3(
                  capi.SQLITE_MISUSE,
                  "Invalid argument for BEGIN qualifier."
                );
              }
              opener += " " + arguments[0];
              callback = arguments[1];
            }
            affirmDbOpen(this).exec(opener);
            try {
              const rc = callback(this);
              this.exec("COMMIT");
              return rc;
            } catch (e2) {
              this.exec("ROLLBACK");
              throw e2;
            }
          },
          savepoint: function(callback) {
            affirmDbOpen(this).exec("SAVEPOINT oo1");
            try {
              const rc = callback(this);
              this.exec("RELEASE oo1");
              return rc;
            } catch (e2) {
              this.exec("ROLLBACK to SAVEPOINT oo1; RELEASE SAVEPOINT oo1");
              throw e2;
            }
          },
          checkRc: function(resultCode) {
            return checkSqlite3Rc(this, resultCode);
          }
        };
        const affirmStmtOpen = function(stmt) {
          if (!stmt.pointer)
            toss3("Stmt has been closed.");
          return stmt;
        };
        const isSupportedBindType = function(v3) {
          let t2 = BindTypes[null === v3 || void 0 === v3 ? "null" : typeof v3];
          switch (t2) {
            case BindTypes.boolean:
            case BindTypes.null:
            case BindTypes.number:
            case BindTypes.string:
              return t2;
            case BindTypes.bigint:
              if (wasm.bigIntEnabled)
                return t2;
            default:
              return util.isBindableTypedArray(v3) ? BindTypes.blob : void 0;
          }
        };
        const affirmSupportedBindType = function(v3) {
          return isSupportedBindType(v3) || toss3("Unsupported bind() argument type:", typeof v3);
        };
        const affirmParamIndex = function(stmt, key) {
          const n2 = "number" === typeof key ? key : capi.sqlite3_bind_parameter_index(stmt.pointer, key);
          if (0 === n2 || !util.isInt32(n2)) {
            toss3("Invalid bind() parameter name: " + key);
          } else if (n2 < 1 || n2 > stmt.parameterCount)
            toss3("Bind index", key, "is out of range.");
          return n2;
        };
        const affirmNotLockedByExec = function(stmt, currentOpName) {
          if (stmt._lockedByExec) {
            toss3(
              "Operation is illegal when statement is locked:",
              currentOpName
            );
          }
          return stmt;
        };
        const bindOne = function f2(stmt, ndx, bindType, val) {
          affirmNotLockedByExec(affirmStmtOpen(stmt), "bind()");
          if (!f2._) {
            f2._tooBigInt = (v3) => toss3(
              "BigInt value is too big to store without precision loss:",
              v3
            );
            f2._ = {
              string: function(stmt2, ndx2, val2, asBlob) {
                const [pStr, n2] = wasm.allocCString(val2, true);
                const f3 = asBlob ? capi.sqlite3_bind_blob : capi.sqlite3_bind_text;
                return f3(stmt2.pointer, ndx2, pStr, n2, capi.SQLITE_WASM_DEALLOC);
              }
            };
          }
          affirmSupportedBindType(val);
          ndx = affirmParamIndex(stmt, ndx);
          let rc = 0;
          switch (null === val || void 0 === val ? BindTypes.null : bindType) {
            case BindTypes.null:
              rc = capi.sqlite3_bind_null(stmt.pointer, ndx);
              break;
            case BindTypes.string:
              rc = f2._.string(stmt, ndx, val, false);
              break;
            case BindTypes.number: {
              let m2;
              if (util.isInt32(val))
                m2 = capi.sqlite3_bind_int;
              else if ("bigint" === typeof val) {
                if (!util.bigIntFits64(val)) {
                  f2._tooBigInt(val);
                } else if (wasm.bigIntEnabled) {
                  m2 = capi.sqlite3_bind_int64;
                } else if (util.bigIntFitsDouble(val)) {
                  val = Number(val);
                  m2 = capi.sqlite3_bind_double;
                } else {
                  f2._tooBigInt(val);
                }
              } else {
                val = Number(val);
                if (wasm.bigIntEnabled && Number.isInteger(val)) {
                  m2 = capi.sqlite3_bind_int64;
                } else {
                  m2 = capi.sqlite3_bind_double;
                }
              }
              rc = m2(stmt.pointer, ndx, val);
              break;
            }
            case BindTypes.boolean:
              rc = capi.sqlite3_bind_int(stmt.pointer, ndx, val ? 1 : 0);
              break;
            case BindTypes.blob: {
              if ("string" === typeof val) {
                rc = f2._.string(stmt, ndx, val, true);
                break;
              } else if (val instanceof ArrayBuffer) {
                val = new Uint8Array(val);
              } else if (!util.isBindableTypedArray(val)) {
                toss3(
                  "Binding a value as a blob requires",
                  "that it be a string, Uint8Array, Int8Array, or ArrayBuffer."
                );
              }
              const pBlob = wasm.alloc(val.byteLength || 1);
              wasm.heap8().set(val.byteLength ? val : [0], pBlob);
              rc = capi.sqlite3_bind_blob(
                stmt.pointer,
                ndx,
                pBlob,
                val.byteLength,
                capi.SQLITE_WASM_DEALLOC
              );
              break;
            }
            default:
              sqlite32.config.warn("Unsupported bind() argument type:", val);
              toss3("Unsupported bind() argument type: " + typeof val);
          }
          if (rc)
            DB.checkRc(stmt.db.pointer, rc);
          stmt._mayGet = false;
          return stmt;
        };
        Stmt.prototype = {
          finalize: function() {
            if (this.pointer) {
              affirmNotLockedByExec(this, "finalize()");
              const rc = capi.sqlite3_finalize(this.pointer);
              delete __stmtMap.get(this.db)[this.pointer];
              __ptrMap.delete(this);
              delete this._mayGet;
              delete this.parameterCount;
              delete this._lockedByExec;
              delete this.db;
              return rc;
            }
          },
          clearBindings: function() {
            affirmNotLockedByExec(affirmStmtOpen(this), "clearBindings()");
            capi.sqlite3_clear_bindings(this.pointer);
            this._mayGet = false;
            return this;
          },
          reset: function(alsoClearBinds) {
            affirmNotLockedByExec(this, "reset()");
            if (alsoClearBinds)
              this.clearBindings();
            const rc = capi.sqlite3_reset(affirmStmtOpen(this).pointer);
            this._mayGet = false;
            checkSqlite3Rc(this.db, rc);
            return this;
          },
          bind: function() {
            affirmStmtOpen(this);
            let ndx, arg;
            switch (arguments.length) {
              case 1:
                ndx = 1;
                arg = arguments[0];
                break;
              case 2:
                ndx = arguments[0];
                arg = arguments[1];
                break;
              default:
                toss3("Invalid bind() arguments.");
            }
            if (void 0 === arg) {
              return this;
            } else if (!this.parameterCount) {
              toss3("This statement has no bindable parameters.");
            }
            this._mayGet = false;
            if (null === arg) {
              return bindOne(this, ndx, BindTypes.null, arg);
            } else if (Array.isArray(arg)) {
              if (1 !== arguments.length) {
                toss3(
                  "When binding an array, an index argument is not permitted."
                );
              }
              arg.forEach(
                (v3, i2) => bindOne(this, i2 + 1, affirmSupportedBindType(v3), v3)
              );
              return this;
            } else if (arg instanceof ArrayBuffer) {
              arg = new Uint8Array(arg);
            }
            if ("object" === typeof arg && !util.isBindableTypedArray(arg)) {
              if (1 !== arguments.length) {
                toss3(
                  "When binding an object, an index argument is not permitted."
                );
              }
              Object.keys(arg).forEach(
                (k2) => bindOne(this, k2, affirmSupportedBindType(arg[k2]), arg[k2])
              );
              return this;
            } else {
              return bindOne(this, ndx, affirmSupportedBindType(arg), arg);
            }
            toss3("Should not reach this point.");
          },
          bindAsBlob: function(ndx, arg) {
            affirmStmtOpen(this);
            if (1 === arguments.length) {
              arg = ndx;
              ndx = 1;
            }
            const t2 = affirmSupportedBindType(arg);
            if (BindTypes.string !== t2 && BindTypes.blob !== t2 && BindTypes.null !== t2) {
              toss3("Invalid value type for bindAsBlob()");
            }
            return bindOne(this, ndx, BindTypes.blob, arg);
          },
          step: function() {
            affirmNotLockedByExec(this, "step()");
            const rc = capi.sqlite3_step(affirmStmtOpen(this).pointer);
            switch (rc) {
              case capi.SQLITE_DONE:
                return this._mayGet = false;
              case capi.SQLITE_ROW:
                return this._mayGet = true;
              default:
                this._mayGet = false;
                sqlite32.config.warn(
                  "sqlite3_step() rc=",
                  rc,
                  capi.sqlite3_js_rc_str(rc),
                  "SQL =",
                  capi.sqlite3_sql(this.pointer)
                );
                DB.checkRc(this.db.pointer, rc);
            }
          },
          stepReset: function() {
            this.step();
            return this.reset();
          },
          stepFinalize: function() {
            try {
              const rc = this.step();
              this.reset();
              return rc;
            } finally {
              try {
                this.finalize();
              } catch (e2) {
              }
            }
          },
          get: function(ndx, asType) {
            if (!affirmStmtOpen(this)._mayGet) {
              toss3("Stmt.step() has not (recently) returned true.");
            }
            if (Array.isArray(ndx)) {
              let i2 = 0;
              const n2 = this.columnCount;
              while (i2 < n2) {
                ndx[i2] = this.get(i2++);
              }
              return ndx;
            } else if (ndx && "object" === typeof ndx) {
              let i2 = 0;
              const n2 = this.columnCount;
              while (i2 < n2) {
                ndx[capi.sqlite3_column_name(this.pointer, i2)] = this.get(i2++);
              }
              return ndx;
            }
            affirmColIndex(this, ndx);
            switch (void 0 === asType ? capi.sqlite3_column_type(this.pointer, ndx) : asType) {
              case capi.SQLITE_NULL:
                return null;
              case capi.SQLITE_INTEGER: {
                if (wasm.bigIntEnabled) {
                  const rc = capi.sqlite3_column_int64(this.pointer, ndx);
                  if (rc >= Number.MIN_SAFE_INTEGER && rc <= Number.MAX_SAFE_INTEGER) {
                    return Number(rc).valueOf();
                  }
                  return rc;
                } else {
                  const rc = capi.sqlite3_column_double(this.pointer, ndx);
                  if (rc > Number.MAX_SAFE_INTEGER || rc < Number.MIN_SAFE_INTEGER) {
                    toss3(
                      "Integer is out of range for JS integer range: " + rc
                    );
                  }
                  return util.isInt32(rc) ? rc | 0 : rc;
                }
              }
              case capi.SQLITE_FLOAT:
                return capi.sqlite3_column_double(this.pointer, ndx);
              case capi.SQLITE_TEXT:
                return capi.sqlite3_column_text(this.pointer, ndx);
              case capi.SQLITE_BLOB: {
                const n2 = capi.sqlite3_column_bytes(this.pointer, ndx), ptr = capi.sqlite3_column_blob(this.pointer, ndx), rc = new Uint8Array(n2);
                if (n2)
                  rc.set(wasm.heap8u().slice(ptr, ptr + n2), 0);
                if (n2 && this.db._blobXfer instanceof Array) {
                  this.db._blobXfer.push(rc.buffer);
                }
                return rc;
              }
              default:
                toss3(
                  "Don't know how to translate",
                  "type of result column #" + ndx + "."
                );
            }
            toss3("Not reached.");
          },
          getInt: function(ndx) {
            return this.get(ndx, capi.SQLITE_INTEGER);
          },
          getFloat: function(ndx) {
            return this.get(ndx, capi.SQLITE_FLOAT);
          },
          getString: function(ndx) {
            return this.get(ndx, capi.SQLITE_TEXT);
          },
          getBlob: function(ndx) {
            return this.get(ndx, capi.SQLITE_BLOB);
          },
          getJSON: function(ndx) {
            const s2 = this.get(ndx, capi.SQLITE_STRING);
            return null === s2 ? s2 : JSON.parse(s2);
          },
          getColumnName: function(ndx) {
            return capi.sqlite3_column_name(
              affirmColIndex(affirmStmtOpen(this), ndx).pointer,
              ndx
            );
          },
          getColumnNames: function(tgt = []) {
            affirmColIndex(affirmStmtOpen(this), 0);
            const n2 = this.columnCount;
            for (let i2 = 0; i2 < n2; ++i2) {
              tgt.push(capi.sqlite3_column_name(this.pointer, i2));
            }
            return tgt;
          },
          getParamIndex: function(name) {
            return affirmStmtOpen(this).parameterCount ? capi.sqlite3_bind_parameter_index(this.pointer, name) : void 0;
          },
          getParamName: function(ndx) {
            return affirmStmtOpen(this).parameterCount ? capi.sqlite3_bind_parameter_name(this.pointer, ndx) : void 0;
          },
          isBusy: function() {
            return 0 !== capi.sqlite3_stmt_busy(affirmStmtOpen(this));
          },
          isReadOnly: function() {
            return 0 !== capi.sqlite3_stmt_readonly(affirmStmtOpen(this));
          }
        };
        {
          const prop = {
            enumerable: true,
            get: function() {
              return __ptrMap.get(this);
            },
            set: () => toss3("The pointer property is read-only.")
          };
          Object.defineProperty(Stmt.prototype, "pointer", prop);
          Object.defineProperty(DB.prototype, "pointer", prop);
        }
        Object.defineProperty(Stmt.prototype, "columnCount", {
          enumerable: false,
          get: function() {
            return capi.sqlite3_column_count(this.pointer);
          },
          set: () => toss3("The columnCount property is read-only.")
        });
        sqlite32.oo1 = {
          DB,
          Stmt
        };
        if (util.isUIThread()) {
          sqlite32.oo1.JsStorageDb = function(storageName = "session") {
            const opt = dbCtorHelper.normalizeArgs(...arguments);
            storageName = opt.filename;
            if ("session" !== storageName && "local" !== storageName) {
              toss3("JsStorageDb db name must be one of 'session' or 'local'.");
            }
            opt.vfs = "kvvfs";
            dbCtorHelper.call(this, opt);
          };
          const jdb = sqlite32.oo1.JsStorageDb;
          jdb.prototype = Object.create(DB.prototype);
          jdb.clearStorage = capi.sqlite3_js_kvvfs_clear;
          jdb.prototype.clearStorage = function() {
            return jdb.clearStorage(affirmDbOpen(this).filename);
          };
          jdb.storageSize = capi.sqlite3_js_kvvfs_size;
          jdb.prototype.storageSize = function() {
            return jdb.storageSize(affirmDbOpen(this).filename);
          };
        }
      });
      globalThis.sqlite3ApiBootstrap.initializers.push(function(sqlite32) {
        const util = sqlite32.util;
        sqlite32.initWorker1API = function() {
          "use strict";
          const toss = (...args) => {
            throw new Error(args.join(" "));
          };
          if (!(globalThis.WorkerGlobalScope instanceof Function)) {
            toss("initWorker1API() must be run from a Worker thread.");
          }
          const sqlite33 = this.sqlite3 || toss("Missing this.sqlite3 object.");
          const DB = sqlite33.oo1.DB;
          const getDbId = function(db) {
            let id = wState.idMap.get(db);
            if (id)
              return id;
            id = "db#" + ++wState.idSeq + "@" + db.pointer;
            wState.idMap.set(db, id);
            return id;
          };
          const wState = {
            dbList: [],
            idSeq: 0,
            idMap: /* @__PURE__ */ new WeakMap(),
            xfer: [],
            open: function(opt) {
              const db = new DB(opt);
              this.dbs[getDbId(db)] = db;
              if (this.dbList.indexOf(db) < 0)
                this.dbList.push(db);
              return db;
            },
            close: function(db, alsoUnlink) {
              if (db) {
                delete this.dbs[getDbId(db)];
                const filename = db.filename;
                const pVfs = util.sqlite3__wasm_db_vfs(db.pointer, 0);
                db.close();
                const ddNdx = this.dbList.indexOf(db);
                if (ddNdx >= 0)
                  this.dbList.splice(ddNdx, 1);
                if (alsoUnlink && filename && pVfs) {
                  util.sqlite3__wasm_vfs_unlink(pVfs, filename);
                }
              }
            },
            post: function(msg, xferList) {
              if (xferList && xferList.length) {
                globalThis.postMessage(msg, Array.from(xferList));
                xferList.length = 0;
              } else {
                globalThis.postMessage(msg);
              }
            },
            dbs: /* @__PURE__ */ Object.create(null),
            getDb: function(id, require2 = true) {
              return this.dbs[id] || (require2 ? toss("Unknown (or closed) DB ID:", id) : void 0);
            }
          };
          const affirmDbOpen = function(db = wState.dbList[0]) {
            return db && db.pointer ? db : toss("DB is not opened.");
          };
          const getMsgDb = function(msgData, affirmExists = true) {
            const db = wState.getDb(msgData.dbId, false) || wState.dbList[0];
            return affirmExists ? affirmDbOpen(db) : db;
          };
          const getDefaultDbId = function() {
            return wState.dbList[0] && getDbId(wState.dbList[0]);
          };
          const isSpecialDbFilename = (n2) => {
            return "" === n2 || ":" === n2[0];
          };
          const wMsgHandler = {
            open: function(ev) {
              const oargs = /* @__PURE__ */ Object.create(null), args = ev.args || /* @__PURE__ */ Object.create(null);
              if (args.simulateError) {
                toss("Throwing because of simulateError flag.");
              }
              const rc = /* @__PURE__ */ Object.create(null);
              oargs.vfs = args.vfs;
              oargs.filename = args.filename || "";
              const db = wState.open(oargs);
              rc.filename = db.filename;
              rc.persistent = !!sqlite33.capi.sqlite3_js_db_uses_vfs(
                db.pointer,
                "opfs"
              );
              rc.dbId = getDbId(db);
              rc.vfs = db.dbVfsName();
              return rc;
            },
            close: function(ev) {
              const db = getMsgDb(ev, false);
              const response = {
                filename: db && db.filename
              };
              if (db) {
                const doUnlink = ev.args && "object" === typeof ev.args ? !!ev.args.unlink : false;
                wState.close(db, doUnlink);
              }
              return response;
            },
            exec: function(ev) {
              const rc = "string" === typeof ev.args ? { sql: ev.args } : ev.args || /* @__PURE__ */ Object.create(null);
              if ("stmt" === rc.rowMode) {
                toss(
                  "Invalid rowMode for 'exec': stmt mode",
                  "does not work in the Worker API."
                );
              } else if (!rc.sql) {
                toss("'exec' requires input SQL.");
              }
              const db = getMsgDb(ev);
              if (rc.callback || Array.isArray(rc.resultRows)) {
                db._blobXfer = wState.xfer;
              }
              const theCallback = rc.callback;
              let rowNumber = 0;
              const hadColNames = !!rc.columnNames;
              if ("string" === typeof theCallback) {
                if (!hadColNames)
                  rc.columnNames = [];
                rc.callback = function(row, stmt) {
                  wState.post(
                    {
                      type: theCallback,
                      columnNames: rc.columnNames,
                      rowNumber: ++rowNumber,
                      row
                    },
                    wState.xfer
                  );
                };
              }
              try {
                const changeCount = !!rc.countChanges ? db.changes(true, 64 === rc.countChanges) : void 0;
                db.exec(rc);
                if (void 0 !== changeCount) {
                  rc.changeCount = db.changes(true, 64 === rc.countChanges) - changeCount;
                }
                if (rc.callback instanceof Function) {
                  rc.callback = theCallback;
                  wState.post({
                    type: theCallback,
                    columnNames: rc.columnNames,
                    rowNumber: null,
                    row: void 0
                  });
                }
              } finally {
                delete db._blobXfer;
                if (rc.callback)
                  rc.callback = theCallback;
              }
              return rc;
            },
            "config-get": function() {
              const rc = /* @__PURE__ */ Object.create(null), src2 = sqlite33.config;
              ["bigIntEnabled"].forEach(function(k2) {
                if (Object.getOwnPropertyDescriptor(src2, k2))
                  rc[k2] = src2[k2];
              });
              rc.version = sqlite33.version;
              rc.vfsList = sqlite33.capi.sqlite3_js_vfs_list();
              return rc;
            },
            export: function(ev) {
              const db = getMsgDb(ev);
              const response = {
                byteArray: sqlite33.capi.sqlite3_js_db_export(db.pointer),
                filename: db.filename,
                mimetype: "application/x-sqlite3"
              };
              wState.xfer.push(response.byteArray.buffer);
              return response;
            },
            toss: function(ev) {
              toss("Testing worker exception");
            }
          };
          globalThis.onmessage = async function(ev) {
            ev = ev.data;
            let result, dbId = ev.dbId, evType = ev.type;
            const arrivalTime = performance.now();
            try {
              if (wMsgHandler.hasOwnProperty(evType) && wMsgHandler[evType] instanceof Function) {
                result = await wMsgHandler[evType](ev);
              } else {
                toss("Unknown db worker message type:", ev.type);
              }
            } catch (err2) {
              evType = "error";
              result = {
                operation: ev.type,
                message: err2.message,
                errorClass: err2.name,
                input: ev
              };
              if (err2.stack) {
                result.stack = "string" === typeof err2.stack ? err2.stack.split(/\n\s*/) : err2.stack;
              }
              if (0)
                sqlite33.config.warn(
                  "Worker is propagating an exception to main thread.",
                  "Reporting it _here_ for the stack trace:",
                  err2,
                  result
                );
            }
            if (!dbId) {
              dbId = result.dbId || getDefaultDbId();
            }
            wState.post(
              {
                type: evType,
                dbId,
                messageId: ev.messageId,
                workerReceivedTime: arrivalTime,
                workerRespondTime: performance.now(),
                departureTime: ev.departureTime,
                result
              },
              wState.xfer
            );
          };
          globalThis.postMessage({
            type: "sqlite3-api",
            result: "worker1-ready"
          });
        }.bind({ sqlite3: sqlite32 });
      });
      "use strict";
      globalThis.sqlite3ApiBootstrap.initializers.push(function(sqlite32) {
        const wasm = sqlite32.wasm, capi = sqlite32.capi, toss = sqlite32.util.toss3;
        const vfs = /* @__PURE__ */ Object.create(null);
        sqlite32.vfs = vfs;
        capi.sqlite3_vfs.prototype.registerVfs = function(asDefault = false) {
          if (!(this instanceof sqlite32.capi.sqlite3_vfs)) {
            toss("Expecting a sqlite3_vfs-type argument.");
          }
          const rc = capi.sqlite3_vfs_register(this, asDefault ? 1 : 0);
          if (rc) {
            toss("sqlite3_vfs_register(", this, ") failed with rc", rc);
          }
          if (this.pointer !== capi.sqlite3_vfs_find(this.$zName)) {
            toss(
              "BUG: sqlite3_vfs_find(vfs.$zName) failed for just-installed VFS",
              this
            );
          }
          return this;
        };
        vfs.installVfs = function(opt) {
          let count = 0;
          const propList = ["io", "vfs"];
          for (const key of propList) {
            const o = opt[key];
            if (o) {
              ++count;
              o.struct.installMethods(o.methods, !!o.applyArgcCheck);
              if ("vfs" === key) {
                if (!o.struct.$zName && "string" === typeof o.name) {
                  o.struct.addOnDispose(
                    o.struct.$zName = wasm.allocCString(o.name)
                  );
                }
                o.struct.registerVfs(!!o.asDefault);
              }
            }
          }
          if (!count)
            toss(
              "Misuse: installVfs() options object requires at least",
              "one of:",
              propList
            );
          return this;
        };
      });
      "use strict";
      globalThis.sqlite3ApiBootstrap.initializers.push(function(sqlite32) {
        if (!sqlite32.wasm.exports.sqlite3_declare_vtab) {
          return;
        }
        const wasm = sqlite32.wasm, capi = sqlite32.capi, toss = sqlite32.util.toss3;
        const vtab = /* @__PURE__ */ Object.create(null);
        sqlite32.vtab = vtab;
        const sii = capi.sqlite3_index_info;
        sii.prototype.nthConstraint = function(n2, asPtr = false) {
          if (n2 < 0 || n2 >= this.$nConstraint)
            return false;
          const ptr = this.$aConstraint + sii.sqlite3_index_constraint.structInfo.sizeof * n2;
          return asPtr ? ptr : new sii.sqlite3_index_constraint(ptr);
        };
        sii.prototype.nthConstraintUsage = function(n2, asPtr = false) {
          if (n2 < 0 || n2 >= this.$nConstraint)
            return false;
          const ptr = this.$aConstraintUsage + sii.sqlite3_index_constraint_usage.structInfo.sizeof * n2;
          return asPtr ? ptr : new sii.sqlite3_index_constraint_usage(ptr);
        };
        sii.prototype.nthOrderBy = function(n2, asPtr = false) {
          if (n2 < 0 || n2 >= this.$nOrderBy)
            return false;
          const ptr = this.$aOrderBy + sii.sqlite3_index_orderby.structInfo.sizeof * n2;
          return asPtr ? ptr : new sii.sqlite3_index_orderby(ptr);
        };
        const __xWrapFactory = function(methodName, StructType) {
          return function(ptr, removeMapping = false) {
            if (0 === arguments.length)
              ptr = new StructType();
            if (ptr instanceof StructType) {
              this.set(ptr.pointer, ptr);
              return ptr;
            } else if (!wasm.isPtr(ptr)) {
              sqlite32.SQLite3Error.toss(
                "Invalid argument to",
                methodName + "()"
              );
            }
            let rc = this.get(ptr);
            if (removeMapping)
              this.delete(ptr);
            return rc;
          }.bind(/* @__PURE__ */ new Map());
        };
        const StructPtrMapper = function(name, StructType) {
          const __xWrap = __xWrapFactory(name, StructType);
          return Object.assign(/* @__PURE__ */ Object.create(null), {
            StructType,
            create: (ppOut) => {
              const rc = __xWrap();
              wasm.pokePtr(ppOut, rc.pointer);
              return rc;
            },
            get: (pCObj) => __xWrap(pCObj),
            unget: (pCObj) => __xWrap(pCObj, true),
            dispose: (pCObj) => {
              const o = __xWrap(pCObj, true);
              if (o)
                o.dispose();
            }
          });
        };
        vtab.xVtab = StructPtrMapper("xVtab", capi.sqlite3_vtab);
        vtab.xCursor = StructPtrMapper("xCursor", capi.sqlite3_vtab_cursor);
        vtab.xIndexInfo = (pIdxInfo) => new capi.sqlite3_index_info(pIdxInfo);
        vtab.xError = function f2(methodName, err2, defaultRc) {
          if (f2.errorReporter instanceof Function) {
            try {
              f2.errorReporter(
                "sqlite3_module::" + methodName + "(): " + err2.message
              );
            } catch (e2) {
            }
          }
          let rc;
          if (err2 instanceof sqlite32.WasmAllocError)
            rc = capi.SQLITE_NOMEM;
          else if (arguments.length > 2)
            rc = defaultRc;
          else if (err2 instanceof sqlite32.SQLite3Error)
            rc = err2.resultCode;
          return rc || capi.SQLITE_ERROR;
        };
        vtab.xError.errorReporter = 1 ? console.error.bind(console) : false;
        vtab.xRowid = (ppRowid64, value) => wasm.poke(ppRowid64, value, "i64");
        vtab.setupModule = function(opt) {
          let createdMod = false;
          const mod = this instanceof capi.sqlite3_module ? this : opt.struct || (createdMod = new capi.sqlite3_module());
          try {
            const methods = opt.methods || toss("Missing 'methods' object.");
            for (const e2 of Object.entries({
              xConnect: "xCreate",
              xDisconnect: "xDestroy"
            })) {
              const k2 = e2[0], v3 = e2[1];
              if (true === methods[k2])
                methods[k2] = methods[v3];
              else if (true === methods[v3])
                methods[v3] = methods[k2];
            }
            if (opt.catchExceptions) {
              const fwrap = function(methodName, func) {
                if (["xConnect", "xCreate"].indexOf(methodName) >= 0) {
                  return function(pDb2, pAux, argc, argv2, ppVtab, pzErr) {
                    try {
                      return func(...arguments) || 0;
                    } catch (e2) {
                      if (!(e2 instanceof sqlite32.WasmAllocError)) {
                        wasm.dealloc(wasm.peekPtr(pzErr));
                        wasm.pokePtr(pzErr, wasm.allocCString(e2.message));
                      }
                      return vtab.xError(methodName, e2);
                    }
                  };
                } else {
                  return function(...args) {
                    try {
                      return func(...args) || 0;
                    } catch (e2) {
                      return vtab.xError(methodName, e2);
                    }
                  };
                }
              };
              const mnames = [
                "xCreate",
                "xConnect",
                "xBestIndex",
                "xDisconnect",
                "xDestroy",
                "xOpen",
                "xClose",
                "xFilter",
                "xNext",
                "xEof",
                "xColumn",
                "xRowid",
                "xUpdate",
                "xBegin",
                "xSync",
                "xCommit",
                "xRollback",
                "xFindFunction",
                "xRename",
                "xSavepoint",
                "xRelease",
                "xRollbackTo",
                "xShadowName"
              ];
              const remethods = /* @__PURE__ */ Object.create(null);
              for (const k2 of mnames) {
                const m2 = methods[k2];
                if (!(m2 instanceof Function))
                  continue;
                else if ("xConnect" === k2 && methods.xCreate === m2) {
                  remethods[k2] = methods.xCreate;
                } else if ("xCreate" === k2 && methods.xConnect === m2) {
                  remethods[k2] = methods.xConnect;
                } else {
                  remethods[k2] = fwrap(k2, m2);
                }
              }
              mod.installMethods(remethods, false);
            } else {
              mod.installMethods(methods, !!opt.applyArgcCheck);
            }
            if (0 === mod.$iVersion) {
              let v3;
              if ("number" === typeof opt.iVersion)
                v3 = opt.iVersion;
              else if (mod.$xShadowName)
                v3 = 3;
              else if (mod.$xSavePoint || mod.$xRelease || mod.$xRollbackTo)
                v3 = 2;
              else
                v3 = 1;
              mod.$iVersion = v3;
            }
          } catch (e2) {
            if (createdMod)
              createdMod.dispose();
            throw e2;
          }
          return mod;
        };
        capi.sqlite3_module.prototype.setupModule = function(opt) {
          return vtab.setupModule.call(this, opt);
        };
      });
      "use strict";
      globalThis.sqlite3ApiBootstrap.initializers.push(function(sqlite32) {
        const installOpfsVfs = function callee2(options) {
          var _a8;
          if (!globalThis.SharedArrayBuffer || !globalThis.Atomics) {
            return Promise.reject(
              new Error(
                "Cannot install OPFS: Missing SharedArrayBuffer and/or Atomics. The server must emit the COOP/COEP response headers to enable those. See https://sqlite.org/wasm/doc/trunk/persistence.md#coop-coep"
              )
            );
          } else if ("undefined" === typeof WorkerGlobalScope) {
            return Promise.reject(
              new Error(
                "The OPFS sqlite3_vfs cannot run in the main thread because it requires Atomics.wait()."
              )
            );
          } else if (!globalThis.FileSystemHandle || !globalThis.FileSystemDirectoryHandle || !globalThis.FileSystemFileHandle || !globalThis.FileSystemFileHandle.prototype.createSyncAccessHandle || !((_a8 = navigator == null ? void 0 : navigator.storage) == null ? void 0 : _a8.getDirectory)) {
            return Promise.reject(new Error("Missing required OPFS APIs."));
          }
          if (!options || "object" !== typeof options) {
            options = /* @__PURE__ */ Object.create(null);
          }
          const urlParams = new URL(globalThis.location.href).searchParams;
          if (urlParams.has("opfs-disable")) {
            return Promise.resolve(sqlite32);
          }
          if (void 0 === options.verbose) {
            options.verbose = urlParams.has("opfs-verbose") ? +urlParams.get("opfs-verbose") || 2 : 1;
          }
          if (void 0 === options.sanityChecks) {
            options.sanityChecks = urlParams.has("opfs-sanity-check");
          }
          if (void 0 === options.proxyUri) {
            options.proxyUri = callee2.defaultProxyUri;
          }
          if ("function" === typeof options.proxyUri) {
            options.proxyUri = options.proxyUri();
          }
          const thePromise = new Promise(function(promiseResolve_, promiseReject_) {
            const loggers = [
              sqlite32.config.error,
              sqlite32.config.warn,
              sqlite32.config.log
            ];
            const logImpl = (level, ...args) => {
              if (options.verbose > level)
                loggers[level]("OPFS syncer:", ...args);
            };
            const log2 = (...args) => logImpl(2, ...args);
            const warn = (...args) => logImpl(1, ...args);
            const error = (...args) => logImpl(0, ...args);
            const toss = sqlite32.util.toss;
            const capi = sqlite32.capi;
            const util = sqlite32.util;
            const wasm = sqlite32.wasm;
            const sqlite3_vfs = capi.sqlite3_vfs;
            const sqlite3_file = capi.sqlite3_file;
            const sqlite3_io_methods = capi.sqlite3_io_methods;
            const opfsUtil = /* @__PURE__ */ Object.create(null);
            const thisThreadHasOPFS = () => {
              var _a9;
              return globalThis.FileSystemHandle && globalThis.FileSystemDirectoryHandle && globalThis.FileSystemFileHandle && globalThis.FileSystemFileHandle.prototype.createSyncAccessHandle && ((_a9 = navigator == null ? void 0 : navigator.storage) == null ? void 0 : _a9.getDirectory);
            };
            opfsUtil.metrics = {
              dump: function() {
                let k2, n2 = 0, t2 = 0, w2 = 0;
                for (k2 in state.opIds) {
                  const m2 = metrics[k2];
                  n2 += m2.count;
                  t2 += m2.time;
                  w2 += m2.wait;
                  m2.avgTime = m2.count && m2.time ? m2.time / m2.count : 0;
                  m2.avgWait = m2.count && m2.wait ? m2.wait / m2.count : 0;
                }
                sqlite32.config.log(
                  globalThis.location.href,
                  "metrics for",
                  globalThis.location.href,
                  ":",
                  metrics,
                  "\nTotal of",
                  n2,
                  "op(s) for",
                  t2,
                  "ms (incl. " + w2 + " ms of waiting on the async side)"
                );
                sqlite32.config.log("Serialization metrics:", metrics.s11n);
                W2.postMessage({ type: "opfs-async-metrics" });
              },
              reset: function() {
                let k2;
                const r3 = (m2) => m2.count = m2.time = m2.wait = 0;
                for (k2 in state.opIds) {
                  r3(metrics[k2] = /* @__PURE__ */ Object.create(null));
                }
                let s2 = metrics.s11n = /* @__PURE__ */ Object.create(null);
                s2 = s2.serialize = /* @__PURE__ */ Object.create(null);
                s2.count = s2.time = 0;
                s2 = metrics.s11n.deserialize = /* @__PURE__ */ Object.create(null);
                s2.count = s2.time = 0;
              }
            };
            const opfsIoMethods = new sqlite3_io_methods();
            const opfsVfs = new sqlite3_vfs().addOnDispose(
              () => opfsIoMethods.dispose()
            );
            let promiseWasRejected = void 0;
            const promiseReject = (err2) => {
              promiseWasRejected = true;
              opfsVfs.dispose();
              return promiseReject_(err2);
            };
            const promiseResolve = () => {
              promiseWasRejected = false;
              return promiseResolve_(sqlite32);
            };
            const W2 = new Worker(
              new URL("sqlite3-opfs-async-proxy.js", import.meta.url)
            );
            setTimeout(() => {
              if (void 0 === promiseWasRejected) {
                promiseReject(
                  new Error(
                    "Timeout while waiting for OPFS async proxy worker."
                  )
                );
              }
            }, 4e3);
            W2._originalOnError = W2.onerror;
            W2.onerror = function(err2) {
              error("Error initializing OPFS asyncer:", err2);
              promiseReject(
                new Error(
                  "Loading OPFS async Worker failed for unknown reasons."
                )
              );
            };
            const pDVfs = capi.sqlite3_vfs_find(null);
            const dVfs = pDVfs ? new sqlite3_vfs(pDVfs) : null;
            opfsIoMethods.$iVersion = 1;
            opfsVfs.$iVersion = 2;
            opfsVfs.$szOsFile = capi.sqlite3_file.structInfo.sizeof;
            opfsVfs.$mxPathname = 1024;
            opfsVfs.$zName = wasm.allocCString("opfs");
            opfsVfs.$xDlOpen = opfsVfs.$xDlError = opfsVfs.$xDlSym = opfsVfs.$xDlClose = null;
            opfsVfs.addOnDispose(
              "$zName",
              opfsVfs.$zName,
              "cleanup default VFS wrapper",
              () => dVfs ? dVfs.dispose() : null
            );
            const state = /* @__PURE__ */ Object.create(null);
            state.verbose = options.verbose;
            state.littleEndian = (() => {
              const buffer = new ArrayBuffer(2);
              new DataView(buffer).setInt16(0, 256, true);
              return new Int16Array(buffer)[0] === 256;
            })();
            state.asyncIdleWaitTime = 150;
            state.asyncS11nExceptions = 1;
            state.fileBufferSize = 1024 * 64;
            state.sabS11nOffset = state.fileBufferSize;
            state.sabS11nSize = opfsVfs.$mxPathname * 2;
            state.sabIO = new SharedArrayBuffer(
              state.fileBufferSize + state.sabS11nSize
            );
            state.opIds = /* @__PURE__ */ Object.create(null);
            const metrics = /* @__PURE__ */ Object.create(null);
            {
              let i2 = 0;
              state.opIds.whichOp = i2++;
              state.opIds.rc = i2++;
              state.opIds.xAccess = i2++;
              state.opIds.xClose = i2++;
              state.opIds.xDelete = i2++;
              state.opIds.xDeleteNoWait = i2++;
              state.opIds.xFileSize = i2++;
              state.opIds.xLock = i2++;
              state.opIds.xOpen = i2++;
              state.opIds.xRead = i2++;
              state.opIds.xSleep = i2++;
              state.opIds.xSync = i2++;
              state.opIds.xTruncate = i2++;
              state.opIds.xUnlock = i2++;
              state.opIds.xWrite = i2++;
              state.opIds.mkdir = i2++;
              state.opIds["opfs-async-metrics"] = i2++;
              state.opIds["opfs-async-shutdown"] = i2++;
              state.opIds.retry = i2++;
              state.sabOP = new SharedArrayBuffer(i2 * 4);
              opfsUtil.metrics.reset();
            }
            state.sq3Codes = /* @__PURE__ */ Object.create(null);
            [
              "SQLITE_ACCESS_EXISTS",
              "SQLITE_ACCESS_READWRITE",
              "SQLITE_BUSY",
              "SQLITE_CANTOPEN",
              "SQLITE_ERROR",
              "SQLITE_IOERR",
              "SQLITE_IOERR_ACCESS",
              "SQLITE_IOERR_CLOSE",
              "SQLITE_IOERR_DELETE",
              "SQLITE_IOERR_FSYNC",
              "SQLITE_IOERR_LOCK",
              "SQLITE_IOERR_READ",
              "SQLITE_IOERR_SHORT_READ",
              "SQLITE_IOERR_TRUNCATE",
              "SQLITE_IOERR_UNLOCK",
              "SQLITE_IOERR_WRITE",
              "SQLITE_LOCK_EXCLUSIVE",
              "SQLITE_LOCK_NONE",
              "SQLITE_LOCK_PENDING",
              "SQLITE_LOCK_RESERVED",
              "SQLITE_LOCK_SHARED",
              "SQLITE_LOCKED",
              "SQLITE_MISUSE",
              "SQLITE_NOTFOUND",
              "SQLITE_OPEN_CREATE",
              "SQLITE_OPEN_DELETEONCLOSE",
              "SQLITE_OPEN_MAIN_DB",
              "SQLITE_OPEN_READONLY"
            ].forEach((k2) => {
              if (void 0 === (state.sq3Codes[k2] = capi[k2])) {
                toss("Maintenance required: not found:", k2);
              }
            });
            state.opfsFlags = Object.assign(/* @__PURE__ */ Object.create(null), {
              OPFS_UNLOCK_ASAP: 1,
              OPFS_UNLINK_BEFORE_OPEN: 2,
              defaultUnlockAsap: false
            });
            const opRun = (op, ...args) => {
              const opNdx = state.opIds[op] || toss("Invalid op ID:", op);
              state.s11n.serialize(...args);
              Atomics.store(state.sabOPView, state.opIds.rc, -1);
              Atomics.store(state.sabOPView, state.opIds.whichOp, opNdx);
              Atomics.notify(state.sabOPView, state.opIds.whichOp);
              const t2 = performance.now();
              while ("not-equal" !== Atomics.wait(state.sabOPView, state.opIds.rc, -1)) {
              }
              const rc = Atomics.load(state.sabOPView, state.opIds.rc);
              metrics[op].wait += performance.now() - t2;
              if (rc && state.asyncS11nExceptions) {
                const err2 = state.s11n.deserialize();
                if (err2)
                  error(op + "() async error:", ...err2);
              }
              return rc;
            };
            opfsUtil.debug = {
              asyncShutdown: () => {
                warn(
                  "Shutting down OPFS async listener. The OPFS VFS will no longer work."
                );
                opRun("opfs-async-shutdown");
              },
              asyncRestart: () => {
                warn(
                  "Attempting to restart OPFS VFS async listener. Might work, might not."
                );
                W2.postMessage({ type: "opfs-async-restart" });
              }
            };
            const initS11n = () => {
              if (state.s11n)
                return state.s11n;
              const textDecoder = new TextDecoder(), textEncoder = new TextEncoder("utf-8"), viewU8 = new Uint8Array(
                state.sabIO,
                state.sabS11nOffset,
                state.sabS11nSize
              ), viewDV = new DataView(
                state.sabIO,
                state.sabS11nOffset,
                state.sabS11nSize
              );
              state.s11n = /* @__PURE__ */ Object.create(null);
              const TypeIds = /* @__PURE__ */ Object.create(null);
              TypeIds.number = {
                id: 1,
                size: 8,
                getter: "getFloat64",
                setter: "setFloat64"
              };
              TypeIds.bigint = {
                id: 2,
                size: 8,
                getter: "getBigInt64",
                setter: "setBigInt64"
              };
              TypeIds.boolean = {
                id: 3,
                size: 4,
                getter: "getInt32",
                setter: "setInt32"
              };
              TypeIds.string = { id: 4 };
              const getTypeId = (v3) => TypeIds[typeof v3] || toss(
                "Maintenance required: this value type cannot be serialized.",
                v3
              );
              const getTypeIdById = (tid) => {
                switch (tid) {
                  case TypeIds.number.id:
                    return TypeIds.number;
                  case TypeIds.bigint.id:
                    return TypeIds.bigint;
                  case TypeIds.boolean.id:
                    return TypeIds.boolean;
                  case TypeIds.string.id:
                    return TypeIds.string;
                  default:
                    toss("Invalid type ID:", tid);
                }
              };
              state.s11n.deserialize = function(clear = false) {
                ++metrics.s11n.deserialize.count;
                const t2 = performance.now();
                const argc = viewU8[0];
                const rc = argc ? [] : null;
                if (argc) {
                  const typeIds = [];
                  let offset = 1, i2, n2, v3;
                  for (i2 = 0; i2 < argc; ++i2, ++offset) {
                    typeIds.push(getTypeIdById(viewU8[offset]));
                  }
                  for (i2 = 0; i2 < argc; ++i2) {
                    const t3 = typeIds[i2];
                    if (t3.getter) {
                      v3 = viewDV[t3.getter](offset, state.littleEndian);
                      offset += t3.size;
                    } else {
                      n2 = viewDV.getInt32(offset, state.littleEndian);
                      offset += 4;
                      v3 = textDecoder.decode(viewU8.slice(offset, offset + n2));
                      offset += n2;
                    }
                    rc.push(v3);
                  }
                }
                if (clear)
                  viewU8[0] = 0;
                metrics.s11n.deserialize.time += performance.now() - t2;
                return rc;
              };
              state.s11n.serialize = function(...args) {
                const t2 = performance.now();
                ++metrics.s11n.serialize.count;
                if (args.length) {
                  const typeIds = [];
                  let i2 = 0, offset = 1;
                  viewU8[0] = args.length & 255;
                  for (; i2 < args.length; ++i2, ++offset) {
                    typeIds.push(getTypeId(args[i2]));
                    viewU8[offset] = typeIds[i2].id;
                  }
                  for (i2 = 0; i2 < args.length; ++i2) {
                    const t3 = typeIds[i2];
                    if (t3.setter) {
                      viewDV[t3.setter](offset, args[i2], state.littleEndian);
                      offset += t3.size;
                    } else {
                      const s2 = textEncoder.encode(args[i2]);
                      viewDV.setInt32(offset, s2.byteLength, state.littleEndian);
                      offset += 4;
                      viewU8.set(s2, offset);
                      offset += s2.byteLength;
                    }
                  }
                } else {
                  viewU8[0] = 0;
                }
                metrics.s11n.serialize.time += performance.now() - t2;
              };
              return state.s11n;
            };
            const randomFilename = function f2(len = 16) {
              if (!f2._chars) {
                f2._chars = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ012346789";
                f2._n = f2._chars.length;
              }
              const a3 = [];
              let i2 = 0;
              for (; i2 < len; ++i2) {
                const ndx = Math.random() * (f2._n * 64) % f2._n | 0;
                a3[i2] = f2._chars[ndx];
              }
              return a3.join("");
            };
            const __openFiles = /* @__PURE__ */ Object.create(null);
            const opTimer = /* @__PURE__ */ Object.create(null);
            opTimer.op = void 0;
            opTimer.start = void 0;
            const mTimeStart = (op) => {
              opTimer.start = performance.now();
              opTimer.op = op;
              ++metrics[op].count;
            };
            const mTimeEnd = () => metrics[opTimer.op].time += performance.now() - opTimer.start;
            const ioSyncWrappers = {
              xCheckReservedLock: function(pFile, pOut) {
                wasm.poke(pOut, 0, "i32");
                return 0;
              },
              xClose: function(pFile) {
                mTimeStart("xClose");
                let rc = 0;
                const f2 = __openFiles[pFile];
                if (f2) {
                  delete __openFiles[pFile];
                  rc = opRun("xClose", pFile);
                  if (f2.sq3File)
                    f2.sq3File.dispose();
                }
                mTimeEnd();
                return rc;
              },
              xDeviceCharacteristics: function(pFile) {
                return capi.SQLITE_IOCAP_UNDELETABLE_WHEN_OPEN;
              },
              xFileControl: function(pFile, opId, pArg) {
                return capi.SQLITE_NOTFOUND;
              },
              xFileSize: function(pFile, pSz64) {
                mTimeStart("xFileSize");
                let rc = opRun("xFileSize", pFile);
                if (0 == rc) {
                  try {
                    const sz = state.s11n.deserialize()[0];
                    wasm.poke(pSz64, sz, "i64");
                  } catch (e2) {
                    error("Unexpected error reading xFileSize() result:", e2);
                    rc = state.sq3Codes.SQLITE_IOERR;
                  }
                }
                mTimeEnd();
                return rc;
              },
              xLock: function(pFile, lockType) {
                mTimeStart("xLock");
                const f2 = __openFiles[pFile];
                let rc = 0;
                if (!f2.lockType) {
                  rc = opRun("xLock", pFile, lockType);
                  if (0 === rc)
                    f2.lockType = lockType;
                } else {
                  f2.lockType = lockType;
                }
                mTimeEnd();
                return rc;
              },
              xRead: function(pFile, pDest, n2, offset64) {
                mTimeStart("xRead");
                const f2 = __openFiles[pFile];
                let rc;
                try {
                  rc = opRun("xRead", pFile, n2, Number(offset64));
                  if (0 === rc || capi.SQLITE_IOERR_SHORT_READ === rc) {
                    wasm.heap8u().set(f2.sabView.subarray(0, n2), pDest);
                  }
                } catch (e2) {
                  error("xRead(", arguments, ") failed:", e2, f2);
                  rc = capi.SQLITE_IOERR_READ;
                }
                mTimeEnd();
                return rc;
              },
              xSync: function(pFile, flags) {
                mTimeStart("xSync");
                ++metrics.xSync.count;
                const rc = opRun("xSync", pFile, flags);
                mTimeEnd();
                return rc;
              },
              xTruncate: function(pFile, sz64) {
                mTimeStart("xTruncate");
                const rc = opRun("xTruncate", pFile, Number(sz64));
                mTimeEnd();
                return rc;
              },
              xUnlock: function(pFile, lockType) {
                mTimeStart("xUnlock");
                const f2 = __openFiles[pFile];
                let rc = 0;
                if (capi.SQLITE_LOCK_NONE === lockType && f2.lockType) {
                  rc = opRun("xUnlock", pFile, lockType);
                }
                if (0 === rc)
                  f2.lockType = lockType;
                mTimeEnd();
                return rc;
              },
              xWrite: function(pFile, pSrc, n2, offset64) {
                mTimeStart("xWrite");
                const f2 = __openFiles[pFile];
                let rc;
                try {
                  f2.sabView.set(wasm.heap8u().subarray(pSrc, pSrc + n2));
                  rc = opRun("xWrite", pFile, n2, Number(offset64));
                } catch (e2) {
                  error("xWrite(", arguments, ") failed:", e2, f2);
                  rc = capi.SQLITE_IOERR_WRITE;
                }
                mTimeEnd();
                return rc;
              }
            };
            const vfsSyncWrappers = {
              xAccess: function(pVfs, zName, flags, pOut) {
                mTimeStart("xAccess");
                const rc = opRun("xAccess", wasm.cstrToJs(zName));
                wasm.poke(pOut, rc ? 0 : 1, "i32");
                mTimeEnd();
                return 0;
              },
              xCurrentTime: function(pVfs, pOut) {
                wasm.poke(
                  pOut,
                  24405875e-1 + (/* @__PURE__ */ new Date()).getTime() / 864e5,
                  "double"
                );
                return 0;
              },
              xCurrentTimeInt64: function(pVfs, pOut) {
                wasm.poke(
                  pOut,
                  24405875e-1 * 864e5 + (/* @__PURE__ */ new Date()).getTime(),
                  "i64"
                );
                return 0;
              },
              xDelete: function(pVfs, zName, doSyncDir) {
                mTimeStart("xDelete");
                const rc = opRun(
                  "xDelete",
                  wasm.cstrToJs(zName),
                  doSyncDir,
                  false
                );
                mTimeEnd();
                return rc;
              },
              xFullPathname: function(pVfs, zName, nOut, pOut) {
                const i2 = wasm.cstrncpy(pOut, zName, nOut);
                return i2 < nOut ? 0 : capi.SQLITE_CANTOPEN;
              },
              xGetLastError: function(pVfs, nOut, pOut) {
                warn("OPFS xGetLastError() has nothing sensible to return.");
                return 0;
              },
              xOpen: function f2(pVfs, zName, pFile, flags, pOutFlags) {
                mTimeStart("xOpen");
                let opfsFlags = 0;
                if (0 === zName) {
                  zName = randomFilename();
                } else if (wasm.isPtr(zName)) {
                  if (capi.sqlite3_uri_boolean(zName, "opfs-unlock-asap", 0)) {
                    opfsFlags |= state.opfsFlags.OPFS_UNLOCK_ASAP;
                  }
                  if (capi.sqlite3_uri_boolean(zName, "delete-before-open", 0)) {
                    opfsFlags |= state.opfsFlags.OPFS_UNLINK_BEFORE_OPEN;
                  }
                  zName = wasm.cstrToJs(zName);
                }
                const fh = /* @__PURE__ */ Object.create(null);
                fh.fid = pFile;
                fh.filename = zName;
                fh.sab = new SharedArrayBuffer(state.fileBufferSize);
                fh.flags = flags;
                fh.readOnly = !(sqlite32.SQLITE_OPEN_CREATE & flags) && !!(flags & capi.SQLITE_OPEN_READONLY);
                const rc = opRun("xOpen", pFile, zName, flags, opfsFlags);
                if (!rc) {
                  if (fh.readOnly) {
                    wasm.poke(pOutFlags, capi.SQLITE_OPEN_READONLY, "i32");
                  }
                  __openFiles[pFile] = fh;
                  fh.sabView = state.sabFileBufView;
                  fh.sq3File = new sqlite3_file(pFile);
                  fh.sq3File.$pMethods = opfsIoMethods.pointer;
                  fh.lockType = capi.SQLITE_LOCK_NONE;
                }
                mTimeEnd();
                return rc;
              }
            };
            if (dVfs) {
              opfsVfs.$xRandomness = dVfs.$xRandomness;
              opfsVfs.$xSleep = dVfs.$xSleep;
            }
            if (!opfsVfs.$xRandomness) {
              vfsSyncWrappers.xRandomness = function(pVfs, nOut, pOut) {
                const heap = wasm.heap8u();
                let i2 = 0;
                for (; i2 < nOut; ++i2)
                  heap[pOut + i2] = Math.random() * 255e3 & 255;
                return i2;
              };
            }
            if (!opfsVfs.$xSleep) {
              vfsSyncWrappers.xSleep = function(pVfs, ms) {
                Atomics.wait(state.sabOPView, state.opIds.xSleep, 0, ms);
                return 0;
              };
            }
            opfsUtil.getResolvedPath = function(filename, splitIt) {
              const p3 = new URL(filename, "file://irrelevant").pathname;
              return splitIt ? p3.split("/").filter((v3) => !!v3) : p3;
            };
            opfsUtil.getDirForFilename = async function f2(absFilename, createDirs = false) {
              const path2 = opfsUtil.getResolvedPath(absFilename, true);
              const filename = path2.pop();
              let dh = opfsUtil.rootDirectory;
              for (const dirName of path2) {
                if (dirName) {
                  dh = await dh.getDirectoryHandle(dirName, {
                    create: !!createDirs
                  });
                }
              }
              return [dh, filename];
            };
            opfsUtil.mkdir = async function(absDirName) {
              try {
                await opfsUtil.getDirForFilename(
                  absDirName + "/filepart",
                  true
                );
                return true;
              } catch (e2) {
                return false;
              }
            };
            opfsUtil.entryExists = async function(fsEntryName) {
              try {
                const [dh, fn] = await opfsUtil.getDirForFilename(fsEntryName);
                await dh.getFileHandle(fn);
                return true;
              } catch (e2) {
                return false;
              }
            };
            opfsUtil.randomFilename = randomFilename;
            opfsUtil.treeList = async function() {
              const doDir = async function callee3(dirHandle, tgt) {
                tgt.name = dirHandle.name;
                tgt.dirs = [];
                tgt.files = [];
                for await (const handle of dirHandle.values()) {
                  if ("directory" === handle.kind) {
                    const subDir = /* @__PURE__ */ Object.create(null);
                    tgt.dirs.push(subDir);
                    await callee3(handle, subDir);
                  } else {
                    tgt.files.push(handle.name);
                  }
                }
              };
              const root = /* @__PURE__ */ Object.create(null);
              await doDir(opfsUtil.rootDirectory, root);
              return root;
            };
            opfsUtil.rmfr = async function() {
              const dir = opfsUtil.rootDirectory, opt = { recurse: true };
              for await (const handle of dir.values()) {
                dir.removeEntry(handle.name, opt);
              }
            };
            opfsUtil.unlink = async function(fsEntryName, recursive = false, throwOnError = false) {
              try {
                const [hDir, filenamePart] = await opfsUtil.getDirForFilename(
                  fsEntryName,
                  false
                );
                await hDir.removeEntry(filenamePart, { recursive });
                return true;
              } catch (e2) {
                if (throwOnError) {
                  throw new Error(
                    "unlink(",
                    arguments[0],
                    ") failed: " + e2.message,
                    {
                      cause: e2
                    }
                  );
                }
                return false;
              }
            };
            opfsUtil.traverse = async function(opt) {
              const defaultOpt = {
                recursive: true,
                directory: opfsUtil.rootDirectory
              };
              if ("function" === typeof opt) {
                opt = { callback: opt };
              }
              opt = Object.assign(defaultOpt, opt || {});
              const doDir = async function callee3(dirHandle, depth) {
                for await (const handle of dirHandle.values()) {
                  if (false === opt.callback(handle, dirHandle, depth))
                    return false;
                  else if (opt.recursive && "directory" === handle.kind) {
                    if (false === await callee3(handle, depth + 1))
                      break;
                  }
                }
              };
              doDir(opt.directory, 0);
            };
            const importDbChunked = async function(filename, callback) {
              const [hDir, fnamePart] = await opfsUtil.getDirForFilename(
                filename,
                true
              );
              const hFile = await hDir.getFileHandle(fnamePart, {
                create: true
              });
              let sah = await hFile.createSyncAccessHandle();
              let nWrote = 0, chunk, checkedHeader = false, err2 = false;
              try {
                sah.truncate(0);
                while (void 0 !== (chunk = await callback())) {
                  if (chunk instanceof ArrayBuffer)
                    chunk = new Uint8Array(chunk);
                  if (0 === nWrote && chunk.byteLength >= 15) {
                    util.affirmDbHeader(chunk);
                    checkedHeader = true;
                  }
                  sah.write(chunk, { at: nWrote });
                  nWrote += chunk.byteLength;
                }
                if (nWrote < 512 || 0 !== nWrote % 512) {
                  toss(
                    "Input size",
                    nWrote,
                    "is not correct for an SQLite database."
                  );
                }
                if (!checkedHeader) {
                  const header = new Uint8Array(20);
                  sah.read(header, { at: 0 });
                  util.affirmDbHeader(header);
                }
                sah.write(new Uint8Array([1, 1]), { at: 18 });
                return nWrote;
              } catch (e2) {
                await sah.close();
                sah = void 0;
                await hDir.removeEntry(fnamePart).catch(() => {
                });
                throw e2;
              } finally {
                if (sah)
                  await sah.close();
              }
            };
            opfsUtil.importDb = async function(filename, bytes) {
              if (bytes instanceof Function) {
                return importDbChunked(filename, bytes);
              }
              if (bytes instanceof ArrayBuffer)
                bytes = new Uint8Array(bytes);
              util.affirmIsDb(bytes);
              const n2 = bytes.byteLength;
              const [hDir, fnamePart] = await opfsUtil.getDirForFilename(
                filename,
                true
              );
              let sah, err2, nWrote = 0;
              try {
                const hFile = await hDir.getFileHandle(fnamePart, {
                  create: true
                });
                sah = await hFile.createSyncAccessHandle();
                sah.truncate(0);
                nWrote = sah.write(bytes, { at: 0 });
                if (nWrote != n2) {
                  toss(
                    "Expected to write " + n2 + " bytes but wrote " + nWrote + "."
                  );
                }
                sah.write(new Uint8Array([1, 1]), { at: 18 });
                return nWrote;
              } catch (e2) {
                if (sah) {
                  await sah.close();
                  sah = void 0;
                }
                await hDir.removeEntry(fnamePart).catch(() => {
                });
                throw e2;
              } finally {
                if (sah)
                  await sah.close();
              }
            };
            if (sqlite32.oo1) {
              const OpfsDb = function(...args) {
                const opt = sqlite32.oo1.DB.dbCtorHelper.normalizeArgs(...args);
                opt.vfs = opfsVfs.$zName;
                sqlite32.oo1.DB.dbCtorHelper.call(this, opt);
              };
              OpfsDb.prototype = Object.create(sqlite32.oo1.DB.prototype);
              sqlite32.oo1.OpfsDb = OpfsDb;
              OpfsDb.importDb = opfsUtil.importDb;
              sqlite32.oo1.DB.dbCtorHelper.setVfsPostOpenCallback(
                opfsVfs.pointer,
                function(oo1Db, sqlite33) {
                  sqlite33.capi.sqlite3_busy_timeout(oo1Db, 1e4);
                }
              );
            }
            const sanityCheck = function() {
              const scope = wasm.scopedAllocPush();
              const sq3File = new sqlite3_file();
              try {
                const fid = sq3File.pointer;
                const openFlags = capi.SQLITE_OPEN_CREATE | capi.SQLITE_OPEN_READWRITE | capi.SQLITE_OPEN_MAIN_DB;
                const pOut = wasm.scopedAlloc(8);
                const dbFile = "/sanity/check/file" + randomFilename(8);
                const zDbFile = wasm.scopedAllocCString(dbFile);
                let rc;
                state.s11n.serialize("This is \xE4 string.");
                rc = state.s11n.deserialize();
                log2("deserialize() says:", rc);
                if ("This is \xE4 string." !== rc[0])
                  toss("String d13n error.");
                vfsSyncWrappers.xAccess(opfsVfs.pointer, zDbFile, 0, pOut);
                rc = wasm.peek(pOut, "i32");
                log2("xAccess(", dbFile, ") exists ?=", rc);
                rc = vfsSyncWrappers.xOpen(
                  opfsVfs.pointer,
                  zDbFile,
                  fid,
                  openFlags,
                  pOut
                );
                log2(
                  "open rc =",
                  rc,
                  "state.sabOPView[xOpen] =",
                  state.sabOPView[state.opIds.xOpen]
                );
                if (0 !== rc) {
                  error("open failed with code", rc);
                  return;
                }
                vfsSyncWrappers.xAccess(opfsVfs.pointer, zDbFile, 0, pOut);
                rc = wasm.peek(pOut, "i32");
                if (!rc)
                  toss("xAccess() failed to detect file.");
                rc = ioSyncWrappers.xSync(sq3File.pointer, 0);
                if (rc)
                  toss("sync failed w/ rc", rc);
                rc = ioSyncWrappers.xTruncate(sq3File.pointer, 1024);
                if (rc)
                  toss("truncate failed w/ rc", rc);
                wasm.poke(pOut, 0, "i64");
                rc = ioSyncWrappers.xFileSize(sq3File.pointer, pOut);
                if (rc)
                  toss("xFileSize failed w/ rc", rc);
                log2("xFileSize says:", wasm.peek(pOut, "i64"));
                rc = ioSyncWrappers.xWrite(sq3File.pointer, zDbFile, 10, 1);
                if (rc)
                  toss("xWrite() failed!");
                const readBuf = wasm.scopedAlloc(16);
                rc = ioSyncWrappers.xRead(sq3File.pointer, readBuf, 6, 2);
                wasm.poke(readBuf + 6, 0);
                let jRead = wasm.cstrToJs(readBuf);
                log2("xRead() got:", jRead);
                if ("sanity" !== jRead)
                  toss("Unexpected xRead() value.");
                if (vfsSyncWrappers.xSleep) {
                  log2("xSleep()ing before close()ing...");
                  vfsSyncWrappers.xSleep(opfsVfs.pointer, 2e3);
                  log2("waking up from xSleep()");
                }
                rc = ioSyncWrappers.xClose(fid);
                log2("xClose rc =", rc, "sabOPView =", state.sabOPView);
                log2("Deleting file:", dbFile);
                vfsSyncWrappers.xDelete(opfsVfs.pointer, zDbFile, 4660);
                vfsSyncWrappers.xAccess(opfsVfs.pointer, zDbFile, 0, pOut);
                rc = wasm.peek(pOut, "i32");
                if (rc)
                  toss(
                    "Expecting 0 from xAccess(",
                    dbFile,
                    ") after xDelete()."
                  );
                warn("End of OPFS sanity checks.");
              } finally {
                sq3File.dispose();
                wasm.scopedAllocPop(scope);
              }
            };
            W2.onmessage = function({ data }) {
              switch (data.type) {
                case "opfs-unavailable":
                  promiseReject(new Error(data.payload.join(" ")));
                  break;
                case "opfs-async-loaded":
                  W2.postMessage({ type: "opfs-async-init", args: state });
                  break;
                case "opfs-async-inited": {
                  if (true === promiseWasRejected) {
                    break;
                  }
                  try {
                    sqlite32.vfs.installVfs({
                      io: { struct: opfsIoMethods, methods: ioSyncWrappers },
                      vfs: { struct: opfsVfs, methods: vfsSyncWrappers }
                    });
                    state.sabOPView = new Int32Array(state.sabOP);
                    state.sabFileBufView = new Uint8Array(
                      state.sabIO,
                      0,
                      state.fileBufferSize
                    );
                    state.sabS11nView = new Uint8Array(
                      state.sabIO,
                      state.sabS11nOffset,
                      state.sabS11nSize
                    );
                    initS11n();
                    if (options.sanityChecks) {
                      warn(
                        "Running sanity checks because of opfs-sanity-check URL arg..."
                      );
                      sanityCheck();
                    }
                    if (thisThreadHasOPFS()) {
                      navigator.storage.getDirectory().then((d2) => {
                        W2.onerror = W2._originalOnError;
                        delete W2._originalOnError;
                        sqlite32.opfs = opfsUtil;
                        opfsUtil.rootDirectory = d2;
                        log2("End of OPFS sqlite3_vfs setup.", opfsVfs);
                        promiseResolve();
                      }).catch(promiseReject);
                    } else {
                      promiseResolve();
                    }
                  } catch (e2) {
                    error(e2);
                    promiseReject(e2);
                  }
                  break;
                }
                default: {
                  const errMsg = "Unexpected message from the OPFS async worker: " + JSON.stringify(data);
                  error(errMsg);
                  promiseReject(new Error(errMsg));
                  break;
                }
              }
            };
          });
          return thePromise;
        };
        installOpfsVfs.defaultProxyUri = "sqlite3-opfs-async-proxy.js";
        globalThis.sqlite3ApiBootstrap.initializersAsync.push(
          async (sqlite33) => {
            try {
              let proxyJs = installOpfsVfs.defaultProxyUri;
              if (sqlite33.scriptInfo.sqlite3Dir) {
                installOpfsVfs.defaultProxyUri = sqlite33.scriptInfo.sqlite3Dir + proxyJs;
              }
              return installOpfsVfs().catch((e2) => {
                sqlite33.config.warn(
                  "Ignoring inability to install OPFS sqlite3_vfs:",
                  e2.message
                );
              });
            } catch (e2) {
              sqlite33.config.error("installOpfsVfs() exception:", e2);
              return Promise.reject(e2);
            }
          }
        );
      });
      globalThis.sqlite3ApiBootstrap.initializers.push(function(sqlite32) {
        "use strict";
        const toss = sqlite32.util.toss;
        const toss3 = sqlite32.util.toss3;
        const initPromises = /* @__PURE__ */ Object.create(null);
        const capi = sqlite32.capi;
        const util = sqlite32.util;
        const wasm = sqlite32.wasm;
        const SECTOR_SIZE = 4096;
        const HEADER_MAX_PATH_SIZE = 512;
        const HEADER_FLAGS_SIZE = 4;
        const HEADER_DIGEST_SIZE = 8;
        const HEADER_CORPUS_SIZE = HEADER_MAX_PATH_SIZE + HEADER_FLAGS_SIZE;
        const HEADER_OFFSET_FLAGS = HEADER_MAX_PATH_SIZE;
        const HEADER_OFFSET_DIGEST = HEADER_CORPUS_SIZE;
        const HEADER_OFFSET_DATA = SECTOR_SIZE;
        const PERSISTENT_FILE_TYPES = capi.SQLITE_OPEN_MAIN_DB | capi.SQLITE_OPEN_MAIN_JOURNAL | capi.SQLITE_OPEN_SUPER_JOURNAL | capi.SQLITE_OPEN_WAL;
        const OPAQUE_DIR_NAME = ".opaque";
        const getRandomName = () => Math.random().toString(36).slice(2);
        const textDecoder = new TextDecoder();
        const textEncoder = new TextEncoder();
        const optionDefaults = Object.assign(/* @__PURE__ */ Object.create(null), {
          name: "opfs-sahpool",
          directory: void 0,
          initialCapacity: 6,
          clearOnInit: false,
          verbosity: 2,
          forceReinitIfPreviouslyFailed: false
        });
        const loggers = [
          sqlite32.config.error,
          sqlite32.config.warn,
          sqlite32.config.log
        ];
        const log2 = sqlite32.config.log;
        const warn = sqlite32.config.warn;
        const error = sqlite32.config.error;
        const __mapVfsToPool = /* @__PURE__ */ new Map();
        const getPoolForVfs = (pVfs) => __mapVfsToPool.get(pVfs);
        const setPoolForVfs = (pVfs, pool) => {
          if (pool)
            __mapVfsToPool.set(pVfs, pool);
          else
            __mapVfsToPool.delete(pVfs);
        };
        const __mapSqlite3File = /* @__PURE__ */ new Map();
        const getPoolForPFile = (pFile) => __mapSqlite3File.get(pFile);
        const setPoolForPFile = (pFile, pool) => {
          if (pool)
            __mapSqlite3File.set(pFile, pool);
          else
            __mapSqlite3File.delete(pFile);
        };
        const ioMethods = {
          xCheckReservedLock: function(pFile, pOut) {
            const pool = getPoolForPFile(pFile);
            pool.log("xCheckReservedLock");
            pool.storeErr();
            wasm.poke32(pOut, 1);
            return 0;
          },
          xClose: function(pFile) {
            const pool = getPoolForPFile(pFile);
            pool.storeErr();
            const file = pool.getOFileForS3File(pFile);
            if (file) {
              try {
                pool.log(`xClose ${file.path}`);
                pool.mapS3FileToOFile(pFile, false);
                file.sah.flush();
                if (file.flags & capi.SQLITE_OPEN_DELETEONCLOSE) {
                  pool.deletePath(file.path);
                }
              } catch (e2) {
                return pool.storeErr(e2, capi.SQLITE_IOERR);
              }
            }
            return 0;
          },
          xDeviceCharacteristics: function(pFile) {
            return capi.SQLITE_IOCAP_UNDELETABLE_WHEN_OPEN;
          },
          xFileControl: function(pFile, opId, pArg) {
            return capi.SQLITE_NOTFOUND;
          },
          xFileSize: function(pFile, pSz64) {
            const pool = getPoolForPFile(pFile);
            pool.log(`xFileSize`);
            const file = pool.getOFileForS3File(pFile);
            const size = file.sah.getSize() - HEADER_OFFSET_DATA;
            wasm.poke64(pSz64, BigInt(size));
            return 0;
          },
          xLock: function(pFile, lockType) {
            const pool = getPoolForPFile(pFile);
            pool.log(`xLock ${lockType}`);
            pool.storeErr();
            const file = pool.getOFileForS3File(pFile);
            file.lockType = lockType;
            return 0;
          },
          xRead: function(pFile, pDest, n2, offset64) {
            const pool = getPoolForPFile(pFile);
            pool.storeErr();
            const file = pool.getOFileForS3File(pFile);
            pool.log(`xRead ${file.path} ${n2} @ ${offset64}`);
            try {
              const nRead = file.sah.read(
                wasm.heap8u().subarray(pDest, pDest + n2),
                { at: HEADER_OFFSET_DATA + Number(offset64) }
              );
              if (nRead < n2) {
                wasm.heap8u().fill(0, pDest + nRead, pDest + n2);
                return capi.SQLITE_IOERR_SHORT_READ;
              }
              return 0;
            } catch (e2) {
              return pool.storeErr(e2, capi.SQLITE_IOERR);
            }
          },
          xSectorSize: function(pFile) {
            return SECTOR_SIZE;
          },
          xSync: function(pFile, flags) {
            const pool = getPoolForPFile(pFile);
            pool.log(`xSync ${flags}`);
            pool.storeErr();
            const file = pool.getOFileForS3File(pFile);
            try {
              file.sah.flush();
              return 0;
            } catch (e2) {
              return pool.storeErr(e2, capi.SQLITE_IOERR);
            }
          },
          xTruncate: function(pFile, sz64) {
            const pool = getPoolForPFile(pFile);
            pool.log(`xTruncate ${sz64}`);
            pool.storeErr();
            const file = pool.getOFileForS3File(pFile);
            try {
              file.sah.truncate(HEADER_OFFSET_DATA + Number(sz64));
              return 0;
            } catch (e2) {
              return pool.storeErr(e2, capi.SQLITE_IOERR);
            }
          },
          xUnlock: function(pFile, lockType) {
            const pool = getPoolForPFile(pFile);
            pool.log("xUnlock");
            const file = pool.getOFileForS3File(pFile);
            file.lockType = lockType;
            return 0;
          },
          xWrite: function(pFile, pSrc, n2, offset64) {
            const pool = getPoolForPFile(pFile);
            pool.storeErr();
            const file = pool.getOFileForS3File(pFile);
            pool.log(`xWrite ${file.path} ${n2} ${offset64}`);
            try {
              const nBytes = file.sah.write(
                wasm.heap8u().subarray(pSrc, pSrc + n2),
                { at: HEADER_OFFSET_DATA + Number(offset64) }
              );
              return n2 === nBytes ? 0 : toss("Unknown write() failure.");
            } catch (e2) {
              return pool.storeErr(e2, capi.SQLITE_IOERR);
            }
          }
        };
        const opfsIoMethods = new capi.sqlite3_io_methods();
        opfsIoMethods.$iVersion = 1;
        sqlite32.vfs.installVfs({
          io: { struct: opfsIoMethods, methods: ioMethods }
        });
        const vfsMethods = {
          xAccess: function(pVfs, zName, flags, pOut) {
            const pool = getPoolForVfs(pVfs);
            pool.storeErr();
            try {
              const name = pool.getPath(zName);
              wasm.poke32(pOut, pool.hasFilename(name) ? 1 : 0);
            } catch (e2) {
              wasm.poke32(pOut, 0);
            }
            return 0;
          },
          xCurrentTime: function(pVfs, pOut) {
            wasm.poke(
              pOut,
              24405875e-1 + (/* @__PURE__ */ new Date()).getTime() / 864e5,
              "double"
            );
            return 0;
          },
          xCurrentTimeInt64: function(pVfs, pOut) {
            wasm.poke(pOut, 24405875e-1 * 864e5 + (/* @__PURE__ */ new Date()).getTime(), "i64");
            return 0;
          },
          xDelete: function(pVfs, zName, doSyncDir) {
            const pool = getPoolForVfs(pVfs);
            pool.log(`xDelete ${wasm.cstrToJs(zName)}`);
            pool.storeErr();
            try {
              pool.deletePath(pool.getPath(zName));
              return 0;
            } catch (e2) {
              pool.storeErr(e2);
              return capi.SQLITE_IOERR_DELETE;
            }
          },
          xFullPathname: function(pVfs, zName, nOut, pOut) {
            const i2 = wasm.cstrncpy(pOut, zName, nOut);
            return i2 < nOut ? 0 : capi.SQLITE_CANTOPEN;
          },
          xGetLastError: function(pVfs, nOut, pOut) {
            const pool = getPoolForVfs(pVfs);
            const e2 = pool.popErr();
            pool.log(`xGetLastError ${nOut} e =`, e2);
            if (e2) {
              const scope = wasm.scopedAllocPush();
              try {
                const [cMsg, n2] = wasm.scopedAllocCString(e2.message, true);
                wasm.cstrncpy(pOut, cMsg, nOut);
                if (n2 > nOut)
                  wasm.poke8(pOut + nOut - 1, 0);
              } catch (e3) {
                return capi.SQLITE_NOMEM;
              } finally {
                wasm.scopedAllocPop(scope);
              }
            }
            return e2 ? e2.sqlite3Rc || capi.SQLITE_IOERR : 0;
          },
          xOpen: function f2(pVfs, zName, pFile, flags, pOutFlags) {
            const pool = getPoolForVfs(pVfs);
            try {
              pool.log(`xOpen ${wasm.cstrToJs(zName)} ${flags}`);
              const path2 = zName && wasm.peek8(zName) ? pool.getPath(zName) : getRandomName();
              let sah = pool.getSAHForPath(path2);
              if (!sah && flags & capi.SQLITE_OPEN_CREATE) {
                if (pool.getFileCount() < pool.getCapacity()) {
                  sah = pool.nextAvailableSAH();
                  pool.setAssociatedPath(sah, path2, flags);
                } else {
                  toss("SAH pool is full. Cannot create file", path2);
                }
              }
              if (!sah) {
                toss("file not found:", path2);
              }
              const file = { path: path2, flags, sah };
              pool.mapS3FileToOFile(pFile, file);
              file.lockType = capi.SQLITE_LOCK_NONE;
              const sq3File = new capi.sqlite3_file(pFile);
              sq3File.$pMethods = opfsIoMethods.pointer;
              sq3File.dispose();
              wasm.poke32(pOutFlags, flags);
              return 0;
            } catch (e2) {
              pool.storeErr(e2);
              return capi.SQLITE_CANTOPEN;
            }
          }
        };
        const createOpfsVfs = function(vfsName) {
          if (sqlite32.capi.sqlite3_vfs_find(vfsName)) {
            toss3("VFS name is already registered:", vfsName);
          }
          const opfsVfs = new capi.sqlite3_vfs();
          const pDVfs = capi.sqlite3_vfs_find(null);
          const dVfs = pDVfs ? new capi.sqlite3_vfs(pDVfs) : null;
          opfsVfs.$iVersion = 2;
          opfsVfs.$szOsFile = capi.sqlite3_file.structInfo.sizeof;
          opfsVfs.$mxPathname = HEADER_MAX_PATH_SIZE;
          opfsVfs.addOnDispose(
            opfsVfs.$zName = wasm.allocCString(vfsName),
            () => setPoolForVfs(opfsVfs.pointer, 0)
          );
          if (dVfs) {
            opfsVfs.$xRandomness = dVfs.$xRandomness;
            opfsVfs.$xSleep = dVfs.$xSleep;
            dVfs.dispose();
          }
          if (!opfsVfs.$xRandomness && !vfsMethods.xRandomness) {
            vfsMethods.xRandomness = function(pVfs, nOut, pOut) {
              const heap = wasm.heap8u();
              let i2 = 0;
              for (; i2 < nOut; ++i2)
                heap[pOut + i2] = Math.random() * 255e3 & 255;
              return i2;
            };
          }
          if (!opfsVfs.$xSleep && !vfsMethods.xSleep) {
            vfsMethods.xSleep = (pVfs, ms) => 0;
          }
          sqlite32.vfs.installVfs({
            vfs: { struct: opfsVfs, methods: vfsMethods }
          });
          return opfsVfs;
        };
        class OpfsSAHPool {
          vfsDir;
          #dhVfsRoot;
          #dhOpaque;
          #dhVfsParent;
          #mapSAHToName = /* @__PURE__ */ new Map();
          #mapFilenameToSAH = /* @__PURE__ */ new Map();
          #availableSAH = /* @__PURE__ */ new Set();
          #mapS3FileToOFile_ = /* @__PURE__ */ new Map();
          #apBody = new Uint8Array(HEADER_CORPUS_SIZE);
          #dvBody;
          #cVfs;
          #verbosity;
          constructor(options = /* @__PURE__ */ Object.create(null)) {
            this.#verbosity = options.verbosity ?? optionDefaults.verbosity;
            this.vfsName = options.name || optionDefaults.name;
            this.#cVfs = createOpfsVfs(this.vfsName);
            setPoolForVfs(this.#cVfs.pointer, this);
            this.vfsDir = options.directory || "." + this.vfsName;
            this.#dvBody = new DataView(
              this.#apBody.buffer,
              this.#apBody.byteOffset
            );
            this.isReady = this.reset(
              !!(options.clearOnInit ?? optionDefaults.clearOnInit)
            ).then(() => {
              if (this.$error)
                throw this.$error;
              return this.getCapacity() ? Promise.resolve(void 0) : this.addCapacity(
                options.initialCapacity || optionDefaults.initialCapacity
              );
            });
          }
          #logImpl(level, ...args) {
            if (this.#verbosity > level)
              loggers[level](this.vfsName + ":", ...args);
          }
          log(...args) {
            this.#logImpl(2, ...args);
          }
          warn(...args) {
            this.#logImpl(1, ...args);
          }
          error(...args) {
            this.#logImpl(0, ...args);
          }
          getVfs() {
            return this.#cVfs;
          }
          getCapacity() {
            return this.#mapSAHToName.size;
          }
          getFileCount() {
            return this.#mapFilenameToSAH.size;
          }
          getFileNames() {
            const rc = [];
            const iter = this.#mapFilenameToSAH.keys();
            for (const n2 of iter)
              rc.push(n2);
            return rc;
          }
          async addCapacity(n2) {
            for (let i2 = 0; i2 < n2; ++i2) {
              const name = getRandomName();
              const h2 = await this.#dhOpaque.getFileHandle(name, {
                create: true
              });
              const ah = await h2.createSyncAccessHandle();
              this.#mapSAHToName.set(ah, name);
              this.setAssociatedPath(ah, "", 0);
            }
            return this.getCapacity();
          }
          async reduceCapacity(n2) {
            let nRm = 0;
            for (const ah of Array.from(this.#availableSAH)) {
              if (nRm === n2 || this.getFileCount() === this.getCapacity()) {
                break;
              }
              const name = this.#mapSAHToName.get(ah);
              ah.close();
              await this.#dhOpaque.removeEntry(name);
              this.#mapSAHToName.delete(ah);
              this.#availableSAH.delete(ah);
              ++nRm;
            }
            return nRm;
          }
          releaseAccessHandles() {
            for (const ah of this.#mapSAHToName.keys())
              ah.close();
            this.#mapSAHToName.clear();
            this.#mapFilenameToSAH.clear();
            this.#availableSAH.clear();
          }
          async acquireAccessHandles(clearFiles) {
            const files = [];
            for await (const [name, h2] of this.#dhOpaque) {
              if ("file" === h2.kind) {
                files.push([name, h2]);
              }
            }
            return Promise.all(
              files.map(async ([name, h2]) => {
                try {
                  const ah = await h2.createSyncAccessHandle();
                  this.#mapSAHToName.set(ah, name);
                  if (clearFiles) {
                    ah.truncate(HEADER_OFFSET_DATA);
                    this.setAssociatedPath(ah, "", 0);
                  } else {
                    const path2 = this.getAssociatedPath(ah);
                    if (path2) {
                      this.#mapFilenameToSAH.set(path2, ah);
                    } else {
                      this.#availableSAH.add(ah);
                    }
                  }
                } catch (e2) {
                  this.storeErr(e2);
                  this.releaseAccessHandles();
                  throw e2;
                }
              })
            );
          }
          getAssociatedPath(sah) {
            sah.read(this.#apBody, { at: 0 });
            const flags = this.#dvBody.getUint32(HEADER_OFFSET_FLAGS);
            if (this.#apBody[0] && (flags & capi.SQLITE_OPEN_DELETEONCLOSE || (flags & PERSISTENT_FILE_TYPES) === 0)) {
              warn(
                `Removing file with unexpected flags ${flags.toString(16)}`,
                this.#apBody
              );
              this.setAssociatedPath(sah, "", 0);
              return "";
            }
            const fileDigest = new Uint32Array(HEADER_DIGEST_SIZE / 4);
            sah.read(fileDigest, { at: HEADER_OFFSET_DIGEST });
            const compDigest = this.computeDigest(this.#apBody);
            if (fileDigest.every((v3, i2) => v3 === compDigest[i2])) {
              const pathBytes = this.#apBody.findIndex((v3) => 0 === v3);
              if (0 === pathBytes) {
                sah.truncate(HEADER_OFFSET_DATA);
              }
              return pathBytes ? textDecoder.decode(this.#apBody.subarray(0, pathBytes)) : "";
            } else {
              warn("Disassociating file with bad digest.");
              this.setAssociatedPath(sah, "", 0);
              return "";
            }
          }
          setAssociatedPath(sah, path2, flags) {
            const enc = textEncoder.encodeInto(path2, this.#apBody);
            if (HEADER_MAX_PATH_SIZE <= enc.written + 1) {
              toss("Path too long:", path2);
            }
            this.#apBody.fill(0, enc.written, HEADER_MAX_PATH_SIZE);
            this.#dvBody.setUint32(HEADER_OFFSET_FLAGS, flags);
            const digest = this.computeDigest(this.#apBody);
            sah.write(this.#apBody, { at: 0 });
            sah.write(digest, { at: HEADER_OFFSET_DIGEST });
            sah.flush();
            if (path2) {
              this.#mapFilenameToSAH.set(path2, sah);
              this.#availableSAH.delete(sah);
            } else {
              sah.truncate(HEADER_OFFSET_DATA);
              this.#availableSAH.add(sah);
            }
          }
          computeDigest(byteArray) {
            let h1 = 3735928559;
            let h2 = 1103547991;
            for (const v3 of byteArray) {
              h1 = 31 * h1 + v3 * 307;
              h2 = 31 * h2 + v3 * 307;
            }
            return new Uint32Array([h1 >>> 0, h2 >>> 0]);
          }
          async reset(clearFiles) {
            await this.isReady;
            let h2 = await navigator.storage.getDirectory();
            let prev, prevName;
            for (const d2 of this.vfsDir.split("/")) {
              if (d2) {
                prev = h2;
                h2 = await h2.getDirectoryHandle(d2, { create: true });
              }
            }
            this.#dhVfsRoot = h2;
            this.#dhVfsParent = prev;
            this.#dhOpaque = await this.#dhVfsRoot.getDirectoryHandle(
              OPAQUE_DIR_NAME,
              { create: true }
            );
            this.releaseAccessHandles();
            return this.acquireAccessHandles(clearFiles);
          }
          getPath(arg) {
            if (wasm.isPtr(arg))
              arg = wasm.cstrToJs(arg);
            return (arg instanceof URL ? arg : new URL(arg, "file://localhost/")).pathname;
          }
          deletePath(path2) {
            const sah = this.#mapFilenameToSAH.get(path2);
            if (sah) {
              this.#mapFilenameToSAH.delete(path2);
              this.setAssociatedPath(sah, "", 0);
            }
            return !!sah;
          }
          storeErr(e2, code) {
            if (e2) {
              e2.sqlite3Rc = code || capi.SQLITE_IOERR;
              this.error(e2);
            }
            this.$error = e2;
            return code;
          }
          popErr() {
            const rc = this.$error;
            this.$error = void 0;
            return rc;
          }
          nextAvailableSAH() {
            const [rc] = this.#availableSAH.keys();
            return rc;
          }
          getOFileForS3File(pFile) {
            return this.#mapS3FileToOFile_.get(pFile);
          }
          mapS3FileToOFile(pFile, file) {
            if (file) {
              this.#mapS3FileToOFile_.set(pFile, file);
              setPoolForPFile(pFile, this);
            } else {
              this.#mapS3FileToOFile_.delete(pFile);
              setPoolForPFile(pFile, false);
            }
          }
          hasFilename(name) {
            return this.#mapFilenameToSAH.has(name);
          }
          getSAHForPath(path2) {
            return this.#mapFilenameToSAH.get(path2);
          }
          async removeVfs() {
            if (!this.#cVfs.pointer || !this.#dhOpaque)
              return false;
            capi.sqlite3_vfs_unregister(this.#cVfs.pointer);
            this.#cVfs.dispose();
            delete initPromises[this.vfsName];
            try {
              this.releaseAccessHandles();
              await this.#dhVfsRoot.removeEntry(OPAQUE_DIR_NAME, {
                recursive: true
              });
              this.#dhOpaque = void 0;
              await this.#dhVfsParent.removeEntry(this.#dhVfsRoot.name, {
                recursive: true
              });
              this.#dhVfsRoot = this.#dhVfsParent = void 0;
            } catch (e2) {
              sqlite32.config.error(this.vfsName, "removeVfs() failed:", e2);
            }
            return true;
          }
          exportFile(name) {
            const sah = this.#mapFilenameToSAH.get(name) || toss("File not found:", name);
            const n2 = sah.getSize() - HEADER_OFFSET_DATA;
            const b = new Uint8Array(n2 > 0 ? n2 : 0);
            if (n2 > 0) {
              const nRead = sah.read(b, { at: HEADER_OFFSET_DATA });
              if (nRead != n2) {
                toss(
                  "Expected to read " + n2 + " bytes but read " + nRead + "."
                );
              }
            }
            return b;
          }
          async importDbChunked(name, callback) {
            const sah = this.#mapFilenameToSAH.get(name) || this.nextAvailableSAH() || toss("No available handles to import to.");
            sah.truncate(0);
            let nWrote = 0, chunk, checkedHeader = false, err2 = false;
            try {
              while (void 0 !== (chunk = await callback())) {
                if (chunk instanceof ArrayBuffer)
                  chunk = new Uint8Array(chunk);
                if (0 === nWrote && chunk.byteLength >= 15) {
                  util.affirmDbHeader(chunk);
                  checkedHeader = true;
                }
                sah.write(chunk, { at: HEADER_OFFSET_DATA + nWrote });
                nWrote += chunk.byteLength;
              }
              if (nWrote < 512 || 0 !== nWrote % 512) {
                toss(
                  "Input size",
                  nWrote,
                  "is not correct for an SQLite database."
                );
              }
              if (!checkedHeader) {
                const header = new Uint8Array(20);
                sah.read(header, { at: 0 });
                util.affirmDbHeader(header);
              }
              sah.write(new Uint8Array([1, 1]), {
                at: HEADER_OFFSET_DATA + 18
              });
            } catch (e2) {
              this.setAssociatedPath(sah, "", 0);
              throw e2;
            }
            this.setAssociatedPath(sah, name, capi.SQLITE_OPEN_MAIN_DB);
            return nWrote;
          }
          importDb(name, bytes) {
            if (bytes instanceof ArrayBuffer)
              bytes = new Uint8Array(bytes);
            else if (bytes instanceof Function)
              return this.importDbChunked(name, bytes);
            const sah = this.#mapFilenameToSAH.get(name) || this.nextAvailableSAH() || toss("No available handles to import to.");
            const n2 = bytes.byteLength;
            if (n2 < 512 || n2 % 512 != 0) {
              toss("Byte array size is invalid for an SQLite db.");
            }
            const header = "SQLite format 3";
            for (let i2 = 0; i2 < header.length; ++i2) {
              if (header.charCodeAt(i2) !== bytes[i2]) {
                toss("Input does not contain an SQLite database header.");
              }
            }
            const nWrote = sah.write(bytes, { at: HEADER_OFFSET_DATA });
            if (nWrote != n2) {
              this.setAssociatedPath(sah, "", 0);
              toss(
                "Expected to write " + n2 + " bytes but wrote " + nWrote + "."
              );
            } else {
              sah.write(new Uint8Array([1, 1]), {
                at: HEADER_OFFSET_DATA + 18
              });
              this.setAssociatedPath(sah, name, capi.SQLITE_OPEN_MAIN_DB);
            }
            return nWrote;
          }
        }
        class OpfsSAHPoolUtil {
          #p;
          constructor(sahPool) {
            this.#p = sahPool;
            this.vfsName = sahPool.vfsName;
          }
          async addCapacity(n2) {
            return this.#p.addCapacity(n2);
          }
          async reduceCapacity(n2) {
            return this.#p.reduceCapacity(n2);
          }
          getCapacity() {
            return this.#p.getCapacity(this.#p);
          }
          getFileCount() {
            return this.#p.getFileCount();
          }
          getFileNames() {
            return this.#p.getFileNames();
          }
          async reserveMinimumCapacity(min) {
            const c3 = this.#p.getCapacity();
            return c3 < min ? this.#p.addCapacity(min - c3) : c3;
          }
          exportFile(name) {
            return this.#p.exportFile(name);
          }
          importDb(name, bytes) {
            return this.#p.importDb(name, bytes);
          }
          async wipeFiles() {
            return this.#p.reset(true);
          }
          unlink(filename) {
            return this.#p.deletePath(filename);
          }
          async removeVfs() {
            return this.#p.removeVfs();
          }
        }
        const apiVersionCheck = async () => {
          const dh = await navigator.storage.getDirectory();
          const fn = ".opfs-sahpool-sync-check-" + getRandomName();
          const fh = await dh.getFileHandle(fn, { create: true });
          const ah = await fh.createSyncAccessHandle();
          const close = ah.close();
          await close;
          await dh.removeEntry(fn);
          if (close == null ? void 0 : close.then) {
            toss(
              "The local OPFS API is too old for opfs-sahpool:",
              "it has an async FileSystemSyncAccessHandle.close() method."
            );
          }
          return true;
        };
        sqlite32.installOpfsSAHPoolVfs = async function(options = /* @__PURE__ */ Object.create(null)) {
          var _a8;
          options = Object.assign(
            /* @__PURE__ */ Object.create(null),
            optionDefaults,
            options || {}
          );
          const vfsName = options.name;
          if (options.$testThrowPhase1) {
            throw options.$testThrowPhase1;
          }
          if (initPromises[vfsName]) {
            try {
              const p3 = await initPromises[vfsName];
              return p3;
            } catch (e2) {
              if (options.forceReinitIfPreviouslyFailed) {
                delete initPromises[vfsName];
              } else {
                throw e2;
              }
            }
          }
          if (!globalThis.FileSystemHandle || !globalThis.FileSystemDirectoryHandle || !globalThis.FileSystemFileHandle || !globalThis.FileSystemFileHandle.prototype.createSyncAccessHandle || !((_a8 = navigator == null ? void 0 : navigator.storage) == null ? void 0 : _a8.getDirectory)) {
            return initPromises[vfsName] = Promise.reject(
              new Error("Missing required OPFS APIs.")
            );
          }
          return initPromises[vfsName] = apiVersionCheck().then(async function() {
            if (options.$testThrowPhase2) {
              throw options.$testThrowPhase2;
            }
            const thePool = new OpfsSAHPool(options);
            return thePool.isReady.then(async () => {
              const poolUtil = new OpfsSAHPoolUtil(thePool);
              if (sqlite32.oo1) {
                const oo1 = sqlite32.oo1;
                const theVfs = thePool.getVfs();
                const OpfsSAHPoolDb = function(...args) {
                  const opt = oo1.DB.dbCtorHelper.normalizeArgs(...args);
                  opt.vfs = theVfs.$zName;
                  oo1.DB.dbCtorHelper.call(this, opt);
                };
                OpfsSAHPoolDb.prototype = Object.create(oo1.DB.prototype);
                poolUtil.OpfsSAHPoolDb = OpfsSAHPoolDb;
              }
              thePool.log("VFS initialized.");
              return poolUtil;
            }).catch(async (e2) => {
              await thePool.removeVfs().catch(() => {
              });
              throw e2;
            });
          }).catch((err2) => {
            return initPromises[vfsName] = Promise.reject(err2);
          });
        };
      });
      "use strict";
      if ("undefined" !== typeof Module3) {
        const SABC = Object.assign(
          /* @__PURE__ */ Object.create(null),
          {
            exports: "undefined" === typeof wasmExports ? Module3["asm"] : wasmExports,
            memory: Module3.wasmMemory
          },
          globalThis.sqlite3ApiConfig || {}
        );
        globalThis.sqlite3ApiConfig = SABC;
        let sqlite32;
        try {
          sqlite32 = globalThis.sqlite3ApiBootstrap();
        } catch (e2) {
          console.error("sqlite3ApiBootstrap() error:", e2);
          throw e2;
        } finally {
          delete globalThis.sqlite3ApiBootstrap;
          delete globalThis.sqlite3ApiConfig;
        }
        Module3.sqlite3 = sqlite32;
      } else {
        console.warn(
          "This is not running in an Emscripten module context, so",
          "globalThis.sqlite3ApiBootstrap() is _not_ being called due to lack",
          "of config info for the WASM environment.",
          "It must be called manually."
        );
      }
    });
    moduleRtn = readyPromise;
    return moduleRtn;
  };
})();
var toExportForESM = function() {
  var _a8, _b5;
  const originalInit = sqlite3InitModule;
  if (!originalInit) {
    throw new Error(
      "Expecting globalThis.sqlite3InitModule to be defined by the Emscripten build."
    );
  }
  const initModuleState = globalThis.sqlite3InitModuleState = Object.assign(
    /* @__PURE__ */ Object.create(null),
    {
      moduleScript: (_a8 = globalThis == null ? void 0 : globalThis.document) == null ? void 0 : _a8.currentScript,
      isWorker: "undefined" !== typeof WorkerGlobalScope,
      location: globalThis.location,
      urlParams: ((_b5 = globalThis == null ? void 0 : globalThis.location) == null ? void 0 : _b5.href) ? new URL(globalThis.location.href).searchParams : new URLSearchParams()
    }
  );
  initModuleState.debugModule = initModuleState.urlParams.has(
    "sqlite3.debugModule"
  ) ? (...args) => console.warn("sqlite3.debugModule:", ...args) : () => {
  };
  if (initModuleState.urlParams.has("sqlite3.dir")) {
    initModuleState.sqlite3Dir = initModuleState.urlParams.get("sqlite3.dir") + "/";
  } else if (initModuleState.moduleScript) {
    const li = initModuleState.moduleScript.src.split("/");
    li.pop();
    initModuleState.sqlite3Dir = li.join("/") + "/";
  }
  globalThis.sqlite3InitModule = function ff(...args) {
    return originalInit(...args).then((EmscriptenModule) => {
      const s2 = EmscriptenModule.sqlite3;
      s2.scriptInfo = initModuleState;
      if (ff.__isUnderTest)
        s2.__isUnderTest = true;
      const f2 = s2.asyncPostInit;
      delete s2.asyncPostInit;
      return f2();
    }).catch((e2) => {
      console.error("Exception loading sqlite3 module:", e2);
      throw e2;
    });
  };
  globalThis.sqlite3InitModule.ready = originalInit.ready;
  if (globalThis.sqlite3InitModuleState.moduleScript) {
    const sim = globalThis.sqlite3InitModuleState;
    let src2 = sim.moduleScript.src.split("/");
    src2.pop();
    sim.scriptDir = src2.join("/") + "/";
  }
  initModuleState.debugModule("sqlite3InitModuleState =", initModuleState);
  if (0) {
    console.warn("Replaced sqlite3InitModule()");
    console.warn("globalThis.location.href =", globalThis.location.href);
    if ("undefined" !== typeof document) {
      console.warn(
        "document.currentScript.src =",
        (_c = document == null ? void 0 : document.currentScript) == null ? void 0 : _c.src
      );
    }
  }
  return globalThis.sqlite3InitModule;
}();
sqlite3InitModule = toExportForESM;
var sqlite3_bundler_friendly_default = sqlite3InitModule;

// ../../../node_modules/.pnpm/@sqlite.org+sqlite-wasm@3.48.0-build4/node_modules/@sqlite.org/sqlite-wasm/sqlite-wasm/jswasm/sqlite3-worker1-promiser.mjs
init_define_ENV_DEFINED_IN_BUILD_STEP();
globalThis.sqlite3Worker1Promiser = function callee(config = callee.defaultConfig) {
  if (1 === arguments.length && "function" === typeof arguments[0]) {
    const f2 = config;
    config = Object.assign(/* @__PURE__ */ Object.create(null), callee.defaultConfig);
    config.onready = f2;
  } else {
    config = Object.assign(/* @__PURE__ */ Object.create(null), callee.defaultConfig, config);
  }
  const handlerMap = /* @__PURE__ */ Object.create(null);
  const noop2 = function() {
  };
  const err = config.onerror || noop2;
  const debug = config.debug || noop2;
  const idTypeMap = config.generateMessageId ? void 0 : /* @__PURE__ */ Object.create(null);
  const genMsgId = config.generateMessageId || function(msg) {
    return msg.type + "#" + (idTypeMap[msg.type] = (idTypeMap[msg.type] || 0) + 1);
  };
  const toss = (...args) => {
    throw new Error(args.join(" "));
  };
  if (!config.worker)
    config.worker = callee.defaultConfig.worker;
  if ("function" === typeof config.worker)
    config.worker = config.worker();
  let dbId;
  let promiserFunc;
  config.worker.onmessage = function(ev) {
    ev = ev.data;
    debug("worker1.onmessage", ev);
    let msgHandler = handlerMap[ev.messageId];
    if (!msgHandler) {
      if (ev && "sqlite3-api" === ev.type && "worker1-ready" === ev.result) {
        if (config.onready)
          config.onready(promiserFunc);
        return;
      }
      msgHandler = handlerMap[ev.type];
      if (msgHandler && msgHandler.onrow) {
        msgHandler.onrow(ev);
        return;
      }
      if (config.onunhandled)
        config.onunhandled(arguments[0]);
      else
        err("sqlite3Worker1Promiser() unhandled worker message:", ev);
      return;
    }
    delete handlerMap[ev.messageId];
    switch (ev.type) {
      case "error":
        msgHandler.reject(ev);
        return;
      case "open":
        if (!dbId)
          dbId = ev.dbId;
        break;
      case "close":
        if (ev.dbId === dbId)
          dbId = void 0;
        break;
      default:
        break;
    }
    try {
      msgHandler.resolve(ev);
    } catch (e2) {
      msgHandler.reject(e2);
    }
  };
  return promiserFunc = function() {
    let msg;
    if (1 === arguments.length) {
      msg = arguments[0];
    } else if (2 === arguments.length) {
      msg = /* @__PURE__ */ Object.create(null);
      msg.type = arguments[0];
      msg.args = arguments[1];
      msg.dbId = msg.args.dbId;
    } else {
      toss("Invalid arguments for sqlite3Worker1Promiser()-created factory.");
    }
    if (!msg.dbId && msg.type !== "open")
      msg.dbId = dbId;
    msg.messageId = genMsgId(msg);
    msg.departureTime = performance.now();
    const proxy = /* @__PURE__ */ Object.create(null);
    proxy.message = msg;
    let rowCallbackId;
    if ("exec" === msg.type && msg.args) {
      if ("function" === typeof msg.args.callback) {
        rowCallbackId = msg.messageId + ":row";
        proxy.onrow = msg.args.callback;
        msg.args.callback = rowCallbackId;
        handlerMap[rowCallbackId] = proxy;
      } else if ("string" === typeof msg.args.callback) {
        toss(
          "exec callback may not be a string when using the Promise interface."
        );
      }
    }
    let p3 = new Promise(function(resolve2, reject) {
      proxy.resolve = resolve2;
      proxy.reject = reject;
      handlerMap[msg.messageId] = proxy;
      debug(
        "Posting",
        msg.type,
        "message to Worker dbId=" + (dbId || "default") + ":",
        msg
      );
      config.worker.postMessage(msg);
    });
    if (rowCallbackId)
      p3 = p3.finally(() => delete handlerMap[rowCallbackId]);
    return p3;
  };
};
globalThis.sqlite3Worker1Promiser.defaultConfig = {
  worker: function() {
    return new Worker(
      new URL("sqlite3-worker1-bundler-friendly.mjs", import.meta.url),
      {
        type: "module"
      }
    );
  },
  onerror: (...args) => console.error("worker1 promiser error", ...args)
};
sqlite3Worker1Promiser.v2 = function(config) {
  let oldFunc;
  if ("function" == typeof config) {
    oldFunc = config;
    config = {};
  } else if ("function" === typeof (config == null ? void 0 : config.onready)) {
    oldFunc = config.onready;
    delete config.onready;
  }
  const promiseProxy = /* @__PURE__ */ Object.create(null);
  config = Object.assign(config || /* @__PURE__ */ Object.create(null), {
    onready: async function(func) {
      try {
        if (oldFunc)
          await oldFunc(func);
        promiseProxy.resolve(func);
      } catch (e2) {
        promiseProxy.reject(e2);
      }
    }
  });
  const p3 = new Promise(function(resolve2, reject) {
    promiseProxy.resolve = resolve2;
    promiseProxy.reject = reject;
  });
  try {
    this.original(config);
  } catch (e2) {
    promiseProxy.reject(e2);
  }
  return p3;
}.bind({
  original: sqlite3Worker1Promiser
});
var sqlite3_worker1_promiser_default = sqlite3Worker1Promiser.v2;

// ../../../node_modules/.pnpm/@sqlite.org+sqlite-wasm@3.48.0-build4/node_modules/@sqlite.org/sqlite-wasm/index.mjs
var sqlite3Worker1Promiser2 = globalThis.sqlite3Worker1Promiser;
var sqlite_wasm_default = sqlite3_bundler_friendly_default;

// ../../../packages/sqlite-wasm-kysely/dist/util/sqliteWasmBinary.js
init_define_ENV_DEFINED_IN_BUILD_STEP();
function base64ToArrayBuffer(base64) {
  var binaryString = atob(base64);
  var bytes = new Uint8Array(binaryString.length);
  for (var i2 = 0; i2 < binaryString.length; i2++) {
    bytes[i2] = binaryString.charCodeAt(i2);
  }
  return bytes.buffer;
}
var sqliteWasmBase64 = "AGFzbQEAAAABqwVZYAJ/fwF/YAF/AX9gA39/fwF/YAF/AGADf39/AGACf38AYAR/f39/AX9gBX9/f39/AX9gBH9/f38AYAR/f39+AX9gBn9/f39/fwF/YAJ/fgF/YAV/f39/fwBgAABgAXwBfGAAAX9gAX8BfmAHf39/f39/fwF/YAZ/f39/f38AYAJ/fgBgCH9/f39/f39/AX9gBH9+f38Bf2ADf39+AX9gAn9/AX5gA39+fwF/YAl/f39/f39/f38Bf2ABfgF/YAR/fn9/AGACfHwBfGADf39+AGABfwF8YAd/f39/f39/AGAJf39/f39/f39/AGADf35+AX9gAXwBfmAGf39/f39+AX9gBX9/f39+AGACf3wAYAR/f39+AGABfABgAAF8YAF+AX5gBX9/fn9/AX9gBH9/fn8AYAJ/fwF8YAp/f39/f39/f39/AX9gA39/fwF+YAN/fn8BfmAHf39/f35/fwF/YAZ/f39+f38Bf2AHf39/f39+fgBgC39/f39/f39/f39/AX9gAXwBf2AAAX5gBX9+f39/AX9gC39/f39/f39/f39/AGAIf39/f39/f38AYAR/f35/AX9gA398fwF/YAN8fH8BfGACfH8BfGAGf3x/f39/AX9gAn5/AX9gBH9+fn8AYAJ+fwBgA398fABgBn9/f35+fwF/YAV/f35/fwBgA39/fAF/YAJ8fgF/YAh/f39/f35/fwBgA39/fgF+YAJ+fAF/YAd/f39+f39/AX9gDX9/f39/f39/f39/f38AYAh/fn5/f39/fwF/YAJ/fgF+YAZ/f39/fn4AYAN/fn4AYAZ+f39/f38BfmAHf35/f39/fwF/YAR/f35+AGACfH8Bf2ACf3wBfGADfH5+AXxgBH9/f34BfmADfn9/AX9gBX9+fn5+AGACfn4BfAKiByMDZW52E19fc3lzY2FsbF9mYWNjZXNzYXQABhZ3YXNpX3NuYXBzaG90X3ByZXZpZXcxCGZkX2Nsb3NlAAEDZW52E2Vtc2NyaXB0ZW5fZGF0ZV9ub3cAKANlbnYgX2Vtc2NyaXB0ZW5fZ2V0X25vd19pc19tb25vdG9uaWMADwNlbnYSZW1zY3JpcHRlbl9nZXRfbm93ACgDZW52EF9fc3lzY2FsbF9mY2htb2QAAANlbnYPX19zeXNjYWxsX2NobW9kAAADZW52El9fc3lzY2FsbF9mY2hvd24zMgACA2VudhFfX3N5c2NhbGxfZmNudGw2NAACA2VudhBfX3N5c2NhbGxfb3BlbmF0AAYDZW52D19fc3lzY2FsbF9pb2N0bAACFndhc2lfc25hcHNob3RfcHJldmlldzEIZmRfd3JpdGUABhZ3YXNpX3NuYXBzaG90X3ByZXZpZXcxB2ZkX3JlYWQABgNlbnYRX19zeXNjYWxsX2ZzdGF0NjQAAANlbnYQX19zeXNjYWxsX3N0YXQ2NAAAA2VudhRfX3N5c2NhbGxfbmV3ZnN0YXRhdAAGA2VudhFfX3N5c2NhbGxfbHN0YXQ2NAAAFndhc2lfc25hcHNob3RfcHJldmlldzEHZmRfc3luYwABA2VudhVfX3N5c2NhbGxfZnRydW5jYXRlNjQACwNlbnYQX19zeXNjYWxsX2dldGN3ZAAAFndhc2lfc25hcHNob3RfcHJldmlldzERZW52aXJvbl9zaXplc19nZXQAABZ3YXNpX3NuYXBzaG90X3ByZXZpZXcxC2Vudmlyb25fZ2V0AAAWd2FzaV9zbmFwc2hvdF9wcmV2aWV3MQdmZF9zZWVrABUDZW52EV9fc3lzY2FsbF9ta2RpcmF0AAIDZW52CV90enNldF9qcwAIA2Vudg1fbG9jYWx0aW1lX2pzAEADZW52Cl9tdW5tYXBfanMAIwNlbnYIX21tYXBfanMAMANlbnYUX19zeXNjYWxsX3JlYWRsaW5rYXQABgNlbnYPX19zeXNjYWxsX3JtZGlyAAEDZW52El9fc3lzY2FsbF91bmxpbmthdAACA2VudhNfX3N5c2NhbGxfdXRpbWVuc2F0AAYWd2FzaV9zbmFwc2hvdF9wcmV2aWV3MQ1mZF9mZHN0YXRfZ2V0AAADZW52FmVtc2NyaXB0ZW5fcmVzaXplX2hlYXAAAQNlbnYGbWVtb3J5AgGAAoCAAgOvFK0UDQYBAgYHAQAFBQMBAwEQBQUFBQUFBQUEAQ8NBQ0BAw8AAwEpKRoaAAsLBAQQCx4BBAsABQUEQQEEEAsFAQMWAQEBAQAABgYEBQAAAgcAAAYAAgEGAgMEAgYGBQIAAgACAAAGAAAHARcBBwADAQYRAQEAAwoEABMqAwEFAAEAAAMBAwUAAAABAQMBA0IIGgUBAgMMBQUBAwACBgYBAgMAAQIAAAACAQAD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c3FsaXRlM19tYWxsb2M2NABID3NxbGl0ZTNfcmVhbGxvYwBJEXNxbGl0ZTNfcmVhbGxvYzY0AEsSc3FsaXRlM192YWx1ZV90ZXh0AF4Sc3FsaXRlM19yYW5kb21uZXNzAGoPc3FsaXRlM19zdHJpY21wAGsQc3FsaXRlM19zdHJuaWNtcABtFXNxbGl0ZTNfdXJpX3BhcmFtZXRlcgByE3NxbGl0ZTNfdXJpX2Jvb2xlYW4AdhFzcWxpdGUzX3NlcmlhbGl6ZQCEARJzcWxpdGUzX3ByZXBhcmVfdjIAhwEMc3FsaXRlM19zdGVwAIgBFHNxbGl0ZTNfY29sdW1uX2ludDY0AIkBDXNxbGl0ZTNfcmVzZXQAigEMc3FsaXRlM19leGVjAIsBEnNxbGl0ZTNfY29sdW1uX2ludACMARBzcWxpdGUzX2ZpbmFsaXplAI4BFHNxbGl0ZTNfZmlsZV9jb250cm9sAI8BE3NxbGl0ZTNfY29sdW1uX25hbWUApQETc3FsaXRlM19jb2x1bW5fdGV4dACmARNzcWxpdGUzX2NvbHVtbl90eXBlAKcBDnNxbGl0ZTNfZXJybXNnAKkBE3NxbGl0ZTNfZGVzZXJpYWxpemUArQEWc3FsaXRlM19jbGVhcl9iaW5kaW5ncwD2ARJzcWxpdGUzX3ZhbHVlX2Jsb2IA+QETc3FsaXRlM192YWx1ZV9ieXRlcwD9ARRzcWxpdGUzX3ZhbHVlX2RvdWJsZQCBAhFzcWxpdGUzX3ZhbHVlX2ludACDAhNzcWxpdGUzX3ZhbHVlX2ludDY0AIUCFXNxbGl0ZTNfdmFsdWVfc3VidHlwZQCGAhVzcWxpdGUzX3ZhbHVlX3BvaW50ZXIAhwISc3FsaXRlM192YWx1ZV90eXBlAIkCFnNxbGl0ZTNfdmFsdWVfbm9jaGFuZ2UAigIWc3FsaXRlM192YWx1ZV9mcm9tYmluZACLAhFzcWxpdGUzX3ZhbHVlX2R1cACMAhJzcWxpdGUzX3ZhbHVlX2ZyZWUAjwITc3FsaXRlM19yZXN1bHRfYmxvYgCQAhtzcWxpdGUzX3Jlc3VsdF9lcnJvcl90b29iaWcAkwIac3FsaXRlM19yZXN1bHRfZXJyb3Jfbm9tZW0AlAIVc3FsaXRlM19yZXN1bHRfZG91YmxlAJcCFHNxbGl0ZTNfcmVzdWx0X2Vycm9yAJkCEnNxbGl0ZTNfcmVzdWx0X2ludACcAhRzcWxpdGUzX3Jlc3VsdF9pbnQ2NACeAhNzcWxpdGUzX3Jlc3VsdF9udWxsAJ8CFnNxbGl0ZTNfcmVzdWx0X3BvaW50ZXIAoQIWc3FsaXRlM19yZXN1bHRfc3VidHlwZQCkAhNzcWxpdGUzX3Jlc3VsdF90ZXh0AKUCF3NxbGl0ZTNfcmVzdWx0X3plcm9ibG9iAKsCGXNxbGl0ZTNfcmVzdWx0X3plcm9ibG9iNjQArAIZc3FsaXRlM19yZXN1bHRfZXJyb3JfY29kZQCuAhFzcWxpdGUzX3VzZXJfZGF0YQCyAhlzcWxpdGUzX2NvbnRleHRfZGJfaGFuZGxlALMCFXNxbGl0ZTNfdnRhYl9ub2NoYW5nZQC0AhVzcWxpdGUzX3Z0YWJfaW5fZmlyc3QAtQIUc3FsaXRlM192dGFiX2luX25leHQAvgIZc3FsaXRlM19hZ2dyZWdhdGVfY29udGV4dAC/AhNzcWxpdGUzX2dldF9hdXhkYXRhAMECE3NxbGl0ZTNfc2V0X2F1eGRhdGEAwgIUc3FsaXRlM19jb2x1bW5fY291bnQAxAISc3FsaXRlM19kYXRhX2NvdW50AMUCE3NxbGl0ZTNfY29sdW1uX2Jsb2IAxgIUc3FsaXRlM19jb2x1bW5fYnl0ZXMAxwIVc3FsaXRlM19jb2x1bW5fZG91YmxlAMgCFHNxbGl0ZTNfY29sdW1uX3ZhbHVlAMkCF3NxbGl0ZTNfY29sdW1uX2RlY2x0eXBlAMsCEXNxbGl0ZTNfYmluZF9ibG9iAMwCE3NxbGl0ZTNfYmluZF9kb3VibGUAzwIQc3FsaXRlM19iaW5kX2ludADQAhJzcWxpdGUzX2JpbmRfaW50NjQA0QIRc3FsaXRlM19iaW5kX251bGwA0gIUc3FsaXRlM19iaW5kX3BvaW50ZXIA0wIRc3FsaXRlM19iaW5kX3RleHQA1AIcc3FsaXRlM19iaW5kX3BhcmFtZXRlcl9jb3VudADXAhtzcWxpdGUzX2JpbmRfcGFyYW1ldGVyX25hbWUA2AIcc3FsaXRlM19iaW5kX3BhcmFtZXRlcl9pbmRleADaAhFzcWxpdGUzX2RiX2hhbmRsZQDdAhVzcWxpdGUzX3N0bXRfcmVhZG9ubHkA3gIWc3FsaXRlM19zdG10X2lzZXhwbGFpbgDfAhRzcWxpdGUzX3N0bXRfZXhwbGFpbgDgAhFzcWxpdGUzX3N0bXRfYnVzeQDhAhNzcWxpdGUzX3N0bXRfc3RhdHVzAOMCC3NxbGl0ZTNfc3FsAOQCFHNxbGl0ZTNfZXhwYW5kZWRfc3FsAOUCFXNxbGl0ZTNfcHJldXBkYXRlX29sZADoAhdzcWxpdGUzX3ByZXVwZGF0ZV9jb3VudAD0AhdzcWxpdGUzX3ByZXVwZGF0ZV9kZXB0aAD1AhtzcWxpdGUzX3ByZXVwZGF0ZV9ibG9id3JpdGUA9gIVc3FsaXRlM19wcmV1cGRhdGVfbmV3APcCGnNxbGl0ZTNfdmFsdWVfbnVtZXJpY190eXBlAPgCFnNxbGl0ZTNfc2V0X2F1dGhvcml6ZXIAnwMPc3FsaXRlM19zdHJnbG9iAKEDD3NxbGl0ZTNfc3RybGlrZQCkAxZzcWxpdGUzX2F1dG9fZXh0ZW5zaW9uAKUDHXNxbGl0ZTNfY2FuY2VsX2F1dG9fZXh0ZW5zaW9uAKYDHHNxbGl0ZTNfcmVzZXRfYXV0b19leHRlbnNpb24ApwMSc3FsaXRlM19wcmVwYXJlX3YzAKsDFXNxbGl0ZTNfY3JlYXRlX21vZHVsZQCsAxhzcWxpdGUzX2NyZWF0ZV9tb2R1bGVfdjIArgMUc3FsaXRlM19kcm9wX21vZHVsZXMArwMUc3FsaXRlM19kZWNsYXJlX3Z0YWIAsAMYc3FsaXRlM192dGFiX29uX2NvbmZsaWN0ALsDFnNxbGl0ZTNfdnRhYl9jb2xsYXRpb24AvQMPc3FsaXRlM192dGFiX2luAMEDFnNxbGl0ZTNfdnRhYl9yaHNfdmFsdWUAwgMVc3FsaXRlM192dGFiX2Rpc3RpbmN0AMMDFHNxbGl0ZTNfa2V5d29yZF9uYW1lAMQDFXNxbGl0ZTNfa2V5d29yZF9jb3VudADFAxVzcWxpdGUzX2tleXdvcmRfY2hlY2sAxgMQc3FsaXRlM19jb21wbGV0ZQDIAxJzcWxpdGUzX2xpYnZlcnNpb24AyQMZc3FsaXRlM19saWJ2ZXJzaW9uX251bWJlcgDKAxBzcWxpdGUzX3NodXRkb3duAMsDGXNxbGl0ZTNfbGFzdF9pbnNlcnRfcm93aWQA0QMdc3FsaXRlM19zZXRfbGFzdF9pbnNlcnRfcm93aWQA0gMRc3FsaXRlM19jaGFuZ2VzNjQA0wMPc3FsaXRlM19jaGFuZ2VzANQDF3NxbGl0ZTNfdG90YWxfY2hhbmdlczY0ANUDFXNxbGl0ZTNfdG90YWxfY2hhbmdlcwDWAxFzcWxpdGUzX3R4bl9zdGF0ZQDXAxBzcWxpdGUzX2Nsb3NlX3YyANwDFHNxbGl0ZTNfYnVzeV9oYW5kbGVyAN0DGHNxbGl0ZTNfcHJvZ3Jlc3NfaGFuZGxlcgDeAxRzcWxpdGUzX2J1c3lfdGltZW91dADfAxFzcWxpdGUzX2ludGVycnVwdADhAxZzcWxpdGUzX2lzX2ludGVycnVwdGVkAOIDF3NxbGl0ZTNfY3JlYXRlX2Z1bmN0aW9uAOMDGnNxbGl0ZTNfY3JlYXRlX2Z1bmN0aW9uX3YyAOYDHnNxbGl0ZTNfY3JlYXRlX3dpbmRvd19mdW5jdGlvbgDnAxlzcWxpdGUzX292ZXJsb2FkX2Z1bmN0aW9uAOgDEHNxbGl0ZTNfdHJhY2VfdjIA7gMTc3FsaXRlM19jb21taXRfaG9vawDvAxNzcWxpdGUzX3VwZGF0ZV9ob29rAPADFXNxbGl0ZTNfcm9sbGJhY2tfaG9vawDxAxZzcWxpdGUzX3ByZXVwZGF0ZV9ob29rAPIDFHNxbGl0ZTNfZXJyb3Jfb2Zmc2V0APoDD3NxbGl0ZTNfZXJyY29kZQD7AxhzcWxpdGUzX2V4dGVuZGVkX2VycmNvZGUA/AMOc3FsaXRlM19lcnJzdHIA/QMNc3FsaXRlM19saW1pdAD+AwxzcWxpdGUzX29wZW4A/wMPc3FsaXRlM19vcGVuX3YyAIoEGHNxbGl0ZTNfY3JlYXRlX2NvbGxhdGlvbgCLBBtzcWxpdGUzX2NyZWF0ZV9jb2xsYXRpb25fdjIAjAQYc3FsaXRlM19jb2xsYXRpb25fbmVlZGVkAI4EFnNxbGl0ZTNfZ2V0X2F1dG9jb21taXQAjwQdc3FsaXRlM190YWJsZV9jb2x1bW5fbWV0YWRhdGEAkAQdc3FsaXRlM19leHRlbmRlZF9yZXN1bHRfY29kZXMAlgQPc3FsaXRlM191cmlfa2V5AKUEEXNxbGl0ZTNfdXJpX2ludDY0AKgED3NxbGl0ZTNfZGJfbmFtZQCqBBNzcWxpdGUzX2RiX2ZpbGVuYW1lAKsEE3NxbGl0ZTNfZGJfcmVhZG9ubHkArQQac3FsaXRlM19jb21waWxlb3B0aW9uX3VzZWQArgQZc3FsaXRlM19jb21waWxlb3B0aW9uX2dldACvBBNzcWxpdGUzc2Vzc2lvbl9kaWZmALAEFXNxbGl0ZTNzZXNzaW9uX2F0dGFjaAC/BBVzcWxpdGUzc2Vzc2lvbl9jcmVhdGUAwwQVc3FsaXRlM3Nlc3Npb25fZGVsZXRlAMUEG3NxbGl0ZTNzZXNzaW9uX3RhYmxlX2ZpbHRlcgDHBBhzcWxpdGUzc2Vzc2lvbl9jaGFuZ2VzZXQAyAQdc3FsaXRlM3Nlc3Npb25fY2hhbmdlc2V0X3N0cm0A0wQcc3FsaXRlM3Nlc3Npb25fcGF0Y2hzZXRfc3RybQDUBBdzcWxpdGUzc2Vzc2lvbl9wYXRjaHNldADVBBVzcWxpdGUzc2Vzc2lvbl9lbmFibGUA1gQXc3FsaXRlM3Nlc3Npb25faW5kaXJlY3QA1wQWc3FsaXRlM3Nlc3Npb25faXNlbXB0eQDYBBpzcWxpdGUzc2Vzc2lvbl9tZW1vcnlfdXNlZADZBBxzcWxpdGUzc2Vzc2lvbl9vYmplY3RfY29uZmlnANoEHXNxbGl0ZTNzZXNzaW9uX2NoYW5nZXNldF9zaXplANsEFnNxbGl0ZTNjaGFuZ2VzZXRfc3RhcnQA3AQZc3FsaXRlM2NoYW5nZXNldF9zdGFydF92MgDeBBtzcWxpdGUzY2hhbmdlc2V0X3N0YXJ0X3N0cm0A3wQec3FsaXRlM2NoYW5nZXNldF9zdGFydF92Ml9zdHJtAOAEFXNxbGl0ZTNjaGFuZ2VzZXRfbmV4dADhBBNzcWxpdGUzY2hhbmdlc2V0X29wAOkEE3NxbGl0ZTNjaGFuZ2VzZXRfcGsA6gQUc3FsaXRlM2NoYW5nZXNldF9vbGQA6wQUc3FsaXRlM2NoYW5nZXNldF9uZXcA7AQZc3FsaXRlM2NoYW5nZXNldF9jb25mbGljdADtBB1zcWxpdGUzY2hhbmdlc2V0X2ZrX2NvbmZsaWN0cwDuBBlzcWxpdGUzY2hhbmdlc2V0X2ZpbmFsaXplAO8EF3NxbGl0ZTNjaGFuZ2VzZXRfaW52ZXJ0APAEHHNxbGl0ZTNjaGFuZ2VzZXRfaW52ZXJ0X3N0cm0A8wQZc3FsaXRlM2NoYW5nZXNldF9hcHBseV92MgD0BBZzcWxpdGUzY2hhbmdlc2V0X2FwcGx5AP4EHnNxbGl0ZTNjaGFuZ2VzZXRfYXBwbHlfdjJfc3RybQD/BBtzcWxpdGUzY2hhbmdlc2V0X2FwcGx5X3N0cm0AgAUWc3FsaXRlM2NoYW5nZWdyb3VwX25ldwCBBRZzcWxpdGUzY2hhbmdlZ3JvdXBfYWRkAIIFGXNxbGl0ZTNjaGFuZ2Vncm91cF9vdXRwdXQAjwUbc3FsaXRlM2NoYW5nZWdyb3VwX2FkZF9zdHJtAJEFHnNxbGl0ZTNjaGFuZ2Vncm91cF9vdXRwdXRfc3RybQCSBRlzcWxpdGUzY2hhbmdlZ3JvdXBfZGVsZXRlAJMFF3NxbGl0ZTNjaGFuZ2VzZXRfY29uY2F0AJQFHHNxbGl0ZTNjaGFuZ2VzZXRfY29uY2F0X3N0cm0AlQUVc3FsaXRlM3Nlc3Npb25fY29uZmlnAJYFEHNxbGl0ZTNfc291cmNlaWQAlwUYc3FsaXRlM19fd2FzbV9wc3RhY2tfcHRyAJgFHHNxbGl0ZTNfX3dhc21fcHN0YWNrX3Jlc3RvcmUAmQUac3FsaXRlM19fd2FzbV9wc3RhY2tfYWxsb2MAmgUec3FsaXRlM19fd2FzbV9wc3RhY2tfcmVtYWluaW5nAJsFGnNxbGl0ZTNfX3dhc21fcHN0YWNrX3F1b3RhAJwFFnNxbGl0ZTNfX3dhc21fZGJfZXJyb3IAnQUZc3FsaXRlM19fd2FzbV90ZXN0X3N0cnVjdACeBRdzcWxpdGUzX193YXNtX2VudW1fanNvbgCfBRhzcWxpdGUzX193YXNtX3Zmc191bmxpbmsAoAUUc3FsaXRlM19fd2FzbV9kYl92ZnMAoQUWc3FsaXRlM19fd2FzbV9kYl9yZXNldACiBR9zcWxpdGUzX193YXNtX2RiX2V4cG9ydF9jaHVua2VkAKMFGnNxbGl0ZTNfX3dhc21fZGJfc2VyaWFsaXplAKQFHXNxbGl0ZTNfX3dhc21fdmZzX2NyZWF0ZV9maWxlAKUFH3NxbGl0ZTNfX3dhc21fcG9zaXhfY3JlYXRlX2ZpbGUApwUic3FsaXRlM19fd2FzbV9rdnZmc01ha2VLZXlPblBzdGFjawCoBRtzcWxpdGUzX193YXNtX2t2dmZzX21ldGhvZHMAqgUZc3FsaXRlM19fd2FzbV92dGFiX2NvbmZpZwCrBRpzcWxpdGUzX193YXNtX2RiX2NvbmZpZ19pcACsBRtzcWxpdGUzX193YXNtX2RiX2NvbmZpZ19waWkArQUZc3FsaXRlM19fd2FzbV9kYl9jb25maWdfcwCuBRZzcWxpdGUzX193YXNtX2NvbmZpZ19pAK8FF3NxbGl0ZTNfX3dhc21fY29uZmlnX2lpALAFFnNxbGl0ZTNfX3dhc21fY29uZmlnX2oAsQUYc3FsaXRlM19fd2FzbV9xZm10X3Rva2VuALIFGXNxbGl0ZTNfX3dhc21faW5pdF93YXNtZnMAswUZc3FsaXRlM19fd2FzbV90ZXN0X2ludHB0cgC0BRpzcWxpdGUzX193YXNtX3Rlc3Rfdm9pZHB0cgC1BRxzcWxpdGUzX193YXNtX3Rlc3RfaW50NjRfbWF4ALYFHHNxbGl0ZTNfX3dhc21fdGVzdF9pbnQ2NF9taW4AtwUfc3FsaXRlM19fd2FzbV90ZXN0X2ludDY0X3RpbWVzMgC4BR9zcWxpdGUzX193YXNtX3Rlc3RfaW50NjRfbWlubWF4ALkFG3NxbGl0ZTNfX3dhc21fdGVzdF9pbnQ2NHB0cgC6BSFzcWxpdGUzX193YXNtX3Rlc3Rfc3RhY2tfb3ZlcmZsb3cAuwUcc3FsaXRlM19fd2FzbV90ZXN0X3N0cl9oZWxsbwC8BR9zcWxpdGUzX193YXNtX1NRTFRlc3Rlcl9zdHJnbG9iAL0FBm1hbGxvYwDAFARmcmVlAMIUB3JlYWxsb2MAwxQbZW1zY3JpcHRlbl9idWlsdGluX21lbWFsaWduAMUUGV9lbXNjcmlwdGVuX3N0YWNrX3Jlc3RvcmUAzBQXX2Vtc2NyaXB0ZW5fc3RhY2tfYWxsb2MAzRQcZW1zY3JpcHRlbl9zdGFja19nZXRfY3VycmVudADOFAniCQEAQQEL8gRAswG3AscH1wejBqQGowKoApYDmAOuCa8JsAngA+oD9AOBBIMEhATOA6IGpQbJAbEEsgSzBLQEuwS8BL0EvgSHE4gTiROKE8QE7ATyBvMG9Ab1BvYG9wb4Bp8InQjuB4QIhQi9CL4IvwipC+AL4QvSC6ALlQrwCpoKmwqcCqEK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BCACoiABIAArAwgiBaKgoDkDACAAIAMrAwggAysDAKA5AwAgACADKwMIIAArAwChOQMIIAAgAysDACAAKwMIoDkDCAsXACAARQRAQQAPCyAAEJUUQf////8DcQsxACAAIAKsEFMiAkEASgRAIAAoAgQgACgCEGogASACEJcTGiAAIAAoAhAgAmo2AhALC5oBAwF+AXwBfyAALwEQIgNBJHEEQCAAKQMADwsCQCADQQhxBEBCgICAgICAgICAfyEBIAArAwAiAkT////////fw2MNAUL///////////8AIQEgAkT////////fQ2QNASACmUQAAAAAAADgQ2MEQCACsA8LQoCAgICAgICAgH8PCyADQRJxRQ0AIAAoAghFDQAgABCEAiEBCyABCxMAIAAEQCAAIAEQ7wIPCyABEEcLKAAgACABOgAUIAAoAgwEQCAAEF8LIAFBEkYEQCAAKAIAQRIQmgIaCwsJACAAQQEQ/AELNQAgAC0AFUEEcQRAIAAoAgAgACgCBBAyIAAgAC0AFUH7AXE6ABULIABBADYCECAAQgA3AgQLWgAgAUUEQCAAIAIQ7wIPCwJAAkAgASAAKALkAk8NACAAKALcAiABTQRAIAJCgQFaDQEMAgsgASAAKALgAkkNACACIAAzAbYCWA0BCyAAIAEgAhDABSEBCyABCx8BAX8gAEUgAEGgogVGckUEQCAAEGIhASAAEEALIAELOgEBfwJAIAAoAgQiAUUNACABIAAoAhBqQQA6AAAgACgCDEUNACAALQAVQQRxDQAgABBjDwsgACgCBAtNAQF/AkAgACgCACAAKAIQQQFqrRBcIgEEQCABIAAoAgQgACgCEEEBahCXExogACAALQAVQQRyOgAVDAELIABBBxBdCyAAIAE2AgQgAQtLAQF/QhgQSCIBRQRAQaCiBQ8LIAAEfyAAKAJ4BUGAlOvcAwshACABQQA7ARQgAUEANgIQIAEgADYCDCABQQA2AgggAUIANwIAIAELdwIBfwF/IwBB8ABrIgIkAAJ/IABFBEBB6v4BECQaQQAMAQtBABA7DQAaIAJBADsBHCACQQA2AhggAkLGgICAgMCyzTs3AhAgAkEANgIIIAIgAkEgajYCDCACQQhqIAAgARBMIAJBCGoQYgshAyACQfAAaiQAIAMLLQIBfwF/IwBBEGsiAyQAEDtFBEAg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KALwAREkAAw7CyAFQgA3A+ACIAVBADYCyAMgACAEELMHIQwgACgCYCAEKAIEQQJ0aigCACIKLQAFQQJxRQRAIAooAiQgBUHIA2oQ7AciBg1AAkAgBSgCyAMEQCAFQgE3A+ACDAELIAUgCigCJBCZAyIJNwPgAiAJQv///////////wBRBEAgCiAKLQAFQQJyOgAFDAELIAUgCUIBfDcD4AILQQAhDQsgBCgCDCIDBEAgCyECICIoAgAiAQRAA0AgASICKAIEIgENAAsgAigCDCECCyACIANBKGxqIgEQtgdBDSEGIAEpAwAiCUL///////////8AUQ1AIAotAAVBAnENQCAJIAUpA+ACIg9ZBEAgBSAJQgF8Ig83A+ACCyABIA83AwALAkAgCi0ABUECcQRAQQAhAQNAAkBBCCAFQeACahBqIAUgBSkD4AJC//////////8/g0IBfCIJNwPgAiAKKAIkIAlBACAFQcgDahDwByECIAIgBSgCyAMiA3INACABQeMASSEHIAFBAWohASAHDQELCyACDQFBACENIANFDQELIApBADYCGCAKQQA6AAMgDCAFKQPgAjcDAAw7CyACQQ0gAhshBgw/CyAAIAQQswchASAAKAJgIAQoAgRBAnRqKAIAIgIgAikDECIJQgF8NwMQIAEgCTcDAAw5CyAEKAIMIQEMAQsgCyAEKAIMIgFBKGxqIgItABBBJHENACAFQeACaiACQSgQlxMaIAVB4AJqQcMAELcHIAUvAfACQQRxRQ00IAUpA+ACDAELIAsgAUEobGopAwALIQkgACgCYCAEKAIEQQJ0aigCACIBKAIkIQJBACENIAVBADYC0AIgAiAJQQAgBUHQAmoQ8AchBiABQQA2AhggASAJNwM4IAFBADsBAiABIAUoAtACIgI2AhwCQCACBEAgBCgCCEUNASAGIQ0MNAsgBkUNNgw7C0HlhAYQ4AEhBgw6CyAEKAIQIAAoAmAgBCgCBEECdGooAgAvAQZMDTQLIAAoAmAgBCgCBEECdGooAgAhASAFIAsgBCgCDEEobGoiAzYC5AIgBSAEKAIQIgI7AfQCAkAgAkH//wNxBEAgASgCKCECIAVBADoA9gIgBSACNgLgAiABKAIkIAVB4AJqIAFBHGoQ3wchBgwBCyADLQARQQRxBEAgAxD6AQ03CyABKAIoEPECIgJF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/wJxOwEQQQAhAQsgAQtfAQF/QQchASAAIAAoAgxBA2pBARD7AUUEQCAAKAIIIAAoAgxqQQA6AAAgACgCCCAAKAIMakEAOgABIAAoAgggACgCDGpBADoAAiAAIAAvARBBgARyOwEQQQAhAQsgAQsHACAAEPMBCycAIABBACACQQBOG0UEQCABIAMgABCRAg8LIAAgASACQQAgAxCSAgseACABQQFqQQJPBEAgACABEQMACyACBEAgAhCTAgsLUgEBfwJAAkAgACgCACIFIAEgAqwgAyAEEJkBIgIEQCACQRJGDQEgABCUAg8LIAUtABBBAnFFBEAgBSAALQAYOgASCyAFEJUCRQ0BCyAAEJMCCwshACAABEAgAEESNgIUIAAoAgBBl40BQn9BAUEAEJkBGgsLIQAgAARAIAAoAgAQmgEgAEEHNgIUIAAoAgAoAhQQlAELCzwCAX8BfyAALwEQIgJBEnFFBEBBAA8LIAAoAgwhASACQYAIcQRAIAAoAgAgAWohAQsgASAAKAIUKAJ4SgtBAAJAIABFBEAgA0EBakECSQ0BIAEgAxEDAA8LIAJCgICAgAhaBEAgASADIAAQkQIPCyAAIAEgAqdBACADEJICCwsRACAABEAgACgCACABEJgCCwsdACAAEJoBIAEgAWEEQCAAQQg7ARAgACABOQMACwsgACAABEAgAEEBNgIUIAAoAgAgASACrEEBQX8QmQEaCwsrAAJAIABFDQAgACgCgAIiAEUNACAAIAE2AgwgACAAKAIoQQFqNgIoCyABCzAAIAEgACgCGEoEQCAAIAFBABD7AQ8LIAAgACgCIDYCCCAAIAAvARBBLXE7ARBBAAsSACAABEAgACgCACABrBCYAQsLFQAgABCaASAAQQQ7ARAgACABNwMACxEAIAAEQCAAKAIAIAEQmAELCw8AIAAEQCAAKAIAEJoBCwtAAQF/IAAuARAiAUEASARAIAAgACgCABCwBxogAC8BECEBCyABQYAgcQRAIAAoAgggACgCJBEDAAsgAEEBOwEQCzkAAkAgAEUEQCADQQFqQQJJDQEgASADEQMADwsgACgCACIAEPcBIABBATsBECAAIAEgAiADEKICCws4ACAAEPgBIABB8AA6ABMgAEGBNDsBECAAIAE2AgggACADQQggAxs2AiQgACACQYGBAyACGzYCAAsDAAEL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CJoLIgg5AwALIAwgACACRiAKQQBKcXFFIAlBAExyRQRAIAkhBgwBCwJAIAlBAkgNAEF/IQYgDEF/cyAJQQNHcQ0AIApBAEoNAQtBACEGCyAHQRBqJAAgBgs8AAJ/QQEgAEQAAAAAAAAAAGENABpBACAAvSABub1SIAFCgICAgICAgHxTcg0AGiABQoCAgICAgIAEUwsL1AQHAX8BfwF/AX8BfgF/AX8CfyADQQFGBEAgACEEQQEMAQtBAyADayEFIAJBfnEhBANAAkAgBCAFTA0AIAAgBWotAAANACAFQQJqIQUMAQsLIAQgBUohBiAFQQFzIQIgACADQQFxaiEEQQILIQMgACACaiEAAkADQEEBIQcgACAETQ0BIAQtAAAiBUHghQNqLQAAQQFxBEAgAyAEaiEEDAELCwJAAkAgBUEraw4DAQIAAgsgAyAEaiEEQQAhBwwBCyADIARqIQQLIAQhBQNAAkAgACAFSwRAIAUtAABBMEYNAQtBACECA0ACQCACIAVqIgkgAE8iCg0AIAktAAAiCUEwa0H/AXFBCUsNACACIANqIQIgCEIKfiAJrUL/AYN8QjB9IQgMAQsLIAFC////////////AEKAgICAgICAgIB/IAcbIAhCACAIfSAHGyAIQgBTGzcDAAJAIAIgBCAFR3JFBEBBfyEGDAELIAYgCnINACACIQQDQEEBIQYgBCAFai0AAEHghQNqLQAAQQFxRQ0BIAUgAyAEaiIEaiAASQ0AC0EAIQYLAkAgAiADQRNsIgRJDQBBASEAIAIgBE0EQEEAIQRBACEAA0AgACAEQRFLckUEQCAFIAMgBGxqLAAAIARB6boCaiwAAGtBCmwhACAEQQFqIQQMAQsLIABFBEAgBSADQRJsaiwAAEE4ayEACyAAQQBIDQELIAFC////////////AEKAgICAgICAgIB/IAcbNwMAQQJBAyAGIAcbIAAbIQYLIAYPCyADIAVqIQUMAAsAC5wBAwF8AX4BfwJAIAAvARAiA0EgcUUEQAJ+AkAgACsDACIBRP///////9/DYw0AQv///////////wAgAUT////////fQ2QNARogAZlEAAAAAAAA4ENjRQ0AIAGwDAELQoCAgICAgICAgH8LIgJC////////////AHxCfVYgASACuWJyDQEgACACNwMACyAAIANBwOQDcUEE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AQQBfwF/AX8BfyMAQRBrIgMkACAAKAIAIQJBPCEEA0AgAiADQQxqEOYCIAJqIQIgAygCDCIBQbgBRg0ACyABQfYAa0ECSSABQaUBa0ECSXIgAUE8RnJFBEBBPCABIAFBAXRBgJ8Dai8BAEE8RhshBAsgACACNgIAIANBEGokACAEC6MBBgF/AX8BfgF/AX8BfyAAKAIAIAAoAgwiAWtBDG0hBEEBIQIgACgCCCABayIFQQxtIgZBGGxByAlqrSEDAkACQCAAQRBqIAFGBEBBACADEPUIIgFFDQIgASAAKAIMIAVBDGoQlxMaDAELIAEgAxD1CCIBRQ0BCyAAIAE2AgwgACABIARBDGxqNgIAIAAgBkEYbCABakG8CWo2AghBACECCyACC0sCAX8BfyAAKAIEIQIDQCAAKAIAIgEgACgCDE1FBEAgACABQQxrNgIAIAAgAS8BAiABQQRqELoDDAELCyACKAIAEJQBIAAgAjYCBAuvsQEYAX8BfwF/AX8BfwF/AX8BfwF/AX8BfwF/AX8BfgF/AX8BfwF/AX8BfwF/AX8BfwF/IwBBgAZrIgYkACAAKAIAIQQCQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJA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dGoiASgCBEYEQCABIAI2AgQLIAEgASgCAEEBazYCAAsgAxBAIAAgACgCBEEBayIDNgIEIAMNAiAAEPABDAILIAMgATYCDCADIAI2AggMAQsgAkUEQEEAIQQMAQtCEBBHIgZFBEAgAiEEDAELIAYgAjYCCCAGIAE2AgwgACAAKAIEQQFqIgM2AgQCQCADQQpJDQAgAyAAKAIAIgJBAXRNDQBBgAEgA0EBdCADQQR0QYAISxsiAyACRg0AQaStBygCACICBEAgAhENAAsgA0EDdK0QRyEDQaitBygCACICBEAgAhENAAsgA0UNACAAKAIMEEAgACADNgIMIAAgA0G0oAUoAgARAQAiAkEDdiIENgIAIANBACACQXhxEJkTIQcgACgCCCEDIABBADYCCANAIAMEQCADKAIAIQIgACAHIAMoAgwQzAggBHBBA3RqIAMQzQggAiEDDAELCyAFIAEQzAggACgCAHA2AgwLQQAhBCAAIAAoAgwiAyAFKAIMQQN0akEAIAMbIAYQzQgLIAVBEGokACAECzYAIAAQKEUEQEGhmQsQJA8LIAAgAzYC2AEgACACQQAgARsiAzYC1AEgACABQQAgAxs6AF5BAAsuACAAEChFBEBB3pkLECQaQQAPCyAAIAE2AuABIAAoAtwBIQEgACACNgLcASABCy4AIAAQKEUEQEH3mQsQJBpBAA8LIAAgATYC8AEgACgC7AEhASAAIAI2AuwBIAELLgAgABAoRQRAQZCaCxAkGkEADwsgACABNgLoASAAKALkASEBIAAgAjYC5AEgAQslACAARQRAQQAPCyAAIAE2AogCIAAoAoQCIQEgACACNgKEAiABCzIAIAAQKEUEQEH6mgsQJA8LIAFBAEoEQCAAQREgARD1AxpBAA8LIABBAEEAEPUDGkEACzgAAkAgACADSg0AQaStBygCACIABEAgABENAAsgASACEPYDGkGorQcoAgAiAEUNACAAEQ0AC0EACy4AIAAQKEUEQEGSmwsQJBpBAA8LIAAgATYCkAIgACgClAIhASAAIAI2ApQCIAELDwAgACABQQBBAEEAEPcDC8sBAgF/AX8jAEEQayIFJAACQCAAEChFBEBBspsLECQhBAwBCyADBEAgA0F/NgIACyAEBEAgBEF/NgIACyACQQRPBEBBwJsLECQhBAwBC0EMIQYCQAJAIAFF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qwdPDQAgAEEAIgJBzYADajYC0A8gAUGQrAcgAWtBviAgAEHQD2oQixQgAWoiAUGQqwdPDQAgAEEAQZHCAmo2AsAPIAFBkKwHIAFrQdvrACAAQcAPahCLFCABaiIBQZCrB08NACAAQeQANgKwDyABQQAgAWtBkKwHakGuvgEgAEGwD2oQixQgAWoiAUGQqwdPDQAgAEEAQbwhajYCoA8gAUGQrAcgAWtB2+sAIABBoA9qEIsUIAFqIgJBkKsHTw0AIABBkA9qQQAiAUHLiQFqNgIAIABCgICAgMAANwOIDyAAQY7+ADYChA8gAEGBgQM2AoAPIAJBkKwHIAJrQYogIABBgA9qEIsUIAJqIgJBkKsHTw0AIABB8A5qQQBB9coCajYCACAAQoSAgIDAADcD6A4gAEGKlQE2AuQOIABBzYADNgLgDiACQZCsByACa0GKICAAQeAOahCLFCACaiICQZCrB08NACAAQdAOakEAQfXKAmo2AgAgAEKIgICAwAA3A8gOIABB2Ds2AsQOIABBzYADNgLADiACQZCsByACa0GKICAAQcAOahCLFCACaiICQZCrB08NACAAQbAOakEAQZrLAmo2AgAgAEKMgICAwAA3A6gOIABBsSk2AqQOIABBzYADNgKgDiACQZCsByACa0GKICAAQaAOahCLFCACaiICQZCrB08NACAAQZAOakEAQeXLAmo2AgAgAEKQgICAwAA3A4gOIABBzDs2AoQOIABBzYADNgKADiACQZCsByACa0GKICAAQYAOahCLFCACaiICQZCrB08NACAAQfANakEAQeXLAmo2AgAgAEKUgICAwAA3A+gNIABBhiY2AuQNIABBzYADNgLgDSACQZCsByACa0GKICAAQeANahCLFCACaiICQZCrB08NACAAQdANakEAQZrLAmo2AgAgAEKYgICAwAA3A8gNIABBk4EBNgLEDSAAQc2AAzYCwA0gAkGQrAcgAmtBiiAgAEHADWoQixQgAmoiAkGQqwdPDQAgAEGwDWpBAEHlywJqNgIAIABCnICAgMAANwOoDSAAQfWXATYCpA0gAEHNgAM2AqANIAJBkKwHIAJrQYogIABBoA1qEIsUIAJqIgJBkKsHTw0AIABBkA1qQQBBp8sCajYCACAAQqCAgIDAADcDiA0gAEH27gA2AoQNIABBzYADNgKADSACQZCsByACa0GKICAAQYANahCLFCACaiICQZCrB08NACAAQfAMakEAQeXLAmo2AgAgAEKkgICAwAA3A+gMIABB9S42AuQMIABBzYADNgLgDCACQZCsByACa0GKICAAQeAMahCLFCACaiICQZCrB08NACAAQdAMakEAQeXLAmo2AgAgAEKogICAwAA3A8gMIABB8o0BNgLEDCAAQc2AAzYCwAwgAkGQrAcgAmtBiiAgAEHADGoQixQgAmoiAkGQqwdPDQAgAEGwDGpBAEGtzQJqNgIAIABCrICAgMAANwOoDCAAQZaAATYCpAwgAEHNgAM2AqAMIAJBkKwHIAJrQYogIABBoAxqEIsUIAJqIgJBkKsHTw0AIABBkAxqQQBBmssCajYCACAAQrCAgIDAADcDiAwgAEHPqwE2AoQMIABBzYADNgKADCACQZCsByACa0GKICAAQYAMahCLFCACaiICQZCrB08NACAAQfALakEAQYbLAmo2AgAgAEK0gICAwAA3A+gLIABBpJUBNgLkCyAAQc2AAzYC4AsgAkGQrAcgAmtBiiAgAEHgC2oQixQgAmoiAkGQqwdPDQAgAEHQC2pBAEHlywJqNgIAIABCuICAgMAANwPICyAAQeaAATYCxAsgAEHNgAM2AsALIAJBkKwHIAJrQYogIABBwAtqEIsUIAJqIgJBkKsHTw0AIABBsAtqQQBB5csCajYCACAAQryAgIDAADcDqAsgAEHovgE2AqQLIABBzYADNgKgCyACQZCsByACa0GKICAAQaALahCLFCACaiICQZCrB08NACAAQZALakEAQeXLAmo2AgAgAELAgICAwAA3A4gLIABBpTg2AoQLIABBzYADNgKACyACQZCsByACa0GKICAAQYALahCLFCACaiICQZCrB08NACAAQfAKakEAQeXLAmo2AgAgAELEgICAwAA3A+gKIABB3IgBNgLkCiAAQc2AAzYC4AogAkGQrAcgAmtBiiAgAEHgCmoQixQgAmoiAkGQqwdPDQAgAEHQCmpBAEHsygJqNgIAIABCyICAgMAANwPICiAAQd75ADYCxAogAEHNgAM2AsAKIAJBkKwHIAJrQYogIABBwApqEIsUIAJqIgJBkKsHTw0AIABBsApqQQBB48YCajYCACAAQsyAgIDAADcDqAogAEHAnAE2AqQKIABBzYADNgKgCiACQZCs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QZCsByABa0Hb6wAgAEGgBWoQixQgAWoiAkGQqwdPDQAgAEEAIgFBy4kBajYCkAUgAEKAgICAwAA3A4gFIABB3TQ2AoQFIABBgYEDNgKABSACQZCsByACa0GKICAAQYAFahCLFCACaiICQZCrB08NACAAQQBByfQAajYC8AQgAEKEgICAwAA3A+gEIABB6TQ2AuQEIABBzYADNgLgBCACQZCsByACa0GKICAAQeAEahCLFCACaiICQZCrB08NACAAQQBBy4kBajYC0AQgAEKIgICAwAA3A8gEIABBhig2AsQEIABBzYADNgLABCACQZCsByACa0GKICAAQcAEahCLFCACaiICQZCrB08NACAAQQBByfQAajYCsAQgAEKMgICAwAA3A6gEIABBjyg2AqQEIABBzYADNgKgBCACQZCsByACa0GKICAAQaAEahCLFCACaiICQZCrB08NACAAQQBByfQAajYCkAQgAEKQgICAwAA3A4gEIABB6KUBNgKEBCAAQc2AAzYCgAQgAkGQrAcgAmtBiiAgAEGABGoQixQgAmoiAkGQqwdPDQAgAEEAQcuJAWo2AvADIABClICAgMAANwPoAyAAQbeCATYC5AMgAEHNgAM2AuADIAJBkKwHIAJrQYogIABB4ANqEIsUIAJqIgJBkKsHTw0AIABBAEHJ9ABqNgLQAyAAQpiAgIDAADcDyAMgAEGA7AA2AsQDIABBzYADNgLAAyACQZCsByACa0GKICAAQcADahCLFCACaiICQZCrB08NACAAQQBBy4kBajYCsAMgAEKcgICAwAA3A6gDIABBh+wANgKkAyAAQc2AAzYCoAMgAkGQrAcgAmtBiiAgAEGgA2oQixQgAmoiAkGQqwdPDQAgAEEAQcuJAWo2ApADIABCoICAgMAANwOIAyAAQZmyATYChAMgAEHNgAM2AoADIAJBkKwHIAJrQYogIABBgANqEIsUIAJqIgJBkKsHTw0AIABBAEG5vgFqNgLwAiAAQqiAgICAATcD6AIgAEG6LzYC5AIgAEHNgAM2AuACIAJBkKwHIAJrQYogIABB4AJqEIsUIAJqIgJBkKsHTw0AIABBAEHyiAFqNgLQAiAAQrCAgICAATcDyAIgAEG9PTYCxAIgAEHNgAM2AsACIAJBkKwHIAJrQYogIABBwAJqEIsUIAJqIgJBkKsHTw0AIABB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GgsgByAIKAIEEQEAGiAFRQ0AIAQoAgQNACAAIAFBASAAKAIcEQIAGgsgBEEQaiQAIAULUgEBfwJAAkAgADQCBBCvASIFRQRAQQchAAwBCyAAIAEgBSADQf/+AXEgBCAAKAIYEQcAIgBFBEBBACEADAILIAUQQAtBACEFCyACIAU2AgAgAAtUAQF/QRUhAyABQQEgAhtFIABFIAJBAEhyckUEQCAAQfwrENQTIgBFBEBBCg8LIAIEf0EKQQAgASACQQEgABDeE0EBRxsFQQALIQMgABDIExoLIAMLHgEBf0GEoAUoAgAQmgUiAgRAIAAgASACEKkFCyACCy8BAX8jAEEQayIDJAAgAyABNgIEIAMgADYCAEEgIAJBvNYAIAMQaBogA0EQaiQACwYAQfifBQtPAgF/AX8jAEEQayIDJABBFSEEAkACQAJAIAFBAWsOAwEAAAILIAAgAUEAELwDIQQMAQsgAyACNgIAIABBASADELwDIQQLIANBEGokACAEC0ECAX8BfyMAQRBrIgQkAEEVIQUgAUHqB2tBEU0EQCAEIAM2AgQgBCACNgIAIAAgASAEEM8DIQULIARBEGokACAFC0YCAX8BfyMAQRBrIgUkAEEVIQYgAUHpB0YEQCAFIAQ2AgggBSADNgIEIAUgAjYCACAAQekHIAUQzwMhBgsgBUEQaiQAIAYLOAIBfwF/IwBBEGsiAyQAQRUhBCABQegHRgRAIAMgAjYCACAAQegHIAMQzwMhBAsgA0EQaiQAIAQLJgEBfyMAQRBrIgIkACACIAE2AgAgACACEMwDIQEgAkEQaiQAIAELLQEBfyMAQRBrIgMkACADIAI2AgQgAyABNgIAIAAgAxDMAyECIANBEGokACACCyYBAX8jAEEQayICJAAgAiABNwMAIAAgAhDMAyEAIAJBEGokACAACzYBAX8jAEEQayICJAAgAAR/IAIgADYCAEGA5wFBjvMAIAEbIAIQZgVBAAshACACQRBqJAAgAAsEAEEMCxUBAX8gACAAKAIAQQF0IgE2AgAgAQsEACAACw0AQv///////////wALDQBCgICAgICAgICAfwsHACAAQgGGCyIAIAFC////////////ADcDACAAQoCAgICAgICAgH83AwALFQEBfiAAIAApAwBCAYYiATcDACABCw0AIAAEQANADAALAAsLOwEB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AAJ/IABBIBCbAgRAIABBADoAEkEHDAELIAAoAgghBQJAIAAvARAiAkEEcQRAIAApAwAhBiADQQA6ACUgBiAGQj+HIgSFIAR9IQRBFCECA0AgA0EQaiACaiAEIARCCoAiB0IKfn2nQTByOgAAIARCClRFBEAgAkEBayECIAchBAwBCwsgBkIAUwRAIAJBAWsiAiADQRBqakEtOgAACyAFIANBEGogAmpBFiACaxCXExpBFSACayECDAELIANBADsBJCADQgA3AhwgA0EANgIQIAMgBTYCFCADQSA2AhggAwJ8IAJBIHEEQCAAKQMAuQwBCyAAKwMACzkDACADQRBqQdKNASADEFcgBSADKAIgIgJqQQA6AAALIAAgAjYCDCAAQQE6ABIgACAALwEQQYIEciICQdP/A3EgAiABGzsBEEEACyECIANBMGokACACCy4AIAAoAlggASgCCEEobGoiAS0AEUGQAXEEQCABEPgHGiABDwsgAUEEOwEQIAELVAAgAC0AEUGQAXEEQCAAIAEgAhD5Bw8LIAAgASkDADcDACAAIAEoAhA2AhAgACABKQMINwMIIAEtABFBIHFFBEAgACAALwEQQf+fAnEgAnI7ARALCxsBAX8gAC8BEEEtcSIBRQRAIAAQ+gchAQsgAQsdACAAIAAQWzcDACAAIAAvARBBwOQDcUEEcjsBEAt7AQF/AkAgAUHDAE4EQCAALwEQIgJBBHENASACQShxRQRAIAJBAnFFDQIgAEEBEPkCDwsgAUHFAEsNASAAEP0CDwsgAUHCAEcNACAALwEQIgFBAnEgAUEscUVyRQRAIABBARCyBxogAC8BECEBCyAAIAFB0/8DcTsBEAsL9QECAX8BfwJAIAAvARAiBEEBcQ0AAkACQAJAAkACQCABQcEAaw4FAAQBAgMECyAEQRBxRQRAIABBwgAQtwcgAC8BECIBQQJxRQ0FIAAgAUHA5ANxQRByOwEQQQAPCyAAIARB0OQDcTsBEEEADwsgABD7B0EADwsgABC2B0EADwsgABDtAkEADwsgACAEQQN2QQJxIARyOwEQIABBwgAQtwcgACAALwEQIgNBw/cDcTsBECACQQFHBEAgACAAKAIMQX5xNgIMCwJAIANBAnFFBEAgACACOgASDAELQQEhAyACIAAtABJHDQELIAAQpwJBACEDCyADC6YCBwF/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GCABQQA6ALABIAEgEDoAXiAIQX9BAEEBELsBGiABQQE6AFUgCgRAIAooAgQQ7gEgCkEANgIMIApBADYCBAsgARC/AQsgBUHQAWokACAEC8cCAgF/AX8gAC0ABSECAkACQCAALQAPRQ0AIAFBAmsOAwABAAELIAEgAkYNACAAIAE6AAUCQCABQQFxIAJBBXFBAUdyDQAgAC0ABA0AIAAoAkQiASgCACICBEAgASACKAIEEQEAGiABQQA2AgALIAAtABJBAk8EQCAAKAIAIgEoAhwiAkUNAiABIAAoArwBQQAgAhECABoMAgtBACECIAAtABEiASEDIAFFBEAgABD9BiECIAAtABEhAwsgA0H/AXFBAUYEQCAAQQIQ2wYhAgsCQCACDQAgACgCACICKAIcIgMEQCACIAAoArwBQQAgAxECABoLIAFBAUcNACAAQQEQ5gYaDAILIAENASAAEK0GDAELAkAgAUECaw4DAAEAAQsgACgCRCIBKAIAIgJFDQAgASACKAIEEQEAGiABQQA2AgALIAAtAAULYAEBfiAAKQMAIQICQAJAIAFCAFkEQCACQgBXIAJC////////////AIUgAVpyDQEMAgsgAkIAWQ0AIAFCAXxCgYCAgICAgICAfyACfVMNAQsgACABIAJ8NwMAQQAPC0EBCxwBAX8gACAAKAIAIgEoAtQBNgIEIAEgADYC1AELhwEDAX8BfwF/IAAoAhQhAiAAEPcBIAJCIBDvAiIBRQRAQQcPCyACIAEQVCEDIAFBADYCFCABQgA3AgggASACNgIEIAFBADYCACABQQA2AhwgAUEBOwEaIAEgAUEgajYCECABIANB4P8/akEEdjsBGCAAQS42AiQgAEGQIDsBECAAIAE2AghBAAvJAQUBfwF/AX8BfwF/IwBBoAFrIgEkACABQQBBoAEQmRMhAwNAIAAEQCAAKAIIIQRBACEBIABBADYCCANAIAMgAUECdGoiAigCACIFBEAgBSAAEMsHIQAgAkEANgIAIAFBAWohAQwBCwsgAiAANgIAIAQhAAwBCwsgAygCACEAQQEhAQNAIAFBKEZFBEACQCADIAFBAnRqKAIAIgJFDQAgAEUEQCACIQAMAQsgACACEMsHIQALIAFBAWohAQwBCwsgA0GgAWokACAAC14CAX8BfyMAQRBrIgQkAANAAkAgACIDKAIMIgAEQCAAIAEgBEEMahDKByAEKAIMIAM2AggMAQsgASADNgIACyADQQhqIQEgAygCCCIADQALIAIgAzYCACAEQRBqJAALegUBfwF+AX8BfwF+IwBBEGsiBSECAkADQCAAKQMAIQMgASEEA0AgBCIBKQMAIgYgA1kEQCADIAZTBEAgAiAANgIIIAAhAgsgACgCCCIADQIMAwsgAiABNgIIIAEhAiABKAIIIgQNAAsLIAAhAQsgAiABNgIIIAUoAggLbAQBfwF/AX8BfyMAQRBrIgEkACAAKAIIIQQgAEIANwMIQQEhAwNAIAQiAgRAIAEgAigCCDYCDCACIAA2AgwgAiABQQxqIAMQ1Qg2AgggA0EBaiEDIAEoAgwhBCACIQAMAQsLIAFBEGokACAAC2QCAX8BfwJ/IAAvARgiAQRAIAFBAWshAiAAKAIQDAELIAAoAgRC+AcQ7wIiAUUEQEEADwsgASAAKAIANgIAIAAgATYCAEE+IQIgAUEIagshASAAIAI7ARggACABQRBqNgIQIAELXAIBfwF/IAAQzQciAgRAIAJBADYCCCACIAE3AwACQCAAKAIMIgMEQCADKQMAIAFZBEAgACAALwEaQf7/A3E7ARoLIAMgAjYCCAwBCyAAIAI2AggLIAAgAjYCDAsLRwIBfwF/IAAoAgAhAQNAIAEEQCABKAIAIQIgACgCBCABEDUgAiEBDAELCyAAQQA2AgAgAEKAgICAgIDAADcCFCAAQgA3AggLygMIAX8BfwF/AX8BfwF/AX8BfyMAQTBrIgQkACAAKAIUIQogAyEFAkADQAJAIAJFDQAgACgCEEUNACAAIAIQ0ggNACAFQQFrIQYgACgCBCIHIAIgBEEsakEAIAcoAtwBEQYABEAgBCACNgIgIABB+SwgBEEgahDRBwwDBSAEKAIsKAIEIQgCfwJAAkAgAQRAIAhBBGoQxwEhCSAAKAIAIgctABEEQCAAIAJBAkEAENIHIAAoAgAhBwsgCSAHKAIoQQJ2QQJrSw0BQQAhAiAJQQAgCUEAShshByAIQQhqIQsDQCACIAdHBEAgCyACQQJ0ahDHASEFIAAoAgAtABEEQCAAIAVBAkEAENIHCyAAIAUQ0ggaIAJBAWohAgwBCwsgBiAJawwDCyAAKAIALQARRSAGRXINASAAIAgQxwFBBCACENIHDAELIAQgAjYCECAAQdwtIARBEGoQ0QcgBUECawwBCyAGCyEFIAgQxwEhAiAEKAIsEI0BDAILAAsLIAUhBgsCQCAGRQ0AIAogACgCFEcNACAEIAM2AgggBCADIAZrNgIEIARBACICQdCPAUH9iQEgARtqNgIAIABBqC4gBBDRBwsgBEEwaiQAC7wBAwF/AX8BfiMAQRBrIgMkACAAENMIAkAgACgCECIERQ0AIAAgBEEBazYCECAAIAAoAhRBAWo2AhQgAyACNgIMIABBMGohAiAAKAJABEAgAkGAgQNBARBNCyAAKAIgIgQEQCAAKQIkIQUgAyAAKAIsNgIIIAMgBTcDACACIAQgAxBXCyACIAEgAygCDBBMIAAtAERBB0cNACAAQQA2AhAgAEEHNgIYIAAoAhQNACAAQQE2AhQLIANBEGokAAu8AQMBfwF/AX8jAEEwayIEJAACQCAAKAIAIAEgBEEvaiAEQShqEIoHIgUEQAJAIAVBihhHIAVBB0dxDQAgAEEANgIQIABBBzYCGCAAKAIUDQAgAEEBNgIUCyAEIAE2AgAgAEGfLCAEENEHDAELIAIgBC0ALyIGRiAEKAIoIgUgA0ZxDQAgBCAFNgIgIAQgBjYCHCAEIAM2AhggBCACNgIUIAQgATYCECAAQZ3EAiAEQRBqENEHCyAEQTBqJAAL0AwbAX8BfwF/AX8BfwF/AX8BfwF/AX8BfwF/AX8BfwF/AX8BfwF/AX8BfwF+AX8BfwF/AX8BfwF/IwBBkAFrIgQkACAEIAM3A4gBIARBADYChAEgACgCLCEZIAAoAighGiAAKAIgIRsgABDTCEF/IQwCQAJAIAAoAhBFDQAgAUUNASAAKAIAIgYoAighEiAAIAEQ0ggNASAAIAE2AiggAEGOgAM2AiAgBiABIARBhAFqQQAQ6AEiBQRAQQAhAiAEIAU2AmAgAEGguAEgBEHgAGoQ0QcgBUGKGEcNASAAQQc2AhgMAQsgBCgChAEiBy0AACEcIAdBADoAACAHEKgGIgUEQCAEIAU2AlAgAEHvuwEgBEHQAGoQ0QcMAQsgBxCOCCIFBEAgBCAFNgJAIABBk/gAIARBQGsQ0QcMAQsgBy0ACSEFIAcoAjghCyAAQfT/AjYCICAFIAtqIg0tAANBCHQgDS0ABHIhCiANLQAGIA0tAAVBCHRyQQFrIQwCQCAHLQAIIghFBEAgBy0AAQ0BCyAAIAApA1AgCq18NwNQCyAMQf//A3EhEEF/IQxBASEPIApBAWsiEUEBdCEKIAUgCEECdGsgC2pBDGohFgJAIAhFBEAgDUEIahDHASEIIAYtABEEQCAAQauAAzYCICAAIAhBBSABENIHC0EAIQUgACAIIARBiAFqIAMQ0wchDEEAIQ8MAQsgACgCSCIFQQA2AgALIBBBAWohHSAKIBZqIQogEkEFayEeIBJBBGshDkEBIRQgESEIA0ACQCAIQQBIDQAgACgCEEUNACAAIAg2AiwCQCAQIAotAAEgCi0AAEEIdHIiCUkgCSAOTXFFBEAgBCAONgIoIAQgHTYCJCAEIAk2AiAgAEHELCAEQSBqENEHQQAhFAwBCyAHIAkgC2oiFyAEQegAaiAHKAJQEQQAIBIgCSAELwF6akkEQEEAIRQgAEGYpgFBABDRBwwBCyAHLQABBEAgBCkDiAEhGCAEKQNoIQMCQAJAIA8EQCADIBhVDQEMAgsgAyAYUw0BCyAEIAM3AzAgAEHI8QAgBEEwahDRByAEKQNoIQMLIAQgAzcDiAFBACEPCyAEKAJ0IhMgBC8BeCIVSwRAIBMgHmogFWsgDm4hFSAXIAQvAXpqQQRrEMcBIRMgBi0AEQRAIAAgE0EDIAEQ0gcLIABBACATIBUQ0AcLIActAAhFBEAgFxDHASEJIAYtABEEQCAAIAlBBSABENIHC0EAIQ8gACAJIARBiAFqIAQpA4gBENMHIgkgDEYNASAAQbjGAEEAENEHIAkhDAwBCyAFIAkgBC8BempBAWsgCUEQdHIQ1AgLIApBAmshCiAIQQFrIQgMAQsLIAIgBCkDiAE3AwAgAEEANgIgIBQEQCAAKAIQQQBMDQECQCAHLQAIDQAgACgCSCIFQQA2AgADQCARQQBIDQEgBSAHIAsgFiARQQF0aiICLQAAQQh0IAItAAFyIgJqIAcoAkwRAAAgAmpBAWsgAkEQdHIQ1AggEUEBayERDAALAAsgDUECaiEGIA1BAWohAgNAIAYtAAAgAi0AAEEIdHIiBgRAIAUgBiAGIAtqIgItAAJBCHQgAi0AA3JqQQFrIAZBEHRyENQIIAJBAWohBgwBBSAFKAIAIQhBACEOAkACQANAIAhFDQEgBSgCBCELIAUgBSAIQQJ0aiICKAIANgIEIAJBfzYCACAFIAhBAWsiCDYCAEEBIQYDQAJAIAZBAXQiAiAISw0AIAUgBkECdGoiCigCACIHIAUgAkEBciIGIAIgBSACQQJ0aigCACAFIAZBAnRqKAIASxsiAkECdGoiBigCACIJSQ0AIAogCTYCACAGIAc2AgAgBSgCACEIIAIhBgwBCwsgEEH//wNxIgIgC0EQdiIGSQRAIA4gAkF/c2ogBmohDiALIRAMAQsLIAQgATYCFCAEIAY2AhAgAEGDLiAEQRBqENEHIAUoAgBFDQEMBQsgEEH//wNxIQILIBIgAkF/c2ogDmoiBSANLQAHIgJGDQMgBCABNgIIIAQgAjYCBCAEIAU2AgAgAEGoLSAEENEHDAMLAAsACyAHIBw6AAALIAQoAoQBEIwHIAAgGTYCLCAAIBo2AiggACAbNgIgIAxBAWohBQsgBEGQAWokACAFCxIAIAAoAhhBCGogACgCBBCJAws4ACAAIAEoAiQQMyAAIAEoAigQsgMgACABKAIQEDIgAS0AN0EQcQRAIAAgASgCIBAyCyAAIAEQNQufAgQBfwF/AX8BfyMAQRBrIgUkACAAKAIQIAFBBHRqKAIMIgNBEGohBANAIAQoAgAiBARAIAQoAggiAiACKAIcQW9xNgIcDAELCyADQSBqIgQhAgNAIAIoAgAiAgRAIAIoAggiAyADLwA3Qf/+A3E7ADcMAQsLIAUgADYCCCAFIAAoAhAgAUEEdGooAgAiAjYCDEEAIQMCQCAAQbKxAiACEIgDIgFFDQAgAS0AKw0AIAUgAjYCACAAQZaxAiAFEIEDIgJFBEBBByEDDAELIAAgAkEvIAVBCGpBABCLASEDIAAgAhA1CwNAIAQoAgAiBARAIAQoAggiAi0AN0GAAXENASACEJ4IDAELCyADQQdGBEAgABCUAQsgBUEQaiQAIAML2gQHAX8BfwF/AX8BfwF/AX8jAEEQayIIJAAgACgCCCEFIAAoAgAiBCAEKAIYQcAAcjYCGAJAIAJFDQAgACAAKAIUQQFqNgIUIAQtAFcEQCAAIAJBABCZCEEBIQYMAQsCQCACKAIMIglFDQACQCACKAIQIgcEQAJAIActAAAiCkHfAXFBwwBHDQAgBy0AAUHfAXFB0gBHDQAgBC0AsAEhByAEIAU6ALABAkACQCAJIARBrAFqIgYQmggEQCAAKAIYIgYgBCgCrAFPDQJBACEFIAZFDQJBkaAFLQAADQEMAgtBkaAFLQAARQ0BCyAAIAJB+aUBEJkICyAEIAI2ArQBIAQgBC0AsgFB/gFxOgCyAUEAIQYgCEEANgIMIAQgAigCEEF/QQBBACAIQQxqQQAQqQMaIAQgBzoAsAECQCAEKAJAIgVFDQAgBC0AsgFBAXENACAAKAIMIAVIBEAgACAFNgIMCwJAAkAgBUEHaw4DAAECAQsgBBCUAQwBCyAFQf8BcUEGRg0AIAAgAiAEEKkBEJkICyAEQdCwBTYCtAEgCCgCDBCOARoMBAsgAigCBCIHRSAKcg0CDAELIAIoAgQiB0UNAQsgBCAHIAQoAhAgBUEEdGooAgAQmwgiBEUEQCAAIAJBmikQmQgMAgsCQAJAIAIoAgwgBEEsaiIFEJoIRQ0AIAQoAiwiBUECSQ0AIAUgACgCGEsNAEEAIQUgBBCcCEUNA0GRoAUtAAANAQwDC0GRoAUtAABFDQILIAAgAkH5pQEQmQgMAQsgACACQQAQmQgLIAhBEGokACAGC58EBwF/AX8BfwF/AX8BfwF/IwBBIGsiAyQAAkACQAJAAkAgACgCBCIFLQARBEAgBRDeASAAQQQgA0EYahDaByADKAIYIgYgBSgCMEsNAkHsnwUoAgAhBwNAIAUgBiIEQQFqIgYQ3wEgBkYNACAEIAcgBSgCJG5GDQALIAMgBjYCGCADIAUgA0EMaiADQRBqIAZBARCLByIENgIUIAQNBAJAIAYgAygCECIHRwRAIANBADoACyADQQA2AgQgBUEAQQAQ4gEhBCADKAIMEIwHIAQNBiAFIAYgA0EcakEAEOgBIgQNBiAFIAYgA0ELaiADQQRqEIoHIQQCQAJAIAMtAAsiCEEBa0H/AXFBAU0EQEHj9gQQ4AEhBAwBCyAERQ0BCyADKAIcIQcMBgsgBSADKAIcIgkgCCADKAIEIAdBABCNByEEIAkQjAcgBA0GIAUgBiADQRxqQQAQ6AEiBA0GIAMgAygCHCIHKAJIEMEBIgQ2AhQgBEUNAQwFCyADIAMoAgwiBzYCHAsgBSAGQQFBACADQRRqEJUHIAMoAhQiBA0DIAMgAEEEIAYQvgEiBDYCFCAEDQMMAQsgAyAFIANBHGogA0EYakEBQQAQiwciBDYCFCAEDQMgAygCHCEHCyAHQQ1BCiACQQFxGxCBByAHKAJIEI0BIAEgAygCGDYCAEEAIQQMAgtBs/YEEOABIQQMAQsgBxCMBwsgA0EgaiQAIAQLPAIBfwF/IAAoAgQiBCABQQAQ4gEiA0UEQCAALQALBEAgACABQgBBARCBCAsgBCABQQAgAhCCCCEDCyADC0EBAX8gACgCBCEDIAICfyABQQ9GBEAgACgCFCADKAIAKAJsagwBCyADKAIMKAI4IAFBAnRqQSRqEMcBCyIBNgIACx8AIAEoAgBFBEAgASAAKAI0IAAgACgCBBCxCDYCAAsL9QsPAX8BfwF/AX8BfwF/AX4BfwF/AX8BfwF/AX4BfAF8IwBBQGoiBSQAIAIoAgQhBwJAAn8CQAJAAkACfyADBEAgBSABLAABIghB/wFxIgM2AhBBAiEJIAhBAEgEQCABQQFqIAVBEGoQvAJBAWpB/wFxIQkgBSgCECEDCyABLQAAIQ0gB0EoaiEHQQEhDCANIANBgAFPBH8gA0EMa0EBdgUgA0HQlQNqLQAACyIDagwBCyAFIAEsAAAiA0H/AXEiDTYCPEEBIQkgA0EASARAIAEgBUE8ahC8AiEJIAUoAjwhDQsgDQsiCCAATQRAIAJBF2ohDgNAAkACQAJAAn8CQCAHLwEQIgZBJHEEQCABIAlqLQAAIgNBCk8EQEF/QQEgA0EKRhshBkEADAwLIANBB0YNAUF/IQYgA0UNCiABIAhqIQQgBykDACIQAn4CQAJAAkACQAJAAkACQCADQQFrDgYAAQIDBAUGCyAEMAAADAYLIAQtAAEgBCwAAEEIdHKsDAULIAQtAAIgBC0AAUEIdCAELAAAQRB0cnKsDAQLIAQoAAAiBEEYdCAEQYD+A3FBCHRyIARBCHZBgP4DcSAEQRh2cnKsDAMLIAQxAAUgBDEAA0IQhiAEMQACQhiGhCAEMQAEQgiGhIQgBC0AASAELAAAQQh0cq1CIIaEDAILIAQpAAAiCkI4hiAKQoD+A4NCKIaEIApCgID8B4NCGIYgCkKAgID4D4NCCIaEhCAKQgiIQoCAgPgPgyAKQhiIQoCA/AeDhCAKQiiIQoD+A4MgCkI4iISEhAwBCyADQQhrrQsiClUNCiAKIBBXDQUMCQsCQCAGQQhxBEAgASAJai0AACIDQQpPBEBBf0EBIANBCkYbIQZBAAwNC0F/IQYgA0EHRwRAIANFDQwgASAIaiADIAVBEGoQvQIgBSkDECAHKwMAEPEHDAQLQQEhAyABIAhqIAVBEGoQlQgNCyAFKwMQIhEgBysDACISYw0LIBEgEmQNAQwFCyAGQQJxBEAgBSABIAlqIgYsAAAiA0H/AXEiBDYCDCADQQBIBEAgBiAFQQxqELwCGiAFKAIMIQQLIARBDEkEQEF/IQYgBCEDDAwLQQEhAyAEQQFxRQ0KIAUgBEEMa0EBdiILNgIcAkAgACAIIAtqTwRAIAwgAigCACIGLwEISQ0BCyAOQfO9BRDgAToAAAwKCyAGIAxBAnRqKAIUIg8EQCAFIAYtAAQ6ACIgBigCDCEDIAVBAjsBICAFIAM2AiQgBSABIAhqNgIYIAQhAyAFQRBqIAcgDyAOEPwHDAQLIAEgCGogBygCCCALIAcoAgwiDyALIA9IGxCcEyIGDQsgBCEDIAsgD2sMAwsgASAJaiIELQAAIQMgBkEQcQRAIAUgAzYCDEF/IQYgA8BBAEgEQCAEIAVBDGoQvAIaIAUoAgwhAwsgA0EBcSADQQxJcg0LIAAgA0EMa0EBdiIEIAhqTwRAIActABFBBHEEQCABIAhqIAQQlghFDQMgBCAHKAIAawwFCyABIAhqIAcoAgggBCAHKAIMIgsgBCALSBsQnBMiBgRAQQEhAwwNCyAEIAtrDAQLIA5Bkb4FEOABOgAADAkLQQEhBgJAIANBB2sOBAALCwYECyABIAhqIAVBEGoQlQgNBAtBASEDDAgLIAEgCGogBUEQahCVCBpBByEDQQAgBykDACAFKwMQEPEHawsiBkUNAgwHCyADDQYMAQtBByEDCwJAIAxBAWoiDCACLwEURg0AIANBgAFPBH8gA0EMa0EBdgUgA0HQlQNqLQAACyIGIAhqIgggAEsNACANIAOtEOEHIAlqIglNBEAgDkHEvgUQ4AE6AAAMBAsgB0EoaiEHDAELCyACQQE6ABogAiwAFiEGDAULIAJBor0FEOABOgAXC0EAIQYMAwtBASEGCyADRQshCCACKAIAKAIQIAxqLQAAIgNFDQAgA0ECcQRAQQEhCSAIRQRAIAcvARBBAXEhCQsgCSADQQFxIgNGDQELQQAgBmshBgsgBUFAayQAIAYLDwAgACgCGARAIAAQ+AELCxYAIAAoAiQtAABFBEBBAA8LIAAQvQcL/AkOAX8BfwF/AX8BfwF/AX8BfwF/AX8BfwF/AX8BfkEBIQQCf0EwIAEoAgAiAy8BCEENSw0AGiABKAIEIgUvARAhBCABAn8gAygCEC0AACIIRQRAQf8BIQdBAQwBC0EBIQdBMCAIQQJxDQEaQf8BCyIIOgAZIAEgBzoAGCAEQQRxBEAgASAFKQMANwMIQTEMAQtBASEIQTAgBEE5cQ0AGkEBIQRBMCADKAIUDQAaIAEgBSgCCDYCCCABIAUoAgw2AhBBMgshCiABQQA6ABcCQAJAAkACQCAALQAADQAgACgCdCIGLQAIRQ0AQQAhAyAALABEIgRBACAEQQBKGyEFIABByABqIQcgAEH4AGohCQNAIAMgBUcEQCADQQF0IQQgA0ECdCEIIANBAWohAyAEIAdqLwEAIAggCWooAgAvARhPDQEMAgsLAkAgAC8BRiIDIAYvARhBAWtHDQAgACADIAEgChCGCCIDQQBKDQAgAS0AFw0AIAIgAzYCAEEADwsCQCAALABEQQBMDQAgAEEAIAEgChCGCEEASg0AIAEtABcNACAAIAAtAAFB8wFxOgABIAAoAnQiAy0AAA0CQaLXBBDgAQ8LIAFBADoAFwsgABD0ByIGQRBGDQIgBg0BIAAoAnQhAwsgAEH4AGohCyAAQcgAaiEPIABBIGohDCAAQfQAaiENIAMvARghBAJAAkADQCAEQf//A3FBAWsiBCEIQQAhBwJAA0AgAygCRCADLwEaIAMoAkAgBEF+cWoiBS0AAEEIdCAFLQABcnFqIgVBAWohBiAEQQF1IQkCQCAFLQAAIgQgAy0AC00EQCAEIAYgASAKEQIAIQQMAQsCQCAGLAAAIgZBAEgNACAEQQd0QYD/AHEgBnIiBCADLwEOSw0AIAQgBUECaiABIAoRAgAhBAwBCyADIAUgAy0ACmsgDCADKAJQEQQAAkAgDCkDACIQpyIEQQJOBEAgBCAAKAIUIgUoAihuIAUoAjBNDQELQfnXBBDgASEGDAYLIBBCEnxC/////w+DEEciBUUEQEEHIQYMBgsgACAJOwFGIABBACAEIAVBABDwAiEGIAQgBWoiDkEAOwAQIA5CADcACCAOQgA3AAAgACAALQABQfsBcToAASAGBEAgBRBADAYLIAQgBSABEO4HIQQgBRBACwJAAkAgBEEASARAIAlBAWohBwwBCyAERQ0BIAlBAWshCAsgByAISg0CIAcgCGohBAwBCwtBACEGIAJBADYCACAAIAk7AUYgAS0AF0UNA0GZ2AQQ4AEhBgwDCyADLQAIBEAgACAJOwFGIAIgBDYCAEEAIQYMAwsgAygCOCEEAn8gAy8BGCAHTARAIAQgAy0ACWpBCGoMAQsgBCADLwEaIAMoAkAgB0EBdGoiCC0AAEEIdCAILQABcnFqCyIDEMcBIQQgAEEAOwEyIAAgAC0AAUH5AXE6AAEgACwARCIDQRNOBEBBuNgEEOABDwsgDyADQQF0aiAHOwEAIAsgA0ECdGogACgCdDYCACAAIANBAWo6AEQgAEEAOwFGIAAoAhQgBCANIAAtAAIQhwgiBg0BIA0oAgAiAy8BGCIEBEAgAy0AASAALQBFRg0BCwsgAxCMB0HD2AQQ4AEhBgsgACAALQBEQQFrIgM6AEQgACALIAPAQQJ0aigCADYCdAsgAEEAOwEyCyAGDwsgAkF/NgIAQQALhQgMAX8BfwF/AX8BfwF/AX8BfwF/AX8BfwF/IwBBIGsiBSQAIAAoAggiBCgCBCEHAkACQAJAIAAtAAAiAgRAIAJBA0kNASAAEJ0DIgINA0EAIQIgAC0AAA0DCyAAKAJ0IgMvARgiAiAALwFGIglNBEBB3fQEEOABIQIMAwsgACwARCEKIAMoAkAiCCAJQQF0aiIGLQAAIQsgBi0AASEGIAMvARohDCADKAI4IQ0gAygCFEEASARAIAMQjggNAiADKAJAIQggAy8BGCECCyANIAtBCHQgBnIgDHFqIgYgCCACQf//A3FqSQRAQeT0BBDgASECDAMLQQAhCAJAIAFBAnEiAUUNAAJAIAMtAAhFDQBBASEIIAMoAhQgAyAGIAMoAkwRAABqQQJqIAcoAihBAXRBA25KDQAgAy8BGEEBRw0BCyAFIAAQkAciAjYCHEEAIQggAg0DCyADLQAIRQRAIAAQ5AciAg0DCyAALQABQSBxBEAgByAAKAJAIAAQ4gEiAg0DCwJAIAAoAnANACAELQALRQ0AIAQgACgCQCAAKQMgQQAQgQgLIAMoAkgQwQEiAg0CIAMgBiAFIAMoAlARBABBACECIAUoAgwgBS8BEEcEQCADIAYgBRCPCCECCyAFIAI2AhwgAyAJIAUvARIgBUEcahCQCCAFKAIcIgINAiADLQAIRQRAIABB9ABqIgYoAgAiBCgCFEEASARAIAQQjggiAg0ECyAELwEaIAQoAkAgBC8BGEEBdGoiAkECay0AAEEIdCACQQFrLQAAcnEiAkEDTQRAQb/1BBDgASECDAQLIApBAnQgAGpB/ABqIAYgACwAREEBayAKShsoAgAoAgQhBiAEIAQoAjggAmoiCyAEKAJMEQAAIQIgBygCRCEMIAUgBCgCSBDBASIHNgIcIAdFBEAgBSADIAkgC0EEayACQQRqIAwgBhCUCDYCHAsgBCAELwEYQQFrIAIgBUEcahCQCCAFKAIcIgINAwsgACgCdCgCFEEDbCAAKAIUKAIoQQF0SgRAIAAQkwgiAg0DCyAKIAAsAERIBEAgACgCdBCRByAAIAAtAERBAWsiAjoARCAAQfgAaiEEA0AgAsAiByAKTEUEQCAAIAJBAWs6AEQgBCAHQQJ0aigCABCMByAALQBEIQIMAQsLIAAgBCAHQQJ0aigCADYCdCAAEJMIIgINAwsgCARAIABBAjoAACADLwEYIgIgCU0EQCAAQX82AgQgACACQQFrOwFGQQAhAgwECyAAQQE2AgRBACECDAMLIAAQ9AchAiABBEAgABCPByAAQQM6AAALIAJBACACQRBHGyECDAILQdT0BBDgASECDAELQeH0BBDgASECCyAFQSBqJAAgAgsnAQF/QQEhAQNAIABCgAFURQRAIAFBAWohASAAQgeIIQAMAQsLIAEL+wEEAX8BfwF/AX8jAEEwayICJAAgAEEBOgBAIAAoAlQoAhghASACQQhqQQBBKBCZExoCQCAAKAJ4RQRAIAEgAEH4AGoQwQgiAQ0BCyAAQcgAaiAAQShqEOYHIgENACAAKAJ4IAJBCGogACgCVCgCDCAAKQOAARDCCCAAIAAoAlBBAWo2AlAgAkEIaiAAKQMwEMMIIABBgAFqIQQgACgCKCEDA0AgAyIBBEAgASgCBCEDIAJBCGogATQCABDDCCACQQhqIAFBCGogASgCABDECCAAKAIsDQEgARBADAELCyAAQQA2AiggAkEIaiAEEMUIIQELIAJBMGokACABC+gTDwF/AX8BfwF/AX8BfwF/AX8BfwF/AX8BfwF+AX8BfyMAQUBqIgUkACAFIAM2AjAgACgCCCEPAkACQCAALQABQSBxRQ0AIAUgDygCBCAAKAJAIAAQ4gEiBDYCNCAEDQEgA0UNACAALABEQQBODQBBsvEEEOABIQQMAQsgAC0AAEEDTwRAIAUgABD0ByIENgI0IARBb3ENAQsCQCAAKAJwIgRFBEAgDy0ACwRAIA8gACgCQCABKQMIQQAQgQgLAkAgAC0AAUECcUUNACABKQMIIAApAyBSDQAgAC8BMkUNAiAAKAIsIAEoAiAgASgCHGpHDQIgACABEIwIIQQMAwsgAw0BIAUgACABKQMIIAJBA3ZBAXEgBUEwahDwByIENgI0IAQNAgwBCyADIAJBAnFyRQRAIAUCfyABLwEYIgMEQCAFIAQ2AgggASgCFCEEIAVBADoAIiAFQQA6AB4gBSADOwEcIAUgBDYCDCAAIAVBCGogBUEwahDfBwwBCyAAIAEoAgAgASkDCCACQQN2QQFxIAVBMGoQjQgLIgQ2AjQgBA0CIAUoAjAhAwsgAw0AIAAQ7gIgACkDICIQIAEpAwhSDQAgASgCACEEIAVBADYCKCAFIBA+AiQgBSAENgIYIAAgBUEIahCMCCEEDAELIAAoAnQiBigCFEEASARAIAAtAABBAk8EQEGt8gQQ4AEhBAwCCyAFIAYQjggiBDYCNCAEDQELIA8oAgQiBCgCRCELAkACQCACQYABTwRAIAVBADYCNCAEKAJIIglBA0wEQCALQQA6AANBBCEJIA8oAgQhBAsgBC0AEUUNASAJIAYvAQ5NDQEgBiALIAVBCGogBigCUBEEACAFKAIUIAUvARhGDQEgDygCBCAJIAtqQQRrEMcBQQMgBigCBCAFQTRqEJUHIAUoAjQiBEUNAQwDCyAGLQAKIQQCQCAGLQABBEAgASgCECEMIAsCfyABKAIcIgggASgCIGoiA0H/AE0EQCAEIAtqIAM6AABBAQwBCyAEIAtqIAOsEO8HQf8BcQsiByAEaiIEaiABKQMIEO8HIARqIQQMAQsgASgCACEMIAQCfyABKQMIIhCnIghB/wBNBEAgBCALaiAQPAAAQQEMAQsgBCALaiAQxBDvB0H/AXELIgNqIQQgCCEDCyAEIAtqIQogBi8BDiIJIANOBEAgAyAEaiIJQQNMBEAgAyAKakEAOgAAQQQhCQsgCiAMIAgQlxMgCGpBACADIAhrEJkTGgwBCyAGKAI0Ig0oAighDiAGLwEQIQcgBUEANgI8IAsgByAHIAMgB2sgDkEEa3BqIg4gCSAOSBsiByAEaiIEaiESIARBBGohCUEAIQ4DQAJAIAMgByADIAdIGyIEIAhMBEAgCiAMIAQQlxMaDAELIAhBAEoEQCAKIAwgCBCXExogCCEEDAELIApBACAEEJkTGgsgAyAEayIDQQBKBEAgCCAEayEIIAQgDGohDCAEIApqIQogByAEayIHDQEgBUEANgI4IAUoAjwiESEEIA0tABEEQEHsnwUoAgAhCgNAIA0gBCIHQQFqIgQQ3wEgBEYNACAHIAogDSgCJG5GDQALIAUgBDYCPAsgBSANIAVBOGogBUE8aiAEQQAQiwciBDYCCAJAIA0tABFFIARyRQRAIA0gBSgCPCIHQQRBAyARGyARIAVBCGoQlQcgBSgCCCIERQ0BIAUoAjgQjAcMBQsgBA0EIAUoAjwhBwsgEiAHQRh0IAdBgP4DcUEIdHIgB0EIdkGA/gNxIAdBGHZycjYAACAOEIwHIAUoAjgiDigCOCISQQA2AAAgDSgCKEEEayEHIA4oAjhBBGohCgwBCwsgDhCMBwsgAEEAOwEyIAAvAUYhAwJAIAUoAjAiBEUEQCAGLwEYIANNBEBB1/IEEOABIQQMBAsgBigCSBDBASIEDQMgBigCOCAGLwEaIAYoAkAgA0EBdGoiBC0AAEEIdCAELQABcnFqIQQgBi0ACEUEQCALIAQoAAA2AAALIAYgBCAFQQhqIAYoAlARBABBACEIIAUoAhQgBS8BGEcEQCAGIAQgBUEIahCPCCEICyAFIAg2AjQgACAALQABQfsBcToAAQJAIAkgBS8BGiIIRw0AIAUoAhQgBS8BGEcNACAPKAIELQARBEAgCSAGLwEQTw0BCyAGKAI4IAYtAAlqQQpqIARLBEBB8vIEEOABIQQMBQsgBigCPCAEIAlqSQRAQfXyBBDgASEEDAULIAQgCyAJEJcTGkEAIQQMBAsgBiADIAggBUE0ahCQCCAFKAI0IgRFDQEMAwsgBEEATg0AIAYvARhFDQAgACADQQFqIgQ7AUYgACAALQABQfkBcToAASAEQf//A3EhAwsCQAJAAkACQCAJQQJqIgggBigCFEoEQCAGIAYtAAwiBEEBajoADCAGIARBAnRqIAs2AiQgBiAEQQF0aiADOwEcDAELIAYoAkgQwQEiBA0DIAYtAAkhBCAGKAI4IQwgBUEANgIIAkAgBi8BEiAGLwEYQQF0aiINIAQgDGoiCi0ABUEIdCAKLQAGciIHSwRAQdm2BCEEIAcNBEGAgAQhByAGKAI0KAIoQYCABEYNAQwEC0HctgQhBCAHIAYoAjQoAihKDQMLAn8CQAJAIAotAAJFBEAgCi0AAUUNAiANQQJqIAdNDQEMAgsgDUECaiAHSw0BCyAGIAkgBUEIahCRCCIEBEAgBCAMayIEIA1MDQQgBEEIdgwCCyAFKAIIIgQNBQsgByAIIA1qSARAIAZBBCAGKAIUIAhrIgQgBEEEThsQkggiBA0FIAotAAYgCi0ABUEIdHJBAWtB//8DcUEBaiEHCyAKIAcgCWsiBEEIdCAEQYD+A3FBCHZyOwAFIARBCHYLIQcgBiAGKAIUIAhB//8DcWs2AhQgBCAMaiALIAkQlxMaIAYoAkAgA0EBdGoiCEECaiAIIAYvARggA2tBAXQQmBMaIAggBDoAASAIIAc6AAAgBiAGLwEYQQFqOwEYIAwgBi0ACWoiBCAELQAEQQFqIgQ6AAQgBCAEQf8BcUcEQCAMIAYtAAlqIgQgBC0AA0EBajoAAwsgBigCNC0AEUUNACAFQQA2AgggBiAGIAsgBUEIahCWByAFKAIIIgQNAwtBACEEDAILQe22BBDgASEEDAELIAQQ4AEhBAsgBi0ADEUNASAAIAAtAAFB+QFxOgABIAAQkwghBCAAKAJ0QQA6AAwgAEEBOgAAIAJBAnFFIARyDQEgABCPB0EAIQQCQCAAKAJwRQ0AIAAgASkDCBBHIgM2AhAgA0UEQEEHIQQMAQsgAyABKAIAIAEoAggQlxMaCyAAQQM6AAAgACABKQMINwM4DAELIA4QjAcLIAVBQGskACAEC0wBAX8gAEEAOwEyIAAgAC0AAUHxAXE6AAECQAJAIAAtAAANACAALwFGIgFFDQAgACgCdC0ACA0BCyAAEIoIDwsgACABQQFrOwFGQQALggMHAX8BfwF/AX8BfwF/AX8jAEEQayIGJAAgACgCBCEHIAAoAgwgACgCCCgCBCIIQThsahDHCCICRQRAIAZBADYCDCAAKAIMIgUgCEEBckE4bGohAyAFIAhB/v8DcUE4bGohBCAAKAIAIAhqQQJtIQIDQCACQQBMRQRAAkACQCAEKAIYRQ0AAkACQCADKAIYRQ0AIAcgBkEMaiAEKAIgIAQoAhQgAygCICADKAIUIAcoAigRCgAiBUEASA0AIAUgAyAETXINAQsgACgCCCIDIAJBAnRqIAQgACgCDCIFa0E4bTYCACADIAJBAXNBAnRqKAIAIQMgBkEANgIMIAUgA0E4bGohAwwCCyAEKAIYRQ0AIAZBADYCDAsgACgCCCIEIAJBAnRqIAMgACgCDCIFa0E4bTYCACAFIAQgAkEBc0ECdGooAgBBOGxqIQQLIAJBAXYhAgwBCwsgASAFIAAoAggoAgRBOGxqKAIYRTYCACAHKAIQLQAXIQILIAZBEGokACACC/ECCAF/AX8BfwF/AX8BfwF/AX8jAEGAAmsiBiQAIAAoAgwhAgJ/IAAoAhBFBEAgACACKAIcEPECIgM2AhBBByADRQ0BGiAAKAIMIgIoAhwvAQYhBCADQQA6ABcgAyAEOwEUC0EBIQQgASgCACEDIABBMkEzQTQgAi0ARCICQQJGGyACQQFGG0EBajYCKCAGQQBBgAIQmRMhBwN/IAMEfwJ/IAEoAgQiAgRAQQAgAiADRg0BGiACIAMoAgRqDAELIAMoAgQLIQhBACECIANBADYCBANAIAcgAkECdGoiBCgCACIJBEAgACADIAkQwAghAyAEQQA2AgAgAkEBaiECDAELCyAEIAM2AgAgCCEDDAEFQQAhAgNAIAVBwABGRQRAAkAgByAFQQJ0aigCACIDRQ0AIAJFBEAgAyECDAELIAAgAiADEMAIIQILIAVBAWohBQwBCwsgASACNgIAIAAoAhAtABcLCwshAiAGQYACaiQAIAILxwEHAX8BfwF/AX8BfgF/AX8jAEEQayIGJAAgAikDACEIIAMgARDoByIJNgIAQQBBByAJGyEEIABBMGohCgNAIAEgB0wgBHJFBEACQCAAIAkoAgwgB0E4bGoiBSAKIAgQyAgiBA0AIAZCADcDCCAFIAZBCGoQyQghBCAFIAYpAwggBSkDAHw3AwggBA0AIAUQxwghBAsgB0EBaiEHIAUpAwghCAwBCwsgBARAIAkQqQcgA0EANgIACyACIAg3AwAgBkEQaiQAIAQLcwIBfwF/QQIhAQNAIAEiAkEBdCEBIAAgAkoNAAsCQEGIogUoAgAiAQRAQeQAIAERAQANAQsgAkE8bEEQaqwQrwEiAUUNACABQQA2AgQgASACNgIAIAEgAUEQaiIANgIMIAEgACACQThsajYCCCABDwtBAAuIAQEBfwJAAkBBiKIFKAIAIgNFDQBB5AAgAxEBAEUNACACQQA2AgAMAQsgAkLAABCvASIDNgIAIANFDQAgAyAANgIAIAMgATYCBCADIAAoAgwiAigCCEEJaiIBIAIoAgRBAm0iAiABIAJKGyICNgIQIAAgACkDSCACrHw3A0hBAA8LIAEQqQdBBwvIAwsBfwF/AX8BfwF/AX8BfwF/AX4BfwF+IwBBEGsiCCQAIAEgADYCBCABKAIAIgJBACACQQBKGyEHAkADQCAFIAdHBEAgASgCDCAFQThsaiIGKAIwIgIEQCACKAIAIgMoAgwoAhghCSADIAIoAgQQ6gciBA0DIAI0AhAhCiACAn4gAygCQCIEBEAgAykDSAwBCyAJIANBQGsiCxDBCCEEIANCADcDSCAEDQQgCygCACEEQgALIgw3AwggAiAENgIwIAMgCiAMfDcDSCAGEMcIIgQNAwsgBUEBaiEFDAELCyABKAIAIQIDQCACQQJIRQRAIAJBAWshBQJ/IAEoAgBBAm0iAyACSARAIAUgA2tBAXQiA0EBcgwBCyABKAIIIAVBA3RqIgIoAgAhAyACKAIECyECAkAgASgCDCIGIANBOGxqIgQoAhhFDQAgBiACQThsaiIGKAIYRQRAIAMhAgwBCyABKAIEIQcgCEEANgIMIAMgAiAHIAhBDGogBCgCICAEKAIUIAYoAiAgBigCFCAHKAIoEQoAQQBMGyECCyABKAIIIAVBAnRqIAI2AgAgBSECDAELCyAAKAIQLQAXIQQLIAhBEGokACAEC3UEAX4BfwF/AX8gAC0AAARAQgAPCwJAIAAoAnQiAi0ACEUEQEJ/IQEMAQsgAEH4AGohAyAALABEIQQgAjMBGCEBQQAhAANAIABB/wFxIgIgBE4NASAAQQFqIQAgASADIAJBAnRqKAIAMwEYfiEBDAALAAsgAQsoAAJAIAAtAAANACAALQABQQhxRQ0AIAFBADYCAEEADwsgACABEIMIC0sBAX8CfyAALQBABEAgACgCFCIAKAIMIAAoAggoAgRBOGxqIgJBFGohACACKAIgDAELIAAoAigiAEEIagshAiABIAAoAgA2AgAgAgsNACAAIAEgAkEAENwHC0cBAX8gAUL/AFgEQCAAIAE8AABBAQ8LIAFC//8AWARAIAAgAaciAkH/AHE6AAEgACACQQd2QYABcjoAAEECDwsgACABEIAIC4MFDQF/AX8BfwF/AX4BfwF/AX8BfwF/AX8BfwF/IwBBEGsiCSQAAkACQCAALQAADQAgAC0AASIEQQJxRQ0AIAEgACkDICIIUQRAQQAhBCADQQA2AgAMAgsgASAIVw0AIARBCHEEQCADQX82AgBBACEEDAILIAhCAXwgAVINACADQQA2AgAgABC4AiIEQeUARg0AIAQNASAAEO4CQQAhBCAAKQMgIAFRDQELIAAQ9AciBEEQRwRAIAQNASACQQFzIQ0DQCAAKAJ0IgUvARgiDkEBayIKIA11IQYgBSgCQCELIAUvARohDCAFKAJEIQ9BACEHIAUtAAIhEAJAAkACfwJAA0AgDyALIAZBAXRqIgQtAABBCHQgBC0AAXIgDHFqIQQCQCAQRQ0AA0AgBEEBaiECIAQsAABBAE4EQCACIQQMAgsgAiIEIAUoAjxJDQALQd7VBBDgASEEDAgLIAQgCUEIahD6BhoCQAJAIAEgCSkDCCIIVQRAIAZBAWohByAGIApIDQFBfwwFCyABIAhZDQEgBiAHTA0DIAZBAWshCgsgByAKakEBdSEGDAELCyAAIAY7AUYgBS0ACEUEQCAGIQcMAwtBACEEIABBADsBMiAAIAg3AyAgACAALQABQQJyOgABIANBADYCAAwGC0EBCyEEIAUtAAhFDQAgACAGOwFGIAMgBDYCAEEAIQQMAQsgBSgCOCEEAn8gByAOTgRAIAQgBS0ACWpBCGoMAQsgBCALIAdBAXRqIgItAABBCHQgAi0AAXIgDHFqCyIEEMcBIQQgACAHOwFGIAAgBBD2ByIERQ0BCwsgAEEAOwEyDAELIANBfzYCAEEAIQQLIAlBEGokACAEC34DAX8BfgF8QQEhAgJAIAEgAWIgAUQAAAAAAADgw2NyDQBBfyECIAFEAAAAAAAA4ENmDQACfiABmUQAAAAAAADgQ2MEQCABsAwBC0KAgICAgICAgIB/CyIDIABVDQBBASECIAAgA1UNAEF/IAEgALkiBGMgASAEZBshAgsgAgvqAQEBfyAAKAIEIQUgAUEBTQRAIAFFBEBB6MwEEOABDwsgBSgCMEEARyEBCyAEIAM2AnAgBEH/AToARCAEIAE2AkAgBCAFNgIUIAQgADYCCEEAIQMgBEEAOgABIAVBCGohAANAIAAoAgAiAARAIAEgACgCQEYEQCAAIAAtAAFBIHI6AAEgBEEgOgABQSAhAwsgAEEYaiEADAELCyAEQQE6AAAgBCAFKAIINgIYIAUgBDYCCAJ/IAIEQCAEQQA6AAIgBCADQQFyOgABQQAiACAFKAJEDQEaIAUQrggPCyAEQQI6AAJBAAshAEEACzoBAX8gAQRAIAAgASgCHCICKAIUEDMgACACKAIYELIDIAAgAigCCBClCCAAIAEoAgwQMyAAIAEQNQsL8gICAX8BfwJAAkACQAJAIAAsAEQiAkEATgRAIAAoAnQhASACRQ0BIAEQkQcgAEH4AGohAgNAIAAgAC0AREEBayIBOgBEIAFB/wFxRQ0DIAIgAcBBAnRqKAIAEJEHDAALAAsgACgCQCIBRQRADAQLIAAtAAAiAkEDTwRAIAJBBEYEQCAAKAIEDwsgABCXByAAKAJAIQELIAAoAhQgASAAQfQAaiAALQACEIcIIgEEQCAAQQE6AAAgAQ8LIABBADoARCAAIAAoAnQiAS0AAToARQsgAS0AAARAIAEtAAEgACgCcEVGDQILQdnTBBDgAQ8LIAAgACgCeCIBNgJ0CyAAQQA7ATIgAEEAOwFGIAAgAC0AAUHxAXE6AAEgAS8BGARAIABBADoAAEEADwsgAS0ACEUEQCABKAIEQQFHBEBB5dMEEOABDwsgASgCOCABLQAJakEIahDHASEBIABBADoAACAAIAEQ9gcPCwsgAEEBOgAAQRALWQIBfwF/IABBADsBMiAAIAAtAAFB+QFxOgABIAAgACwARCIBQQF0IABqLwFGOwFGIAAgAUEBayIBOgBEIAAoAnQhAiAAIAAgAcBBAnRqKAJ4NgJ0IAIQkQcL0wECAX8BfyAALABEIgJBE04EQEHE0gQQ4AEPCyAAQQA7ATIgACAALQABQfkBcToAASAAIAJBAXRqIAAvAUY7AUggAEH4AGoiAyACQQJ0aiAAKAJ0NgIAIAAgAkEBajoARCAAQQA7AUYCQCAAKAIUIAEgAEH0AGogAC0AAhCHCCICRQRAIAAoAnQiAS8BGARAQQAhAiABLQABIAAtAEVGDQILIAEQjAdB0tIEEOABIQILIAAgAC0AREEBayIBOgBEIAAgAyABwEECdGooAgA2AnQLIAILgAQHAX8BfwF/AX8BfwF+AX4gBi0AEiELIAYoAhQhByACQYABTwR/IAJBDGtBAXYFIAJB0JUDai0AAAsiCiAHKAJ4SgRAQRIPCwJAAkACQAJAIApBoR9JDQAgACgCKA0AAkAgAC0ABUEQcQRAIAAoAlAhCAwBCyAAIAdCIBDDAiIINgJQIAhFDQQgACAALQAFQRByOgAFCwJAAkAgCCgCACIJRQ0AAkAgCCgCECABRw0AIAgoAhQgBEcNACAIKAIYIAVHDQAgCCkDCCEMIAAoAiQQvAchDSAIKAIAIQkgDCANUQ0CIAlFDQELIAkQqAILIAggCkEDaq0Q/wciCTYCACAJRQ0EIAAoAiQgA6cgCiAJEOoCIgcNAyAJIApqIgdBADoAAiAHQQA7AAAgCCAFNgIYIAggBDYCFCAIIAE2AhAgCCAAKAIkELwHNwMICyAJQQhrIgcgBykDAEIBfDcDACAKrSEDIAJBAXEEQCAGIAkgAyALQQkQmQEhByAGIAYvARBBgARyOwEQDAILIAYgCSADQQBBCRCZASEHDAELIAAoAiQgA6cgCiAGEP4HIgcNASAGKAIIIAIgBhC9AkEAIQcgAkEBcUUgC0EBR3INACAGKAIIIApqQQA6AAAgBiAGLwEQQYAEcjsBEAsgBiAGLwEQQf//AnE7ARALIAcPC0EHCxAAIAAQmgEgAEEEOwEQIAALEAAgABCgAiAAIAEgAhC0BwusAQMBfwF/AX8jAEEQayIBJAACQCAAAn4gAC0AEUEEcQRAQgAgABD6AQ0BGgsCQCAAKAIIIAAgACgCDCAALQASEPoCIgNBAEwEQEEIIQIgAw0DIAAoAgggAUEIaiAAKAIMIAAtABIQ/AJBAUwNAQwDC0EIIQIgA0EBRw0CIAAoAgggAUEIaiAAKAIMIAAtABIQ/AINAgsgASkDCAs3AwBBBCECCyABQRBqJAAgAgv0AQQBfAF/AX8BfiMAQRBrIgIkACAALwEQIgNBLXFFBEACfwJAAkAgACgCCCAAIAAoAgwgAC0AEhD6AkEBSw0AIAAoAgggAkEIaiAAKAIMIAAtABIQ/AJBAUoNACACKQMIIQQMAQsCfgJAIAArAwAiAUT////////fw2MNAEL///////////8AIAFE////////30NkDQEaIAGZRAAAAAAAAOBDY0UNACABsAwBC0KAgICAgICAgIB/CyEEIAEgBBD7Ag0AQQgMAQsgACAENwMAQQQLIgMgAC8BEEHAZHFyIQMLIAAgA0Ht9wNxOwEQIAJBEGokAAv5AQMBfwF/AX8jAEHQAGsiBCQAAkAgAC0AEiACLQAERgRAIAIoAgggACgCDCAAKAIIIAEoAgwgASgCCCACKAIMEQcAIQUMAQsgACgCFCEGIARBADYCQCAEIAY2AjwgBEEBOwE4IARBADYCGCAEIAY2AhQgBEEBOwEQIARBKGogAEGAgAEQtAcgBCABQYCAARC0BwJAIARBKGogAi0ABBD8ASIAQQAgBCACLQAEEPwBIgEbRQRAIANFDQEgA0EHOgAADAELIAIoAgggBCgCNCAAIAQoAgwgASACKAIMEQcAIQULIARBKGoQ3QcgBBDdBwsgBEHQAGokACAFC6IBBAF/AX8BfwF/IAEoAgwhAiAAKAIMIQMgAS8BECIFIAAvARAiBHJBgAhxBEAgBEGACHEiBCAFcQRAIAAoAgAgASgCAGsPCyAEBEAgASgCCCACEJYIRQRAQX8PCyAAKAIAIAJrDwsgACgCCCADEJYIRQRAQQEPCyADIAEoAgBrDwsgACgCCCABKAIIIAMgAiACIANKGxCcEyIAIAMgAmsgABsLdgEBfyADQQE7ARAgASACaq0gACgCFCIENQIwIAQ1AiR+VgRAQYqSBRDgAQ8LIAMgAkEBahCbAiIERQRAIAAgASACIAMoAggQ6gIiBEUEQCADKAIIIAJqQQA6AAAgAyACNgIMIANBEDsBEEEADwsgAxD3AQsgBAsgAQF/IABCCXwQSCIBRQRAQQAPCyABQgE3AwAgAUEIagvpAQYBfwF/AX8BfwF/AX8jAEEQayEEAkAgAUKAgICAgICAgAFUBEBBASEDA0AgBSICIARBBmpqIAGnQYABcjoAACADIgZBAWohAyACQQFqIQUgAUL/AFYhByABQgeIIQEgBw0ACyAEIAQtAAZB/wBxOgAGQQAhAwNAIAMgBkYNAiAAIANqIARBBmogAmotAAA6AAAgA0EBaiEDIAJBAWshAgwACwALIAAgATwACCABQgiIIQFBByECA38gAkEASAR/QQkFIAAgAmogAadBgAFyOgAAIAJBAWshAiABQgeIIQEMAQsLIQULIAULYQEBfyAAQQA6AAsgACgCBEEIaiEEA0AgBCgCACIEBEACQCAELQABQRBxRQ0AIABBAToACyAEKAJAIAFHDQAgA0UEQCAEKQMgIAJSDQELIARBAToAAAsgBEEYaiEEDAELCwu0AwUBfwF/AX8BfwF/IwBBIGsiBSQAAkAgACgCMCABSQRAQb33BBDgASEGDAELIAAgASAFQRxqQQAQhwgiBg0AIAUoAhwhBAJAAkAgAC0AEEEEcQ0AIAQoAkgoAiBBAkEBIAFBAUYbRg0AQcT3BBDgASEGDAELIAQtAAkhCEEAIQEDQCAELwEYIgcgAUsEQCAEKAI4IAQvARogBCgCQCABQQF0aiIHLQAAQQh0IActAAFycWohByAELQAIRQRAIAAgBxDHAUEBIAMQgggiBg0DCyAEIAcgBSAEKAJQEQQAIAUoAgwgBS8BEEcEQCAEIAcgBRCPCCIGDQMLIAFBAWohAQwBCwsgBUEANgIYAkACQCAELQAIRQRAIAUgACAEKAI4IAhqQQhqEMcBQQEgAxCCCCIGNgIYIAYNAyADRQ0CIAQtAAENAiAELwEYIQcMAQsgA0UNAQsgAyADKQMAIAetQv//A4N8NwMACyACBEAgBCAFQRhqENsHIAUoAhghBgwBCyAEKAJIEMEBIgYNACAEIAQoAjggCGotAABBCHIQgQdBACEGCyAEEIwHCyAFQSBqJAAgBgtbAQF/AkAgABD0ByICQRBHBEAgAg0BIAFBADYCACAAELIIIQIgAC0AASEBIAJFBEAgACABQQhyOgABQQAPCyAAIAFB9wFxOgABIAIPCyABQQE2AgBBACECCyACC4wDAwF/AX4BfiABIAEtAABBP3FqIQMCQAJAAkACQAJAAkACQAJAAkAgAS0AAUEBaw4JBwABAgMEBggFBgsgAy0AASADLAAAQQh0cqwhBAwHCyADLQACIAMtAAFBCHQgAywAAEEQdHJyrCEEDAYLIAMoAAAiA0EYdCADQYD+A3FBCHRyIANBCHZBgP4DcSADQRh2cnKsIQQMBQsgAzEABSADMQADQhCGIAMxAAJCGIaEIAMxAARCCIaEhCADLQABIAMsAABBCHRyrUIghoQhBAwECyADKQAAIgRCOIYgBEKA/gODQiiGhCAEQoCA/AeDQhiGIARCgICA+A+DQgiGhIQgBEIIiEKAgID4D4MgBEIYiEKAgPwHg4QgBEIoiEKA/gODIARCOIiEhIQhBAwDC0IBIQQMAgsgACABIAIQ7gcPCyADMAAAIQQLIAQgAikDCCIFUwRAIAIsABgPCyAEIAVVBEAgAiwAGQ8LIAIvARRBAk8EQCAAIAEgAkEBENwHDwsgAkEBOgAaIAIsABYLgAIEAX8BfwF/AX8jAEEQayIFJAAgBSABLAABIgM2AgwgAUEBaiEEAn8CQAJAA0AgA0ELTARAIANBAE4NAiAEIAVBDGoQvAIaIAUoAgwiA0ELSg0BDAILCyADQQFxRQ0BIAAgA0EMa0EBdiIDIAEtAAAiBGpIBEAgAkHnvwUQ4AE6ABdBAAwDCyABIARqIAIoAgggAigCECIEIAMgAyAEShsQnBMiBkEASg0BIAZBAEgNACADIARGBEAgAi8BFEECTwRAIAAgASACQQEQ3AcMBAsgAkEBOgAaIAIsABYMAwsgAyAESg0BCyACLAAYDAELIAIsABkLIQMgBUEQaiQAIAMLkgEDAX8BfwF/IAAoAnQiACgCRCAALwEaIAAoAkAgAUEBdGoiAS0AAEEIdCABLQABcnFqIgFBAWohBCABLQAAIgUgAC0AC00EQCAFIAQgAiADEQIADwtB4wAhBgJAIAQsAAAiBEEASA0AIAVBB3RBgP8AcSAEciIEIAAvAQ5LDQAgBCABQQJqIAIgAxECACEGCyAGC6ABAgF/AX8jAEEQayIFJAACQCAAKAIwIAFJBEAgAkEANgIAQfO6BBDgASEDDAELIAAoAgAiBCABIAVBDGogAyAEKALcAREGACIDBEAgAkEANgIADAELAkAgBSgCDCIDKAIIIgQtAAANACADIAEgABCDBxogBBCoBiIDRQ0AIAQQkQcgAkEANgIADAELIAIgBDYCAEEAIQMLIAVBEGokACADC1ICAX8BfwNAAkAgAQ0AIAAoAnQiAi0ACA0AIAAgAigCOCACLwEaIAIoAkAgAC8BRkEBdGoiAS0AAEEIdCABLQABcnFqEMcBEPYHIQEMAQsLIAELvQIDAX8BfwF/AkACQAJAIAAtAAAiAUUNACABQQNPBEAgABCdAyICDQIgAC0AACEBC0HlACECAkAgAUH/AXFBAWsOAgIAAQtBACECIABBADoAACAAKAIEQQBKDQELIAAgAC8BRkEBaiIDOwFGIAAoAnQhAQJAAkACQEGIogUoAgAiAkUNAEGcAyACEQEARQ0AIAFBADoAAAwBCyABLQAADQELQajZBBDgAQ8LIAEtAAghAgJAIAEvARggA0H//wNxTQRAIAJB/wFxRQRAIAAgASgCOCABLQAJakEIahDHARD2ByICRQ0CDAMLA0AgAC0AREUEQCAAQQE6AABB5QAPCyAAEPUHIAAvAUYgACgCdCIBLwEYTw0ACyABLQABRQ0DIAAQuAIPCyACQf8BcQ0CCyAAEIgIIQILIAIPC0EAC68CAgF/AX8CQAJAIAAtAAAiAUUNACABQQNPBEAgABCdAyICDQIgAC0AACEBC0HlACECAkAgAUH/AXFBAWsOAgIAAQtBACECIABBADoAACAAKAIEQQBIDQELIAAoAnQhAQJAAkACQEGIogUoAgAiAkUNAEGcAyACEQEARQ0AIAFBADoAAAwBCyABLQAADQELQYXaBBDgAQ8LIAEtAAhFBEAgACABKAI4IAEvARogASgCQCAALwFGQQF0aiICLQAAQQh0IAItAAFycWoQxwEQ9gciAg0BIAAQsggPCwJAA0AgAC8BRiIBDQEgAC0ARARAIAAQ9QcMAQsLIABBAToAAEHlAA8LIAAgAUEBazsBRkEAIQIgACgCdCIBLQABRQ0AIAEtAAgNACAAEOQHIQILIAILPQIBfwF/IAIEQANAIAEgA0cEQCACKAIEIANBKGxqIgQoAiAEQCAEEN0HCyADQQFqIQMMAQsLIAAgAhA4CwtqBAF/AX8BfwF/AkAgACgCdCICKAI8IAAoAigiAyAALwEwIgRqTwRAIAMgAigCOCACLwESak8NAQtB4fAEEOABDwsgBCABKAIgIAEoAhxqIgVGBEAgAiADIAFBACAFELQIDwsgACABELUIC3ABAX8gAQRAIAAoAnAiBRDxAiIDRQRAQQcPCyAFIAKnIAEgAxDyAgJ/AkAgAy8BFCIBBEAgASAFLwEITQ0BC0GSrwQQ4AEMAQsgACADIAQQ3wcLIQEgACgCcCgCDCADEDUgAQ8LIAAgAiADIAQQ8AcLtgILAX8BfwF/AX8BfwF/AX8BfwF/AX8BfyAALwEYIQYgAC0ACiEHIAAoAjgiCCAALQAJIglqIgEtAAVBCHQgAS0ABnJBAWtB//8DcSICIAEtAAdqQQFqIQMgACgCNCgCKCEEAkACQCABLQACIAEtAAFBCHRyIgFFDQAgASACTQ0BIARBBGshCgNAIAEgCkoEQEH4uAQQ4AEPCyABIAhqIgItAAJBCHQgAi0AA3IiCyABaiEFIAMgC2ohAyACLQABIAItAABBCHRyIgIhASACIAVBA2pLDQALIAIEQEGCuQQQ4AEPCyAEIAVPDQBBhrkEEOABDwsCQCADIARMBEAgAyAHIAlqIAZBAXRqQQhqIgFODQELQZK5BBDgAQ8LIAAgAyABa0H//wNxNgIUQQAPC0HzuAQQ4AELrQICAX8BfyMAQRBrIgMkAAJAIAEgAi8BEmoiASAAKAI8SwRAQaneBBDgASECDAELIAFBBGsQxwEhASACLwEQQX9zIAIoAgwgACgCNCIEKAIoQQRrIgJqaiACbiEAA0AgAEUEQEEAIQIMAgsgA0EANgIMIANBADYCCAJAIAFBAk8EQCABIAQoAjBNDQELQbreBBDgASECDAILAn8CQAJAIABBAWsiAARAIAQgASADQQhqIANBDGoQrwgiAg0FIAMoAggiAg0BCyADIAQgARCwCCICNgIIIAINAEEAIQIMAQsgAigCSCgCIEEBRg0AQc7eBBDgAQwBCyAEIAIgARCxCAshAiADKAIIIgEEQCABKAJIEI0BCyACDQEgAygCDCEBDAALAAsgA0EQaiQAIAILmAIEAX8BfwF/AX8gAygCAEUEQCAAKAI0KAIoIAAoAkAgAUEBdGoiBC0AAEEIdCAELQABciIHIAJqSQRAIANBzuAEEOABNgIADwsgAC0ACSEFIAAoAjghBiAAIAcgAkH//wNxELYIIgIEQCADIAI2AgAPCyAAIAAvARhBAWsiAzsBGCADQf//A3FFBEAgBSAGaiIDQQA6AAcgA0EANgABIAMgACgCNCgCKEEIdjoABSADIAAoAjQoAig6AAYgACAAKAI0KAIoIAAtAAkgAC0ACmprQQhrNgIUDwsgBCAEQQJqIANB//8DcSABa0EBdBCYExogBSAGaiIDIAAtABk6AAMgAyAALQAYOgAEIAAgACgCFEECajYCFAsLrwIHAX8BfwF/AX8BfwF/AX8gACgCOCIFIAAtAAkiCEEBaiIGaiIDLQAAQQh0IAMtAAFyIQMgACgCNCgCKCIJIAFrIQcCQAJAA0AgAyIAIAdKDQEgACAFaiIDLQACQQh0IAMtAANyIAFrIgRBAE4EQCAEQQNNBEBBACEBIAUgCGoiAC0AB0E5Sw0EIAUgBmogAy8AADsAACAAIAAtAAcgBGo6AAcgAw8LIAcgACAEaiIASQRAIAJBk7YEEOABNgIAQQAPCyADIARBCHQgBEGA/gNxQQh2cjsAAiAAIAVqDwsgACEGIAMtAAEgAy0AAEEIdHIiAyAASw0AC0EAIQEgA0UNASACQaK2BBDgATYCAEEADwtBACEBIAAgCUEEa0wNACACQam2BBDgATYCAAtBAAuMBg4BfwF/AX8BfwF/AX8BfwF/AX8BfwF/AX8BfwF/IAAvARIiAiAALwEYIgtBAXRqIQwgACgCNCIFKAIoIQMCfwJAIAAoAjgiBiAALQAJaiIILQAHIAFKBEAgA0EEayEJDAELIAgtAAIgCC0AAUEIdHIiASADQQRrIglKBEBBkbUEEOABDwsgAUUNACAJIAEgBmoiBC0AAEEIdCAELQABciIHSQRAQZS1BBDgAQ8LIAcEQCAGIAdqIgotAAANASAKLQABDQELIAgtAAYgCC0ABUEIdHIiBSABTwRAQZy1BBDgAQ8LIAQtAAMgBC0AAkEIdHIiCiABaiEEAkACQCAHBEAgBCAHSwRAQZ+1BBDgAQ8LIAYgB2oiCy0AAkEIdCALLQADciIJIAdqIANMDQFBobUEEOABDwtBACEJIAMgBE4NAUGltQQQ4AEPCyAEIAZqIgMgCWogAyAHIARrEJgTGiAJIApqIQoLIAYgDGohCyAGIAUgCmoiA2ogBSAGaiABIAVrEJgTGiACIAZqIQIDQCACIAtPRQRAIAohBQJAIAEgAi0AASACLQAAQQh0ciIETQRAIAkhBSAEIAdPDQELIAIgBCAFaiIFQQh0IAVBgP4DcUEIdnI7AAALIAJBAmohAgwBCwsgCC0ABwwBCwJAIAtFDQAgCC0ABiAILQAFQQh0ciENIAUoAgAoAuABIAYgAxCXEyEOIAIgBmohD0EAIQIgAyEBA0AgAiALRgRAIAEhAwwCCyAJIA8gAkEBdGoiBS0AAEEIdCAFLQABciIESARAQca1BBDgAQ8LIA0gASAAIAQgDmoiCiAAKAJMEQAAIgdrIgFMIAQgB2ogA0xxBEAgBSABQQh0IAFBgP4DcUEIdnI7AAAgASAGaiAKIAcQlxMaIAJBAWohAgwBBUHMtQQQ4AEPCwALAAsgCEEAOgAHQQALIQEgACgCFCADIAxrIgIgAWpHBEBB2rUEEOABDwsgCEEAOwABIAggA0EIdCADQYD+A3FBCHZyOwAFIAYgDGpBACACEJkTGkEAC5k0KQF/AX8BfwF/AX8BfwF/AX8BfwF/AX8BfwF/AX8BfwF/AX8BfwF/AX8BfwF/AX8BfwF/AX8BfwF/AX8BfwF/AX8BfwF/AX8BfwF/AX8BfwF/AX8jAEGgAmsiAiQAIABByABqISggAEH4AGohJiAAKAJ0IQogAkFAayEiIAJB2ABqISAgAkEPaiEpA0ACQAJAIAooAhRBAE4NACAKEI4IRQ0AQQAhAQwBCyAAAn8CQCAKLQAMRQRAQQAhASAKKAIUQQNsIAAoAhQoAihBAXRMDQMgAC0ARCIjRQ0DDAELIAAtAEQiIw0AIAAoAhRBCGohAQJAA0AgASgCACIBRQ0BAkACQCAAIAFGDQAgAS0AAA0AIAEoAnQgACgCdEYNAQsgAUEYaiEBDAELC0Hl7gQQ4AEhAQwDCyACQQA2AhggAkEANgLwASAKKAI0IQMCQAJAIAooAkgQwQEiAQRAQQAhBAwBCyACIAMgAkEYaiACQfABaiAKKAIEQQAQiwc2AjAgCiACKAIYIgQgAkEwahC3CCADLQARBEAgAyACKALwAUEFIAooAgQgAkEwahCVBwsgAigCMCIBRQ0BCyAAQQA2AnwgBBCMBwwDCyAEQRxqIApBHGogCi0ADEEBdBCXExogBEEkaiAKQSRqIAotAAxBAnQQlxMaIAQgCi0ADDoADCAKIAQoAjgtAABB9wFxEIEHIAooAjggCi0ACWogAigC8AEiAUEYdCABQYD+A3FBCHRyIAFBCHZBgP4DcSABQRh2cnI2AAggACAENgJ8IAAgCjYCeEEAIQEgAEEANgFGIABBAToARCAEDAELIAooAkgoAiBBAk4EQEGh7wQQ4AEhAQwCCyAoICPAQQFrIgFBAXRqLwEAIRECQCAmIAFBAnRqKAIAIgkoAkgQwQEiAQ0AIAkoAhRBAEgEQCAJEI4IIgENAQsCQCAKLQACRQ0AIAotAAxBAUcNACAKLwEcIgEgCi8BGEcNACAJKAIEQQFGDQAgCS8BGCARRw0AIAFFBEBBoeYEEOABIQEMAgsgCigCNCIEIAJBGGogAkHQAWpBAEEAEIsHIgENASACIAooAiQiATYCsAEgAiAKIAEgCigCTBEAADsBkAEgAigCGCIGQQ0QgQcgAiAKNgI0IAJBATYCMCACIAJBkAFqNgI8IAIgAkGwAWo2AjggCigCPCEBIAJB/////wc2AmwgAkECNgJYIAIgATYCQCACIAJBMGpBAEEBIAYQuAgiATYC8AEgAUUEQCAGIAQoAiggBi8BEiACLwGQAWprQQJrNgIUAkAgBC0AEUUNACAEIAIoAtABQQUgCSgCBCACQfABahCVByACLwGQASAGLwEQTQ0AIAYgBiACKAKwASACQfABahCWBwsgCigCOCAKLwEaIAooAkAgCi8BGEEBdGoiAUECay0AAEEIdCABQQFrLQAAcnFqIQNBACEBA0ACQCACIAMgAUEBaiIFaiIENgKwASABIANqIgcsAABBAE4NACABQQhJIQggBSEBIAgNAQsLIAdBCmohBSApIQMDQAJAIAIgBEEBaiIBNgKwASADIAQsAAAiBDoAACADQQFqIQMgBEEATg0AIAEhBCABIAVJDQELCyACKALwASIBRQRAIAkgCS8BGCACQQtqIAMgAkELamtBACAKKAIEEJQIIQELIAkoAjggCS0ACWogAigC0AEiBEEYdCAEQYD+A3FBCHRyIARBCHZBgP4DcSAEQRh2cnI2AAgLIAYQjAcMAQsgACgCFCgCJBCpBiEfIAAtAAMhASACQQA2ApwCIAJBADoAiAEgAkEANgKEASACQTBqQQBBPBCZExogAkH/////BzYCbCAfBH8gAUEBcSEUQQAhEiAJKAI4IQMCfyAJLwEYIgEgCS0ADCIEaiIXQQJPBEACf0EAIBFFDQAaIBEgFGpBAmsgESAXRg0AGiARQQFrCyESQQIgFGshFwsgASASIARrIBdqIgRGBEAgAyAJLQAJakEIagwBCyADIAkvARogCSgCQCAEQQF0aiIBLQAAQQh0IAEtAAFycWoLIRwgCSgCNCEVIBdBAWohGUEAIQQgHBDHASEFIBchAUEAIQgCQANAAkAgBEUEQCACIBUgBSABQQJ0IgcgAkGQAmpqIgNBABCHCCIENgKcAiAERQ0BC0EAIQQgAkGQAmpBACABQQJ0QQRqEJkTGgwCCwJAIAMoAgAiBCgCFEEATg0AIAIgBBCOCCIDNgKcAiADRQ0AQQAhBCACQZACakEAIAcQmRMaDAILIAggBC8BGGpBBGohCCABBEAgAUEBayIBIBJqIQQCQCAJLQAMIgNFDQAgBCAJLwEcRw0AIAFBAnQiAyACQegBamogCSgCJCIENgIAIAQQxwEhBSACQZABaiADaiAJIAQgCSgCTBEAADYCAEEAIQQgCUEAOgAMDAILIAFBAnQiByACQegBamoiBiAJKAI4IAkvARogCSgCQCAEIANrQQF0aiIDLQAAQQh0IAMtAAFycWoiAzYCACADEMcBIQUgAkGQAWogB2ogCSADIAkoAkwRAAAiBzYCAAJAIBUtABhBDHFFDQAgFSgCKCADIAkoAjhrIhogB2pIDQAgGiAfaiADIAcQlxMaIAYgHyADIAkoAjhrajYCAAsgCSAEIAktAAxrIAcgAkGcAmoQkAggAigCnAIhBAwBCwsgAiAFNgKMASACIBUoAiQgCEEDakH8////B3EiAUEGbGqsEEciBTYCOCAFRQRAIAJBBzYCnAJBACEEDAELIAIgAigCkAIiFjYCNCACIAUgAUECdGoiDDYCPCAMIAFBAXRqIRMgFi0ACCInQQJ0IR0gFi0AAiEPQQAhBEEAIQZBACEQA0ACQCAQIBlHBEAgEEECdCIOIAJBkAJqaigCACINKAI4IggtAAAgFigCOC0AAEcEQCACQcnpBBDgATYCnAJBACEEDAQLIAggDS8BEmohASANLwEaIQcgDCAEQQF0akEAIA0vARgiAyANLQAMakEBdBCZExogDS0ADCIaRQ0BIA0vARwiCyADTQRAQQAhAwNAIAMgC0YEQCANQSRqIQtBACEDA0AgAyAaRkUEQCAFIARBAnRqIAsgA0ECdGooAgA2AgAgA0EBaiEDIARBAWohBAwBCwsgAiAENgIwDAQFIAUgBEECdGogCCABLQABIAEtAABBCHRyIAdxajYCACADQQFqIQMgBEEBaiEEIAFBAmohAQwBCwALAAsgAkHh6QQQ4AE2ApwCQQAhBAwDCyAdIBUoAihqQQxrIRpBACEBQQAhBwNAAkAgByAZRgRAQQAhECACKAIwIRMgGSEGDAELICIgAUECdCIDaiAHQQJ0IgYgAkGQAmpqKAIAIgQoAjw2AgAgAyAgaiACQbABaiAGaigCACILNgIAIAEEfyABQQFrIgMgASALICAgA0ECdGooAgBGGwVBAAshEyAPRQRAICIgE0EBaiITQQJ0IgFqIAkoAjw2AgAgASAgaiALQQFqNgIACyACQZABaiAGaiIFIBogBCgCFGsiAzYCACAEQSRqIQhBACEBA0AgASAELQAMT0UEQCAFIAQgCCABQQJ0aigCACAEKAJMEQAAIANqQQJqIgM2AgAgAUEBaiEBDAELCyACQdABaiAGaiALNgIAIBNBAWohASAHQQFqIQcMAQsLA0ACQCAGIBBKBEAgEEECaiEMIBBBAnQiGCACQdABamohBSAQQQFqIg1BAnQiASACQdABamohGyACQZABaiABaiEEIAJBkAFqIBhqIg4oAgAhAQNAAkAgASAaTARAIA4gATYCACAFKAIAIgMgEyADIBNKGyEHA0AgAyAHRg0FIAJBMGogAxC5CEECaiIIIAFqIgEgGkoNAiAOIAE2AgAgA0EBaiEDAkAgDw0AQQAhCCADIBNODQAgAkEwaiADELkIQQJqIQgLIAQgBCgCACAIazYCAAwACwALIAYgDUwEQCAQQQRPBEAgDiABNgIAIAJBxuoEEOABNgKcAkEAIQQMCQsgBEEANgIAIBsgEzYCACAMIQYLAn8gAkEwaiAFKAIAIgtBAWsiCBC5CEECaiIHIgMgDw0AGkEAIgMgCyATTg0AGiACQTBqIAsQuQhBAmoLIQMgASAHayEBIAQgBCgCACADajYCACAFIAg2AgAMAQsLIAUgAzYCACAQBH8gAiAYaigCzAEFQQALIQEgDSEQIAEgA0gNAiACQefqBBDgATYCnAJBACEEDAULIAIoAjwhDSAGQQFrIiQhDANAAkACQCAMQQBKBEAgDEECdCIhIAJBkAFqaiIbKAIAIQUgDEEBayIYQQJ0IgEgAkGQAWpqIiUoAgAhCCACQTBqIAJB0AFqIAFqIhAoAgAiASAPayIDELkIGkF+QQAgDCAkRxshDgNAIAJBMGogAUEBayIEELkIIQcgDSADQQF0ai8BACELAkAgBUUEQCALQQJqIQsMAQsgFA0DIAUgC2pBAmoiCyAIIA5qIAdrSg0DCyAQIAQ2AgAgA0EBayEDIAggB2tBAmshCCABQQFKIQcgCyEFIAQhASAHDQALDAILQQAhASAGQQAgBkEAShshCCARIBJrIQcgFigCOC0AACEbQQAhBANAAkAgASAIRgRAQQAhASAEQQAgBEEAShshEAwBCwJAAkAgASAXTQRAIAFBAnQiAyACQfABamogAkGQAmogA2oiBSgCACIDNgIAIAVBADYCACACIAMoAkgQwQEiBTYCnAIgBEEBaiEEIAMoAkgoAiBBAkEBIAEgB0YbRiAFcg0BIAJBtOsEEOABNgKcAgwMCyACIBUgAkEYaiACQYwBakEBIAIoAowBIBQbQQAQiwciAzYCnAIgAw0LIAIoAhgiAyAbEIEHIAFBAnQiBSACQbABamogEzYCACACQfABaiAFaiADNgIAIARBAWohBCAVLQARRQ0BIBUgAygCBEEFIAkoAgQgAkGcAmoQlQcgAigCnAJFDQEMCwsgBQ0KCyABQQFqIQEMAQsLA0AgASAQRkUEQCABQQJ0IgMgAkHwAGpqIAJB8AFqIANqKAIAKAIENgIAIAFBAWohAQwBCwtBACEIIARBAWsiFEEAIBRBAEobIQsDQCALIAgiBUcEQCAFIgNBAWoiCCEBA0AgASAETkUEQCABIAMgAkHwAWogAUECdGooAgAoAgQgAkHwAWogA0ECdGooAgAoAgRJGyEDIAFBAWohAQwBCwsgAyAFRg0BIAJB8AFqIANBAnRqKAIAIgEoAgQhByACQfABaiAFQQJ0aigCACIDKAIEIQUgAygCSCIGLwEcIRFB7J8FKAIAIQ4gFSgCJCEMIAYgASgCSC8BHCIWOwEcIAYgDiAMbkEBahCTByABKAJIIgYgETsBHCAGIAUQkwcgAygCSCIGIBY7ARwgBiAHEJMHIAMgBzYCBCABIAU2AgQMAQsLIBwgAkHwAWogFEECdGooAgAiAygCBCIBQRh0IAFBgP4DcUEIdHIgAUEIdkGA/gNxIAFBGHZycjYAACAbQQhxIAQgGUZyRQRAIAMoAjggF0ECdCACQfABaiACQZACaiAEIBlKG2ooAgAoAjgoAAg2AAgLIBUtABEEQCACKALwASIFLQAMIAUvARhqIQMgD0UhDkEAIQ0gBSEGQQAhAUEAIQgDQCAIIBNIBEAgCCAOaiEHIAIoAjggCEECdGooAgAhEQNAIAMgCEdFBEAgByACQfABaiACQZACaiABQQFqIgEgBEgbIAFBAnRqKAIAIgUvARhqIAUtAAxqIQMMAQsLAkAgAkHQAWogDUECdGooAgAgCEYEQCACQfABaiANQQFqIg1BAnRqKAIAIQYgD0UNAQsCQCABIARODQAgBigCBCACQfAAaiABQQJ0aigCAEcNACARIAUoAjhJDQAgESAFKAI8SQ0BCyAnRQRAIBUgERDHAUEFIAYoAgQgAkGcAmoQlQcLIAJBMGogCBC5CCAGLwEQSwRAIAYgBSARIAJBnAJqEJYHCyACKAKcAg0LIAIoAjAhEwsgCEEBaiEIDAELCyACKAI8IQ0LQQAhFiACKAI4IRFBACEIAkACQANAAkAgCCALRwRAIBYgH2ohDiANIAhBAnQiASACQdABamooAgAiBUEBdGovAQAiAyAdaiEGIBEgBUECdGooAgAhBwJAIAJB8AFqIAFqKAIAIgwtAAhFBEAgDCgCOCAHKAAANgAIDAELIA8EQCAMIBEgBUEBayIFQQJ0aigCACACQRhqIAwoAlARBAAgDkEEaiACKQMYEO8HQQRqIQYgDiEHQQAhDgwBCyAHQQRrIQcgA0EERw0AIAkgByAJKAJMEQAAIQYLQQAhAQNAIAFBAnQhAyABQQFqIQEgAyAgaigCACAFTA0ACyAHIAMgImooAgAiAU8gBiAHaiABTXINASACQf3sBBDgATYCnAIMDAsgBEEBIARrIgcgBCAHShshGyAPRSEhIAIoAjQhCCACKALQASEkAkADQCAHIBtHBEACQCAHIAdBH3UiAXMgAWsiASACQYQBamoiFi0AAA0AAn8CQCAHQQBIBEAgAUEBayIDQQJ0IgUgAkGwAWpqKAIAIAJB0AFqIAVqKAIATg0BDAMLIAdFBEBBACELQQAhDyAkDAILIAFBAWshAwsgEyEPIAEgF00EQCACQbABaiADQQJ0aigCACAhaiEPCyACQdABaiABQQJ0aigCACACQdABaiADQQJ0aigCACAhaiILawshEiABQQJ0IiUgAkHwAWpqKAIAIgYoAkAhAyAGLQAJIQ4gBigCOCEcIAYtAAwhDCAGLwEYIgEhBSALIA9KBEAgBiAPIAsgD2sgAkEwahC6CCIFIAFKBEBBr+UEIQEMCQsgBigCQCIUIBQgBUEBdGogAUEBdBCYExogASAFayEFCyADIBJBAXRqIRQgASAPaiAMaiIDIAsgEmoiAUoEQCAFIAYgASADIAFrIAJBMGoQughrIQULIAIgHCAOIBxqIhgtAAVBCHQgGC0ABnJqIgE2AhgCQAJAIAEgFEkNACABIAYoAjxLDQAgCyAPSARAIAYoAkAiASASIA8gC2siAyADIBJKGyIDQQF0aiABIAVBAXQQmBMaIAYgFCACQRhqIAEgCyADIAJBMGoQuwgNASADIAVqIQULIAZBHGohHUEAIQEDQCAGLQAMIAFLBEAgDyAdIAFBAXRqLwEAaiIOIAtrIgNBAEggAyASTnJFBEAgBigCQCADQQF0aiEMIAMgBUgEQCAMQQJqIAwgBSADa0EBdBCYExoLIAJBMGogDhC5CBogBiAUIAJBGGogDCAOQQEgAkEwahC7CA0DIAVBAWohBQsgAUEBaiEBDAELCyAGIBQgAkEYaiAGKAJAIAVBAXRqIAUgC2ogEiAFayACQTBqELsIDQAgBkEAOgAMIAYgEjsBGCAYIBJBCHY6AAMgGCAGLQAYOgAEIBggAigCGCAcayIBQQh0IAFBgP4DcUEIdnI7AAUMAQsgCyEBIBIiA0EATARAQfnlBCEBDAkLA0AgA0EASgRAIA0gAUEBdGoiBS8BAEUEQCAFIAggESABQQJ0aigCACAIKAJMEQAAOwEACyADQQFrIQMgAUEBaiEBDAELCyACQTBqIAsgEiAGELgIIgENBAsgFkEBOgAAIAYgGiACQZABaiAlaigCAGs2AhQLIAdBAWohBwwBCwsgAkEANgKcAgJAICNBAUcNACAJLwEYDQAgAigC8AEiASgCFCAJLQAJSA0AIAIgAUF/EJIINgKcAiABIAkgAkGcAmoQtwggASACQZwCahDbBwwECyAVLQARRQ0DQQAhASAnDQMDQCABIBBGDQQgFSACQfABaiABQQJ0aigCACIDKAI4QQhqEMcBQQUgAygCBCACQZwCahCVByABQQFqIQEMAAsACyACIAE2ApwCDAsLIAYgFmohFiAIIBJqIQEgCEEBaiEIIAkgASAHIAYgDiAMKAIEEJQIIgFFDQALIAIgATYCnAIMCQsgBCAZIAQgGUobIQMgBCEBA0AgASADRg0JIAJBkAJqIAFBAnRqKAIAIAJBnAJqENsHIAFBAWohAQwACwALIAIgARDgATYCnAIMBwsgASEEIAUhCwsgGyALNgIAICUgCDYCAEEAIQEgDEEBRwRAIAIgIWooAsgBIQELIBghDCABIARIDQALIAJBk+sEEOABNgKcAkEAIQQMBAsgBSAHNgIAIA0iBiEQDAALAAsgCCANLwESaiANLwEYQQF0aiEDA0AgASADT0UEQCAFIARBAnRqIAggAS0AASABLQAAQQh0ciAHcWo2AgAgAiAEQQFqIgQ2AjAgAUECaiEBDAELCyACQbABaiAOaiAENgIAIBAgF08gD3JFBEAgDCAEQQF0aiIBIAJBkAFqIA5qKAIAIgM7AQAgBSAEQQJ0aiAGIBNqIAJB6AFqIA5qKAIAIANB//8DcSIIEJcTIB1qIgc2AgAgASABLwEAIB1rIgM7AQAgBiAIaiEGAkAgDS0ACEUEQCAHIA0oAjgoAAg2AAAMAQsDQCADQf//A3FBA0sNASAGIBNqQQA6AAAgASABLwEAQQFqIgM7AQAgBkEBaiEGDAALAAsgAiAEQQFqIgQ2AjALIBBBAWohEAwACwALQQAhAUEAIAIoAjgQMgN/IAEgGUYEf0EAIQEgBEEAIARBAEobIQQDQCABIARGRQRAIAJB8AFqIAFBAnRqKAIAEIwHIAFBAWohAQwBCwsgAigCnAIFIAJBkAJqIAFBAnRqKAIAEIwHIAFBAWohAQwBCwsFQQcLIQEgHgRAIB4QoAYLIB8hHgsgCkEAOgAMIAoQjAcgACAALQBEQQFrIgQ6AEQgJiAEwEECdGooAgALIgo2AnQgAUUNAQsLIB4EQCAeEKAGCyACQaACaiQAIAEL9gUGAX8BfwF/AX8BfwF/IwBBEGsiByQAAkACQAJAAkACQCAALQAMRQRAIANBAmoiCSAAKAIUTA0BCwJAIARFBEAgAiEEDAELIAQgAiADEJcTGgsgBCAFQRh0IAVBgP4DcUEIdHIgBUEIdkGA/gNxIAVBGHZycjYAACAAIAAtAAwiBUEBajoADCAAIAVBAnRqIAQ2AiQgACAFQQF0aiABOwEcDAELIAAoAkgQwQEiBA0DIAAtAAkhBCAAKAI4IQogB0EANgIMAkAgAC8BEiAALwEYQQF0aiILIAQgCmoiCC0ABUEIdCAILQAGciIGSwRAQdm2BCEEIAYNBEGAgAQhBiAAKAI0KAIoQYCABEYNAQwEC0HctgQhBCAGIAAoAjQoAihKDQMLAn8CQAJAIAgtAAJFBEAgCC0AAUUNAiALQQJqIAZNDQEMAgsgC0ECaiAGSw0BCyAAIAMgB0EMahCRCCIEBEAgBCAKayIEIAtMDQQgBEEIdgwCCyAHKAIMIgQNBQsgBiAJIAtqSARAIABBBCAAKAIUIAlrIgQgBEEEThsQkggiBA0FIAgtAAYgCC0ABUEIdHJBAWtB//8DcUEBaiEGCyAIIAYgA2siBEEIdCAEQYD+A3FBCHZyOwAFIARBCHYLIQYgACAAKAIUIAlB//8DcWs2AhQgBCAKaiIJQQRqIAJBBGogA0EEaxCXExogCSAFQRh0IAVBgP4DcUEIdHIgBUEIdkGA/gNxIAVBGHZycjYAACAAKAJAIAFBAXRqIgVBAmogBSAALwEYIAFrQQF0EJgTGiAFIAQ6AAEgBSAGOgAAIAAgAC8BGEEBajsBGCAKIAAtAAlqIgUgBS0ABEEBaiIFOgAEIAUgBUH/AXFHBEAgCiAALQAJaiIFIAUtAANBAWo6AAMLIAAoAjQtABFFDQAgB0EANgIIIAAgACACIAdBCGoQlgcgBygCCCIEDQMLQQAhBAwCC0HttgQQ4AEhBAwBCyAEEOABIQQLIAdBEGokACAEC4EBAgF+AX4gASAAMQAHIAAxAAZCCIaEIAAxAAVCEIYgADEABEIYhoQgADEAAUIQhiAAMQAAQhiGhCICIAAxAAMgADEAAkIIhoSEQiCGhIQiAzcDACABQQFBCCACQoCAwP8Hg0KAgMD/B1EgA0L/////////B4NCAFJxIgAbOwEQIAALQQMBfwF/AX8gAUEAIAFBAEobIQRBASEDAkADQCACIARGDQEgACACaiEBIAJBAWohAiABLQAARQ0AC0EAIQMLIAMLGwAgASACEJ8BIQIgASAAKAIAEDIgACACNgIACxwBAX8gAEEAEMUBIgFFBEAgAEEAEMQBIQELIAELjAIEAX8BfwF/AX4jAEEwayIDJAACQCAAAn9BByIEIAAoAgAiBS0AVw0AGiAAKAIEKAIADQEgACgCEEEDcSIEBEAgASkCACEGIAMgAjYCLCADIAY3AyAgAyAEQQJ0QQAiBGpBgLEFaigCADYCKCAFQeDhACADQSBqEIEDIQQgACgCBCAENgIAQQEMAQsgBS0AIEEBcQRAQeLaCBDgAQwBCyADIAEoAgQiAUGUoQIgARs2AhAgBUGfyQIgA0EQahCBAyEEAkAgAkUNACACLQAARQ0AIAMgAjYCBCADIAQ2AgAgBUGA6wAgAxCBAyEECyAAKAIEIAQ2AgBB6doIEOABCyIENgIMCyADQTBqJAALZwMBfwF/AX4gAQJ/A0AgACACai0AACIDQTprQXZPBEAgA63CIARCCn58QjB9IgRCgICAgBBWBEBBACEDQQAMAwUgAkEBaiECDAILAAsLIASnQQAgA0UgAkEAR3EiAxsLIgI2AgAgAwtkAwF/AX8BfwNAAkAgACgCFCADTARAQQAhBAwBCyAAKAIQIAMgA0ECSXMiBUEEdGooAgwhBAJAIAIEQCAAIAUgAhDPCEUNAQsgBEEYaiABEIkDIgQNAQsgA0EBaiEDDAELCyAECz4CAX8BfyAAKAIMQQhqIQIDQCACKAIAIgFFBEBBAA8LIAFBFGohAiAAIAFGDQAgASgCLCAAKAIsRw0AC0EBC5sCAwF/AX8BfyMAQdAAayIFJAACQCACRQ0AIAIoAgAiBEUNACACKAIIRQ0AIAAoAgAgBCAAKAIEEIgDIgRFDQACQCACKAIEIgZFBEAgAigCCCECDAELAn8gAigCACAGEGtFBEAgBBCzAwwBCyAAKAIAIAYgACgCBBCbCAshACACKAIIIQIgAEUNACAAIAAvADdB+/8DcTsANyACIAAvATJBAWogACgCCCAAENAIIAAgAC8AN0GAAXI7ADcgACgCJA0BIAQgACgCCC8BADsBJiAEIAQoAhxBEHI2AhwMAQsgBSAELwEoOwE4IAJBASAEQSZqIAVBCGoQ0AggBCAFLwE4OwEoIAQgBCgCHEEQcjYCHAsgBUHQAGokAEEAC54BBAF/AX8BfwF/QQUgAC8BMiIBIAFBBU8bIQEgACgCCCIDIAAoAgwiBC4BJiICQeIATARAIARB4wA7ASZB4wAhAgsgAkEKayACIAAoAiQbOwEAIANBAmpB4JYDIAFBAXQQlxMaA0AgASAALwEyIgJPRQRAIAMgAUEBaiIBQQF0akEXOwEADAELCyAALQA2BEAgAyACQQF0akEAOwEACwsQACAAEM8HIAAoAgQgABAyC0YBAX8jAEEQayIEJAAgBCADNgIMAkAgACACIAMQsgEiA0UEQEEHIQIMAQsgACABIAMQowghAiAAIAMQNQsgBEEQaiQAIAILWQAgACgCBCgCACgC5AEhAAJAIAFFBEAgACgCHCEBDAELIAFBAEgEQEIAIAGsQgqGfSAAKAIkIAAoAiBqrH+nIQELIAAgATYCHAsgABCxBiIAIAEgACABShsLDwAgACgCBCgCACABEKEGC8sBAgF/AX8jAEEQayIDJAAgACACQX8gA0EMakEAEIcBIgJFBEADQCADKAIMEIgBIgJB5ABGBEAgAygCDEEAEKYBIgJFDQECQCACLQAAIgRByQBHBEAgBEHDAEcNAyACLQABQdIARw0DIAItAAJBxQBHDQMMAQsgAi0AAUHOAEcNAiACLQACQdMARw0CCyAAIAEgAhCjCCICRQ0BCwsgAkEAIAJB5QBHGyICBEAgASAAIAAQqQEQlwgLIAMoAgwQjgEaCyADQRBqJAAgAgs7AAJ/IAAoAgQiAC0AGEECcQRAQQggAC0AESABQQBHRw0BGgsgACABQQJGOgASIAAgAUEARzoAEUEACwsQACABBEAgACABQQEQpwgLC7wBAgF/AX8DQAJAAkAgASgCBCIDQYCAhARxDQACQCABKAIQIgIEQCAAIAIQpggMAQsgASgCFCECIANBgCBxBEAgACACEKUIDAELIAAgAhCyAyABLQAHQQFxRQ0AIAAgASgCLBCoCAsgASgCDCICRQ0AIAEtAABBsgFGDQAgAS0AB0EIcUUEQCACLQAHQQhxRQ0CCyAAIAIQpggLIAEtAAdBCHFFBEAgACABEDgLDwsgACABEDggAiEBDAALAAupAQIBfwF/IAJFIQQDQCABIgMEQCADKAI0IQEgACADKAIcELIDIAAgAygCIBCqCCAAIAMoAiQQMyAAIAMoAigQsgMgACADKAIsEDMgACADKAIwELIDIAAgAygCPBAzIAMoAkAiAgRAIAAgAhCrCAsgAygCSCICBEAgACACEKwICwNAIAMoAkQiAgRAIAIQqQgMAQsLIAQhAkEAIQQgAg0BIAAgAxA4DAELCwtTACABBEAgARCpCCAAIAEoAigQMyAAIAEoAggQsgMgACABKAIMELIDIAAgASgCHBAzIAAgASgCGBAzIAAgASgCABAyIAAgASgCBBAyIAAgARA1CwsyAgF/AX8gACgCICICBEAgAiAAKAIkIgE2AgAgAQRAIAEgACgCIDYCIAsgAEEANgIgCwv4AQMBfwF/AX8gAQRAIAFBCGohAgNAIAEoAgAgBEoEQCACKAIAIgMEQCAAIAMQOAsgAigCBCIDBEAgACADEDgLAkAgAi0ADUEEcQRAIAAgAigCLCIDKAIAEKUIIAAgAxA1DAELIAItAA9BAXENACACKAIsIgNFDQAgACADEDgLIAIvAA0iA0ECcQRAIAAgAigCIBAyIAIvAA0hAwsgA0EIcQRAIAAgAigCIBCyAwsgACACKAIIECsgAigCKCEDAkAgAi0ADkEIcQRAIAAgAxA0DAELIANFDQAgACADEKYICyACQTBqIQIgBEEBaiEEDAELCyAAIAEQOAsLPQIBfwF/IAEEQCABQQxqIQMDQCACIAEoAgBORQRAIAAgAyACQRhsahCtCCACQQFqIQIMAQsLIAAgARA1CwsgAQF/A0AgAQRAIAEoAiQhAiAAIAEQqAggAiEBDAELCwsfACAAIAEoAgQQsgMgACABKAIIEKUIIAAgASgCABAyC0wBAX8gACAAKAIkEKkGIgE2AkQgAUUEQCAAIAAoAggiASgCGDYCCCABQQBByAEQmRMaQQcPCyABQgA3AAAgACAAKAJEQQRqNgJEQQAL/gEEAX8BfwF/AX8jAEEQayIFJAAgBUEANgIMAkACQCAALQARRQ0AQeyfBSgCACEHIAEhBANAIAAgBCIGQQFqIgQQ3wEgBEYNACAGIAcgACgCJG5GDQALIAQgACgCMEsNAAJAIAAgBCAFQQdqIAVBCGoQigciBg0AIAUtAAdBBEcNACAFKAIIIAFHDQFB5QAhBgwCC0EAIQQgBg0BC0EAIQQgACABIAVBDGogAkVBAXQQ6AEiBg0AQQAhBiAFKAIMKAI4EMcBIQQLIAMgBDYCACAFKAIMIQQCQCACBEAgAiAENgIADAELIAQQjAcLIAVBEGokACAGQQAgBkHlAEcbCyABAX8gACgCACABEO0GIgJFBEBBAA8LIAIgASAAEIMHC+0GBgF/AX8BfwF/AX8BfyMAQRBrIgQkACAEQQA2AgwCQAJAIAJBAk8EQCACIAAoAjBNDQELQZbdBBDgASEDDAELIAAoAgwhBgJAIAEEQCABKAJIIgMgAykDIEIBfDcDICADKAIMIgMgAykDEEIBfDcDEAwBCyAAIAIQsAghAQsgBCABNgIIIAQgBigCSBDBASIDNgIEAkACQAJAIAMNACAGKAI4IgUgBUEkahDHASIHQQFqIgNBGHQgA0GA/gNxQQh0ciADQQh2QYD+A3EgA0EYdnJyNgAkIAAtABhBBHEEQCABRQRAIAAgAiAEQQhqQQAQ6AEhAyAEKAIIIQEgAw0CCyAEIAEoAkgQwQEiAzYCBCADDQIgASgCOEEAIAEoAjQoAiQQmRMaCyAALQARBEAgACACQQJBACAEQQRqEJUHIAQoAgQiAw0BCwJAIAdFBEBBACEFDAELIAYoAjhBIGoQxwEiBSAAKAIwSwRAQcXdBBDgASEDDAILIAAgBSAEQQxqQQAQ6AEiAw0BIAQoAgwiCCgCOEEEahDHASIHIAAoAihBAnYiA0ECa0sEQEHQ3QQQ4AEhAwwCCyAHIANBCGtPDQAgCCgCSBDBASIDDQEgCCgCOCAHQQFqIgNBGHQgA0GA/gNxQQh0ciADQQh2QYD+A3EgA0EYdnJyNgAEIAgoAjggB0ECdGogAkEYdCACQYD+A3FBCHRyIAJBCHZBgP4DcSACQRh2cnI2AAgCQCABRQ0AIAAtABhBBHENACABKAJIIgMoAhQiBi0ADA0AIAMvARwiBUECcUUNACAGKAJoDQAgAyAFQev/A3FBEHI7ARwLAkAgACgCQCIDDQAgACAAKAIwEJsEIgM2AkAgAw0AQQchAwwCCyADKAIAIAJJBEBBACEDDAILIAMgAhCcBCEDDAELIAFFBEAgACACIARBCGpBABDoASEDIAQoAgghASADDQELIAEoAkgQwQEiAw0BIAEoAjggBUEYdCAFQYD+A3FBCHRyIAVBCHZBgP4DcSAFQRh2cnI2AABBACEDIAEoAjhBADYABCAGKAI4IAJBGHQgAkGA/gNxQQh0ciACQQh2QYD+A3EgAkEYdnJyNgAgDAELIAENAEEAIQEMAQsgAUEAOgAACyABEIwHIAQoAgwQjAcLIARBEGokACADC1gCAX8BfwJAA0AgACgCdCIBLQAIRQRAIAEoAjggAS0ACWpBCGoQxwEhAiAAIAEvARg7AUYgACACEPYHIgFFDQEMAgsLIAAgAS8BGEEBazsBRkEAIQELIAELMgACQAJAIAMEQCAEEMEBIgMNAiAAIAEgAhCXExoMAQsgASAAIAIQlxMaC0EAIQMLIAMLyQEDAX8BfwF/AkACQCACKAIcIgYgA2siBUEATARAIARBACAEQQBKGyEFA0AgBSAHRg0CIAEgB2oiAi0AAEUEQCAHQQFqIQcMAQsLIAAoAkgQwQEiBg0CIAJBACAEIAdrEJkTGkEADwsCQCAEIAVMBEAgBCEFDAELIAAgASAFaiACIAYgBCAFaxC0CCIGDQILQQAhBiABIAIoAhAgA2ogBRCcE0UNASAAKAJIEMEBIgYNASABIAIoAhAgA2ogBRCYExoLQQAhBgsgBguVAgcBfwF/AX8BfwF/AX8BfyMAQRBrIgYkACABKAIgIQMgASgCHCEFIAYgACgCdCIENgIMAkAgBCAAKAIoIAFBACAALwEwELQIIgINACADIAVqIQUgAC8BMCIDIAAoAihqEMcBIQcgBCgCNCIIKAIoQQRrIQQDQCAIIAcgBkEMakEAEOgBIgINAQJ/AkAgBigCDCIAKAJIKAIgQQFGBEAgAC0AAEUNAQtBxfAEEOABDAELAkAgBSADIARqSwRAIAAoAjgiAhDHASEHDAELIAUgA2shBCAAKAI4IQILIAAgAkEEaiABIAMgBBC0CAshAiAAKAJIEI0BIAINASADIARqIgMgBUgNAAtBACECCyAGQRBqJAAgAguHBQ0BfwF/AX8BfwF/AX8BfwF/AX8BfwF/AX8BfyABIAJqIQYgAC0ACSIDQQFqIQgCQAJAAkAgACgCOCIHIANqIgktAAINACAHIAhqLQAADQAgCCELIAIhBAwBCyAIIQMCQANAIAcgAyILQf//A3EiD2oiCi0AACIFQQh0IAotAAEiDXIiAyIEIAFPDQEgBCAPSw0ACyADQf//A3FFDQBBvLcEEOABDwsgA0H//wNxIgMgACgCNCgCKCIEQQRrSwRAQcG3BBDgAQ8LAn8gA0UgBkEDaiADSXJFBEAgAyAGSQRAQc23BBDgAQ8LIAQgAyAHaiIFLQACQQh0IAUtAANyIANqIg5JBEBB0LcEEOABDwsgAyAGayEMIAUtAAEhDSAFLQAAIQUgDiABawwBCyAGIQ4gAgshBAJAIAggD08NACAKLQADIAotAAJBCHRyIA9qIgNBA2ogAUkNACABIANJDQIgDiALayEEIAwgASADa2ohDCALIQELIAktAAciAyAMQf8BcUkEQEHjtwQQ4AEPCyAJIAMgDGs6AAcgDiEGCyABQf//A3EhAyAJLQAGIAktAAVBCHRyIQogACgCNC0AGEEMcQRAIAMgB2pBACAEQf//A3EQmRMaCwJAIAMgCk0EQCADIApJBEBB8bcEEOABDwsgC0H//wNxIAhHBEBB8rcEEOABDwsgByAIaiIDIA06AAEgAyAFOgAAIAkgBjoABiAJIAZBCHY6AAUMAQsgByALQf//A3FqIAFBCHQgAUGA/gNxQQh2cjsAACADIAdqIgMgBDoAAyADIARBCHY6AAIgAyANOgABIAMgBToAAAsgACAAKAIUIAJqNgIUQQAPC0HdtwQQ4AELrAEFAX8BfwF/AX8BfwJAIAIoAgANACABKAIEIQYgASgCOCIHIAAoAjgiAyAALQAJaiIELQAFQQh0IAQtAAZyIgVqIAMgBWogACgCNCIDKAIoIAVrEJcTGiAHQeQAQQAgBkEBRhtqIAQgAC8BEiAALwEYQQF0ahCXExogAUEAOgAAAkAgARCoBiIADQAgARCOCCIADQAgAy0AEUUNASABEJQHIQALIAIgADYCAAsL2wMQAX8BfwF/AX8BfwF/AX8BfwF/AX8BfwF/AX8BfwF/AX8gAygCQCEKIAMoAjQiBSgCACgC4AEiDyADKAI4IgkgAy0ACWoiBy0ABUEIdCAHLQAGciIGQQAgBiAFKAIoIgVNGyIGaiAGIAlqIhAgBSAGaxCXExogAEEoaiEMIAUgCWohCwNAIAQiBUEBaiEEIAwgBUECdGooAgAgAUwNAAsgAEEQaiERIAEgAmohEiALIQYDQCAMIAVBAnQiBGohEyAEIBFqKAIAIQ0CQANAIAAoAgggAUECdGooAgAiBCAAKAIMIAFBAXRqLwEAIg5qIQgCQAJAIAQgEEkgBCALT3JFBEAgCCALTQ0BQdTjBBDgAQ8LIAggDU0gBCANT3INAUHZ4wQQ4AEPCyAPIAQgCWtqIQQLIAogBiAOayIGIAlrIghBCHQgCEGA/gNxQQh2cjsAACAKQQJqIgogBksEQEHf4wQQ4AEPCyAGIAQgDhCYExogAUEBaiIBIBJODQEgEygCACABSg0ACyAFQQFqIQUMAQsLIANBADoADCADIAI7ARggB0EAOwABIAcgAy0AGToAAyADLQAYIQEgB0EAOgAHIAcgCDoABiAHIAhBCHY6AAUgByABOgAEQQALIwEBfyAAKAIMIAFBAXRqLwEAIgJFBEAgACABELwIIQILIAIL9wMNAX8BfwF/AX8BfwF/AX8BfwF/AX8BfwF/AX8jAEHgAGsiBSQAIAEgASACaiICIAEgAkobIQwgACgCOCILIAAoAjQoAigiDWohDiAALQAKIAsgAC0ACWpqQQhqIQ8DQAJAAkACQAJAIAEgDEYEQEEAIQIgBEEAIARBAEobIQgDQCACIAhGDQIgACACQQJ0IgYgBUEwamooAgAiB0H//wNxIAUgBmooAgAgB2tB//8DcRC2CBogAkEBaiECDAALAAsgAygCCCABQQJ0aigCACICIA9JIAIgDk9yDQMgAiALa0H//wNxIgggAygCDCABQQF0ai8BAGohB0EAIQIgBEEAIARBAEobIQoCQANAIAIgCkYNASAHIAJBAnQiBiAFQTBqaiIQKAIARgRAIBAgCDYCAAwFCyACQQFqIQIgBSAGaiIGKAIAIAhHDQALIAYgBzYCAAwDC0EAIQIgBEEKTgRAA38gAiAERgR/QQAFIAAgAkECdCIGIAVBMGpqKAIAIgpB//8DcSAFIAZqKAIAIAprQf//A3EQtggaIAJBAWohAgwBCwshBAsgBSAEQQJ0IgJqIAc2AgAgBUEwaiACaiAINgIAIAcgDUwNAUEAIQkLIAVB4ABqJAAgCQ8LIARBAWohBAsgCUEBaiEJCyABQQFqIQEMAAsAC98CCgF/AX8BfwF/AX8BfwF/AX8BfwF/IwBBEGsiCyQAAn8gBUEASgRAIAQgBWohDyACKAIAIQggACgCOCEKIAZBKGohDANAIAciBUEBaiEHIAwgBUECdGooAgAgBEwNAAsgBkEQaiIQIAVBAnRqKAIAIQkDQCAGKAIMIARBAXRqLwEAIQcCQAJAAkACQCAKLQABRQRAIAotAAJFDQELIAAgByALQQxqEJEIIg0NAQsgCCABayAHSA0BIAggB2siCCENCyAGKAIIIARBAnRqKAIAIg4gCU8gByAOaiAJTXINAUG15AQQ4AEaC0EBDAMLIAMgDSAOIAcQmBMgCmsiB0EIdCAHQYD+A3FBCHZyOwAAIA8gBEEBaiIESgRAIAQgDCAFQQJ0aigCAE4EQCAQIAVBAWoiBUECdGooAgAhCQsgA0ECaiEDDAELCyACIAg2AgALQQALIQQgC0EQaiQAIAQLNQEBfyAAKAIEIgIgACgCCCABQQJ0aigCACACKAJMEQAAIQIgACgCDCABQQF0aiACOwEAIAILsQIGAX8BfwF/AX8BfwF/IAQgBC0AAGohCiACIAItAABqIQsCQAJAAkAgAi0AASIGIAQtAAEiCUYEQCAGQdWWA2otAAAhCEEAIQYDQCAGIAhGDQMgBiAKaiEHIAYgC2ohCSAGQQFqIQYgCS0AACAHLQAAayIHRQ0ACyALLAAAIgYgCi0AAHPAQQBODQEgBkEfdUEBciEIDAMLIAYgCWshByAJQQdLIAZBCE9xDQBBASEIQQFBfyAHIAZBB0sbIgcgCUEHSxsiBkEASgRAQX8gBiALLAAAQQBIGyEHDAELIAosAABBAEgNAgsgByEIIAcNAQtBACEGIAAoAgwoAhwvAQZBAk8EQCAAIAEgAiADIAQgBRDGCCEGCyAGDwtBACAIayAIIAAoAgwoAhwoAhAtAAAbC/wBBgF/AX8BfwF/AX8BfyMAQRBrIgckACACLQAAIQYgBC0AACEIIAcgAiwAASIJQf8BcTYCDCAJQQBIBEAgAkEBaiAHQQxqELwCGgsgBCAIaiEJIAIgBmohCyAHIAQsAAEiCEH/AXEiBjYCCCAIQQBIBEAgBEEBaiAHQQhqELwCGiAHKAIIIQYLIAAoAgwoAhwhCgJ/IAsgCSAHKAIMIgggBiAGIAhKG0ENa0ECbRCcEyIJIAggBmsgCRsiBkUEQEEAIgYgCi8BBkECSQ0BGiAAIAEgAiADIAQgBRDGCAwBC0EAIAZrIAYgCigCEC0AABsLIQYgB0EQaiQAIAYLNQEBfyAAKAIQIQYgASgCAEUEQCAAKAIMKAIcIAUgBCAGEPICIAFBATYCAAsgAyACIAYQ7gcLvwEFAX8BfwF/AX8BfyMAQRBrIgMkACADQQA2AgwgA0EANgIIIANBDGohBAJAA0AgAkEIaiEFAkADQCAAIANBCGogAUEIaiABKAIAIAUgAigCACAAKAIoEQoAQQBKDQEgBCABNgIAIAEiBkEEaiEEIAEoAgQiAQ0ACyAGIAI2AgQMAgsgBCACNgIAIAIoAgQhBSADQQA2AgggAiIHQQRqIQQgBSICDQALIAcgATYCBAsgAygCDCEBIANBEGokACABC4sBAwF/AX8BfyMAQRBrIgIkAAJAQYiiBSgCACIEBEBBihohA0HKASAEEQEADQELQQAhBCACIAAoAgBBACABQZ4gIAJBDGoQpgUiAzYCDCADDQAgAkIANwMAIAEoAgAiAygCACIBBEAgA0ESIAIgASgCKBECABogAigCDCEECyAEIQMLIAJBEGokACADC1kCAX4BfyABQQBBKBCZEyIBIAKsIgQQRyIFNgIEIAVFBEAgAUEHNgIADwsgASAANgIgIAEgAjYCCCABIAMgAyAEgSIEfTcDGCABIASnIgI2AhAgASACNgIMCygBAX8jAEEQayICJAAgACACQQZqIAJBBmogARDvBxDECCACQRBqJAALvQEFAX8BfwF/AX8BfyACIQMDQAJAIANBAEwNACAAKAIADQAgACgCECIEIAAoAgRqIAEgAiADa2ogAyAAKAIIIARrIgQgAyAESBsiBBCXExogACAAKAIQIARqIgU2AhAgACgCCCAFRgRAIAAgACgCICIHIAAoAgwiBiAAKAIEaiAFIAZrIAApAxggBqx8IAcoAgAoAgwRCQA2AgAgAEIANwIMIAAgACkDGCAANAIIfDcDGAsgAyAEayEDDAELCwuDAQQBfwF/AX8BfwJAIAAoAgANACAAKAIEIgNFDQAgACgCECIEIAAoAgwiAkwNACAAIAAoAiAiBSACIANqIAQgAmsgACkDGCACrHwgBSgCACgCDBEJADYCAAsgASAAKQMYIAA0AhB8NwMAIAAoAgQQQCAAKAIAIQEgAEEAQSgQmRMaIAELNwEBfyAAKAIQIQYgASgCAEUEQCAAKAIMKAIcIAUgBCAGEPICIAFBATYCAAsgAyACIAZBARDcBwuGAwkBfwF/AX8BfwF+AX4BfwF/AX8jAEFAaiICJAAgAkIANwMIAkAgACkDACAAKQMIWQRAAkACQCAAKAIwIgEEQCABKAIEIQcgASgCMCACQRhqIAEoAgAoAgwoAgwgASkDCCIGEMIIIAFBMGohCANAAkAgBA0AIAcoAgwgBygCCCgCBEE4bGoiAygCGEUNACACNAIoIAMoAhQiCawiBSACKQMwfHwgBRDhB6x8IAYgATQCEHxVDQAgAkEYaiAFEMMIIAJBGGogAygCICAJEMQIIAEoAgQgAkEUahDlByEEDAELCyACQRhqIAFBOGoQxQghAyABIAgpAwgiBTcDKCABIAgpAwA3AyAgBCADIAQbIQMgASkDCCIGIAVRBEAgAUEBNgIUCyADDQEgASgCFEUNAgtBACEDCyAAEKsHDAILIAEoAgAgACABQSBqIAYQyAgiAw0BCyAAIAJBCGoQyQgiAw0AIAAgAigCCCIBNgIUIAAgASAAQSBqEMoIIQMLIAJBQGskACADC4kCAwF/AX4BfwJAQYiiBSgCACIGBEBBigIhBEHJASAGEQEADQELIAEoAiwEQCABQQA2AiwLIAEgAzcDACABIAIpAwgiBTcDCCABIAIoAgAiAjYCGAJAIAUgACgCDCIEKAIYNAKoAVUNACACKAIAKAIAQQNIDQAgAUEANgIsIAAoAgwhBAsgAyAEKAIMIgCsIgWBIQNBACEEIAEoAiQiAkUEQCAFEEchAiABIAA2AiggASACNgIkQQBBByACGyEECyADUCAEcg0AIAEoAhgiBCACIAOnIgZqIAEpAwgiBSABKQMAIgN9pyAAIAZrIgEgAyABrHwgBVUbIAMgBCgCACgCCBEJACEECyAEC9sBBAF/AX8BfwF+IwBBIGsiBCQAIAApAwAhBQJAAkAgACgCLCICBEAgAiAFp2ogARD6BiECIAAgACkDACACrXw3AwAMAQsCQCAFIAAoAigiAqyBIgVQDQAgAiAFpyIDa0EJSA0AIAAoAiQgA2ogARD6BiECIAAgACkDACACrXw3AwAMAQtBACECA0AgAEEBIARBDGoQyggiAw0CIARBEGogAkEPcXIgBCgCDCwAACIDOgAAIAJBAWohAiADQQBIDQALIARBEGogARD6BhoLQQAhAwsgBEEgaiQAIAMLswMIAX8BfwF+AX8BfwF+AX4BfiMAQRBrIgckACAAKQMAIQUCQAJAIAAoAiwiAwRAIAIgAyAFp2o2AgAgACAFIAGsfDcDAAwBCyAFIAAoAigiA6wiCYEiCFAEQCAAKAIYIgYgACgCJCADIAApAwggBX0iCqcgCSAKUxsgBSAGKAIAKAIIEQkAIgQNAiAAKAIoIQMLIAMgCKciBmsiAyABTgRAIAIgACgCJCAGajYCACAAIAApAwAgAax8NwMADAELAkAgASAAKAIQIgRMBEAgACgCHCEEDAELQoABIASsQgGGIARBwABIGyEIIAGsIQkDQCAIIgVCAYYhCCAFIAlTDQALIAAoAhwgBRBKIgRFBEBBByEEDAMLIAAgBDYCHCAAIAU+AhALIAQgACgCJCAGaiADEJcTGiAAIAApAwAgA6x8NwMAIAEgA2shAwNAIANBAEoEQCAHQQA2AgwgACADIAAoAigiBiADIAZIGyIGIAdBDGoQyggiBA0DIAAoAhwgASADa2ogBygCDCAGEJcTGiADIAZrIQMMAQsLIAIgACgCHDYCAAtBACEECyAHQRBqJAAgBAuJAQIBfwF/An8gACgCDCIDBEAgAyABEMwIIAAoAgBwIgRBA3RqIgNBBGoMAQsgAEEEaiEDIABBCGoLIgAoAgAhACADKAIAIQMgAgRAIAIgBDYCAAsDQAJAQQAhAiADRQRAQbCtByEADAELIAAoAgwgARBsRQ0AIANBAWshAyAAKAIAIQAMAQsLIAALNAIBfwF/A0AgAC0AACICBEAgAEEBaiEAIAEgAkHgggNqLQAAakGx893xeWwhAQwBCwsgAQuRAQIBfwF/AkAgAUUNACABKAIAIgQEfyABKAIEBUEACyEDIAEgAjYCBCABIARBAWo2AgAgA0UNACACIAM2AgAgAiADKAIEIgE2AgQCQCABBEAgASACNgIADAELIAAgAjYCCAsgAyACNgIEDwsgAiAAKAIIIgE2AgAgAQRAIAEgAjYCBAsgAkEANgIEIAAgAjYCCAs3AQF/AkAgAUUNACAAIAJCAXwQ7wIiAEUNACAAIAEgAqciAxCXEyIBIANqQQA6AAAgASEDCyADCywAIAAoAhAgAUEEdGooAgAgAhBsRQRAQQEPCyABBEBBAA8LQfSAASACEGxFC+MCBAF/AX8BfwF+A0ACQCAALQAAIgRFDQBCACEHIAEgBU0NAANAIARBMGtB/wFxQQlLRQRAIAdCCn4gBK1C/wGDfEIwfSEHIAAtAAEhBCAAQQFqIQAMAQsLIAIgBUEBdGogBxCiBDsBACAFQQFqIQUgACAALQAAQSBGaiEADAELCyADIAMvADdBu39xIgY7ADcgAC0AACEFA0AgBUH/AXEEQAJAIANBkcMCIAAQoQMEf0GcwwIgABChA0UEQCADQQIgAEEDahDRCCIEIARBAkwbrRCiBDsBMAwCC0GFwwIgABChAw0BIAZBwAByBSAGQQRyCyIGOwA3CwNAIAAtAABBIHJBIEYEQCAAIQQDQCAEIgBBAWohBCAALQAAIgVBIEYNAAsMAwUgAEEBaiEADAELAAsACwsCQCACLgEAIgBBwwBIDQAgACACIAFBAXRqQQJrLgEASg0AIAMgBkGAAnI7ADcLCy8BAX8jAEEQayIBJAAgAUEANgIMIAAgAUEMahDnAhogASgCDCEAIAFBEGokACAAC44BBQF/AX8BfwF/AX8jAEEgayICJAACQCAAKAIMIAFBAWtNBEAgAiABNgIQIABB4iwgAkEQahDRB0EBIQMMAQtBASEDQQEgAUEHcXQiBCAAKAIIIAFBA3ZqIgUtAAAiBnEEQCACIAE2AgAgAEGPLSACENEHDAELIAUgBCAGcjoAAEEAIQMLIAJBIGokACADC4IBAwF/AX8BfyAAKAJMIgEoAqgCBEAgAEEJNgIYIABBADYCECAAIAAoAhRBAWo2AhQLAkAgASgC9AIiAkUNACAAIAAoAhxBAWoiAzYCHCADIAEoAvwCcA0AIAEoAvgCIAIRAQBFDQAgAEEJNgIYIABBADYCECAAIAAoAhRBAWo2AhQLC20EAX8BfwF/AX8gACAAKAIAQQFqIgI2AgAgACACQQJ0aiABNgIAA0ACQCACQQJJDQAgACACQQF2IgFBAnRqIgMoAgAiBCAAIAJBAnRqIgIoAgAiBU0NACADIAU2AgAgAiAENgIAIAEhAgwBCwsLawIBfwF/IAAoAgAiAkUEQEEADwsgAUECTgRAIAAgAUEBayIDENUIIQIgACgCACIBRQRAIAIPCyABIAI2AgwgACABKAIINgIAIAEgACADENUINgIIIAEPCyAAIAIoAgg2AgAgAkIANwMIIAILpQMGAX8BfwF/AX8BfwF+IAJCADcCACACQQA2AggCfwJAAkAgARBZIglBAkkNACABLQAAIgVB3ABHIAVBL0dxDQBBACEFQQBBuKwHaigCACIHQQAgB0EAShshB0G8rAcoAgAhCAJAA0AgBSAHRg0BIAVBAnQhBiAFQQFqIQUgBiAIaigCACIGKAI0IAEQkBQNAAsgBiAGKAIwQQFqNgIwDAILQQciBSAJQTtqrRBHIgZFDQIaQQAiBUG8rAdqKAIAQbisBygCAEECdEEEaq0QSiIFRQRAIAYQQEEHDwtBACIHQbisB2oiCEG4rAcoAgAiCEEBajYCACAFIAhBAnRqIAY2AgBBvKwHIAU2AgAgBkEAQTgQmRMiBUEDNgIkQYCiBSkDACEKIAUgBUE4aiIHNgI0IAUgCjcDECAHIAEgCUEBahCXExogBUEBNgIwIAVBCDYCHAwBC0I4EEciBkUEQEEHDwsgBkEAQTgQmRMiBUEDNgIkIAVBgKIFKQMANwMQCyACIAY2AgQgBARAIAQgA0GAAXI2AgALIAJBkKkFNgIAQQALIgULCwAgA0EANgIAQQALKgEBfyMAQRBrIgQkACAEIAE2AgAgAiADQdvrACAEEGgaIARBEGokAEEACxMAIAAoAhQiACABIAAoAigRAAALFQAgACgCFCIAIAEgAiAAKAIsEQQACxUAIAAoAhQiACABIAIgACgCMBECAAsTACAAKAIUIgAgASAAKAI0EQUACxUAIAAoAhQiACABIAIgACgCOBECAAsTACAAKAIUIgAgASAAKAI8EQAACxUAIAAoAhQiACABIAIgACgCRBECAAsTACAAKAIUIgAgASAAKAJIEQAAC40DBwF/AX8BfwF/AX8BfwF/IwBBEGsiBSQAQcMAIQMCQAJAAkACQANAIAMiBkHDAGshBwNAAkAgAC0AACIIBEAgAEEBaiEAAkAgCEHgggNqLQAAIAJBCHRyIgJB4t6xkwZHBEAgAkHywqGbBkYEQEHCACEDIAAhBAwGCyACQfTwlaMHRyACQeLesZsGR3ENAUHCACEDDAULAkAgBw4DAAEAAQsgACAEIAAtAABBKEYbIQRBwQAhAwwECyACQezClZMHRyACQeHesbMGR3EgAkHi6r2jBkdxIAZBwwBHcg0BQcUAIQMMAwsgAUUNBkEAIQAgBUEANgIMIANBwgBLDQUgBA0DQQQhAAwFCyACQf///wdxQfTcpQNHDQALCyABDQFBxAAhAwwDCwNAIAQtAAAiAkUNAiACQTprQXZPBEAgBCAFQQxqEOcCGiAFKAIMQQRtIQAMAwUgBEEBaiEEDAELAAsAC0EAIQBBxAAhAwsgAUH+ASAAIABB/gFOG0EBajoABgsgBUEQaiQAIAPAC4kBAwF/AX8BfyAAIAJBAm1BAWqtEO8CIgMEQCACQQFrIQRBACECA0AgAiAETkUEQCADIAJBAXZqIAEgAmoiAC0AASIFQQF0wEEHdkEJcSAFakEPcSAALQAAIgBBAXTAQQd2QQlxIABqQQR0cjoAACACQQJqIQIMAQsLIAMgAkEBdmpBADoAAAsgAwtqAQF/IAAoAmwiBSAAKAJwTgRAIAAgASACIAMgBBDkCA8LIAAgBUEBajYCbCAAKAJoIAVBFGxqIgBBADYCECAAIAQ2AgwgACADNgIIIAAgAjYCBCAAQQA7AQIgACABOgAAIABBADoAASAFCyIBAX9BASEFIAAQkANFBEAgACABIAIgAyAEEOMIIQULIAULvAMFAX8BfwF/AX8BfyMAQZACayIGJAAgBkEAOwGMAiAGQgA3AoQCIAZByAE2AoACIAZBADYC+AEgBiAGQTBqNgL8ASAGQfgBakGSKhBVIAEtAAYhB0EoIQgDQCAJIAEtAAdPRQRAIAYgCDYCACAGQQAiCEGwuwVqIAdBAnRqKAIANgIEIAZB+AFqQaH1AiAGEFcgB0EBaiEHIAlBAWohCUEsIQgMAQsLIAlFBEAgBiABKAIANgIgIAZB+AFqQaj1AiAGQSBqEFdBASEJC0EAIQggAS0ABSIHQSBxBEAgBkH4AWpB9ewBEFVBASEIIAEtAAUhBwsgB0H/AXFBwABPBEAgBkH4AWpBge0BEFUgCEEBaiEICyAGQfgBakHt5QJBARBNIAZB+AFqEGIaAkACQCAAIAZBMGoQsAMiCkUEQEEYED8iB0UEQEEHIQoMAgsgB0EQaiIKQgA3AgAgB0IANwIIIAdCADcCACAHIAE2AhAgByAJOgAVIAcgADYCDCAHIAg6ABRBACEKDAILIAYgABCpATYCECAFQdvrACAGQRBqEGY2AgALQQAhBwsgBCAHNgIAIAZBkAJqJAAgCguuAgYBfwF/AX8BfwF/AX8jAEEQayEEIAFCgICAgICAgPg/NwMoAkAgAC0AFEUNACABKAIEIQIgBEIANwIIIAEoAgAiBUEAIAVBAEobIQYDQCADIAZHBEACQCACKAIAIgUgAC0AFSIHSA0AIAItAARBAkcNACACLQAFRQRAQRMPCyAEQQhqIAUgB2tBAnRqIANBAWo2AgALIAJBDGohAiADQQFqIQMMAQsLIAQoAggiAkUEQCABQv////8HNwMwIAFCgICA/v///+/BADcDKAwBCyABKAIQIgMgAkEDdGpBCGsiAkEBOgAEIAJBATYCACABQhQ3AzAgAUKAgICAgICAmsAANwMoIAQoAgwiAgRAIAJBA3QgA2pBCGsiAkEBOgAEIAJBAjYCAAtBAA8LQQALCAAgABBAQQALNgEBf0EYED8iAkUEQEEHDwsgAkIANwMAIAJCADcDECACQgA3AwggAiAANgIAIAEgAjYCAEEACw0AIAAQ6gggABBAQQALUwIBfwF/IAAoAgQQjgEaIABCADcDCCAAQQA2AgQgAEEQaiEBQQAhAANAIABBAkZFBEAgASAAQQJ0aiICKAIAEEAgAkEANgIAIABBAWohAAwBCwsLggMGAX8BfwF/AX8BfwF/IwBB0ABrIgUkACAAKAIAIQcgABDqCCADQQAgA0EAShshCiAAQRBqIQkgBygCEC0ABUEgcUUhAwJAAkADQCAGIApHBEAgBCAGQQJ0aigCABBeIggEQCAFIAg2AjAgCSADQQJ0akHb6wAgBUEwahBmIgg2AgAgCEUNAwsgA0EBaiEDIAZBAWohBgwBCwsgBygCDCgCfCEGIAVBADsBTCAFQQA2AkggBSAGNgJEIAVBADYCQCAFQgA3AjggBUE4akHs/wIQVSAAKAIUIgYEQCAFIAY2AiAgBUE4akGWwAIgBUEgahBXCyAFQThqIAcoAhAoAgAQVSAJKAIAIgYEQCAFIAY2AhAgBUE4akHV5AEgBUEQahBXCyAFQThqEGIiA0UNACAHKAIMIANBfyAAQQRqQQAQhwEhBiADEEAgBgRAIAUgBygCDBCpATYCACAHQdvrACAFEGY2AggMAgsgABDsCCEGDAELQQchBgsgBUHQAGokACAGCzgBAX8gACAAKQMIQgF8NwMIIAAoAgQQiAFB5ABHBEAgACgCBBCOASEBIABBADYCBCAAEOoICyABCwgAIAAoAgRFC0EBAX8CQCAAKAIALQAVIgMgAkoEQCABIAAoAgQgAhDJAhCpAgwBCyABIAAgAiADa0ECdGooAhBBf0F/EKUCC0EACw4AIAEgACkDCDcDAEEAC3sCAX8BfwJAIAEoAgQiAkUNAANAIAMgAS4BIk5FBEAgACACKAIAEDIgAkEMaiECIANBAWohAwwBCwsgACABKAIEEDggAS0AK0UEQCAAIAEoAjQQsgMLIAAoApAEDQAgAUEAOwEiIAFBADYCBCABLQArDQAgAUEANgI0CwsOACABBEAgACABEPIICwtJAQF/A0AgASgCECECIAAgASgCABCyAyAAIAEoAgQQMyAAIAEoAggQsgMgACABKAIMEDMgACABKAIYEDIgACABEDUgAiIBDQALC6YDBQF/AX8BfwF/AX8gACgCACEFAn8DQEEAIgMgASICRQ0BGiACLQAAIgFBsAFGBEAgAi0AAiEBCwJAAkACQAJAAkACQAJAIAFB/wFxIgFBqAFrDgoCBQEFBQMFBQUEAAsgAUEkRg0CIAFBzgBGDQEgAUHyAEcNBCAAIAUtAFRBACACKAIIEPQIIQIMBQsgAigCLEUNAwtBACACLgEgIgFBAEgNBRogBSAFLQBUIAIoAiwoAgQgAUEMbGoQlARBABCNBCECDAMLIAIoAgwhAQwDCyACKAIUKAIIIQEMAgtBACACKAIEIgRBgARxRQ0CGiACKAIMIgEEQCABLQAFQQJxDQILIAIoAhAiBiEBIARBgCBxDQEgAigCFCIERQ0BIAUtAFcNAUEAIQIgBCgCACIBQQAgAUEAShshAyAEQQhqIQQDQCACIANGBEAgBiEBDAMLIAJBBHQhASACQQFqIQIgASAEaigCACIBLQAFQQJxRQ0ACwwBCwtBACACRQ0AGiACKAIMBEAgAg8LIAJBACAAIAAoAgAtAFQgAiACKAIAEPQIGwsiAwuUAgUBfwF/AX8BfwF/IwBBEGsiByQAIAAoAgAhBAJAAkAgAkUEQCAEIAEgA0EAEI0EIgJFDQELIAIoAgwNAQsCQCAEKAKYAkUNACAEIAMQnwEiAkUNACAEKAKgAiAEIAEgAiAEKAKYAhEIACAEIAIQNQtBACECAkACQCAEIAEgA0EAEI0EIgVFDQAgBSgCDA0BIAUoAgAhCEEAIQEDQCABQQNGDQEgAUGwmQNqIQYgAUEBaiEBIAQgBi0AACAIQQAQjQQiBigCDEUNAAsgBSAGKQIANwIAIAUgBikCCDcCCCAFQQA2AhAMAQsgByADNgIAIABB/egAIAcQsAIgAEGBAjYCDAwBCyAFIQILIAdBEGokACACCycBAX8Cf0GIogUoAgAiAgRAQQBBvAUgAhEBAA0BGgsgACABpxBJCws2AQF/IAAoAggiAUUEQAJAIAAoAnwNACAAKAIALQBQQQhxDQAgAEEBOgAXCyAAEIIDIQELIAELDwAgACABQQBBAEEAEOMICw8AIAAgASACQQBBABDjCAscACAAIAAgASACIAMgBBDjCCIEIAUgBhC8CiAEC0wBAX8gACgCCCEFIAMtABxBgAFxRQRAIAUgBCABIAMoAhQgAiADLgEkEIMDGg8LIAUgBCABIAMQswMiAygCLCACEOMIGiAAIAMQ6AoLFAAgAEH2AEEAIAFBACACQQAQ+QgLXQIBfwF/AkAgACgCCEUNACAAIAEgAhCJCyIEIAJGDQACQCABEMYKIgMEQEHQACEBIAMtAAZBwABxDQEgAy0AAEGwAUYNAQtB0QAhAQsgACgCCCABIAQgAhCOAxoLCw8AIABBCUEAIAFBABDjCAt2AwF/AX8BfwJAIAAoAgAiBigC7AIiB0UNACAGLQCxAQ0AIAAtANgBDQACQCAGKALwAiABIAIgAyAEIAAoAoACIAcRCgAiBUEBRgRAIABBvKwBQQAQsAIgAEEXNgIMDAELIAVBfXFFDQEgABDnCwtBASEFCyAFC1cBAX8gACgCACACEIkJIgIEQAJAIAAQ9ggiAwRAIABBICABQQJ0Qbi9BWooAgAgAkEAEP4IRQ0BCyAAKAIAIAIQNQ8LIANBACABQQBBACACQXoQ+QgaCwvTBwUBfwF/AX8BfwF/IwBBIGsiCSQAAkACQAJAIAAoAgAiBy0AsQFFDQAgBygCrAFBAUcNACAHQf7tAEGR7gAgBy0AsAEiCEEBRhsQnwEhAgwBCyAAIAEgAiAJQRxqEKwJIgFBAEgNAQJAIANFBEAgASEIDAELQQEhCCABQQFGDQAgAigCBEUNACAAQaG0AUEAELACDAILIAcgCSgCHCIBEIkJIQIgAC0A2AFBAkkNACAAIAIgARDECSECCyAAIAEpAgA3AsQBIAJFDQACQCAAIAJB+StBxqMBIAQbIAIQnQkNACAAQRJB/u0AQZHuAEEBIAMgBy0AsAEiCkEBRhsiA0EBRhtBACAHKAIQIAhBBHRqKAIAIgoQ/ggNACAFRQRAIAAgAyAEQQF0akHahgRqLQAAIAJBACAKEP4IDQELAkACQCAALQDYAQ0AIAcoAhAgCEEEdGooAgAhAyAAEIcDDQIgByACIAMQiAMiCgRAIAYNAiAKLQArIQMgCSABNgIUIAlBACIBQfkrQcajASADQQJGG2o2AhAgAEG/PiAJQRBqELACDAMLIAcgAiADEJsIRQ0AIAkgAjYCACAAQa3cACAJELACDAILIAdCwAAQwwIiAUUEQCAAQQc2AgwgACAAKAIoQQFqNgIoDAILIAFB//8DOwEgIAEgAjYCACAHKAIQIAhBBHRqKAIMIQIgAUHIATsBJiABQQE2AhggASACNgI8IAAgATYC9AEgBy0AsQENAiAAEPYIIgFFDQIgAEEBIAgQuQkgBQRAIAFBqgEQ9wgaCyAAIAAoAjAiAkECaiIGNgJoIAAgAkEBaiIDNgJkIAAgAkEDaiICNgIwIAFB4wAgCCACQQIQ4wgaIAEgASgCnAFBASAIdHI2ApwBIAFBECACEPgIIQsgAUHkACAIQQJBBEEBIAcpAyBCAoNQGxDjCBogAUHkACAIQQUgBy0AVBDjCBpBACEKIAEoAmwhByABKAIALQBXBH9BwK0HBSABKAJoIAtBFGxqCyIKIAc2AggCQCAEIAVyBEAgAUHHAEEAIAYQjgMaDAELIAAgAUGTASAIIAZBARDjCDYCjAELIAAQ9ghB8QBBAEEBIAhBBRCDAxogACgCLEUEQCAAQQE2AiwLIAFB/wBBACADEI4DGiABQc0AQQYgAkEAQd6GBEF/EPkIGiABQYABQQAgAiADEOMIGiABKAJsIgBBAEoEQCABKAJoIABBFGxqQRJrQQg7AQALIAFB+gAQ9wgaDAILIAAgCBCzCSAAEL4JCyAAQQE6ABEgByACEDULIAlBIGokAAsrACAAIAAtABhBAWo6ABggACgCACIAQQA7AbQCIAAgACgCsAJBAWo2ArACC5QbEgF/AX8BfwF/AX8BfwF/AX8BfwF/AX8BfwF/AX8BfwF/AX8BfyMAQcABayIKJAACQCACIARyRQ0AIAAoAvQBIgZFDQAgACgCACELAkACQAJAIARFBEAgCyAGKAIAELgJBEAgBiAGKAIcQYAgcjYCHAsgC0GxAWohEiALLQCxAUUNAyALKAKsASEFIAYtACtFDQIgBQ0BIAZBADYCFAwDCyALLQCxAQ0AIAtBsQFqIRIMAgsgAEGBgQNBABCwAgwCCyAGIAU2AhQgBUEBRw0AIAYgBigCHEEBcjYCHAsCQCADQYCABHFFDQAgBiAGKAIcQYCABHI2AhxBACEFA0AgBSAGLgEiTg0BIAYoAgQgBUEMbGoiCC0ABCIHQQ9NBEAgCCgCACEFIAYoAgAhBiAILQAKQQRxBEAgCiAIQQAiB0GBgQNqEJMENgKYASAKIAU2ApQBIAogBjYCkAEgAEGu+AIgCkGQAWoQsAIMBAsgCiAFNgKEASAKIAY2AoABIABB9dMAIApBgAFqELACDAMLIAdB8AFxQRBGBEAgCEHBADoABQsCQCAILQAKQQFxRQ0AIAdBD3EgBSAGLgEgRnINACAIIAdBAnI6AAQgBiAGKAIcQYAQcjYCHAsgBUEBaiEFDAALAAsCQCADQYABcUUNACAGKAIcIgVBCHEEQCAAQbTPAEEAELACDAILIAVBBHFFBEAgCiAGKAIANgJwIABB69sAIApB8ABqELACDAILIAYgBUGABXI2AhwgACgCCCEMIAAoAgAiDy0AsgFBAnFFBEBBACEFA0AgBSAGLgEiTkUEQAJAIAYoAgQgBUEMbGoiCC0ACkEBcUUNACAILQAEIgdBD3ENACAIIAdBAnI6AAQLIAVBAWohBQwBCwsgBiAGKAIcQYAQcjYCHAsgACgCjAEiBQRAQQAhCCAMKAIALQBXBH9BwK0HBSAMKAJoIAVBFGxqCyIFQQI2AgwLAkAgBi4BICIFQQBOBEAgCiAGKAIEIAVBDGxqKAIAIgU2AqQBIAogBRBZNgKoASAPQTwgCkGkAWpBABDVCSEFAkAgACgCACAFEMUJIgUEQCAALQDYAUECTwRAIAAgBSgCCCAGQSBqELQJCyAFIAAtANYBOgAQIAZB//8DOwEgIABBAEEAQQAgBSAGLQAqQQBBAEEAQQBBAhDDCSAAKAIoRQ0BCyAGIAYoAhxB/35xNgIcDAMLIAYQswMhBwwBCyAGELMDIQdBASEFQQEhCANAIAUgBy8BMk9FBEACQCAHIAggByAFEPsJBEAgByAHLwE0QQFrOwE0DAELIAcoAiAiCSAIQQJ0aiAJIAVBAnRqKAIANgIAIAcoAhwiCSAIaiAFIAlqLQAAOgAAIAcoAgQiCSAIQQF0aiAJIAVBAXRqLwEAOwEAIAhBAWohCAsgBUEBaiEFDAELCyAHIAg7ATILIAcgBy8ANyIFQSByOwA3IA8tALIBQQJxRQRAIAcgBUEocjsANwsgByAHLwEyIg47ATQCQCAMRQ0AIAcoAiwiBUUNAEEAIQggDCgCAC0AVwR/QcCtBwUgDCgCaCAFQRRsagsiBUEJOgAACyAHIAYoAhQ2AiwgBkEIaiEFA0ACQAJAIAUoAgAiBUUEQEEAIQUgBi4BIiIIQQAgCEEAShshCEEAIQkDQCAFIAhGDQIgBygCBCAOIAUQ/AlFBEAgCSAGKAIEIAVBDGxqLQAKQSBxRWohCQsgBUEBaiEFDAALAAsgBS8AN0EDcUECRg0BQQAhCEEAIQkDQCAIIA5GRQRAIAUgBS8BMiAHIAgQ+wlBAXMgCWohCSAIQQFqIQgMAQsLIAUvATIhCCAJRQRAIAUgCDsBNAwCCyAPIAUgCCAJahD9CQ0DIAUvATIhCUEAIQgDQCAIIA5GDQIgBSAFLwEyIAcgCBD7CUUEQCAFKAIEIAlBAXRqIAcoAgQgCEEBdGovAQA7AQAgBSgCICAJQQJ0aiAHKAIgIAhBAnRqKAIANgIAIAcoAhwgCGotAAAEQCAFIAUvADdBgAhyOwA3CyAJQQFqIQkLIAhBAWohCAwACwALIA8gByAJIA5qEP0JDQJBACEFA0AgBSAGLgEiTkUEQAJAIAcoAgQiCCAOIAUQ/AkNACAGKAIEIAVBDGxqLQAKQSBxDQAgCCAOQQF0aiAFOwEAQQAhCCAHKAIgIA5BAnRqQaCVAzYCACAOQQFqIQ4LIAVBAWohBQwBCwsgBxD+CQwCCyAFQRRqIQUMAAsACyALIAYoAjwQgAMhDgJAIAYoAhAiBUUNACAAIAZBBEEAIAUQ/wkaIAAoAihFDQAgCyAGKAIQELIDIAZBADYCEAsCQCAGLQAcQeAAcUUEQCAGLgEiIQUMAQtBACEJQQAhCANAIAggBi4BIiIFTkUEQAJAIAhBDGwiByAGKAIEaiIFLQAKQeAAcQRAIAAgBkEIIAYgBRCYCUEAEP8JRQ0BIAAgBiAGKAIEIAdqIAtB+gBBAEEAENUJEIAKDAELIAlBAWohCQsgCEEBaiEIDAELCyAJDQAgAEHg/gBBABCwAgwBCyAGKAIEIQhBACEHA0AgBUEATEUEQCAFQQFrIQUgByAILQAGaiEHIAhBDGohCAwBCwsgBiAHIAYvASBBD3ZqQQJ0rRCiBDsBKCAGQQhqIQUDQCAFKAIAIgUEQCAFEIEKIAVBFGohBQwBCwsCQCASLQAARQRAIAAQ9ggiBUUNAiAFQfoAQQAQ+AgaQQAhCCAGLQArIQ8CQCAEBEAgAC0A2AEEQCAAQQE2AgwgACAAKAIoQQFqNgIoDAULIAAgACgCLCIMQQFqNgIsIAAgACgCMCIDQQNqIhA2AjAgACgCfCIHIAAgBxtBAToAFSAFQfEAIAwgACgCaCAOEOMIGiADQQFqIQkgBSgCbCIHQQBKBEAgBSgCaCAHQRRsakESa0EQOwEACyAFQQsgCUEAIAdBAWoQ4wgaIAAoAigNBCAAIARBwQAQggoiDUUNBCAGIA0vASIiETsBIiAGIBE7ASQgBiANKAIENgIEIA1BADYCBCANQQA7ASIgCyANECsgCkIANwK0ASAKQgA3AqwBIAogCTYCqAEgCkENOgCkASAAIAQgCkGkAWoQ7AkaIAAoAigNBCADQQJqIQ0gBSAJEIMKQQAhAyAFKAJsIQkgBSgCAC0AVwR/QcCtBwUgBSgCaCAHQRRsagsiByAJNgIIIAVBDCAKKAKoARD4CCEHIAVB4QAgCigCsAEgCigCtAEgDRDjCBogBSAGQQAQhAogBUH/ACAMIBAQjgMaIAVBgAEgDCANIBAQ4wgaIAUgBxD9CBpBACENIAUoAmwhCSAFKAIALQBXBH9BwK0HBSAFKAJoIAdBFGxqCyIHIAk2AgggBUH6ACAMEPgIGiAGLgEiIg1BACANQQBKGyEMIAYoAgQhCUEAIQcDQCAHIAxGRQRAIAdBAWohByAJKAIAEIUKIANqQQVqIQMgCUEMaiEJDAELC0EAIQcgBigCABCFCiADaiIJIA1BBmxqQSNqIhOsEEciDUUEQCALEJQBDAILQe3lAkHs5QIgCUEySCIJGyEVQYPDAkHfgAMgCRshFiAKIBMgDUEAQYH/AmpBABBoIgMQWTYCpAEgAyAKQaQBaiAGKAIAEIYKIAMgCigCpAEiDGpBKDoAAEGBgQNB4IADIAkbIRQgDEEBaiEHIAYoAgQhCUEAIQwDQCADIAdqIRAgEyAHayERIAwgBi4BIk5FBEAgCiARIBAgFEEAEGgQWSAHajYCpAEgAyAKQaQBaiAJKAIAEIYKIAMgCigCpAEiEGogCSwABUECdEHsvAVqKAIAIgcgBxBZIhEQlxMaIAogECARaiIHNgKkASAJQQxqIQkgDEEBaiEMIBYhFAwBCwsgCiAVNgJgIBEgEEHb6wAgCkHgAGoQaBoMAQtBgs0BQeOLAiAPGyEJIABBzAFqIAIgAxsiDSgCACIDIAAoAsQBIgxrIQcgAy0AAEE7RwRAIA0oAgQgB2ohBwsgCiAMNgJYIAogBzYCVCAKIAk2AlAgC0H70QAgCkHQAGoQgQMhDQsgCygCECAOQQR0aigCACEJIAYoAgAhByAAKAJoIQMgCiAAKAJkNgJIIAogDTYCRCAKQUBrIAM2AgAgCiAHNgI8IAogBzYCOCAKQfkrQcajASAPGzYCNCAKIAk2AjAgAEGOuQEgCkEwahCSCSALIA0QMiAAIA4QugkCQCAGLQAcQQhxRQ0AIAAtANgBDQAgCygCECAOQQR0aiIIKAIMKAJIDQAgCiAIKAIANgIgIABBwsoCIApBIGoQkgkLIAogBigCADYCECAFIA4gC0Hh6AIgCkEQahCBA0EAELsJIAYtABxB4ABxBEAgCygCECAOQQR0aigCACEIIAogBigCADYCBCAKIAg2AgAgBUGUAUEBQQBBACALQYHyAiAKEIEDQXoQ+QgaCyASLQAARQ0BCyAGKAI8QQhqIAYoAgAgBhDtAwRAIAsQlAEMAgsgAEEANgL0ASALIAsoAhhBAXI2AhhBACEFIAYoAgBB3acBEJAUDQAgBigCPCAGNgJICyAEDQAgBi0AKw0AIAYgASACIAEoAgAbKAIAIAAoAsQBa0ENajYCLAsgCkHAAWokAAt+BQF/AX8BfwF/AX8CQCAAKAIEIgJBAkkNACAAKAIAIgMtAABB4IUDaiwAAEEATg0AIAJBAWshBEEBIQEDQCABIARHBEAgASADaiEFIAFBAWohASAFLQAAQeCFA2osAABBAE4NAQwCCwsgACADQQFqNgIAIAAgAkECazYCBAsLywEDAX8BfwF/AkAgACgCACACKAIEIgRBNWqtEO8CIgNFDQAgA0GAgIAENgIEIAMgAToAACADQQA2AiggA0IANwIMIANCADcCLCADQQA2AhQgA0EAOwEgIANBADYCHCADQQA7AAEgAyADQTRqIgE2AgggASACKAIAIgUgBBCXEyAEakEAOgAAIAMgBSAAKALwAWs2AiQgAy0ANEHghQNqLAAAQQBIBEAgAxCKCgsgA0EBNgIYIAAtANgBQQJJDQAgACADIAIQxAkaCyADC78BAQF/AkACQCACQdYARiAEQdkARnENAAJAIAJB1wBHDQAgBEHWAGsOBAEAAAEACyAAKAIAQuQAEMMCIgdFDQEgByAEOgASIAcgAjoAESAHIAFB2gAgARs6ABAgBkUEQCAAKAIAKAJQQR50QR91QcMAcSEGCyAHIAFFOgATIAcgBjoAFCAHIAAgBRCrCzYCHCAHIAAgAxCrCzYCGCAHDwsgAEG4/ABBABCwAgsgACgCACAFEDMgACgCACADEDNBAAtNAAJAIAEEQCABIAM2AgwgASACNgIIIARFDQEgASAAKAIAIAQoAgAgBDUCBBDOCDYCBCABDwsgACgCACACELIDIAAoAgAgAxCyAwsgAQvNAQMBfwF/AX8jAEEQayIDJAACQCABKAIEIgRFDQAgACgCACEFIAAgAiAEEKoLIgJFDQBBACEEAkACf0GDlwEgASgCCA0AGgJAIAIoAgxFDQAgASgCDEUNAEG4lgEMAQsgAi0AEw0BQcT8AAshAiADIAEoAgQ2AgQgAyACNgIAIABBs98AIAMQsAIMAQsgASAFIAIoAghBABCVCTYCCCACKAIMIgAEQCABIAUgAEEAEJUJNgIMCyAFIAEoAgQQMiABQQA2AgQLIANBEGokAAuFAgYBfwF/AX8BfwF/AX8jAEEQayIFJAAgAgRAIAAoAgAhBAJ/AkACQAJAIAFFDQAgAigCACIGRQ0AIAFBDGohCANAIAMgASgCACIHTg0CIAYgCCADQRhsaigCABBsRQRAIAUgBjYCACAAQfTlACAFELACCyADQQFqIQMMAAsACyABRQ0BIAEoAgAhBwsgBCABIAdBGGxBJGqtEGAMAQsgBEIkEMMCCyEDAkAgBC0AVwRAIAQgAhCtCAwBCyADIAMoAgAiAUEBajYCACADIAFBGGxqIgEgAikCEDcCHCABIAIpAgg3AhQgASACKQIANwIMIAMhAQsgBCACEDULIAVBEGokACABCyEAIAFFBEBBAA8LIAAgASgCACABNQIEEM4IIgEQ+gkgAQtBAQF/AkAgAUUNACACBEAgAEE2IAEQlgoiAUUNAQsgACgCKEUEQCABIAAoApACNgIIIAAgATYCkAILIAEhAwsgAws2AgF/AX8CQCAAKAKEAiIBRQ0AIAAoAvQBIgJFDQAgACACIAAoAgAgASAANAKIAhDOCBCMAwsLyQQJAX8BfwF/AX8BfwF/AX8BfwF/IwBBQGoiAiQAAkAgACgC9AEiA0UNACAAKAIAIQQgABCLCSAAQQA2AoQCIAMoAixBAEwNACAELQCxAUUEQCAAKAJ8IgUgACAFG0EBOgAVIAEEQCAAIAEoAgQgASgCACAAKALEAWtqNgLIAQsgAiAAQcQBajYCMCAEQQBBgNgBaiACQTBqEIEDIQUgBCgCECAEIAMoAjwQgAMiB0EEdGooAgAhBiADKAIAIQEgAiAAKAJkNgIgIAIgBTYCHCACIAE2AhggAiABNgIUIAIgBjYCECAAQfC5ASACQRBqEJIJIAAQ9gghASAAIAcQugkgAUGmARD3CBogAygCACEGIAIgBTYCBCACIAY2AgAgASAHIARBmeQBIAIQgQNBABC7CSAEIAUQMiAAIAAoAjBBAWoiBDYCMCABIAQgAygCABD7CBogAUGrASAHIAQQjgMaDAELIAMoAgAhByADKAI8IQkCQCAEQYQDaiADKAIwKAIAEIkDIgZFDQAgBigCACIBRQ0AIAEoAgBBA0gNACABKAJcRQ0AIAMoAgAQWSEKIAMoAjxBEGohAQNAIAEoAgAiAUUNASABKAIIIgUtACsNACAFLQAdQRBxDQAgBSgCACIIIAMoAgAgChBtDQAgCCAKaiIILQAAQd8ARw0AIAhBAWogBigCACgCXBEBAEUNACAFIAUoAhxBgCByNgIcDAALAAsgCUEIaiAHIAMQ7QMEQCAEEJQBDAELIABBADYC9AELIAJBQGskAAtEAQF/An8gAi0AD0EBcQRAIAAoAgAiAygCECADIAIoAiwQgANBBHRqDAELIAJBLGoLIQMgACABIAIoAgAgAygCABD/AgtuAwF/AX8BfyMAQRBrIgIkAAJAAkAgASgCACIEQbDBAUEHEG1FDQAgASgCHCIDQYCAAnENAEEAIQEgA0GAIHFFDQEgACgCABCyCUUNAQsgAiAENgIAIABB6rABIAIQsAJBASEBCyACQRBqJAAgAQtxAwF/AX8BfyMAQRBrIgMkAEEAQZ2gAWpB+StBACABLQArIgRBAkYbIARBAUYbIgQEQCADIAEoAgA2AgggAyAENgIEIANBACIBQceCAUH+jQEgAhtqNgIAIABBrvUCIAMQsAJBASEFCyADQRBqJAAgBQtyAQF/IwBBMGsiBSQAIABBAToAECAFIAQ2AiAgBSADNgIcIAUgAjYCGCAFIAE2AhQgBSABNgIQIABB/vsCIAVBEGoQkgkgAkUEQCAFIAQ2AgggBSADNgIEIAUgATYCACAAQa39AiAFEJIJCyAFQTBqJAALPgEBfyMAQRBrIgMkACADIAE2AgQgAyABNgIAIABBue8CIAMQkgkgAkUEQCAAQczwAkEAEJIJCyADQRBqJAAL1AEEAX8BfwF/AX8jAEHQAGsiBCQAAkAgACgCKA0AIAAtANgBDQAgACgCACIDKAIYIQUgBCACNgJMIAMgASACELIBIgJFBEAgAy0AV0UEQCAAQRI2AgwLIAAgACgCKEEBajYCKAwBCyAAIAAtABJBAWo6ABIgBCAAQcwBaiIBQcwAEJcTIQYgAUEAQcwAEJkTIQEgAyADKAIYQQJyNgIYIAAgAhCxAxogAyAFNgIYIAMgAhA1IAEgBkHMABCXExogACAALQASQQFrOgASCyAEQdAAaiQACzcAAkAgACgCCEUNACAAIAEQugkgACgCCCABQQAgAhC7CSABQQFGDQAgACgCCEEBQQAgAhC7CQsLOgIBfwF/AkAgAEUNAANAIAAtAAAiAkUNASAAQQFqIQAgAkHgggNqLQAAIAFqIQEMAAsACyABQf8BcQuiAgkBfwF/AX8BfwF/AX8BfwF/AX8CQCABRQ0AIAAgACABEFSsEO8CIgZFDQAgBiABKAIAIgM2AgAgBiABKAIENgIEIAFBCGohBSAGQQhqIQQDfyADIAhMBH8gBgUgBCAAIAUoAgAiAyACEKgJIgc2AgACQCADRQ0AIAdFIAMtAABBsgFHcg0AAkAgBygCECILBEAgAygCECEJIAshCgwBCyADKAIMIgMgCUYNACAHIAAgAyACEKgJIgo2AhAgAyEJCyAHIAo2AgwLIAQgACAFKAIEEJ8BNgIEIAQgBSgCCCIDNgIIIAQgA0EIdkH7/wNxOwAJIAQgBSgCDDYCDCAFQRBqIQUgBEEQaiEEIAhBAWohCCABKAIAIQMMAQsLIQQLIAQLZAMBfwF/AX8gARCUCSEEIAAuASIiA0EAIANBAEobIQMgACgCBCEAA0ACQCACIANGBEBBfyECDAELIAQgAC0AB0YEQCAAKAIAIAEQbEUNAQsgAkEBaiECIABBDGohAAwBCwsgAguaAgMBfwF/AX8jAEEQayIHJAACQAJAIANBAE4EQCADIAEuASBHDQELIABBhwEgAiAEEI4DGgwBCyADIQYCf0GwASIFIAEtACtBAUYNABogASgCBCADQQxsaiIFLwEKIgZBIHEEQCAAKAIMIQMgBkGAAnEEQCAHIAUoAgA2AgAgA0HA9QIgBxCwAgwDCyADKAI4IQAgBSAGQYACcjsBCiADIAJBAWo2AjggAyABIAUgBBCuCyADIAA2AjggBSAFLwEKQf/9A3E7AQoMAgsgAS0AHEGAAXEEQCABELMDIAPBEOkCIQZB3gAMAQsgASADwRD2CiEGQd4ACyEFIAAgBSACIAYgBBDjCBogACABIAMgBBCfCwsgB0EQaiQACz4BAX8CQCABLwEIIgFFDQAgAC0AKw0AIAAoAjQiAEUNACAAKAIAIAFIDQAgAUEEdCAAakEIaygCACECCyACCzQBAX8jAEEQayIEJAAgBCACNgIIIAQgATYCBCAEIAM2AgAgAEH08gIgBBCSCSAEQRBqJAALPQEBfyAALQATIgFFBEAgACAAKAIwQQFqIgE2AjAgAQ8LIAAgAUEBayIBOgATIAAgAUH/AXFBAnRqKAKgAQswAQF/AkAgAUUNACAALQATIgJBB0sNACAAIAJBAWo6ABMgACACQQJ0aiABNgKgAQsLdQMBfwF/AX8CQCABLQArQQFHDQAgAiABKAIAIgQgBBBZIgUQbQ0AIAIgBWoiAi0AAEHfAEcNACAAQYQDaiABKAIwKAIAEIkDIgFFDQAgASgCACIBKAIAQQNIDQAgASgCXCIBRQ0AIAJBAWogAREBACEDCyADC80BAwF/AX8BfyMAQRBrIgUkAAJAIAAoAgAiBCkDIEKBgICAAYNCAVENACAELQCyAUECcQ0AQZGgBS0AAEUNAAJAIAQtALEBBEACQCACIAQoArQBIgQoAgAQaw0AIAEgBCgCBBBrDQAgAyAEKAIIEGtFDQMLIABBgYEDQQAQsAIMAQsCQCAALQASRQRAIAFBsMEBQQcQbUUNAQsgBBCyCUUNAiAEIAEQuAlFDQILIAUgATYCACAAQZHkACAFELACC0EBIQYLIAVBEGokACAGCyQAAn8gAS0AK0EBRwRAQQAgAS4BIkEASg0BGgsgACABEIgMCwtSAwF/AX8BfwNAAkAgAEF/Rg0AIAAtAAAiA0UNACAAQQFqIgIhACADQcABTwRAA0AgAiIAQQFqIQIgACwAAEFASA0ACwsgAUEBaiEBDAELCyABC5UCAwF/AX8BfyMAQRBrIgUkACAAKAIAIQMCQCAAEIcDDQACQCABRQRAQQAhAQNAIAEgAygCFE4NAiABQQFHBEAgACABEKYLCyABQQFqIQEMAAsACwJAIAIoAgQNACADIAEQpwsiBEEASA0AIAAgBBCmCwwBC0EAIQQgACABIAIgBUEMahCsCSIBQQBIDQAgAigCBARAIAMoAhAgAUEEdGooAgAhBAsgAyAFKAIMEIkJIgFFDQACQCADIAEgBBCbCCICBEAgACACKAIMIAIQqAsMAQsgAEEAIAEgBBD/AiICRQ0AIAAgAkEAEKgLCyADIAEQNQsgAy0AYA0AIAAQ9ggiAUUNACABQaYBEPcIGgsgBUEQaiQAC5gCAwF/AX8BfyMAQRBrIgUkACAAKAIAIQMCQCAAEIcDDQAgAUUEQCAAQQAQpAsMAQsCQCACBEAgAigCAA0BCyAAKAIAIAEQiQkiBEUNASADIAMtAFQgBEEAEI0EBEAgACAEEKQLIAMgBBA1DAILIAMgBBA1CyAAIAEgAiAFQQxqEKwJIgRBAEgNACADIAUoAgwQiQkiAUUNACADIAEgAigCBAR/IAMoAhAgBEEEdGooAgAFQQALIgIQiAMiBARAIAAgBEEAEKULIAMgARA1DAELIAMgASACEJsIIQIgAyABEDUgAgRAIABBACADIAIoAgwoAjwQgAMQuQkgACACQX8QkAoMAQsgAEHhrAFBABCwAgsgBUEQaiQAC5ICBAF/AX8BfwF/IwBBMGsiByQAIAAoAgAhCQJAIAAQhwMNACAAKAIoDQAgB0IANwIoIAdCADcCICAHQgA3AhggB0IANwIQIAcgADYCDCAHQQxqIAQQkg0NACAHQQxqIAUQkg0NACAHQQxqIAYQkg0NACADBEAgAy0AAEH2AEYEQCADKAIIIQgLIAAgASAIQQBBABD+CA0BCyAAEPYIIQggACAEIABBBBDDCiIDEPwIIAAgBSADQQFqEPwIIAAgBiADQQJqEPwIIAhFDQAgAEEAIANBA2oiAyACLgEAIgprIAMgCiACQQAQugsgCEGmASABQRhGEPgIGgsgCSAEEDMgCSAFEDMgCSAGEDMgB0EwaiQAC1QDAX8BfwF/IAAoAgAhAwNAIAIgAygCFE5FBEACQCADKAIQIAJBBHRqIgQoAgRFDQAgAQRAIAEgBCgCABBsDQELIAAgAhCzCQsgAkEBaiECDAELCwvSAQUBfwF/AX8BfwF/IwBBEGsiBCQAIAAoAgAiBSABKAIUEIADIQICQCABENQHIgMEQCAAQQ5BECACQQFGIgYbIAEoAgAgAygCACAFKAIQIAJBBHRqKAIAIgMQ/ggNASAAQQlB/u0AQZHuACAGG0EAIAMQ/ggNAQsgABD2CCIDRQ0AIAUoAhAgAkEEdGooAgAhBSAEIAEoAgA2AgQgBCAFNgIAIABB4OcCIAQQkgkgACACELoJIANBmQEgAkEAQQAgASgCAEEAEPkIGgsgBEEQaiQAC1wBAX8gACgCAEI0EO8CIgQEQCAEQQBBNBCZEyIEQf//AzsBIiAEIAE6AAAgACgCACAEIAIgAxDWCSAAIAQoAhgQiQoaIAQPCyAAKAIAIAIQMyAAKAIAIAMQMyAEC04BAX8CQCAAIAEgAhDnCSIDRQ0AQQAhAgNAIAIgA2oiAC0AACIBRQ0BIAFB4IUDai0AAEEBcQRAIABBIDoAAAsgAkEBaiECDAALAAsgAwt8AwF/AX8BfwJAIAAoAigNACAAKAIAIgcgAigCBEExaq0QwwIiBUUNACAFQTBqIAIoAgAgAigCBBCXEyIGEPoJIAUgAToAACAFIAY2AgwgBSAHIAMgBBCmCTYCJCAALQDYAUECTwRAIAAgBSgCDCACEMQJGgsgBSEGCyAGCxYAIAFFBEBBAA8LIAAgASACQQAQzAsLmwQHAX8BfwF/AX8BfwF/AX8jAEEgayIFJAAgBUEANgIAIAUhBwNAAkACQCABRQ0AIABCzAAQ7wIiA0UNACADIAAgASgCHCACEJUJNgIcIAMgACABKAIgIAIQqwk2AiAgAyAAIAEoAiQgAhCoCTYCJCADIAAgASgCKCACEJUJNgIoIAMgACABKAIsIAIQqAk2AiwgAyAAIAEoAjAgAhCVCTYCMCABLQAAIQYgAyAENgI4IAMgBjoAACADQQA2AjQgACABKAI8IAIQqAkhBCADQgA3AgggAyAENgI8IAEoAgQhBCADQn83AhQgAyAEQV9xNgIEIAMgAS8BAjsBAiAAIAEoAkAQ3gshBCADQQA2AkQgAyAENgJAIAEoAkghBCAFQQA2AgQgA0E0aiEJIAVBBGohCANAAkAgBEUNACAIIABBACAEEN8LIgY2AgAgBkUNACAGQSRqIQggBCgCJCEEDAELCyADIAUoAgQ2AkggAC0AVyEEAkAgASgCRARAIARB/wFxBEAgAyABKAIQNgIQDAILIAVBADYCECAFIAM2AhwgBUEANgIEIAVBASIEQTZqNgIMIAVBODYCCCAFQQRqIAMQtQkaIAAtAFchBAsgAyABKAIQNgIQIARB/wFxRQ0CCyADQQA2AjggACADEKUICyAFKAIAIQQgBUEgaiQAIAQPCyAHIAM2AgAgASgCNCEBIAkhByADIQQMAAsAC6IBBQF/AX8BfwF/AX8jAEEQayIDJAACQCABRQRADAELIAEoAgAiAkEAIAJBAEobIQUgAUEQaiEGQQAhAQNAIAEgBUYNASABQQR0IQIgAUEBaiEBIAIgBmoiAi0AAUEgcUUNAAsgA0H+zQFBACIBQfjNAWoiBSACLQAAIgJBA0cbQfjNASACGzYCACAAQc7dACADELACQQEhBAsgA0EQaiQAIAQLhwQJAX8BfwF/AX8BfwF/AX8BfwF+AkAgAUUEQAwBCyAAQTggASgCACIFQTBsQQhyIAVBAEwbrBDvAiIGRQ0AIAYgASgCACIENgIAIAYgBDYCBCABQQhqIQkgBkEIaiEKA0AgBCAHTARAIAYPCyAKIAdBMGwiBWoiBCAFIAlqIgUoAgw2AgwCQCAFLQANQQRxBEAgAEIQEFwiAwRAIAMgBSgCLCIIKQIAIgs3AgAgAyAIKQIINwIIIAMgACALpyACEKkJIgg2AgAgCA0CIAAgAxA1CyAEIAQvAA1B+/8DcTsADUEAIQMMAQsgBSgCLCEDIAUtAA9BAXENACAAIAMQnwEhAwsgBCADNgIsIAQgACAFKAIAEJ8BNgIAIAQgACAFKAIEEJ8BNgIEIAQgBSgCEDYCEAJAIAQvAA0iA0ECcQRAIAQgACAFKAIgEJ8BNgIgDAELIANBCHEEQCAEIAAgBSgCICACEJUJNgIgDAELIAQgBSgCIDYCIAsgBCAFKAIkIgM2AiQgBC0ADkECcQRAIAMgAygCAEEBajYCAAsgBCAFKAIIIgM2AgggAwRAIAMgAygCGEEBajYCGAsgBSgCKCEDIAQCfyAFLQAOQQhxBEAgACADEOILDAELIAAgAyACEKgJCyIDNgIoIAQgBSkDGDcDGCAHQQFqIQcgASgCACEEDAALAAtBAAuAAQIBfwF/IwBBEGsiBCQAIAAoAgAhBQJAIAIoAgQEQCAFLQCxAQRAIABBwJgBQQAQsAJBfyECDAILIAMgAjYCACAFIAEQpwsiAkEATg0BIAQgATYCACAAQa3XASAEELACQX8hAgwBCyAFLQCwASECIAMgATYCAAsgBEEQaiQAIAILcwQBfwF/AX8BfyAAQQAgAUEIaiIEEI0JIQIgASgCECIFBEAgACgCACAFECsLIAEgAjYCECABIAEvABVBgAhyOwAVIAIEQCACIAIoAhhBAWo2AhggAS0AFUECcUUEQCACDwtBACACIAAgBBCHDBshAwsgAwt/AwF/AX8BfyMAQRBrIgIkACAAKAIYIgMtACRFBEAgASABKAIEQYCAgIAEcjYCBAtBACEAAkAgAS0AAEGdAUcNACADKAIAIgQoAgAtALEBBEAgAUH6ADoAAAwBCyACIAMoAiw2AgAgBEHmzwAgAhCwAkECIQALIAJBEGokACAAC50DDQF/AX8BfwF/AX8BfwF/AX8BfwF/AX8BfwF+IwBBEGsiByQAIAAoAhgiBCgCACgCACIIIAQoAigQhgEhCwJAIAEoAiAiCUUEQEEAIQQMAQsgBEEEaiEMIAlBCGoiDSECAkADQCAJKAIAIANKBEACQCAELQAkDQAgAi8ADSIFQQRxDQACQCACLQAPIgpBAXENACACKAIsIgZFDQAgCCAGEIYBIAtHBEAgBCgCACEDIAQpAiwhDiAHIAY2AgggByAONwMAIANBvNkAIAcQsAIMBQsgCCAGEDIgAiACLwANQYAIciIFOwANIAIgAi0AD0ECciIKOgAPCyAEKAIgIQYgAiAKQQFyOgAPIAIgBUGAAnI7AA0gAiAGNgIsCyANIANBMGxqIgUtAA5BCHFFBEAgDCAFKAIoELYJDQMLIAJBMGohAiADQQFqIQMMAQsLQQAhBCABKAJARQ0BQQAhAwNAIAMgASgCQCICKAIATg0CIANBGGwhBSADQQFqIQMgACACIAVqKAIUELUJRQ0ACwtBAiEECyAHQRBqJAAgBAsDAAELRAEBfyMAQdAAayICJAAgAQR/IAJBBGpBAEHMABCZExogAiABNgIkIABBBGogAkEEahC1CQVBAAshASACQdAAaiQAIAELQgEBfwJAAkAgAC0AI0EQcUUNACAAKAKUAw0AIAAoAsQBDQBBASEBIAAoAoADQQBMDQEgACgCmAMNAQtBACEBCyABCxUBAX8gACgCfCICIAAgAhsgARDdCws2ACAAQZQCaiEAA0ACQCAAKAIAIgAEQCAAKAIAIAJHDQEgACABNgIACw8LIABBDGohAAwACwAL3wIEAX8BfwF/AX8CQCABRQ0AIAAoAghFDQADQCAAIAEgACgCCBEAACICBEAgAkECcQ8LQQIhBSAAIAEoAhwQtwkNASAAIAEoAiQQtgkNASAAIAEoAigQtwkNASAAIAEoAiwQtgkNASAAIAEoAjAQtwkNASAAIAEoAjwQtgkNAQJAIAEoAkgiAkUNAEEBIQMCQCAAKAIMIgRBDkYNACAAKAIAIgMEQCAEQTlGDQEgAy0A2AFBAUsNAQwCCyAEQTlHDQELIAAgAkEAENELDQILAkAgASgCICIDRQ0AIANBCGohAiADKAIAIQMDQCADQQBMDQEgAi8ADSIEQQRxBEAgACACKAIsKAIAELUJDQQgAi8ADSEECyAEQQhxBEAgACACKAIgELcJDQQLIAJBMGohAiADQQFrIQMMAAsACyAAKAIMIgIEQCAAIAEgAhEFAAtBACEFIAEoAjQiAQ0ACwsgBQsSACABRQRAQQAPCyAAIAEQwwsLSgIBfwF/AkAgAUUNACABQQhqIQIgASgCACEBA38gAUEATA0BIAAgAigCABC2CQR/QQIFIAJBEGohAiABQQFrIQEMAQsLIQMLIAMLUgMBfwF/AX8gAUHfABCYFCIDRQRAQQAPCyADQQA6AAAgACABQQAQiAMhAiADQd8AOgAAAkAgAkUNACACLQArQQFHDQAgACACIAEQnAkhBAsgBAs0AQF/IAAoAnwiAyAAIAMbIgAgAhDdCyAAIAAoAlxBASACdHI2AlwgACAALQAUIAFyOgAUCykAIAAoAghB5AAgAUEBIAAoAgAoAhAgAUEEdGooAgwoAgBBAWoQ4wgaC4gBAQF/IABBlQEgAUEAQQAgAkF6EPkIGiAAKAJsIgJBAEoEQCAAKAJoIAJBFGxqQRJrIAM7AQALIAAoAgAoAhQiAkEAIAJBAEobIQIDQCACIARGRQRAIAAgACgCnAFBASAEdHI2ApwBIARBAWohBAwBCwsgACgCDCIEKAJ8IgAgBCAAG0EBOgAVC+NaKwF/AX8BfwF/AX8BfwF/AX8BfwF+AX8BfwF/AX8BfwF/AX8BfwF/AX8BfwF/AX4BfwF/AX8BfwF/AX8BfwF/AX8BfwF/AX8BfwF/AX8BfwF/AX8BfwF/IwBB4ANrIgYkACAAKAIAIQcCQCAAEPYIIgVFDQAgBUGmAUEBQQEQjgMaIABBAjYCMCAAIAEgAiAGQdwDahCsCSIBQQBIDQAgBygCECEIIAFBAUYEQCAAELcBDQELIAcgBigC3AMQiQkiGkUNACABQQR0IgogCGohCAJAIABBEyAaAn8gBARAIAYgAzYCoAMgB0GH1wEgBkGgA2oQgQMMAQsgByADEIkJCyIJIAIoAgQEfyAIKAIABUEACyIEEP4IDQAgBkEANgLMAyAGIAk2AsgDIAYgGjYCxAMgBkEANgLAAyAHQQA2AsgDIAcgBEEOIAZBwANqEI8BIgpBDEcEQCAKRQRAIAVBARCOCyAFQQBBACAGKALAA0F/EI8LIAUgBigCwAMQkAsgBigCwAMQQAwCCyAGKALAAyICBEAgBiACNgIAIABB2+sAIAYQsAIgBigCwAMQQAsgACAKNgIMIAAgACgCKEEBajYCKAwBCyAaEIoDIgpFDQAgCi0ABSILQQFxBEAgABCHAw0BIAotAAUhCwsgC0ECcSALQQRxQQAgCRtyRQRAIAUgChCRCwtBfyEMQQAhCwJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQCAKLQAEQQFrDisRGwYOFQgJHiQaFSUVFR8gIxMHJyYdBAUVAwIKIhYAIQEXFA0PKAsMEhgZFQsgCCgCBCECIAlFBEAgBSACBH4gAigCBDQCJAVCAAsiDhCSCwwqCyAHIAkQ0QgiBTYCZCACIAVBAEEAELsBQQdHDSkgBxCUAQwpCyAIKAIEIQECQCAJRQ0AIAlB1DEQbEUEQEECIQwMAQsgCUEAEKYEIQwLAkAgAigCBA0AQQAhAiAMQQBIDQADQCACIAcoAhRODQEgBygCECACQQR0aigCBCAMEJMLGiACQQFqIQIMAAsACyAFIAEgDBCTC60QkgsMKAsgBkIANwO4AyAAIAEQswkgACAAKAIwQQFqIgI2AjACQCAaLQAAQd8BcUHQAEYEQCAFQbIBIAEgAhCOAxoMAQtBACEAAkAgCUUNACAJIAZBuANqEKkEDQAgBikDuAMiDkIAUw0AQv7///8PIA4gDkL+////D1obpyEACyAFQbMBIAEgAiAAEOMIGgsgBUHUACACQQEQjgMaDCcLIAVBgpMBQbyGAQJ/AkACQAJAIAlFDQAgCUGCkwEQbAR/IAlBvIYBEGwNAUEABUEBCyEBIAIoAgQNAkECIQIDQCACIAcoAhRODQIgBygCECACQQR0aigCBCgCBCgCACABEJQLGiACQQFqIQIMAAsAC0F/IQEgAigCBA0BIActAFkMAgsgByABOgBZCyAIKAIEKAIEKAIAIAEQlAsLIgJBAUYbEJALDCYLAkACQCAJRQ0AQQAhAyAJEFkhAANAIANBBkYNASAJIANBAnRB8LEFaigCACAAEG0EQCADQQFqIQMMAQsLIANBAkcNASAHLQAjQRBxDQBBAiEDDAELQX8hAyACKAIEDQAgAkEBNgIEQQAhAQsgBygCFCEAA0AgAEEASgRAIAcoAhAgAEEBayIAQQR0aigCBEUNASAAIAFHBEAgAigCBA0CCyAFIAUoApwBQQEgAHRyNgKcASAFQQQgAEEBIAMQ4wgaDAELCyAFQdQAQQFBARCOAxoMJQsgCCgCBCgCBCgCACECIAZCfjcDuAMgCUUNCiAJIAZBuANqEKkEGiACQn8gBikDuAMiDiAOQgBTGyIONwOwASACKALoASICRQ0jIAIgDjcDEAwjCyAIKAIEIQAgCUUEQCAFIAAoAgQiAi0AEQR+QgJCASACLQASGwVCAAsiDhCSCwwkCyAHAn9BACAJQbKbARBsRQ0AGkEBIAlBuYQBEGxFDQAaQQIgCUHqhQEQbEUNABogCRDRCCICQf8BcUEAIAJBA0kbCyICOgBaIAAgAhCkCA0jIAJBAWsiAEEBSw0jIAUoAmwhAyAFQQVBkIkEEIQDIgIgADYCXCACIAE2AlQgAiADQQRqNgIwIAIgATYCGCACIAE2AgQgBSAFKAKcAUEBIAF0cjYCnAEMIwsgBkEANgK4AwJAAkAgCUUNACAJIAZBuANqEOcCRQ0AIAYoArgDIgJBAEoNAQtB/////wchAgsgAEEAIAEQuQkgBUHHACACQQEQjgMaIAVBPiABEPgIIQIgBUHUAEEBEPgIGiAFQdYAQQFBfxCOAxogBUEyQQEgAhCOAxpBACEAIAUoAmwhASAFKAIALQBXBH9BwK0HBSAFKAJoIAJBFGxqCyICIAE2AggMIgsgCUUEQCAFIAgoAgw0AlAQkgsMIgsgCRDRCCECIAgoAgwgAjYCUCAIKAIEIAIQpgYMIQsgCUUEQCAHLQAgQSBxBEAgCCgCBEEAEKEIrCEOCyAFIA4QkgsMIQsgBkEBNgK4AyAJIAZBuANqEOcCIQUgBigCuAMhAiAFBEAgCCgCBCACEKEIGgsgCSACQQBHEKYEIQIgByAHKQMgQl+DIAJBAEetQgWGhDcDICAHEJULDCALIAVCABCSCwwfCyAJRQRAIAUgBzEAVhCSCwwfCwJAIAktAABBMGtB/wFxIgJBAk0NACAJQfOdARBsRQRAQQEhAgwBCyAJQcAlEGxFQQF0IQILIAIgACgCACIFLQBWRg0eIAAQlgsNHiAFIAI6AFYMHgsgCUUEQCAFQaCLBigCABCQCwweCwJAIAktAABFDQAgBygCACICIAlBASAGQbgDaiACKAIgEQYARQRAIAYoArgDDQELIABB3iRBABCwAgweCyAHLQBWQQFGBEAgABCWCxoLQaCLBigCABBAIAktAAAEQCAGIAk2AhBBACECQaCLBkHb6wAgBkEQahBmNgIADB4LQaCLBkEANgIADB0LIAlFBEAgBSAIMQAIQgF9EJILDB0LIActAFVFBEAgAEHR+wBBABCwAgwdCyABQQFGDRwgCUEAQQEQpwQhAiAIQQE6AAkgCEEBIAJBAWpBB3EiAiACQQFNGzoACCAHEJULDBwLIAlFBEAgBSAKEJELIAUgCikDCCAHKQMgg0IAUq0QkgsMHAsgCikDCCIOIA5C//9+gyAHLQBVGyEOAkAgCUEAEKYEBEAgDkIBg1BFIAcpAyAiG0KAgICAAYNCAFJxDQEgByAOIBuENwMgDAELIAcgBykDICAOQn+FgzcDICAOQoCAIFEEQCAHQgA3A4gEDAELIA5CAYNQDQAgCUH1ORBsDQAgBxC/AQsgBUGmARD3CBogBxCVCwwbCyAJRQ0aIAAgBBCjCSAAQQIgCSAEEP8CIghFDRogCBCzAyEDIABBBzYCMCAAIAgQngkaIAgoAgQhBCAGIiVBOGohEiAGIiZBNGohEyAGIidBMGohGEEAIQEDQCABIAguASIiC04NGwJAAn8gBC8BCiICQeIAcUUEQEEAIQxBAAwBCyAKKQMIUARAIBRBAWohFAwCCyACQSBxBEBBASEMQQIMAQtBA0EBIAJBwABxQQZ2IgwbCyEPAkAgAkEBcSIARSADRXINAEEBIQIgC0EAIAtBAEobQQFqIQADfyAAIAJGDQEgAygCBCACQQF0akECay4BACABRgR/IAIFIAJBAWohAgwBCwshAAsgCCAEEJgJIQJBACILQY2JAUG4iQEgCikDCCIOUBtqIQ0gBCgCACEQIARBgYEDEJMEIREgBC0ABEEPcUEARyEVIAwgAkVyRQRAIAIoAgghCwsgJSAPNgI4ICYgADYCNCAnIAs2AjAgBiAVNgIsIAYgETYCKCAGIBA2AiQgBiABIBRrNgIgIAVBASANIAZBIGoQlwsLIARBDGohBCABQQFqIQEMAAsACyACKQOwASEODBgLAkAgCUUNACAJIAZBuANqEKkEDQAgBikDuAMiDkIAUw0AIAcgDqdB/////wdxNgLwAwsgBSAHNALwAxCSCwwYCwJAIAlFDQAgCSAGQbgDahCpBA0AIAYpA7gDIg5CAFMNACAHQQsgDqdB/////wdxEP4DGgsgBSAHQQtBfxD+A6wQkgsMFwsCQCAJRQ0AIAkgBkG4A2oQqQQNAEJ/EEYhDiAGKQO4AyIbQgBXIA5QRSAOIBtXcXINACAbEEYaCyAFQn8QRhCSCwwWCwJAIAlFDQAgCSAGQbgDahCpBA0AIAYpA7gDEEUaCyAFQn8QRRCSCwwVCyAJBEAgByAJENEIEN8DGgsgBSAHNAL0AxCSCwwUCwJ/AkAgCUUEQEH+/wMhAgwBCyAJENEIIgJBAnFFDRVBACACQRBxRQ0BGgsgBygC8ANBAWtBzw9JBEBBAAwBC0ECIRhBASEXQdAPCyETIAAgACgCLCIRQQFqNgIsIAEhDyAERQRAIAcoAhRBAWshDwsgAkGAgARxIQwgAkEBcSIUQQJyIRIDQCABIA9KRQRAAkAgAUEBRg0AIAAgARCzCSABQQR0Ig0gBygCEGooAgxBEGohCANAIAgoAgAiCEUNASAIKAIIIgotACsNAEEAIQIgCigCAEGwwQFBBxBtRQ0AIAovASYhA0EAIQQgCiIoQQhqIgshAgNAIAIoAgAiAgRAIANBfyACLQA3QYABcRshAyACQRRqIQIgBEEBaiEEDAELCyAKKAIcQYACcSAMckUEQCAoKAIIRSADwUEATnINAQsgFUEBaiIVQQJGBEAgAEEAIAEQuQkLIAAgESABIApB5gAQ+ggCQCADwUEATgRAIAVBISARIAUoAmwgEmpBfyADQf//A3EiAkEhayACQSBNGyACQSFqEIMDGgwBCyAFQSQgESAFKAJsIBJqEI4DGgsgBCAQakEBaiEQIAcoAhAgDWooAgAhAiAGIAooAgA2ApQDIAYgAjYCkAMgB0Ga8wIgBkGQA2oQgQMhAiAUBEAgBUH2AEEAIAAQmgkiA0EAIAJBehD5CBogBUHUACADQQEQjgMaBSAFQZQBIBggE0EAIAJBehD5CBoLDAALAAsgAUEBaiEBDAELCyAFQaYBEPcIGiAHLQBXIBdBAXNyIBBB5QBIcg0TIBNB5ABsIBBuIgJB5ABLIQFBACEAIAUoAgAtAFcEf0HArQcFIAUoAmgLIQAgAkHkACABGyEDQQAhAiAFKAJsIgVBACAFQQBKGyEBA0AgASACRg0UIAAgAkEUbGoiBS0AAEGUAUYEQCAFIAM2AggLIAJBAWohAgwACwALIAcQzQMaDBILIAkEQCAHIAkQ0QgQ8wMaC0EBIQIgBygCkAJBEUYEQCAHNAKUAiEOCyAFIA4QkgsMEQsgAUEMIAIoAgAbIQICf0EAIAlFDQAaQQEgCUG5hAEQbEUNABpBAiAJQboyEGxFDQAaQQBBAyAJQcyVARBsGwshASAAQQM2AjAgBUEDIAIgAUEBEOMIGiAFQdQAQQFBAxCOAxoMEAsgAEEBNgIwQQAhAgNAIAJBN0YNAiACQQJ0QcCHBmooAgAiAUUNAiAFQQEgARD7CBogBUHUAEEBQQEQjgMaIAJBAWohAgwACwALIAooAgghAiAFIAUoApwBQQEgAXRyNgKcAQJAIAlFDQAgCi0ABUEIcQ0AIAVBAkHMiQQQhAMiBSACNgIcIAUgATYCGCAFIAE2AgQgCRDRCCEBIAVBATsBFiAFIAE2AiAgAkEBRw0PIActACNBEHFFDQ8gBUG7AToAFAwPCyAFQQNB1IkEEIQDIgAgAjYCICAAIAE2AhggACABNgIECyAFEJgLDA0LIBotAAAhBCACKAIAISEgAEEGNgIwQeQAIRwgBkHkADYCuAMgAUF/ICEbIR4gBEHfAXEhAkEAIQwCQCAJRQ0AIAMoAgAgBkG4A2oQ5wIEQCAGQeQAIAYoArgDIgEgAUEATBsiHDYCuAMMAQtBACEBIB5BAE4EQCAHKAIQIB5BBHRqKAIAIQELIABBACAJIAEQ/wIhDCAGKAK4AyEcCyACQdEARiEdIAVBxwAgHEEBa0EBEI4DGiAHQYQDaiEpIAxBAEchIgNAAkACQCAZIAcoAhRODQAgIUEAIBkgHkcbDQEgACAZELMJQQAhASAAQQA6ABcgGUEEdCIIIAcoAhBqKAIMQRBqIhchAgNAIAIoAgAiAgRAIAxBACAMIAIoAggiA0cbDQEgA0EIaiEEIAMoAhxBf3NBB3ZBAXEgAWohAQNAIAQoAgAiA0UNAiADQRRqIQQgAUEBaiEBDAALAAsLIAFFDQEgByABICJqQQJ0QQRqrRDvAiIERQ0AIAwEfyAEQQA2AgRBAQVBAAshAyAXIQIDQCACKAIAIgIEQCAMQQAgDCACKAIIIgFHGw0BIAEtABxBgAFxRQRAIAQgA0EBaiIDQQJ0aiABKAIUNgIACyABQQhqIQEDQCABKAIAIgFFDQIgBCADQQFqIgNBAnRqIAEoAiw2AgAgAUEUaiEBDAALAAsLIAQgAzYCACADQQhqIgIgACgCMEoEQCAAIAI2AjALIAVBywBBAEEIIAIQ4wgaIABBADYCICAAQQA6ABMgBUGbAUEBIANBCCAEQXIQ+QgaIAUoAmwiAkEASgRAIAUoAmggAkEUbGpBEmsgGTsBAAsgBUEzQQIQ+AghAyAGIAcoAhAgCGooAgA2AoADIAVB9gBBAEEDQQAgB0EAIgFB6oADaiAGQYADahCBA0F6EPkIGiAFQfAAQQJBA0EDEOMIGiAFEJkLGiAFKAJsIQIgBSgCAC0AVwR/QcCtBwUgBSgCaCADQRRsagsiASACNgIIIAVBAkGh+gIQ+wgaIBchASAiIQgDQCABKAIAIgFFBEAgFyEfA0AgHygCACIfBEAgDEEAIAwgHygCCCIKRxsNASAKLQArDQFBACECQQAhD0EAIRICQCAdDQAgCi0AHEGAAXFFDQAgBUHLAEEBIAAgChCzAyIPLwEyEMMKIhIgEiAPLwEyakEBaxDjCBoLIAAgCkHmAEEAQQFBACAGQbQDaiAGQbADahDqChogBUHHAEEAQQcQjgMaIApBCGoiAyEBA0AgASgCACIBBEAgBUHHAEEAIAJBCGoQjgMaIAJBAWohAiABQRRqIQEMAQsLIAVBJCAGKAK0AyIQQQAQjgMaIAVB1gBBB0EBEI4DISMCfyAKLQAcQYABcUUEQEEAIQIgCi4BIiIBQQAgAUEAShshBEF/IQEDQCACIARGRQRAIAEgCigCBCACQQxsai0ACkEgcUVqIQEgAkEBaiECDAELCyABIAEgCi4BIEZrDAELIAoQswMvATRBAWsLIgJBAE4EQCAFQd4AIBAgAkEDEOMIGiAFQQMQmgsLAkAgHSAPRXINACAFQSkgEEEAIBIgDy8BMhCDAyEBIAVBMyASEPgIGiAGIAooAgA2AvACIAVB9gBBAEEDQQAgB0G11wAgBkHwAmoQgQNBehD5CBogBRCZCxogBSgCbCECAkAgBSgCAC0AVwRAQcCtByIBIAI2AggMAQsgBSgCaCABQRRsaiIBIAI2AgggAUEUaiEBCyABIAI2AghBACECA0AgAiAPLwEyTw0BIAAgDyAQIAIgAiASahCbCyACQQFqIQIMAAsACyAKKAIcQYCABHEhFEEAIQIDQAJAAn8CfwJAIAouASIgAkoEQCACIAouASBGDQQgAkEMbCIVIAooAgRqIQECfyAUBEAgAS0ABCIIQR9LIg0MAQsgAS0ABCEIQQAhDSABLAAFQcEASgshBCAIQQ9xIARyRQ0EIAEtAApBIHEEQEEDIREgBSAKIBAgAkEDEJcJQQUhE0F/DAQLIAEvAQhFDQEgBkEANgKsAyAHIAogARCYCSAHLQBUIAEtAAUgBkGsA2oQ7AIaIAYoAqwDIghFDQEgCC8BECELIAgQ8wEgC0E/cUGAhQNqLQAADAILAkAgCigCECICRQ0AIActACFBAnENACAHIAJBABCVCSEIIActAFdFBEAgACAQQQFqNgI4IAAgACgCPCICQQJrIgs2AjwgCEEIaiEBIAJBAWshBCAIKAIAIQIDQCACQQJIRQRAIAAgASACQQFrIgJBBHRqKAIAIARBABDCCgwBCwsgACABKAIAIAtBEBCcCyAFIAQQkwogAEEANgI4IAYgCigCADYC4AIgBUH2AEEAQQNBACAHQcDYACAGQeACahCBA0F6EPkIGiAFEJkLGiAFIAsQkwoLIAcgCBCyAwsCQCAdDQBBfyEIQQAhDSAGKAKwAyEUQQAhAgNAIAMoAgAiAUUNASAAIAAoAjxBAWsiAzYCPCABIA9HBEAgACABIBBBAEEAIAZBrANqIAIgCBCdCyEIIAVB1gAgDUEIakEBEI4DGkEAIQIgBUEdIA0gFGoiCyADIAggAS8BNBCDAyEDIAVBA0GY+wIQ+wgaIAVB8ABBB0EDQQMQ4wgaIAVBBEHZ+gIQ+wgaIAVB8ABBBEEDQQMQ4wgaIAVBBCABKAIAEPsIIREgBUHwAEEEQQNBAxDjCBogBRCZCyEVIAUoAgAtAFcEf0HArQcFIAUoAmggA0EUbGoLIgIgBSgCbDYCCCAKLQAcQYABcUUEQCAFQY4BIAtBAxCOAxpBACECIAVBNkEDQQAgCCABLwE0akEBaxDjCCEDIAVBA0H5+gIQ+wgaIAVB8ABBB0EDQQMQ4wgaIAVBBEHu+gIQ+wgaIAUgEUEBaxD9CBogBSgCAC0AVwR/QcCtBwUgBSgCaCADQRRsagsiAiAFKAJsNgIIC0EAIQRBACECA0AgAS8BMiACSwRAQQAhAyABKAIgIAJBAnRqKAIAQaCVA0cEQCAERQRAIAAgACgCPEEBayIENgI8CyAFQd4AIAsgAkEDEOMIGiAFQTVBAyAEIAIgCGoQ4wgaCyACQQFqIQIMAQsLIAQEQCAFQQkQ9wghAyAFIAQQkwogBUEDQQAiAkGY+wJqEPsIGiAFQfAAQQdBA0EDEOMIGiAFQQRBvvoCEPsIGiAFIBFBAWsQ/QgaIAUoAgAtAFcEf0HArQcFIAUoAmggA0EUbGoLIgIgBSgCbDYCCAsgAS0ANgRAIAAgACgCPEEBayIENgI8QQAhAgNAIAIgAS8BMk9FBEACQCABKAIEIAJBAXRqLgEAIgNBAE4EQCAKKAIEIANBDGxqLQAEQQ9xDQELIAVBMyACIAhqIAQQjgMaCyACQQFqIQIMAQsLIAVBJyALEPgIIRMgBSAEEP0IGkEAIQMgBSgCbCECIAUoAgAtAFcEf0HArQcFIAUoAmggE0EUbGoLIgMgAjYCCCAFQSkgCyAEIAggAS8BMhCDAxogBUEDQYb6AhD7CBogBSAREP0IGiAFIAQQkwoLQQAhAyAFKAJsIQIgBSgCAC0AVwR/QcCtBwUgBSgCaCAVQRRsagsiAyACNgIIIAAgBigCrAMQngsgASECCyANQQFqIQ0gAUEUaiEDDAALAAsgBUEnIBAgIxCOAxpBACEBIAUoAmwhAiAFKAIALQBXBH9BwK0HBSAFKAJoICNBFGxqQRRrCyIBIAI2AgggD0UNBiAAIBIgDy8BMhDECgwGC0EFCyETAn8gCi0AHEGAAXEEQCAKELMDIALBEOkCDAELIAogAsEQ9goLIREgEAshCyAAIAAoAjwiGEECayIINgI8IBhBAWshGAJAIAEtAARBD3FFDQAgBUESIAsgCCARIBMQgwMhICAFKAJsIRYCfyALQQBIBEAgICIkIBZBAEwNARogBSgCaCAWQRRsakESa0EPOwEAICAMAQsgFkEASgRAIAUoAmggFkEUbGpBEmtBDTsBAAsgBUHeACALIBFBAxDjCBogBSAKIAJBAxCfCyAFQTRBAyAIEI4DCyEkIAooAgAhFiAGIAEoAgA2AtQCIAYgFjYC0AIgBUH2AEEAQQNBACAHQePUACAGQdACahCBA0F6EPkIGiAERQ0AIAUgGBD9CBogBSgCbCEEAkAgBSgCAC0AVwRAQcCtByIWIAQ2AggMAQsgBSgCaCIWICBBFGxqIAQ2AgggFiAkQRRsaiEWCyAWIAQ2AggLAkAgBUH2AEEAQQNBAAJ/IA0EQCAFQRIgCyAIIBEgExCDAxogBSgCbCIEQQBKBEAgBSgCaCAEQRRsakESayABLQAEQQR2QaOJBGotAAA7AQBBACELCyAKKAIEIBVqKAIAIQQgAS0ABCEBIAYgCigCADYCpAIgBiAENgKoAiAGIAFBAnZBPHFBACIBakHMsAVqKAIANgKgAiAHQbnUACAGQaACahCBAwwBCyAUDQEgASwABSIBQcIARgRAIAVBEiALIAggESATEIMDGiAFKAJsIgFBAEoEQCAFKAJoIAFBFGxqQRJrQRw7AQALIAooAgAhASAGIAooAgQgFWooAgA2ArQCIAYgATYCsAIgB0H31AAgBkGwAmoQgQMMAQsgAUHDAEgNASAFQRIgCyAIIBEgExCDAxogBSgCbCIBQQBKBEAgBSgCaCABQRRsakESa0EbOwEACyALQQBOBEAgBSAKIBAgAkEDEJcJCyAFQeAAQQNBAUEAQfuZAkF/EPkIGiAFQRJBfyAIQQMgExCDAxogBSgCbCIBQQBKBEAgBSgCaCABQRRsakESa0EcOwEACyAKKAIAIQEgBiAKKAIEIBVqKAIANgLEAiAGIAE2AsACIAdBz9QAIAZBwAJqEIEDCyIBQXoQ+QgaCyAFIBgQkwogBRCZCxogBSAIEJMKCyACQQFqIQIMAAsACwsDQCAXKAIAIhdFDQQgDEEAIAwgFygCCCICRxsNACACLQArQQFHDQAgAi4BIkEATARAICkgAigCMCgCABCJA0UNAQsgACACEJ4JGiACKAI0IgFFDQAgASgCCCIBRQ0AIAEoAgAiAUUNACABKAIAQQRIDQAgASgCYEUNACAFQa4BIBlBAyAdEOMIGiACIAIoAhhBAWo2AhggBSACQXAQsQogBUEzQQMQ+AghASAFEJkLGkEAIQIgBSgCAC0AVwR/QcCtBwUgBSgCaCABQRRsagsiAiAFKAJsNgIIDAALAAsgDEEAIAwgASgCCCICRxsNAAJAIAItABxBgAFxRQRAIAhBAWohAwwBCyACQQhqIQMgCCEEA0ACQCADKAIAIgNFDQAgAy8AN0EDcUECRg0AIANBFGohAyAEQQFqIQQMAQsLIAghAyAEIQgLIAhBCGohCiACQQhqIQIDQCACKAIAIgJFBEAgAyEIDAILIAIoAiRFBEAgBUE2IANBCGpBACAKEOMIIQggBUEEIAIoAgAQ+wgaIAVB8ABBBEECQQMQ4wgaIAUQmQsaQQAhBCAFKAIALQBXBH9BwK0HBSAFKAJoIAhBFGxqCyIEIAUoAmw2AggLIAJBFGohAiADQQFqIQMMAAsACwALIAVBB0GwiQQQhAMiAgRAIAJB/wE6AGUgAkH/AToAKSACQQAiAUGpsgFqNgJ0IAJB3oYBNgI4IAJBASAcazYCCAtBACEBIAUoAmxBAmshAiAFKAIALQBXBH9BwK0HBSAFKAJoCyIFIAI2AgwMDgsgGUEBaiEZDAALAAsgCUUNC0EAIgJBkYoEakHchQMgCUEAEKYEIgIbIQBBDEEEIAIbIQNBAiECA0AgAkEERg0MIAdB3aQBIgEgAkEBIABBOkEAQQBBAEEAQQAQ5QMaIAdB3aQBIAJBAUEAEOkDIgUgBSgCBEH7//9+cSADcjYCBCACQQFqIQIMAAsACyAAIAAoAjAiAkEFaiILNgIwIAJBA2ohFSACQQJqIRQgAkEBaiERIAcoAhAgAUEEdGooAgwoAhAhDwNAIA9FDQsCfyAJBEAgAEEAIAkgBBD/AiEDQQAMAQsgDygCCCEDIA8oAgALIQ8gA0UNACADLQArDQAgAygCMEUNACAHKAIQIAcgAygCPBCAAyINQQR0aigCACEEIAAgDRCzCSALIAMuASJqIgIgACgCMEoEQCAAIAI2AjALIABBACANIANB5gAQ+gggBSARIAMoAgAQ+wgaQQEhASADQTBqIgghAgNAIAIoAgAiAgRAAkAgByACKAIIIAQQiAMiCkUNACAGQQA2ArgDIAAgCiACIAZBuANqQQAQoQsNDiAGKAK4AyIMRQRAIAAgASANIApB5gAQ+ggMAQsgBUHmACABIAwoAiwgDRDjCBogACAMEOgKCyACQQRqIQIgAUEBaiEBDAELCyABIAAoAixKBEAgACABNgIsC0EBIQ0gBUEkQQAQ+AghEgNAIAgoAgAiCARAIAcgCCgCCCAEEIgDIRAgBkEANgK0AyAGQQA2ArgDIBAEQCAAIBAgCCAGQbgDaiAGQbQDahChCxoLIAAgACgCPEEBayIKNgI8IAgoAhQiASALaiICIAAoAjBKBEAgACACNgIwCyAIQSRqIQxBACECA0AgASACTEUEQCAFIANBACAGKAK0AyIBIAJBAnRqIAwgAkEDdGogARsoAgAgAiALaiIBEJcJIAVBMyABIAoQjgMaIAJBAWohAiAIKAIUIQEMAQsLAkAgBigCuAMiAgRAIAVB4AAgCyABQQAgByACEOkKIAgoAhQQ+QgaIAVBHSANIAogCyAIKAIUEIMDGgwBCyAQRQ0AIAVBHiANIAUoAmxBAmogCxDjCBogBSAKEP0IGgsgBUHLAEGHASADKAIcQYABcRtBACAUEI4DGiAIKAIIIQIgBiANQQFrNgKUAiAGIAI2ApACIAUgFUG+yAEgBkGQAmoQlwsgBUHUACARQQQQjgMaIAUgChCTCiAHIAYoArQDEDIgCEEEaiEIIA1BAWohDQwBCwsgBUEnQQAgEkEBahCOAxpBACEBIAUoAmwhAiAFKAIALQBXBH9BwK0HBSAFKAJoIBJBFGxqCyIBIAI2AggMAAsACyAJRQ0JIAcgCSAEEIgDIg1FDQkgDS0AKw0JIA0oAjAiAUUNCSAHIA0oAjwQgAMhAiAAQQg2AjAgACACELMJQQAhDCAGIipBjAJqIRAgBiIrQYgCaiERIAYiLEGEAmohFSAGIi1BgAJqIRQDQCABRQ0KIAFBJGohD0EAIQIDQCACIAEoAhRORQRAIA0oAgQgDyACQQN0aiIAKAIAQQxsaigCACEDIAAoAgQhBEEAIQAgASgCCCEIIAEtABoQogshCiABLQAZIQsgKkHehwI2AowCICsgCxCiCzYCiAIgLCAKNgKEAiAtIAQ2AoACIAYgAzYC/AEgBiAINgL4ASAGIAI2AvQBIAYgDDYC8AEgBUEBQfzBACAGQfABahCXCyACQQFqIQIMAQsLIAxBAWohDCABKAIEIQEMAAsACwNAIAtBwABGDQkgBkEAIgJBsLMFaiALQQR0aigCADYC4AEgBUEBQdzrACAGQeABahCXCyALQQFqIQsMAAsACyAAQQE2AjAgB0GMA2ohAgNAIAIoAgAiAkUNCCAGIAIoAggoAgQ2AtABIAVBAUHc6wAgBkHQAWoQlwsMAAsACyAHKAIYIQIgAEEGNgIwIAJBBXZBAXEhAUEAIQADQCAAQRdGRQRAIABBAnRBqIsGaiECA0AgAigCACICBEAgBSACQQEgARCjCyACQSRqIQIMAQsLIABBAWohAAwBCwsgB0GoA2ohAgNAIAIoAgAiAkUNByAFIAIoAghBACABEKMLDAALAAsgAEECNgIwIAdBuANqIQJBACEBA0AgAigCACICRQ0GIAYgAigCCCgCADYCxAFBACEAIAYgATYCwAEgBUEBQePKACAGQcABahCXCyABQQFqIQEMAAsACyAAQQM2AjBBACECA0AgAiAHKAIUTg0FIAcoAhAgAkEEdGoiASgCBCIABEAgASgCACEBIAYgABCsBDYCuAEgBiABNgK0ASAGIAI2ArABIAVBAUGFwgAgBkGwAWoQlwsLIAJBAWohAgwACwALIAlFDQMgByAJIAQQiAMiAkUNAyAHIAIoAjwQgAMhASAAQQU2AjAgACABELMJIAJBCGohAiAGIi5BoAFqIQhBACEBA0AgAigCACICRQ0EIAIvADchACACLQA2IQMgAigCACEEIC4gAigCJEEARzYCoAEgBiAENgKUASAGIANBAEc2ApgBIAZBACIDQdi/BWogAEEDcUECdGooAgA2ApwBIAYgATYCkAEgBUEBQZSJASAGQZABahCXCyACQRRqIQIgAUEBaiEBDAALAAsgCUUNAiAHIAkgBBCbCCIBRQRAIABBAiAJIAQQ/wIiAkUNAyACLQAcQYABcUUNAyACELMDIgFFDQMLIAcgASgCGBCAAyECIAFBMkE0IAopAwhQIgMbai8BACEIIABBA0EGIAMbNgIwIAEoAgwhCyAAIAIQswlBACECA0AgAiAIRg0DQQAhAyABKAIEIAJBAXRqLgEAIgRBAE4EQCALKAIEIARBDGxqKAIAIQMLIAYgAzYCiAEgBiAENgKEASAGIAI2AoABIAVBAUG4yAEgBkGAAWoQlwsgCikDCFBFBEAgASgCHCACai0AACEDIAEoAiAgAkECdGooAgAhBCAGIAIgAS8BMkk2AnggBiAENgJ0IAYgAzYCcCAFQQRBvcgBIAZB8ABqEJcLCyAFQdQAQQEgACgCMBCOAxogAkEBaiECDAALAAsgAEEGNgIwIAAgBBCjCSAGIi9B1ABqIQwDQCANIAcoAhRODQIgBygCECECAkAgBARAIAQgAiANQQR0aigCABBrDQELIAIgDUEEdCILaigCDCIIKAIMIQADQCAIQRBqIQMCQANAIAMhAiAARQ0BA0AgAigCACICRQRAQQAhAAwCCyACKAIIIgEvASINAAsLIAYgASgCADYCYCAHQfHxAiAGQeAAahCBAyICBEAgBkEANgK4AyAHIAJBf0EQIAZBuANqQQAQqwMaIAYoArgDEI4BGiAHIAIQNQsgBy0AVwRAIAcoAoACQZMlQQAQsAIgBygCgAJBBzYCDEEAIQILIABBAWshACAHKAIQIAtqKAIMIQgMAQsLIAhBEGohAQNAIAEoAgAiAUUNASABKAIIIQIgCQRAIAkgAigCABBrDQELQfkrIQACQAJAAkAgAi0AKyIDQQFrDgIAAgELQdyFASEADAELQfkqQcajASACLQAdIgBBEHEbIQALIAcoAhAgC2ooAgAhCEEAIQoCQCACKAIAIgNBsMEBQQcQbQ0AIANBB2oiCkEAQZjuAGoQbEUEQEHZwAEhAwwBCyAKQQBBhe4AahBsDQBBxsABIQMLIAIuASIhCiAvIAIoAhwiAkEQdkEBcTYCVCAGIAJBB3ZBAXE2AlAgBiAKNgJMIAYgADYCSCAGIAM2AkQgBiAINgJAIAVBAUHAiQEgBkFAaxCXCwwACwALIA1BAWohDQwACwALIAUgDhCSCwsgByAaEDUgByAJEDILIAZB4ANqJAALpAEEAX8BfwF/AX8jAEEQayIGJAACQCAAEPYIIgVFDQAgACgCKA0AIAEEQCAAIAEgASAGQQxqEKwJIgRBAEggBEEBRnINAQsCQCACRQ0AIABBAEEAIAJBABD/CQ0AIAAgACgCMEEBaiIDNgIwIAAgAiADEPwICyAFQQUgBCADEI4DGiAFIAUoApwBQQEgBHRyNgKcAQsgACgCACACEDMgBkEQaiQACzoBAX8gACAAKAIwQQFqIgE2AjAgABD2CCIABEAgAEEEQQAgAUF/EOMIGiAAIAAoApwBQQFyNgKcAQsLlAEDAX8BfwF/IwBBQGoiBCQAIAAoAgAoAhAgAUEEdGooAgAhBUEBIQEDQCABQQVHBEAgBCABNgIQQRggBEEgakGPtwEgBEEQahBoIQYgACgCACAGIAUQiAMEQCAEIAM2AgwgBCACNgIIIAQgBjYCBCAEIAU2AgAgAEH74wEgBBCSCQsgAUEBaiEBDAELCyAEQUBrJAALmgEDAX8BfwF/IwBBEGsiAyQAIAAQ9gghBSAAEJoJIQQgAUEBTARAIABBhsEBQQAQsAILIAVBkAEgASAEIAIQ4wgaIAAoAnwiBSAAIAUbQQE6ABUgACgCACgCECACQQR0aigCACECIAMgBDYCDCADIAQ2AgggAyABNgIEIAMgAjYCACAAQcu4ASADEJIJIAAgBBCbCSADQRBqJAALXQEBfyMAQRBrIgUkACAAIAFBABDGCSEBAkAgA0UgBEF/RnENACAAKAIALQCxAQ0AIAUgAikCAEIgiTcDACAAQd/0AiAFELACCyAAIAEgAkEBEN0JIAVBEGokACABC8YBAgF/AX8gACgCACEEAkACfwJAIAFFBEAgBEI4EO8CIgANAQwDCyAAIAFBASABKAIAEN0KIgAEQCAAKAIAQQFrDAILIAQgARCqCAwCCyAAQoGAgIAQNwMAIABBCGpBAEEwEJkTGiAAQX82AhhBAAsiAUEwbCAAaiIFQQhqIQECQCADRQ0AIAMoAgBFDQAgBSAEIAMQiQk2AgggBSAEIAIQiQk2AjQgAA8LIAQgAhCJCSEEIAVBADYCNCAFIAQ2AgggAA8LQQALixkLAX8BfwF/AX8BfwF/AX8BfwF/AX8BfyMAQeABayILJAAgACgCACENIAtBADYCqAEgC0EANgKkAQJAIAAoAigNACAKQQJHBEAgAC0A2AFBAUYNAQsgABCHAw0AIAAgBBCqCQ0AAkACQAJ/IAMEQCAAIAEgAiALQagBahCsCSIBQQBIDQQCQCANLQCxAQ0AIAAgAxCtCSEMIAIoAgQgDEVyDQBBASABIAwoAjwgDSgCECgCHEYbIQELIAAoAgAhDCALIAA2AqwBIAsgDCgCECABQQR0aiIMKAIANgLUASALIAwoAgw2AswBIAsgADYCsAEgC0EBIgxBC2o2ArQBIAtBDTYCuAEgC0EONgK8AUEAIQwgC0EANgLAASALQQA7AcQBIAsgAUEBRjoA0AEgC0GhKTYC2AEgCyALKAKoASITNgLcASALIAtBrAFqNgLIASALQawBaiADELEJGiAAQQAgA0EIahCNCSICRQ0EAkAgAUEBRw0AIA0oAhAoAhwgAigCPEYNACALIAIoAgA2ApABIABB6PcCIAtBkAFqELACDAMLQQAgAi0AHEGAAXFFDQEaIAIQswMMAQsgACgC9AEiAkUNAyANIAIoAjwQgAMhAUEACyEPIA0oAhAhEAJAIAIoAgAiDkGwwQFBBxBtIANFcg0AIA0tALEBDQAgCyAONgIAIABByq0BIAsQsAIMAQsCQAJAAkAgAi0AK0EBaw4CAQACCyAAQY+tAUEAELACDAMLIABBqK0BQQAQsAIMAgsgECABQQR0aiERAkACQAJAIBMEQCANIBMQiQkiDEUNBCAAIAxBoSkgAigCABCdCQ0FIAAtANgBQQFLDQMCQCANLQCxAQ0AIA0gDCARKAIAEIgDRQ0AIAsgDDYCgAEgAEHw3AAgC0GAAWoQsAIMBgsgDSAMIBEoAgAQmwhFDQEgCUUEQCALIAw2AnAgAEGMPiALQfAAahCwAgwGCyAAIAEQswkgABC+CQwFCyACQQhqIQxBASEJA0AgDCgCACIMBEAgCUEBaiEJIAxBFGohDAwBCwsgCyAJNgJkIAsgDjYCYCANQce3ASALQeAAahCBAyIMRQ0DIAAtANgBRQ0BIAwgDC0AB0EBajoABwsgAC0A2AFBAUsNAQsgAEESQf7tAEGR7gAgAUEBRiIJG0EAIBEoAgAiDhD+CA0CIABBA0EBIAkbIAwgAigCACAOEP4IDQILAkAgBEUEQCACKAIEIAIuASJBDGxqIgRBAmsiCSAJLwEAQQhyOwEAIAsgBEEMaygCACIENgKcASALIAQQWTYCoAEgDUE8IAtBnAFqQQAQ1QkhBCAAKAIAIAQQxQkiBARAIAQgBCgCAEEEdGogCEEAIAhBf0cbOgAADAILQQAhBAwDCyAAIARBoSkQ3wkgACgCKA0CC0EAIRAgBCgCACIUQQAgFEEAShshEiAEQQhqIQlBACEIA0AgCCASRkUEQCAJIAhBBHRqKAIAIg4tAABB8gBGBEAgDigCCBBZIBBqQQFqIRALIAhBAWohCAwBCwsgDBBZIQ5BASEIIA8EQCAPLwEyIQgLIA0gCCAUasEgDiAQakEBaiALQaQBahCPCiEIAkAgDS0AV0UEQCAIIAsoAqQBIhI2AgAgCyASIA5BAWoiDmoiEDYCpAEgEiAMIA4QlxMaIAggBToANiAIIAI2AgwgCCAILwA3QfT/A3EgBUEAR0EDdCAKcnI7ADcgCCANKAIQIAFBBHRqKAIMNgIYIAggBCgCADsBMiAHBEAgACACQQIgB0EAEP8JGiAIIAc2AiQLIBEoAgwtAEwhByAALQDYAUECTwRAIAggBDYCKEEAIQQLIAdB/wFxQQNLIRRBACEOA0AgCC8BMiAOSwRAIAkoAgAQjgpBACEHIAAgAkEgIAkoAgBBABD/CRogACgCKA0DAkAgCSgCABCNCiISLQAAQagBRwRAIAAoAvQBIAJGBEAgAEGjP0EAELACDAYLIAgoAihFBEAgCCAENgIoQQAhBAsgCCgCBCAOQQF0akH+/wM7AQAgCCAILwA3QfffA3FBgCByOwA3QX4hEgwBCwJAIBIuASAiEkEASARAIAIuASAhEgwBCyACKAIEIhEgEkEMbCIVai0ABEEPcUUEQCAIIAgvADdB9/8DcTsANyACKAIEIRELIBEgFWotAApBIHFFDQAgCCAILwA3QYAwcjsANwsgCCgCBCAOQQF0aiASOwEACwJAIAkoAgAiES0AAEHyAEYEQCALIBAgESgCCCISIBIQWUEBaiIREJcTIBFqIhE2AqQBDAELIBJBAEgEQCAQIRFBACEQDAELIBAhESACKAIEIBJBDGxqEJQEIRALIBBBoJUDIBAbIRAgDS0AsQFFBEAgACAQEPcJRQ0ECyAIKAIgIA5BAnRqIBA2AgAgCCgCHCAOaiAJLQAIQQAgFBs6AAAgCUEQaiEJIA5BAWohDiARIRAMAQsLAkAgDwRAQQAhBwNAIAcgDy8BMk8NAgJAIAggCC8BMiAPIAcQ+wkEQCAIIAgvATRBAWs7ATQMAQsgCCgCBCAOQQF0aiAPKAIEIAdBAXRqLwEAOwEAIAgoAiAgDkECdGogDygCICAHQQJ0aigCADYCACAIKAIcIA5qIA8oAhwgB2otAAA6AAAgDkEBaiEOCyAHQQFqIQcMAAsACyAIKAIEIA5BAXRqQf//AzsBAEEAIQcgCCgCICAOQQJ0akGglQM2AgALIAgQngggACgC9AFFBEAgCBCBCgsgCBD+CQJAIANFDQAgCC8BNCACLgEiSA0AIAggCC8ANyIPQSByOwA3QQAhByACLgEiIglBACAJQQBKGyEJA0AgByAJRg0BAkAgByACLgEgRg0AIAggB8EQ6QJBAE4NACAIIA9B3/8DcTsANwwCCyAHQQFqIQcMAAsACwJAAkACQAJAIAIgACgC9AFHDQAgAkEIaiEHA0AgBygCACIPRQ0BAkACQCAPLwEyIg4gCC8BMkcNAEEAIQcDQCAHIA5GDQIgB0EBdCIJIA8oAgRqLwEAIAgoAgQgCWovAQBHDQEgB0ECdCEJIAdBAWohByAJIA8oAiBqKAIAIAkgCCgCIGooAgAQbEUNAAsLIA9BFGohBwwBCwsCQCAPLQA2IgcgCC0ANiIBRg0AIAdBC0YgAUELRnJFBEAgC0EANgJQIABB57QBIAtB0ABqELACIA8tADYhBwsgB0H/AXFBC0cNACAPIAgtADY6ADYLIApBAkYEQCAPIA8vADdB/P8DcUECcjsANwtBACEHIAAtANgBQQJJDQUgCCAAKAL4ATYCFAwBCwJAIAAtANgBQQFLDQAgDS0AsQEEQAJAIANFDQAgCCANKAKsATYCLCAIEJwIRQ0AQQAhByAAQfmlAUEAELACIABBs9sHEOABNgIMDAcLIAgoAhhBGGogCCgCACAIEO0DBEAgDRCUAUEAIQcMBwsgDSANKAIYQQFyNgIYDAELIANFBEAgAigCHEGAAXENAQsgACAAKAIwQQFqIgo2AjAgABD2CCIHRQ0DIABBASABELkJIAggB0G7ARD3CDYCLCAHQZMBIAEgCkECEOMIGiAGBH8gACgCzAEiCSAAKALQASIGakEBay0AACEPIAsgEygCACITNgJIIAtBACIOQZ2BAkGBgQMgBRtqNgJAIAsgBiAJIBNraiAPQTtGazYCRCANQYrSACALQUBrEIEDBUEACyEFIA0oAhAgAUEEdGooAgAhCSAIKAIAIQYgAigCACETIAsgBTYCMCALIAo2AiwgCyATNgIoIAsgBjYCJCALIAk2AiAgAEHFogIgC0EgahCSCSANIAUQMiADBEAgACAIIAoQkAogACABELoJIAsgCCgCADYCECAHIAEgDUGG5wIgC0EQahCBA0EAELsJIAdBpgFBAEEBEI4DGgtBACEBIAcoAmwhCiAHKAIALQBXBH9BwK0HBSAHKAJoIAgoAixBFGxqCyIHIAo2AggLAkAgAwRAIA0tALEBRQ0BCyAIIAIoAgg2AhQgAiAINgIIDAILIAAtANgBQQJJDQILIAAgCDYC+AELQQAhBwwEC0EAIQcLIAhFDQILIA0gCBDVBwwBC0EAIQwLIAJBCGohAgNAIAIiASgCACIARQ0BIABBFGohAiAALQA2QQVHDQALA0AgAigCACIKRQ0BIAotADZBBUYNASABIAo2AgAgACAKKAIUNgIUIAogADYCFCAKQRRqIQEMAAsACyANIAcQMyANIAQQsgMgDSADEKoIIA0gDBAyIAtB4AFqJAALRwEBfwJAIAAtANgBQQNGDQAgACgCAEIQEMMCIgNFDQAgAyABNgIAIAMgAikCADcCBCADIAAoApQCNgIMIAAgAzYClAILIAELPgEBfyAAQtgAEO8CIgJFBEAgACABEDMgAg8LIAJCADcCDCACQoGAgIDAADcCACACIAE2AgggAkEANgIUIAILWwEBfyABRQRAIAAoAgAgAhDFCQ8LIAEoAgAiAyABKAIETgRAIAAoAgAgASACEOIKDwsgASADQQFqNgIAIAEgA0EEdGoiAEEANgIUIABCADcCDCAAIAI2AgggAQuCAgYBfwF/AX8BfwF/AX8jAEEQayIEJAAg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CyADQTBqIQMgAkEBaiECDAALAAsgCSkDWCEaCyAMIAkoAhg2AhwgKkEBayEqICFCAXwhIQwACwALIAxFDQELIAAgDCgCJDsBmAEgGSAMELcMC0EAIQwLIBFBoAFqJAAgDAs7AQF/IAAoAgAiAi0AV0UEQCACIAAoAmggAUEUbGoiACwAASAAKAIQEJgHIABBADYCECAAQbsBOwEACwtUAgF/AX8jAEEQayICJAAgACgCACEAIAJBADYCDCAAIAEgAC0AVEHDACACQQxqEOwCGiACKAIMIgAEQCAAEFunQQBKIQMLIAAQ8wEgAkEQaiQAIAMLGgAgACABKAIUEDIgACABKAIgEDIgACABEDULPQIBfwF/AkAgAUUNACABQQhqIQIDQCADIAEoAgBODQEgACACKAIAELgKIAJBEGohAiADQQFqIQMMAAsACwu/AQQBfwF/AX8BfyMAQUBqIgQkAAJAIAEtAABBLEYNAEEBIQIgACgCACABIAAoAhgiBSgCKBCSDEUNACABKAIEQYGAgIACcUGAgICAAkYNACABKAIoDQAgACgCACgCAEGcAUHWtwIQzAkiA0UNACAFKAIkIQIgBEEMaiADQTQQlxMaIAMgAUE0EJcTIQMgASAEQQxqQTQQlxMaIAUgACgCACACIAMQ0gk2AiRBASECIABBATsBFAsgBEFAayQAIAILUAEBfyMAQSBrIgIkACACIAA2AhwgAkEANgIUIAJBADYCBCACQQEiAEFAazYCECACQcAANgIMIAJB2AA2AgggAkEEaiABELYJGiACQSBqJAALrAEDAX8BfwF/AkADQAJAAkAgAC0AACIBQa0Baw4EAAADAQMLIAAoAgwhAAwBCwsgAC0AAiEBCwJAIAFB/wFxIgFBmgFrQQNJIAFB9gBGcg0AIAFBqAFGBEBBASECIAAtAAZBIHENASAAKAIsIgFFDQFBACECIAAuASAiAEEASA0BIAEoAgQiA0UNASAAIAEuASJODQEgAyAAQQxsai0ABEEPcUUPC0EBIQILIAILgQEDAX8BfwF/IAEgASgCGEGAgAhyNgIYA0AgACgCJCACSgRAIAEgACgCICACQRhsaigCACIDKAIUELYKIAMoAgwiBARAIAEgBCgCFBC2CgsgAy0AB0EBcQRAIAEgAygCLCgCKBC4CgsgAkEBaiECDAELCyABIAEo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IAIrAxiZZCIDGysDACEBIAAgACsDCCACQRhqIAJBEGogAxsrAwAgASACKwMIoaCgOQMIIAAgAisDCDkDAAtAAQF+AkAgAUKAgICAgICACH1CgICAgICAgHBWBEAgASECDAELIAAgASABQoCAAYEiAn25EMUNCyAAIAK5EMUNC4MBAwF/AXwBfAJAIABBABC/AiIBRQ0AIAEpAxhCAFcNACABLQAgBEAgAS0AIQRAIABBxSpBfxCZAg8LIAErAwAhAiABKwMIIgO9Qv///////////wCDQv/////////3/wBYBEAgACADIAKgEJcCDwsgACACEJcCDwsgACABKQMQEJ4CCwunAQIBfgF/IABBKBC/AiIARSACKAIAEPgCIgRBBUZyRQRAIAAgACkDGEIBfTcDGCAALQAgRQRAIAIoAgAQWyEDIAAgACkDECADfTcDEA8LIAIoAgAhAiAEQQFGBEAgAhBbIgNCgICAgICAgICAf1IEQCAAQgAgA30Qxg0PCyAAQv///////////wAQxg0gAEQAAAAAAADwPxDFDQ8LIAAgAhBQmhDFDQsLZQMBfwF8AXwgAAJ8RAAAAAAAAAAAIABBABC/AiIBRQ0AGiABLQAgBEAgASsDACICIAErAwgiA6AgAiADvUL///////////8Ag0KAgICAgICA+P8AVBsMAQsgASkDELkLIgIQlwILcAQBfwF8AX4BfAJAIABBABC/AiIBRQ0AIAEpAxgiA0IAVw0AIAACfCABLQAgBEAgASsDACICIAErAwgiBKAgAiAEvUL///////////8Ag0KAgICAgICA+P8AVBsMAQsgASkDELkLIgIgA7qjEJcCCws/ACAAQQgQvwIhAAJAIAEEQEIBIAIoAgAzARCGQtWq1arVqtWq1QCDUA0BCyAARQ0AIAAgACkDAEIBfDcDAAsLHQEBfyAAIABBABC/AiIBBH4gASkDAAVCAAsQngILPwAgAEEIEL8CIQACQCABBEBCASACKAIAMwEQhkLVqtWq1arVqtUAg1ANAQsgAEUNACAAIAApAwBCAX03AwALC5wDBAF/AX8BfwF/AkBCASACKAIAMwEQhkKq1arVqtWq1ap/g0IAUg0AIABBJBC/AiIDRQ0AIAMoAgwhBCADIAAoAgAoAhQoAng2AgwCQCABQQFGBEAgBARAIANBAUEsEFIM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8ABqEFcMEQsgAyADKQOAA7lEAAAAAHCZlEGjOQOAASADQegCakHEjQEgA0GAAWoQVwwQCyADIAMoAowDNgKQASADQegCakHitgEgA0GQAWoQVwwPCyADIAMoApgDNgKgASADQegCakHitgEgA0GgAWoQVwwOCyADKAKUA0EMTgRAIANB6AJqQdrtAUHEggEgBEHwAEYbQQIQTQwOCyADQegCakGD7gFB0YMBIARB8ABGG0ECEE0MDQsgAyADKQKUAzcDsAEgA0HoAmpBzrYBIANBsAFqEFcMDAsgAykDgAMhCCADLQCsA0EEcQRAIAMgCEKAxMzyg/kvfblEAAAAAABAj0CjOQPQASADQegCakHxjgEgA0HQAWoQVwwMCyADIAhC6Ad/QsDSjcWRBn03A8ABIANB6AJqQbyqASADQcABahBXDAsLIAMCfyADKwOgAyIGmUQAAAAAAADgQWMEQCAGqgwBC0GAgICAeAsiBDYC4AEgA0HoAmpB4rYBIANB4AFqEFcMCgsgAyADKQKUAzcD8AEgAwJ/IAMrA6ADIgaZRAAAAAAAAOBBYwRAIAaqDAELQYCAgIB4CyIENgL4ASADQegCakHJtgEgA0HwAWoQVwwJCyADQegCakEBIAMpA4ADQoCU5j18QoC4mSl/p0EHbyIFQTBqIglBNyAFGyAJIARB9QBGG8AQUgwICyADIANBgANqEJUOIAMpA4ADQoCU5j18QoC4mSl/p0EHb2tBB2pBB202AoACIANB6AJqQeK2ASADQYACahBXDAcLIANBuAJqIANBgANqQTAQlxMaIANBADoA4QIgAyADKQO4AkEDIAMpA4ADQoDczBR8QoC4mSl/p0EHb2tBgLiZKWysfDcDuAIgA0G4AmoQjw4gAyADQbgCahCVDkEHbUEBajYCkAIgA0HoAmpB4rYBIANBkAJqEFcMBgsgAyADQYADahCVDiADKQOAA0KA3MwUfEKAuJkpf6dBB29rQQdqQQdtNgKgAiADQegCakHitgEgA0GgAmoQVwwFCyADIAMoAogDNgKwAiADQegCakG/tgEgA0GwAmoQVwwECyAEQSVGDQILIANB6AJqEF8MBAsgAyADKAKQAzYCACADQegCakHitgFB57YBIARB5ABGGyADEFcMAQsgA0HoAmpBAUElEFILIAFBAWohAQwACwALIANBsANq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AyQAAkAgAUEBcQRAIABB4D9BfxCZAgwBCyADIAA2AgAgA0EBOwEYIANCADcDECADQuQANwMIIAMgA0EaajYCBCADQfsAEKgOA0AgASAESgRAQgEgAiAEQQJ0aiIFKAIAMwEQhkKEgJCAgICAAoNQBEAgAEGozQFBfxCZAiADELcODAMFIAMQqQ4gAyAFKAIAEF4gBSgCABD9ARC+DiADQToQqA4gAyAFKAIEEKoOIARBAmohBAwCCwALCyADQf0AEKgOIANBAEEAEKsOIABBygAQpAILIANBgAFqJAAL+wQEAX8BfgF/AX8CQCABRQ0AIAApAwggACkDECIEIAKtfEICfFgEQCAAIAJBAmoQ6A4NASAAKQMQIQQLIAAgBEIBfDcDECAAKAIEIASnakEiOgAAA0BBACEFAkAgAAJ+AkACQANAAkAgAiAFQQNyIgZNBEAgBSEDA0AgAiADTQ0CIAEgA2otAABBgJIEai0AAEUNBCADQQFqIQMMAAsACyABIAVqLQAAQYCSBGotAABFBEAgBSEDDAMLIAEgBUEBciIDai0AAEGAkgRqLQAARQ0CIAEgBUECciIDai0AAEGAkgRqLQAARQ0CIAYiAyABai0AAEGAkgRqLQAARQ0CIAVBBGohBQwBCwsgACkDECIEIAIgBSACIAVLGyIDRQ0CGgwBCyACIANLDQIgACkDECEECyAAKAIEIASnaiABIAMQlxMaIAApAxAgA618CyIEQgF8NwMQIAAoAgQgBKdqQSI6AAAMAgsgAwRAIAAoAgQgACgCEGogASADEJcTGiAAIAApAxAgA618NwMQIAIgA2shAiABIANqIQELAkACQAJAIAEtAAAiBUHcAEcEQCAFQSdGDQEgBUEiRw0CCyAAKQMIIAApAxAiBCACrXxCA3xUBEAgACACQQNqEOgODQUgACkDECEECyAAIARCAXw3AxAgACgCBCAEp2pB3AA6AAAgACAAKQMQIgRCAXw3AxAgACgCBCAEp2ogBToAAAwCCyAAIAApAxAiBEIBfDcDECAAKAIEIASnakEnOgAADAELIAApAwggACkDECACrXxCB3xUBEAgACACQQdqEOgODQMLIAAgBRDpDgsgAkEBayECIAFBAWohAQwACwALC2kBAX8gACACKAIAQQEQog4iAwRAIAAgAigCBEEAEKIOIgIEQAJAAkAC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A0EASiEEDAUFIBIgAkECdGooAgAiBCkCBCEHIAUgAkEwbGoiA0IANwMQIANCADcDGCADIAc3AwAgA0IANwMIIAMQ1xAaIAMQ1xAaIARBADYCCCADIARBBGo2AiggAkEBaiECDAELAAsACyABQQE2AgQMAwtBACEEDAELIAooAgwiBUEANgIIIAVBFGohAwN/IAMEfwJAIAMoAhAiAi0AEA0AIAIpAwAgB1INACACKAIMQQBMDQBBASEEIAVBATYCCAsgAygCFCEDDAEFQQALCyECCyABIAIgBHJFNgIICyAGQfABaiQAIAILkgEGAX8BfwF/AX8BfwF/QQEgASgCJCICIAJBAUwbIQUgAUEoaiEGIAEoAighA0EBIQIDQCACIAVGRQRAAkAgACADIAYgAkECdGooAgAiBBDYECIHQQBMBEAgBw0BIAQoAggNAQsgBCEDCyACQQFqIQIMAQsLIAEgAykDGDcDGCABIAMoAgQ2AgQgASADKAIINgIIC+cBBwF+AX8BfwF/AX4BfwF/IAFBKGohByABKQMYIQICQANAIAFBADYCCEEBIQVBACEEAkADQCABKAIkIARKBEACQCAAIAIgByAEQQJ0aigCACIDKQMYELoPQQBMDQAgACADQQEgAiADKAIQEQkAIghFDQAgAUEANgIIIAgPCyADKAIEDQIgAykDGCEGIAMoAggEQCABQQE2AggLIAVBACACIAZRGyEFIARBAWohBCAGIQIMAQsLIAVFDQEMAgsLIAEQ2RALAkAgASgCCEUNACABIAAoAghGDQAgARDaEAsgASACNwMYQQALvAEEAX8BfwF/AX8gASgCLCEDIAEoAighAgJAA0ACQCAEDQAgAigCBCIFBEBBACEEDAMLAkAgACACIAMQ2BAiBUEATARAQQAhBAwBCyAAIANBASACKQMYIAMoAhARCQAhBCAAIAIgAxDYECEFCyAFDQAgAygCCA0AIAAgAkEAQgAgAigCEBEJACEEDAELCyACKAIEIQULIAEgBTYCBCABIAIoAgg2AgggASACKQMYNwMYIAUEQCADENoQCyAEC7EBBgF/AX8BfwF/AX8BfiAAKAIYIgZBKGohByAAKAIcIQQDQCAFIAYoAhhORQRAAkAgByAFQQJ0aigCACIDLQAQDQAgAykDACIIIAApAwBSIAFBAEcgAiAIVXFFcQ0AIAQgAyABIAIQuBAgAUUNAANAIAMtABANASADKQMAIAJZDQEgBCgCLA0BIAQgA0EAQgAQuBAMAAsACyAFQQFqIQUMAQsLIAQoAixFBEAgABC5EAsLXAMBfwF/AX4gAUGoAWohAwNAAkAgACABQQEgAhC4ECAAKAIsDQAgAS0AEA0AIAEoAjgiBEUgAyABKAJILwEEQegAbGopAwAiBSACWXENACAERSACIAVTcg0BCwsLvgUIAX8BfwF/AX8BfwF/AX4BfyMAQRBrIgYkACABQdAAaiEJIAJFIQIDQAJAAkAgACgCLA0AIAEoAkgvAQQhCCAGQQA2AgwgBiAJIAhB6ABsaiIENgIIAkACQAJ/An8CQAJAAkAgAkEBcQ0AIAQoAkQiAkUNAAJAAkAgBCgCBEECcSILBEBBACEFA0AgBQ0CIAIoAhANAiADIAIpAyBZDQIgACACQQAQuhAgACgCLCEFDAALAAsgBCgCCCEHQQAhBQNAAkAgBQ0AIAIoAhANACADIAIpAyBXDQAgAigCGCEHIAAgAhC7ECAAKAIsIQUMAQsLIAcgBCgCCEwNASAHIAQoAgAoAghKDQMgBCgCEBBAIAQgB0EBazYCCCAEQQA2AhADQCAAKAIsDQUgACAEELwQIAQoAgwiAkUNBSACKAIAIgcvAAAiBUEIdCAFQQh2ckH//wNxIgVFDQALIAVBBEkNAyACKAIIIAVMDQMgBCAFIAdqIARB2ABqEL0QIAVqrTcDGCAAIAQQvhAMBAsgAigCGCICIAQoAghODQAgBCACQQFqNgIIIAAgBBC/EAwDCyAFDQJBAAwDCyAAIAQgBkEMaiAEKAIkEQQAIAQoAgxFDAMLIABBiwI2AiwLQQELIQIDQCACRQRAIAAgBEEAIAQoAiQRBABBASECDAELIAQoAgxFDQIgBCkDWCEKAkACQCALRQRAIAMgClUNAQwCCyADIApZDQELIAAoAiwNAEEAIQIMAQsLQQALIgINACAGKAIMDQAgASAIIAZBCGoQwBBFDQELIAAgASAIQQEQwRAgARDCECAGIAkgASgCSC8BBEHoAGxqIgI2AgggAigCDEUNAQsgAS0APARAIAYoAggoAmBFDQILIAEQwxANASABIAYoAgggASgCMBEFAAsgBkEQaiQADwtBASECDAALAAvfBg0BfwF/AX8BfwF/AX8BfwF/AX4BfgF+AX8BfyMAQRBrIg0kACAAQgA3AwggACgCGCICKAIYIgdBACAHQQBKGyEEIAJBKGohBUKAgICAgICAgIB/IQoDQCABIARGRQRAAkAgBSABQQJ0aigCACIDLQAQDQAgCEEAIAMpAwAiCSAKWRtFBEAgACADKAIINgIIIAAgAygCDDYCDEEBIQggASEGIAkhCgwBCyAIIAkgClFqIQgLIAFBAWohAQwBCwsCQCAIRQRAIABBAToAEAwBCyAAKAIcIgEoAgAoAkQhDCAAQQA6ABAgACAKNwMAIAhBAUcgDHJFBEAgASACIAZBACAKQn8QxBAMAQsgDEEBRiAIQQJIcg0AIA1CADcDCCACKAIgRQRAIAIgAUEsaiAHQRxsrRDCDyIBNgIgIAFFDQEgAiABIAIoAhgiB0EYbGo2AiQLQQAhBEEAIQZBACEBA0AgASAHTkUEQCAFIAFBAnRqKAIAIgMpAwAgClEEQCACKAIkIARBAnRqIAE2AgAgAygCCCADKAIMIAIoAiAgBEEYbGoQxRAgAygCDCAGaiEGIAIoAhghByAEQQFqIQQLIAFBAWohAQwBCwsgAEEgaiEHIAAoAiQgBiAIQQpsamoiASAAKAIoSwRAIAAoAhxBLGogByABEIoQDQELAkAgDA0AIAIoAgAiASACKAIEIAZqTg0AIAIoAgggASAGaiIBQTBsEEkiA0UEQCAAKAIcQQc2AiwMAgsgAiADNgIIIAIgAUEBdDYCAAtBACEDIABBADYCJCAEQQAgBEEAShshBANAQv///////////wAhC0EAIQECQANAIAshCSADIQUgASAERwRAIAIoAiAgAUEYbGoiAy0ADQR/IAUFIAMpAxAiCyAJIAkgC1UiAxshCyABIAUgAxsLIQMgAUEBaiEBDAELIAlC////////////AFENASAHIA1BCGogCRDGECACKAIgIAVBGGxqEMcQGkEAIQNC////////////ACELQQAhASAMDQALIAIoAgggAigCBCIDQRhsaiIBIAk3AwggAigCJCAFQQJ0aigCACEFIAEgCjcDACABIAU2AhAgAiADQQFqNgIEQQAhAwwBCwsgACAAKQMgNwMICyANQRBqJAAL6QIIAX8BfwF/AX8BfwF/AX8BfiMAQRBrIgUkACABIAJBBXRqIgRBCGohAwJAAkAgBCgCDCIH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ACAMIAgpAxAiAVEEQCAIEMcQDQEgCCkDECEBCyABIAogASAKUxshCgsgAEEBaiEADAELCyAKQv///////////wBRIAVyRQRAIAIgCUEIaiAKENUQIQUgCiEMDAELCyAFDQAgAyACKAIANgIAIAQgAigCBDYCAAsgCUEQaiAGRwRAIAYQQAsgCUHwAGokACAFC1oDAX8BfwF/IwBBEGsiAyQAIANBADYCDAJAAkAgACgCBEEPaiIFIAAoAghNDQAgA0EMaiAAIAUQihBFDQAgAygCDCEEDAELIAAgASACEMYQCyADQRBqJAAgBAsUACABQQA2AgQgACABIAIgAxC+DwtHACAAIAApAxg3AxAgACgCACAAKAIEIABBCGogAEEYahDTEARAIABCgICAgICAgIDAADcDGAsgACkDEEKAgICAgICAgMAAUQsnACACKAIEBEBBfw8LIAEoAgQEQEEBDwsgACABKQMYIAIpAxgQug8LOgIBfwF/IABCATcCBCAAQShqIQIDQCABIAAoAiRORQRAIAIgAUECdGooAgAQ2RAgAUEBaiEBDAELCwuSAQIBfwF/AkAgACgCACIBQQRGIAFBCUZyRQRAIABBKGohAkEAIQEDQCABIAAoAiRODQIgAiABQQJ0aigCABDaECABQQFqIQEMAAsACyAAKAIgIgEoAggiAEEAIABBAEobIQAgAUEMaiECQQAhAQNAIAAgAUYNASACIAFBAnRqKAIAQQA2AgggAUEBaiEBDAALAAsLvQQLAX8BfwF/AX8BfwF/AX8BfwF/AX8BfyABQgA3AgQCQAJAIAEoAgAiAkEJRyACQQRHcUUEQCABKAIgIgZBDGohCgNAAkAgBigCCCAHTARAQQAhAgwBCyAKIAdBAnRqKAIAIgkoAhBFBEBBASECDAELIAlBFGohC0EAIQgDQAJAIAkoAhAgCEoEQEEAIQQgCyAIQRhsaiIMIQIDQCACRQ0CIAJBEGohAyACKAIQIgUEQCAFEJcQIANBADYCAAsgACgCACACKAIEIAIoAgggACgCDEEAR0EBdCAMLQAAQQBHciAGKAIEIAMQ3BAiAw0IIARBASACKAIQLQAQGyEEIAIoAhQhAgwACwALIAdBAWohBwwDC0EBIQIgCEEBaiEIIAQNAAsLCyABIAI2AgQMAQsCQAJAIAEoAhAEQCABQShqIQZB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fyMAQRBrIgQkAAJAIAEoAjgiA0EASgRAIAEoAgwoAgAhBSABIANBAWsiAzYCOCABIAEoAkAgA0ECdGo0AgA3AxggACABEL4QIAEoAhghAyAAKAIAKAJEQQFHBEAgASgCYCADaiEDCyADIAVqIARBCGoQvRAaIAEgASkDWCAEKQMIfTcDWAwBCyAAIAEQvxALIARBEGokAAvIAwYBfwF/AX8BfwF/AX8jAEEgayIDJAAgAUHYAGohBiAAQSxqIQggASgCGCEEAkADQAJAIAEoAgAiBUUNACAEIAEoAgwoAghIDQAgACABELwQIAAoAiwNAiABKAIMRQ0CIAZCADcDAEEEIQQMAQsLAkACQCABKAI0IARKBEAgASABKAIMKAIAIARqIANBGGoQvRAgBGqsNwMYIAEgASkDWCADKQMYfDcDWAwBCyABLQAEQQFxDQECQCAFBEBBACEFIANBADYCGCABKAIMEIQRIARHBEAgASgCDCgCACAEaiADQRhqEM8QIARqIQQgAygCGCEFCyABIASsNwMYIAAgASAFEOAQDAELIANBADYCGCADQQA2AhQgA0EANgIQIAAoAgwiBCAEKAIQKAIENgIQIAQgA0EUaiADQRBqIANBGGogA0EMahDvECADKAIYIgRFDQIgASgCDCIFIAQ2AgAgBSADKAIMIgc2AgggBSAHNgIEIAEgBzYCNCAIIAFByABqIAMoAhAgAygCFBDWECABIAQgBhC9EK03AxgLIAJFDQAgAkEBNgIACyAAIAEQvhAMAQsgASgCDBBAIAFBADYCDAsgA0EgaiQAC8EGCQF/AX8BfwF/AX4BfwF/AX8BfyMAQSBrIgQkACABKAIMIQUgBEEANgIcAkACQAJAIAEoAmAgASgCGGoiAyAFKAIISARAIAUoAgAhBgJAIAEoAjQgA0wEQEEBIQggBRCEESADRg0BIAMgBmogBEEcahDPECADaiEDDAELIAMgBmogBEEQahC9ECEFIAEgASkDWCAEKQMQfDcDWCADIAVqIQMLIAEgA6w3AxgMAQsCQCABKAIARQRAIARBADYCECAEQQA2AgwgBEEANgIIIARBADYCBCABLQAEQQFxRQRAIAAoAgwiAyADKAIQKAIENgIQIAMgBEEMaiAEQQhqIARBEGogBEEEahDvECAEKAIQIgMNAgsgASgCDBBAIAFBADYC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cUUNCyADKAIAIgZBAEoNAiADLQAEQQJHDQFBACEEA0AgAiAERg0PIAEoAhAgBEEDdGoiA0EAOgAEIANBADYCACAEQQFqIQQMAAsACyAGQf8BcUUNCgsgAygCACIGQQBMDQELIAYgAC0AFU0NAQsgAy0ABEHAAEYNAQwHC0EAIQhBwQAhBwJAIAMtAAQiA0ECaw4HBgcCBwcHAwALIANBEEYNAyADQSBGDQQgA0HAAEcNBgtBASEIQcYAIQcMBAtBxQAhBwwDC0EBIQhBwgAhBwwCC0HDACEHDAELQQEhCEHEACEHCyAFIAlqIgMgBzoAACADIAZBL2o6AAEgASgCECACQQN0aiIDIAg6AAQgAyAFQQJqIgVBAm02AgALIAJBAWohAgwBCwsgAUEBNgIcIAFBAjYCFCAFQQBKBEAgASAFQQFqIgQQPyICNgIYQQcgAkUNBRogAiAJIAQQlxMaCyABIAApAzAgBUECba2HIgs3AzAgASALuUQAAAAAAAAYQKI5AygMAwsFQQEgBCABKAIEIAJBDGxqLQAEQcAARhshBCACQQFqIQIMAQsLIAFBATYCFCABKAIQIAJBA3RqIgJBAToABCACQQE2AgAgAUEBNgI4IAFCATcDMCABQoCAgICAgICfwAA3AygLQQALIQIgCUEwaiQAIAILCQAgABCOEkEAC4EBAQF/IAAgACgCLEEBayIBNgIsIAFFBEAgAEEAOgAYIAAQkBIgACgCTBCOARogACgCUBCOARogACgCVBCOARogACgCWBCOARogACgCXBCOARogACgCYBCOARogACgCZBCOARogACgCaBCOARogACgCbBCOARogACgCQBBAIAAQQAsLjwEDAX8BfwF/IwBBIGsiASQAIAAoAiAhAiABIAAoAiQiAzYCFCABIAI2AhAgASADNgIMIAEgAjYCCCABIAM2AgQgASACNgIAAkBB/KcCIAEQZiIDRQRAQQchAgwBCyAAEJASIAAoAgwgA0EAQQBBABCLASECIAMQQCACDQAgABCOEkEAIQILIAFBIGokACACCxgBAX8gACgCSCEBIABBADYCSCABEJQDGgs8AgF/AX9C+AEQSCICBH8gAkEAQfgBEJkTIAA2AgAgACAAKAI4QQFqNgI4QQAFQQcLIQMgASACNgIAIAMLQQEBfyAAKAIAIQEgABCTEiAAKAIk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A0EQaiQAIAELogEDAX8BfwF/A0AgACACaiIEIAJB1r8Cai0AADoAACACQQ5HIQMgAkEBaiECIAMNAAsgAQRAQQ4hAiABIQMDQCACQQFqIQIgA0EJSyEEIANBCm4hAyAEDQALIAAgAmpBADoAAANAIAAgAkEBayICaiABIAFBCm4iA0EKbGtBMHI6AAAgAUEJSyEEIAMhASAEDQALDwsgBEEwOgAAIABBADoADwtFAQF/IwBBEGsiAyQAIAMgAjYCDCADIAE2AgggACADQQhqQQEgA0EEahAMELcUIQIgAygCBCEBIANBEGokAEF/IAEgAhsLSwEBfyMAQRBrIgMkAEGcfyAAIAEgA0EPaiACGyIBQQEgAiACQQFNGxAcIgJBH3UgAnEgAiABIANBD2pGGxCdFCECIANBEGokACACCwkAIAAQHRCdFAuoAQACQCABQYAITgRAIABEAAAAAAAA4H+iIQAgAUH/D0kEQCABQf8HayEBDAILIABEAAAAAAAA4H+iIQBB/RcgASABQf0XTxtB/g9rIQEMAQsgAUGBeEoNACAARAAAAAAAAGADoiEAIAFBuHBLBEAgAUHJB2ohAQwBCyAARAAAAAAAAGADoiEAQfBoIAEgAUHwaE0bQZIPaiEBCyAAIAFB/wdqrUI0hr+iC8wBAwF/AX8BfCMAQRBrIgEkAAJAIAC9QiCIp0H/////B3EiAkH7w6T/A00EQCACQYCAwPIDSQ0BIABEAAAAAAAAAABBABCwEyEADAELIAJBgIDA/wdPBEAgACAAoSEADAELIAAgARCvEyECIAErAwghACABKwMAIQMCQAJAAkACQCACQQNxQQFrDgMBAgMACyADIABBARCwEyEADAMLIAMgABCtEyEADAILIAMgAEEBELATmiEADAELIAMgABCtE5ohAAsgAUEQaiQAIAALlgEDAXwBfAF+RAAAAAAAAOA/IACmIQICQCAAmSIBvSIDQv////+fyIvDwABYBEAgARDAEyEBIANC//////////c/WARAIANCgICAgICAgKg+VA0CIAIgASABoCABIAGiIAFEAAAAAAAA8D+go6GiDwsgAiABIAEgAUQAAAAAAADwP6CjoKIPCyABIAIgAqAQshMhAAsgAAsqAQF/IwBBEGsiBCQAIAQgAzYCDCAAIAEgAiADELUUIQMgBEEQaiQAIAMLBQAgAJ8LDgBBnH8gACABQQAQ2RMLGgAgACABEI8UIgBBACAALQAAIAFB/wFxRhsL9QEDAX8BfwF/AkACQAJAIAFB/wFxIgQEQCAAQQNxBEAgAUH/AXEhAgNAIAAtAAAiA0UgAiADRnINBSAAQQFqIgBBA3ENAAsLQYCChAggACgCACICayACckGAgYKEeHFBgIGChHhHDQEgBEGBgoQIbCEEA0BBgIKECCACIARzIgNrIANyQYCBgoR4cUGAgYKEeEcNAiAAKAIEIQIgAEEEaiIDIQAgAkGAgoQIIAJrckGAgYKEeHFBgIGChHhGDQALDAILIAAQlRQgAGoPCyAAIQMLA0AgAyIALQAAIgJFDQEgAEEBaiEDIAIgAUH/AXFHDQALCyAAC0wCAX8BfwJAIAAtAAAiAkUgAiABLQAAIgNHcg0AA0AgAS0AASEDIAAtAAEiAkUNASABQQFqIQEgAEEBaiEAIAIgA0YNAAsLIAIgA2sLyQEDAX8BfwF/IwBBIGsiBCQAAkACQCABLAAAIgIEQCABLQABDQELIAAgAhCPFCEDDAELIARBAEEgEJkTGiABLQAAIgIEQANAIAQgAkEDdkEccWoiAyADKAIAQQEgAnRyNgIAIAEtAAEhAiABQQFqIQEgAg0ACwsgACEDIAAtAAAiAkUNACAAIQEDQCAEIAJBA3ZBHHFqKAIAIAJ2QQFxBEAgASEDDAILIAEtAAEhAiABQQFqIgMhASACDQALCyAEQSBqJAAgAyAAawslAgF/AX8gABCVFEEBaiIBEMAUIgJFBEBBAA8LIAIgACABEJcTCx0AIABBACAAQZkBTRtBAXRB4JYFai8BAEHghwVqCwkAIAAgABCTFAuBAQMBfwF/AX8CQAJAIAAiAUEDcUUNACABLQAARQRAQQAPCwNAIAFBAWoiAUEDcUUNASABLQAADQALDAELA0AgASICQQRqIQFBgIKECCACKAIAIgNrIANyQYCBgoR4cUGAgYKEeEYNAAsDQCACIgFBAWohAiABLQAADQALCyABIABrC2MCAX8BfyACRQRAQQAPCyAALQAAIgMEfwJAA0AgAyABLQAAIgRHIARFcg0BIAJBAWsiAkUNASABQQFqIQEgAC0AASEDIABBAWohACADDQALQQAhAwsgAwVBAAsiACABLQAAawsuAQF/IAFB/wFxIQEDQCACRQRAQQAPCyAAIAJBAWsiAmoiAy0AACABRw0ACyADCxEAIAAgASAAEJUUQQFqEJcUC98BAwF/AX8BfyMAQSBrIgRCADcDGCAEQgA3AxAgBEIANwMIIARCADcDACABLQAAIgJFBEBBAA8LIAEtAAFFBEAgACEBA0AgASIDQQFqIQEgAy0AACACRg0ACyADIABrDwsDQCAEIAJBA3ZBHHFqIgMgAygCAEEBIAJ0cjYCACABLQABIQIgAUEBaiEBIAINAAsgACEDAkAgAC0AACICRQ0AIAAhAQNAIAQgAkEDdkEccWooAgAgAnZBAXFFBEAgASEDDAILIAEtAAEhAiABQQFqIgMhASACDQALCyADIABrC60ECwF/AX8BfwF+AX4BfwF/AX8BfwF+AX4jAEEQayIKJAACQAJAAkAgAkEkTARAIAAtAAAiBQ0BIAAhBAwCCxCeE0EcNgIAQgAhAwwCCyAAIQQCQANAIAXAEJsURQ0BIAQtAAEhBSAEQQFqIgYhBCAFDQALDAELAkAgBUH/AXEiBUEraw4DAAEAAQtBf0EAIAVBLUYbIQkgBEEBaiEECwJ/AkAgAkEQckEQRw0AIAQtAABBMEcNAEEBIQsgBC0AAUHfAXFB2ABGBEAgBEECaiEEQRAMAgsgBEEBaiEEIAJBCCACGwwBCyACQQogAhsLIgytIQdBACECA0ACQAJAIAQtAAAiBkEwayIFQf8BcUEKSQ0AIAZB4QBrQf8BcUEZTQRAIAZB1wBrIQUMAQsgBkHBAGtB/wFxQRlLDQEgBkE3ayEFCyAMIAVB/wFxTA0AIAogB0IAIAhCABDIFEEBIQYCQCAKKQMIQgBSDQAgByAIfiINIAWtQv8BgyIOQn+FVg0AIA0gDnwhCEEBIQsgAiEGCyAEQQFqIQQgBiECDAELCyABBEAgASAEIAAgCxs2AgALAkACQCACBEAQnhNBxAA2AgAgCUEAIANCAYMiB1AbIQkgAyEIDAELIAMgCFYNASADQgGDIQcLIAenIAlyRQRAEJ4TQcQANgIAIANCAX0hAwwCCyADIAhaDQAQnhNBxAA2AgAMAQsgCCAJrCIHhSAHfSEDCyAKQRBqJAAgAwsQACAAQSBGIABBCWtBBUlyCxYAIAAgASACQoCAgICAgICAgH8QmhQLHAAgAEGBYE8EQBCeE0EAIABrNgIAQX8hAAsgAAumAwYBfAF8AX4BfwF/AXwgAL0iBUKAgICAgP////8Ag0KBgICA8ITl8j9UIgZFBEBEGC1EVPsh6T8gAJmhRAdcFDMmpoE8IAEgAZogBUIAWSIHG6GgIQBEAAAAAAAAAAAhAQsgACAAIAAgAKIiBKIiCERjVVVVVVXVP6IgBCAIIAQgBKIiAyADIAMgAyADRHNTYNvLdfO+okSmkjegiH4UP6CiRAFl8vLYREM/oKJEKANWySJtbT+gokQ31gaE9GSWP6CiRHr+EBEREcE/oCAEIAMgAyADIAMgA0TUer90cCr7PqJE6afwMg+4Ej+gokRoEI0a9yYwP6CiRBWD4P7I21c/oKJEk4Ru6eMmgj+gokT+QbMbuqGrP6CioKIgAaCiIAGgoCIEoCEDIAZFBEBBASACQQF0a7ciASAAIAQgAyADoiADIAGgo6GgIgMgA6ChIgMgA5ogBxsPCyACBEBEAAAAAAAA8L8gA6MiASABvUKAgICAcIO/IgEgBCADvUKAgICAcIO/IgMgAKGhoiABIAOiRAAAAAAAAPA/oKCiIAGgIQMLIAMLhgECAX8BfyMAQRBrIgEkAAJAIAC9QiCIp0H/////B3EiAkH7w6T/A00EQCACQYCAgPIDSQ0BIABEAAAAAAAAAABBABCeFCEADAELIAJBgIDA/wdPBEAgACAAoSEADAELIAAgARCvEyECIAErAwAgASsDCCACQQFxEJ4UIQALIAFBEGokACAAC9oBAgF8AX4CQCAAmSIBvSICQoCAgICw/eTwP1oEQCACQoCAgICQgICawABaBEBEAAAAAAAAAIAgAaNEAAAAAAAA8D+gIQEMAgtEAAAAAAAA8D9EAAAAAAAAAEAgASABoBDAE0QAAAAAAAAAQKCjoSEBDAELIAJCgICAgPCVlug/WgRAIAEgAaAQwBMiASABRAAAAAAAAABAoKMhAQwBCyACQoCAgICAgIAIVA0AIAFEAAAAAAAAAMCiEMATIgGaIAFEAAAAAAAAAECgoyEBCyABmiABIAC9QgBTGwsFACAAnQsOAEGcfyAAQQAQHhCdFAs/AAJAIAJFBEBBACECDAELIAIoAghB/////wNHDQAgAkEAIAIoAhhB/////wNHGyECCyAAIAEgAiADEB8QnRQLmgEHAX8BfwF/AX8BfwF/AX4jAEEgayIFJAACfwJAIAIEQCAFQRBqIQggBSEEQQEhBwNAIAIgA0EEdGoiAygCCCIGQb+EPUsNAiADKQMAIQkgBCAGQegHbDYCCCAEIAk3AwBBASEDIAchBkEAIQcgCCEEIAYNAAsgBSEDCyAAIAEgA0EAEKMUDAELQWQQnRQLIQQgBUEgaiQAIAQLDABBnH8gACABEKQUCxcBAX8gAEEAIAEQ7BMiAiAAayABIAIbC4IBAgF/AX4gAL0iA0I0iKdB/w9xIgJB/w9HBEAgAkUEQCABIABEAAAAAAAAAABhBH9BAAUgAEQAAAAAAADwQ6IgARCnFCEAIAEoAgBBQGoLIgI2AgAgAA8LIAEgAkH+B2s2AgAgA0L/////////h4B/g0KAgICAgICA8D+EvyEACyAAC+YCBAF/AX8BfwF/IwBB0AFrIgUkACAFIAI2AswBIAVBoAFqQQBBKBCZExogBSAFKALMATYCyAECQEEAIAEgBUHIAWogBUHQAGogBUGgAWogAyAEEKkUQQBIBEBBfyEEDAELIAAoAkxBAEgEf0EBBSAAEMUTRQshByAAIAAoAgAiCEFfcTYCAAJ/AkACQCAAKAIwRQRAIABB0AA2AjAgAEEANgIcIABCADcDECAAKAIsIQYgACAFNgIsDAELIAAoAhANAQtBfyICIAAQ3BMNARoLIAAgASAFQcgBaiAFQdAAaiAFQaABaiADIAQQqRQLIQIgCEEgcSEEIAYEQCAAQQBBACAAKAIkEQIAGiAAQQA2AjAgACAGNgIsIABBADYCHCAAKAIUIQMgAEIANwMQIAJBfyADGyECCyAAIAAoAgAiAyAEcjYCAEF/IAIgA0EgcRshBCAHDQAgABDGEwsgBUHQAWokACAEC78SEwF/AX8BfwF/AX8BfwF/AX8BfwF/AX8BfwF+AX8BfwF/AX8BfwF/IwBBQGoiCCQAIAggATYCPCAIQSdqIRkgCEEoaiESAkACQAJAAkADQEEAIQcDQCABIQ4gByANQf////8Hc0oNAiAHIA1qIQ0CQAJAAkACQAJAIAEiBy0AACIMBEADQAJAAkAgDEH/AXEiDEUEQCAHIQEMAQsgDEElRw0BIAchDANAIAwtAAFBJUcEQCAMIQEMAgsgB0EBaiEHIAwtAAIhCSAMQQJqIgEhDCAJQSVGDQALCyAHIA5rIgcgDUH/////B3MiDEoNCiAABEAgACAOIAcQqhQLIAcNCCAIIAE2AjwgAUEBaiEHQX8hDwJAIAEsAAFBMGsiCUEJSw0AIAEtAAJBJEcNACABQQNqIQdBASEUIAkhDwsgCCAHNgI8QQAhCwJAIAcsAAAiFUEgayIBQR9LBEAgByEJDAELIAchCUEBIAF0IgFBidEEcUUNAANAIAggB0EBaiIJNgI8IAEgC3IhCyAHLAABIhVBIGsiAUEgTw0BIAkhB0EBIAF0IgFBidEEcQ0ACwsCQCAVQSpGBEACfwJAIAksAAFBMGsiB0EJSw0AIAktAAJBJEcNACAJQQNqIQFBASEUAn8gAEUEQCAEIAdBAnRqQQo2AgBBAAwBCyADIAdBA3RqKAIACwwBCyAUDQYgCUEBaiEBIABFBEAgCCABNgI8QQAhFEEAIREMAwsgAiACKAIAIgdBBGo2AgBBACEUIAcoAgALIREgCCABNgI8IBFBAE4NAUEAIBFrIREgC0GAwAByIQsMAQsgCEE8ahCrFCIRQQBIDQsgCCgCPCEBC0EAIQdBfyEKAn9BACABLQAAQS5HDQAaIAEtAAFBKkYEQAJ/AkAgASwAAkEwayIJQQlLDQAgAS0AA0EkRw0AIAFBBGohAQJ/IABFBEAgBCAJQQJ0akEKNgIAQQAMAQsgAyAJQQN0aigCAAsMAQsgFA0GIAFBAmohAUEAIABFDQAaIAIgAigCACIJQQRqNgIAIAkoAgALIQogCCABNgI8IApBAE4MAQsgCCABQQFqNgI8IAhBPGoQqxQhCiAIKAI8IQFBAQshFwNAIAchCUEcIRAgASIVLAAAIgdB+wBrQUZJDQwgAUEBaiEBIAcgCUE6bGpB35gFai0AACIHQQFrQQhJDQALIAggATYCPAJAIAdBG0cEQCAHRQ0NIA9BAE4EQCAARQRAIAQgD0ECdGogBzYCAAwNCyAIIAMgD0EDdGopAwA3AzAMAgsgAEUNCSAIQTBqIAcgAiAGEKwUDAELIA9BAE4NDEEAIQcgAEUNCQsgAC0AAEEgcQ0MIAtB//97cSIYIAsgC0GAwABxGyELQQAhD0H1KSEWIBIhEAJAAkACfwJAAkACQAJAAkACQAJ/AkACQAJAAkACQAJAAkAgFSwAACIHQVNxIAcgB0EPcUEDRhsgByAJGyIHQdgAaw4hBBcXFxcXFxcXEBcJBhAQEBcGFxcXFwIFAxcXChcBFxcEAAsCQCAHQcEAaw4HEBcLFxAQEAALIAdB0wBGDQsMFQsgCCkDMCETQfUpDAULQQAhBwJAAkACQAJAAkACQAJAIAlB/wFxDggAAQIDBB0FBh0LIAgoAjAgDTYCAAwcCyAIKAIwIA02AgAMGwsgCCgCMCANrDcDAAwaCyAIKAIwIA07AQAMGQsgCCgCMCANOgAADBgLIAgoAjAgDTYCAAwXCyAIKAIwIA2sNwMADBYLQQggCiAKQQhNGyEKIAtBCHIhC0H4ACEHCyAIKQMwIhMgEiAHQSBxEK0UIQ4gC0EIcUUgE1ByDQMgB0EEdkH1KWohFkECIQ8MAwsgCCkDMCITIBIQrhQhDiALQQhxRQ0CIAogEiAOayIHQQFqIAcgCkgbIQoMAgsgCCkDMCITQgBTBEAgCEIAIBN9IhM3AzBBASEPQfUpDAELIAtBgBBxBEBBASEPQfYpDAELQfcpQfUpIAtBAXEiDxsLIRYgEyASEK8UIQ4LIBcgCkEASHENEiALQf//e3EgCyAXGyELIBNCAFIgCnJFBEAgEiEOQQAhCgwPCyAKIBNQIBIgDmtqIgcgByAKSBshCgwNCyAILQAwIQcMCwsgCCgCMCIHQd7MAiAHGyIOQf////8HIAogCkH/////B08bEKYUIgcgDmohECAKQQBOBEAgGCELIAchCgwNCyAYIQsgByEKIBAtAAANEAwMCyAIKQMwIhNQRQ0BQQAhBwwJCyAKBEAgCCgCMAwCC0EAIQcgAEEgIBFBACALELAUDAILIAhBADYCDCAIIBM+AgggCCAIQQhqNgIwQX8hCiAIQQhqCyEMQQAhBwNAAkAgDCgCACIJRQ0AIAhBBGogCRC8FCIJQQBIDRAgCSAKIAdrSw0AIAxBBGohDCAHIAlqIgcgCkkNAQsLQT0hECAHQQBIDQ0gAEEgIBEgByALELAUIAdFBEBBACEHDAELQQAhCSAIKAIwIQwDQCAMKAIAIg5FDQEgCEEEaiAOELwUIg4gCWoiCSAHSw0BIAAgCEEEaiAOEKoUIAxBBGohDCAHIAlLDQALCyAAQSAgESAHIAtBgMAAcxCwFCARIAcgByARSBshBwwJCyAXIApBAEhxDQpBPSEQIAAgCCsDMCARIAogCyAHIAURPQAiB0EATg0IDAsLIActAAEhDCAHQQFqIQcMAAsACyAADQogFEUNBEEBIQcDQCAEIAdBAnRqKAIAIgwEQCADIAdBA3RqIAwgAiAGEKwUQQEhDSAHQQFqIgdBCkcNAQwMCwsgB0EKTwRAQQEhDQwLCwNAIAQgB0ECdGooAgANAUEBIQ0gB0EBaiIHQQpHDQALDAoLQRwhEAwHCyAIIAc6ACdBASEKIBkhDiAYIQsMAQsLIAogECAOayIBIAEgCkgbIhUgD0H/////B3NKDQNBPSEQIBEgDyAVaiIJIAkgEUgbIgcgDEoNBCAAQSAgByAJIAsQsBQgACAWIA8QqhQgAEEwIAcgCSALQYCABHMQsBQgAEEwIBUgAUEAELAUIAAgDiABEKoUIABBICAHIAkgC0GAwABzELAUIAgoAjwhAQwBCwsLQQAhDQwDC0E9IRALEJ4TIBA2AgALQX8hDQsgCEFAayQAIA0LGAAgAC0AAEEgcUUEQCABIAIgABDdExoLC3sFAX8BfwF/AX8BfyAAKAIAIgMsAABBMGsiAkEJSwRAQQAPCwNAQX8hBCABQcyZs+YATQRAQX8gAiABQQpsIgFqIAIgAUH/////B3NLGyEECyAAIANBAWoiAjYCACADLAABIQUgBCEBIAIhAyAFQTBrIgJBCkkNAAsgAQvEAgACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQCABQQlrDhIACgsMCgsCAwQFDAsMDAoLBwgJCyACIAIoAgAiAUEEajYCACAAIAEoAgA2AgAPCwALIAIgAigCACIBQQRqNgIAIAAgATIBADcDAA8LIAIgAigCACIBQQRqNgIAIAAgATMBADcDAA8LIAIgAigCACIBQQRqNgIAIAAgATAAADcDAA8LIAIgAigCACIBQQRqNgIAIAAgATEAADcDAA8LAAsgAiACKAIAQQdqQXhxIgFBCGo2AgAgACABKwMAOQMADwsgACACIAMRBQALDwsgAiACKAIAIgFBBGo2AgAgACABNAIANwMADwsgAiACKAIAIgFBBGo2AgAgACABNQIANwMADwsgAiACKAIAQQdqQXhxIgFBCGo2AgAgACABKQMANwMACz0BAX8gAFBFBEADQCABQQFrIgEgAKdBD3FB8JwFai0AACACcjoAACAAQg9WIQMgAEIEiCEAIAMNAAsLIAELNQEBfyAAUEUEQANAIAFBAWsiASAAp0EHcUEwcjoAACAAQgdWIQIgAEIDiCEAIAINAAsLIAELiwEEAX8BfgF/AX8CQCAAQoCAgIAQVARAIAAhAwwBCwNAIAFBAWsiASAAIABCCoAiA0IKfn2nQTByOgAAIABC/////58BViECIAMhACACDQALCyADUEUEQCADpyECA0AgAUEBayIBIAIgAkEKbiIEQQpsa0EwcjoAACACQQlLIQUgBCECIAUNAAsLIAELbAEBfyMAQYACayIFJAAgBEGAwARxIAIgA0xyRQRAIAUgASACIANrIgNBgAIgA0GAAkkiAhsQmRMaIAJFBEADQCAAIAVBgAIQqhQgA0GAAmsiA0H/AUsNAAsLIAAgBSADEKoUCyAFQYACaiQACxEAIAAgASACQfAEQfEEEKgUC9EYFgF/AX8BfwF/AX8BfwF/AX8BfwF/AX8BfAF/AX8BfgF/AX8BfwF/AX8BfgF+IwBBsARrIgwkACAMQQA2AiwCQCABELQUIhRCAFMEQEEBIRJB/ykhFSABmiIBELQUIRQMAQsgBEGAEHEEQEEBIRJBgiohFQwBC0GFKkGAKiAEQQFxIhIbIRUgEkUhGQsCQCAUQoCAgICAgID4/wCDQoCAgICAgID4/wBRBEAgAEEgIAIgEkEDaiIGIARB//97cRCwFCAAIBUgEhCqFCAAQeWBAUGQ7QEgBUEgcSIHG0GQjgFB8vwBIAcbIAEgAWIbQQMQqhQgAEEgIAIgBiAEQYDAAHMQsBQgAiAGIAIgBkobIQoMAQsgDEEQaiETAkACfwJAIAEgDEEsahCnFCIBIAGgIgFEAAAAAAAAAABiBEAgDCAMKAIsIgZBAWs2AiwgBUEgciIXQeEARw0BDAMLIAVBIHIiF0HhAEYNAiAMKAIsIRZBBiADIANBAEgbDAELIAwgBkEdayIWNgIsIAFEAAAAAAAAsEGiIQFBBiADIANBAEgbCyELIAxBMGpBoAJBACAWQQBOG2oiECEHA0AgBwJ/IAFEAAAAAAAA8EFjIAFEAAAAAAAAAABmcQRAIAGrDAELQQALIgY2AgAgB0EEaiEHIAEgBrihRAAAAABlzc1BoiIBRAAAAAAAAAAAYg0ACwJAIBZBAEwEQCAWIQggByEGIBAhCQwBCyAQIQkgFiEIA0BBHSAIIAhBHU8bIQgCQCAHQQRrIgYgCUkNACAIrSEbQgAhFANAIAYgFEL/////D4MgBjUCACAbhnwiGiAaQoCU69wDgCIUQoCU69wDfn0+AgAgBkEEayIGIAlPDQALIBpCgJTr3ANUDQAgCUEEayIJIBQ+AgALA0AgCSAHIgZJBEAgBkEEayIHKAIARQ0BCwsgDCAMKAIsIAhrIgg2AiwgBiEHIAhBAEoNAAsLIAhBAEgEQCALQRlqQQluQQFqIQ4gF0HmAEYhGANAQQlBACAIayIHIAdBCU8bIQoCQCAGIAlNBEAgCSgCAEVBAnQhBwwBC0GAlOvcAyAKdiENQX8gCnRBf3MhD0EAIQggCSEHA0AgByAHKAIAIgMgCnYgCGo2AgAgAyAPcSANbCEIIAdBBGoiByAGSQ0ACyAJKAIARUECdCEHIAhFDQAgBiAINgIAIAZBBGohBgsgDCAMKAIsIApqIgg2AiwgECAHIAlqIgkgGBsiByAOQQJ0aiAGIAYgB2tBAnUgDkobIQYgCEEASA0ACwtBACEIAkAgBiAJTQ0AIBAgCWtBAnVBCWwhCEEKIQcgCSgCACIDQQpJDQADQCAIQQFqIQggAyAHQQpsIgdPDQALCyALIAhBACAXQeYARxtrIBdB5wBGIAtBAEdxayIHIAYgEGtBAnVBCWxBCWtIBEAgDEEwakGEYEGkYiAWQQBIG2ogB0GAyABqIgNBCW0iDUECdGohCkEKIQcgAyANQQlsayIDQQdMBEADQCAHQQpsIQcgA0EBaiIDQQhHDQALCwJAIAooAgAiAyADIAduIg4gB2xrIg1FIApBBGoiDyAGRnENAAJAIA5BAXFFBEBEAAAAAAAAQEMhASAHQYCU69wDRyAJIApPcg0BIApBBGstAABBAXFFDQELRAEAAAAAAEBDIQELRAAAAAAAAOA/RAAAAAAAAPA/RAAAAAAAAPg/IAYgD0YbRAAAAAAAAPg/IA0gB0EBdiIPRhsgDSAPSRshEQJAIBkNACAVLQAAQS1HDQAgEZohESABmiEBCyAKIAMgDWsiAzYCACABIBGgIAFhDQAgCiADIAdqIgc2AgAgB0GAlOvcA08EQANAIApBADYCACAJIApBBGsiCksEQCAJQQRrIglBADYCAAsgCiAKKAIAQQFqIgc2AgAgB0H/k+vcA0sNAAsLIBAgCWtBAnVBCWwhCEEKIQcgCSgCACIDQQpJDQADQCAIQQFqIQggAyAHQQpsIgdPDQALCyAKQQRqIgcgBiAGIAdLGyEGCwNAIAYiByAJTSIDRQRAIAZBBGsiBigCAEUNAQsLAkAgF0HnAEcEQCAEQQhxIQ0MAQsgCEF/c0F/IAtBASALGyIGIAhKIAhBe0pxIgobIAZqIQtBf0F+IAobIAVqIQUgBEEIcSINDQBBdyEGAkAgAw0AIAdBBGsoAgAiCkUNAEEKIQNBACEGIApBCnANAANAIAYiDUEBaiEGIAogA0EKbCIDcEUNAAsgDUF/cyEGCyAHIBBrQQJ1QQlsIQMgBUFfcUHGAEYEQEEAIQ0gCyADIAZqQQlrIgZBACAGQQBKGyIGIAYgC0obIQsMAQtBACENIAsgAyAIaiAGakEJayIGQQAgBkEAShsiBiAGIAtKGyELC0F/IQogC0H9////B0H+////ByALIA1yIg8bSg0BIAsgD0EAR2pBAWohAwJAIAVBX3EiGEHGAEYEQCAIIANB/////wdzSg0DIAhBACAIQQBKGyEGDAELIBMgCCAIQR91IgZzIAZrrSATEK8UIgZrQQFMBEADQCAGQQFrIgZBMDoAACATIAZrQQJIDQALCyAGQQJrIg4gBToAACAGQQFrQS1BKyAIQQBIGzoAACATIA5rIgYgA0H/////B3NKDQILIAMgBmoiBiASQf////8Hc0oNASAAQSAgAiAGIBJqIgUgBBCwFCAAIBUgEhCqFCAAQTAgAiAFIARBgIAEcxCwFAJAAkACQCAYQcYARgRAIAxBEGpBCXIhCCAQIAkgCSAQSxsiAyEJA0AgCTUCACAIEK8UIQYCQCADIAlHBEAgBiAMQRBqTQ0BA0AgBkEBayIGQTA6AAAgBiAMQRBqSw0ACwwBCyAGIAhHDQAgBkEBayIGQTA6AAALIAAgBiAIIAZrEKoUIAlBBGoiCSAQTQ0ACyAPBEAgAEGbwAJBARCqFAsgC0EATCAHIAlNcg0BA0AgCTUCACAIEK8UIgYgDEEQaksEQANAIAZBAWsiBkEwOgAAIAYgDEEQaksNAAsLIAAgBkEJIAsgC0EJThsQqhQgC0EJayEGIAlBBGoiCSAHTw0DIAtBCUohAyAGIQsgAw0ACwwCCwJAIAtBAEgNACAHIAlBBGogByAJSxshCiAMQRBqQQlyIQggCSEHA0AgCCAHNQIAIAgQrxQiBkYEQCAGQQFrIgZBMDoAAAsCQCAHIAlHBEAgBiAMQRBqTQ0BA0AgBkEBayIGQTA6AAAgBiAMQRBqSw0ACwwBCyAAIAZBARCqFCAGQQFqIQYgCyANckUNACAAQZvAAkEBEKoUCyAAIAYgCCAGayIDIAsgAyALSBsQqhQgCyADayELIAdBBGoiByAKTw0BIAtBAE4NAAsLIABBMCALQRJqQRJBABCwFCAAIA4gEyAOaxCqFAwCCyALIQYLIABBMCAGQQlqQQlBABCwFAsgAEEgIAIgBSAEQYDAAHMQsBQgAiAFIAIgBUobIQoMAQsgFSAFQRp0QR91QQlxaiEOAkAgA0ELSw0AQQwgA2shBkQAAAAAAAAwQCERA0AgEUQAAAAAAAAwQKIhESAGQQFrIgYNAAsgDi0AAEEtRgRAIBEgAZogEaGgmiEBDAELIAEgEaAgEaEhAQsgEyAMKAIsIgcgB0EfdSIGcyAGa60gExCvFCIGRgRAIAZBAWsiBkEwOgAAIAwoAiwhBwsgEkECciENIAVBIHEhCSAGQQJrIg8gBUEPajoAACAGQQFrQS1BKyAHQQBIGzoAACAEQQhxRSADQQBMcSEIIAxBEGohBwNAIAciBgJ/IAGZRAAAAAAAAOBBYwRAIAGqDAELQYCAgIB4CyIHQfCcBWotAAAgCXI6AAAgASAHt6FEAAAAAAAAMECiIgFEAAAAAAAAAABhIAhxIAZBAWoiByAMQRBqa0EBR3JFBEAgBkEuOgABIAZBAmohBwsgAUQAAAAAAAAAAGINAAtBfyEKIANB/f///wcgDSATIA9rIglqIghrSg0AIABBICACIAggA0ECaiAHIAxBEGprIgYgBkECayADSBsgBiADGyIDaiIHIAQQsBQgACAOIA0QqhQgAEEwIAIgByAEQYCABHMQsBQgACAMQRBqIAYQqhQgAEEwIAMgBmtBAEEAELAUIAAgDyAJEKoUIABBICACIAcgBEGAwABzELAUIAIgByACIAdKGyEKCyAMQbAEaiQAIAoLKwEBfyABIAEoAgBBB2pBeHEiAkEQajYCACAAIAIpAwAgAikDCBDLFDkDAAsFACAAvQuKAQIBfwF/IwBBoAFrIgQkACAEIAAgBEGeAWogARsiADYClAEgBCABQQFrIgVBACABIAVPGzYCmAEgBEEAQZABEJkTIgRBfzYCTCAEQfIENgIkIARBfzYCUCAEIARBnwFqNgIsIAQgBEGUAWo2AlQgAEEAOgAAIAQgAiADELEUIQEgBEGgAWokACABC7IBBQF/AX8BfwF/AX8gACgCVCIDKAIAIQUgAygCBCIEIAAoAhQgACgCHCIHayIGIAQgBkkbIgYEQCAFIAcgBhCXExogAyADKAIAIAZqIgU2AgAgAyADKAIEIAZrIgQ2AgQLIAQgAiACIARLGyIEBEAgBSABIAQQlxMaIAMgAygCACAEaiIFNgIAIAMgAygCBCAEazYCBAsgBUEAOgAAIAAgACgCLCIDNgIcIAAgAzYCFCACCxUAIABFBEBBAA8LEJ4TIAA2AgBBfwszAQF/IwBBIGsiASQAIAAgAUEIahAgIgAEfxCeEyAANgIAQQAFQQELIQAgAUEgaiQAIAALBgBB1M8HCxcAQbTQB0GQzgc2AgBB7M8HEOYTNgIAC44CAQF/QQEhAwJAIAAEQCABQf8ATQ0BAkAQuRQoAmAoAgBFBEAgAUGAf3FBgL8DRg0DDAELIAFB/w9NBEAgACABQT9xQYABcjoAASAAIAFBBnZBwAFyOgAAQQIPCyABQYBAcUGAwANHIAFBgLADT3FFBEAgACABQT9xQYABcjoAAiAAIAFBDHZB4AFyOgAAIAAgAUEGdkE/cUGAAXI6AAFBAw8LIAFBgIAEa0H//z9NBEAgACABQT9xQYABcjoAAyAAIAFBEnZB8AFyOgAAIAAgAUEGdkE/cUGAAXI6AAIgACABQQx2QT9xQYABcjoAAUEEDwsLEJ4TQRk2AgBBfyEDCyADDwsgACABOgAAQQELFAAgAEUEQEEADwsgACABQQAQuxQLRQEBfyMAQRBrIgMkACADIAI2AgwgAyABNgIIIAAgA0EIakEBIANBBGoQCxC3FCECIAMoAgQhASADQRBqJABBfyABIAIbCwcAPwBBEHQLUQIBfwF/QbiJBigCACIBIABBB2pBeHEiAmohAAJAIAJBACAAIAFNG0UEQBC+FCAATw0BIAAQIQ0BCxCeE0EwNgIAQX8PC0G4iQYgADYCACABC7chCwF/AX8BfwF/AX8BfwF/AX8BfwF/AX8jAEEQayIKJAACQAJAAkACQAJAAkACQAJAAkACQCAAQfQBTQRAQdjQBygCACIGQRAgAEELakH4A3EgAEELSRsiBUEDdiIBdiIAQQNxBEACQCAAQX9zQQFxIAFqIgVBA3QiAUGA0QdqIgAgAUGI0QdqKAIAIgEoAggiAkYEQEHY0AcgBkF+IAV3cTYCAAwBCyACIAA2AgwgACACNgIICyABQQhqIQAgASAFQQN0IgVBA3I2AgQgASAFaiIBIAEoAgRBAXI2AgQMCwsgBUHg0AcoAgAiB00NASAABEACQCAAIAF0QQIgAXQiAEEAIABrcnFoIgFBA3QiAEGA0QdqIgIgAEGI0QdqKAIAIgAoAggiA0YEQEHY0AcgBkF+IAF3cSIGNgIADAELIAMgAjYCDCACIAM2AggLIAAgBUEDcjYCBCAAIAVqIgMgAUEDdCIBIAVrIgVBAXI2AgQgACABaiAFNgIAIAcEQCAHQXhxQYDRB2ohAkHs0AcoAgAhAQJ/IAZBASAHQQN2dCIEcUUEQEHY0AcgBCAGcjYCACACDAELIAIoAggLIQQgAiABNgIIIAQgATYCDCABIAI2AgwgASAENgIICyAAQQhqIQBB7NAHIAM2AgBB4NAHIAU2AgAMCwtB3NAHKAIAIgtFDQEgC2hBAnRBiNMHaigCACIDKAIEQXhxIAVrIQEgAyECA0ACQCACKAIQIgBFBEAgAigCFCIARQ0BCyAAKAIEQXhxIAVrIgIgASABIAJLIgIbIQEgACADIAIbIQMgACECDAELCyADKAIYIQggAyADKAIMIgBHBEAgAygCCCICIAA2AgwgACACNgIIDAoLIAMoAhQiAgR/IANBFGoFIAMoAhAiAkUNAyADQRBqCyEEA0AgBCEJIAIiAEEUaiEEIAAoAhQiAg0AIABBEGohBCAAKAIQIgINAAsgCUEANgIADAkLQX8hBSAAQb9/Sw0AIABBC2oiAUF4cSEFQdzQBygCACIIRQ0AQR8hByAAQfT//wdNBEAgBUEmIAFBCHZnIgBrdkEBcSAAQQF0a0E+aiEHC0EAIAVrIQECQAJAAkAgB0ECdEGI0wdqKAIAIgJFBEBBACEADAELQQAhACAFQRkgB0EBdmtBACAHQR9HG3QhAwNAAkAgAigCBEF4cSAFayIGIAFPDQAgAiEEIAYiAQ0AQQAhASACIQAMAwsgACACKAIUIgYgBiACIANBHXZBBHFqKAIQIglGGyAAIAYbIQAgA0EBdCEDIAkiAg0ACwsgACAEckUEQEEAIQRBAiAHdCIAQQAgAGtyIAhxIgBFDQMgAGhBAnRBiNMHaigCACEACyAARQ0BCwNAIAAoAgRBeHEgBWsiBiABSSEDIAYgASADGyEBIAAgBCADGyEEIAAoAhAiAkUEQCAAKAIUIQILIAIiAA0ACwsgBEUNACABQeDQBygCACAFa08NACAEKAIYIQkgBCAEKAIMIgBHBEAgBCgCCCICIAA2AgwgACACNgIIDAgLIAQoAhQiAgR/IARBFGoFIAQoAhAiAkUNAyAEQRBqCyEDA0AgAyEGIAIiAEEUaiEDIAAoAhQiAg0AIABBEGohAyAAKAIQIgINAAsgBkEANgIADAcLIAVB4NAHKAIAIgBNBEBB7NAHKAIAIQECQCAAIAVrIgJBEE8EQCABIAVqIgMgAkEBcjYCBCAAIAFqIAI2AgAgASAFQQNyNgIEDAELIAEgAEEDcjYCBCAAIAFqIgAgACgCBEEBcjYCBEEAIQNBACECC0Hg0AcgAjYCAEHs0AcgAzYCACABQQhqIQAMCQsgBUHk0AcoAgAiA0kEQEHk0AcgAyAFayIBNgIAQfDQB0Hw0AcoAgAiACAFaiICNgIAIAIgAUEBcjYCBCAAIAVBA3I2AgQgAEEIaiEADAkLQQAhACAFQS9qIgcCf0Gw1AcoAgAEQEG41AcoAgAMAQtBvNQHQn83AgBBtNQHQoCggICAgAQ3AgBBsNQHIApBDGpBcHFB2KrVqgVzNgIAQcTUB0EANgIAQZTUB0EANgIAQYAgCyIBaiIGQQAgAWsiCXEiBCAFTQ0IQZDUBygCACIBBEBBiNQHKAIAIgIgBGoiCCACTSABIAhJcg0JCwJAQZTUBy0AAEEEcUUEQAJAAkACQAJAQfDQBygCACIBBEBBmNQHIQADQCAAKAIAIgIgAU0EQCABIAIgACgCBGpJDQMLIAAoAggiAA0ACwtBABC/FCIDQX9GDQMgBCEGQbTUBygCACIAQQFrIgEgA3EEQCAEIANrIAEgA2pBACAAa3FqIQYLIAUgBk8NA0GQ1AcoAgAiAARAQYjUBygCACIBIAZqIgIgAU0gACACSXINBAsgBhC/FCIAIANHDQEMBQsgBiADayAJcSIGEL8UIgMgACgCACAAKAIEakYNASADIQALIABBf0YNASAFQTBqIAZNBEAgACEDDAQLQbjUBygCACIBIAcgBmtqQQAgAWtxIgEQvxRBf0YNASABIAZqIQYgACEDDAMLIANBf0cNAgtBlNQHQZTUBygCAEEEcjYCAAsgBBC/FCIDQX9GQQAQvxQiAEF/RnIgACADTXINBSAAIANrIgYgBUEoak0NBQtBiNQHQYjUBygCACAGaiIANgIAQYzUBygCACAASQRAQYzUByAANgIACwJAQfDQBygCACIBBEBBmNQHIQADQCADIAAoAgAiAiAAKAIEIgRqRg0CIAAoAggiAA0ACwwEC0Ho0AcoAgAiAEEAIAAgA00bRQRAQejQByADNgIAC0EAIQBBnNQHIAY2AgBBmNQHIAM2AgBB+NAHQX82AgBB/NAHQbDUBygCADYCAEGk1AdBADYCAANAIABBA3QiAUGI0QdqIAFBgNEHaiICNgIAIAFBjNEHaiACNgIAIABBAWoiAEEgRw0AC0Hk0AcgBkEoayIAQXggA2tBB3EiAWsiAjYCAEHw0AcgASADaiIBNgIAIAEgAkEBcjYCBCAAIANqQSg2AgRB9NAHQcDUBygCADYCAAwECyABIAJJIAEgA09yDQIgACgCDEEIcQ0CIAAgBCAGajYCBEHw0AcgAUF4IAFrQQdxIgBqIgI2AgBB5NAHQeTQBygCACAGaiIDIABrIgA2AgAgAiAAQQFyNgIEIAEgA2pBKDYCBEH00AdBwNQHKAIANgIADAMLQQAhAAwGC0EAIQAMBAtB6NAHKAIAIANLBEBB6NAHIAM2AgALIAMgBmohAkGY1AchAAJAA0AgAiAAKAIAIgRHBEAgACgCCCIADQEMAgsLIAAtAAxBCHFFDQMLQZjUByEAA0ACQCAAKAIAIgIgAU0EQCABIAIgACgCBGoiAkkNAQsgACgCCCEADAELC0Hk0AcgBkEoayIAQXggA2tBB3EiBGsiCTYCAEHw0AcgAyAEaiIENgIAIAQgCUEBcjYCBCAAIANqQSg2AgRB9NAHQcDUBygCADYCACABIAJBJyACa0EHcWpBL2siACAAIAFBEGpJGyIEQRs2AgQgBEGg1AcpAgA3AhAgBEGY1AcpAgA3AghBoNQHIARBCGo2AgBBnNQHIAY2AgBBmNQHIAM2AgBBpNQHQQA2AgAgBEEYaiEAA0AgAEEHNgIEIABBCGohAyAAQQRqIQAgAiADSw0ACyABIARGDQAgBCAEKAIEQX5xNgIEIAEgBCABayIDQQFyNgIEIAQgAzYCAAJ/IANB/wFNBEAgA0F4cUGA0QdqIQACf0HY0AcoAgAiAkEBIANBA3Z0IgNxRQRAQdjQByACIANyNgIAIAAMAQsgACgCCAshAiAAIAE2AgggAiABNgIMQQghBEEMDAELQR8hACADQf///wdNBEAgA0EmIANBCHZnIgBrdkEBcSAAQQF0a0E+aiEACyABIAA2AhwgAUIANwIQIABBAnRBiNMHaiECAkACQEHc0AcoAgAiBEEBIAB0IgZxRQRAQdzQByAEIAZyNgIAIAIgATYCAAwBCyADQRkgAEEBdmtBACAAQR9HG3QhACACKAIAIQQDQCAEIgIoAgRBeHEgA0YNAiAAQR12IQQgAEEBdCEAIAIgBEEEcWoiBigCECIEDQALIAYgATYCEAsgASACNgIYQQwhBCABIQIgASEAQQgMAQsgAigCCCIAIAE2AgwgAiABNgIIIAEgADYCCEEAIQBBDCEEQRgLIQMgASAEaiACNgIAIAEgA2ogADYCAAtB5NAHKAIAIgAgBU0NAEHk0AcgACAFayIBNgIAQfDQB0Hw0AcoAgAiACAFaiICNgIAIAIgAUEBcjYCBCAAIAVBA3I2AgQgAEEIaiEADAQLEJ4TQTA2AgBBACEADAMLIAAgAzYCACAAIAAoAgQgBmo2AgQgAyAEIAUQwRQhAAwCCwJAIAlFDQACQCAEKAIcIgNBAnRBiNMHaiICKAIAIARGBEAgAiAANgIAIAANAUHc0AcgCEF+IAN3cSIINgIADAILAkAgBCAJKAIQRgRAIAkgADYCEAwBCyAJIAA2AhQLIABFDQELIAAgCTYCGCAEKAIQIgIEQCAAIAI2AhAgAiAANgIYCyAEKAIUIgJFDQAgACACNgIUIAIgADYCGAsCQCABQQ9NBEAgBCABIAVqIgBBA3I2AgQgACAEaiIAIAAoAgRBAXI2AgQMAQsgBCAFQQNyNgIEIAQgBWoiAyABQQFyNgIEIAEgA2ogATYCACABQf8BTQRAIAFBeHFBgNEHaiEAAn9B2NAHKAIAIgVBASABQQN2dCIBcUUEQEHY0AcgASAFcjYCACAADAELIAAoAggLIQEgACADNgIIIAEgAzYCDCADIAA2AgwgAyABNgIIDAELQR8hACABQf///wdNBEAgAUEmIAFBCHZnIgBrdkEBcSAAQQF0a0E+aiEACyADIAA2AhwgA0IANwIQIABBAnRBiNMHaiEFAkACQCAIQQEgAHQiAnFFBEBB3NAHIAIgCHI2AgAgBSADNgIADAELIAFBGSAAQQF2a0EAIABBH0cbdCEAIAUoAgAhAgNAIAIiBSgCBEF4cSABRg0CIABBHXYhAiAAQQF0IQAgBSACQQRxaiIGKAIQIgINAAsgBiADNgIQCyADIAU2AhggAyADNgIMIAMgAzYCCAwBCyAFKAIIIgAgAzYCDCAFIAM2AgggA0EANgIYIAMgBTYCDCADIAA2AggLIARBCGohAAwBCwJAIAhFDQACQCADKAIcIgRBAnRBiNMHaiICKAIAIANGBEAgAiAANgIAIAANAUHc0AcgC0F+IAR3cTYCAAwCCwJAIAMgCCgCEEYEQCAIIAA2AhAMAQsgCCAANgIUCyAARQ0BCyAAIAg2AhggAygCECICBEAgACACNgIQIAIgADYCGAsgAygCFCICRQ0AIAAgAjYCFCACIAA2AhgLAkAgAUEPTQRAIAMgASAFaiIAQQNyNgIEIAAgA2oiACAAKAIEQQFyNgIEDAELIAMgBUEDcjYCBCADIAVqIgUgAUEBcjYCBCABIAVqIAE2AgAgBwRAIAdBeHFBgNEHaiECQezQBygCACEAAn9BASAHQQN2dCIEIAZxRQRAQdjQByAEIAZyNgIAIAIMAQsgAigCCAshBCACIAA2AgggBCAANgIMIAAgAjYCDCAAIAQ2AggLQezQByAFNgIAQeDQByABNgIACyADQQhqIQALIApBEGokACAAC9QHBwF/AX8BfwF/AX8BfwF/IABBeCAAa0EHcWoiByACQQNyNgIEIAFBeCABa0EHcWoiBCACIAdqIgNrIQACQEHw0AcoAgAgBEYEQEHw0AcgAzYCAEHk0AdB5NAHKAIAIABqIgI2AgAgAyACQQFyNgIEDAELQezQBygCACAERgRAQezQByADNgIAQeDQB0Hg0AcoAgAgAGoiAjYCACADIAJBAXI2AgQgAiADaiACNgIADAELIAQoAgQiAUEDcUEBRgRAIAFBeHEhCCAEKAIMIQICQCABQf8BTQRAIAQoAggiBSACRgRAQdjQB0HY0AcoAgBBfiABQQN2d3E2AgAMAgsgBSACNgIMIAIgBTYCCAwBCyAEKAIYIQYCQCACIARHBEAgBCgCCCIBIAI2AgwgAiABNgIIDAELAkAgBCgCFCIBBH8gBEEUagUgBCgCECIBRQ0BIARBEGoLIQUDQCAFIQkgASICQRRqIQUgAigCFCIBDQAgAkEQaiEFIAIoAhAiAQ0ACyAJQQA2AgAMAQtBACECCyAGRQ0AAkAgBCgCHCIFQQJ0QYjTB2oiASgCACAERgRAIAEgAjYCACACDQFB3NAHQdzQBygCAEF+IAV3cTYCAAwCCwJAIAQgBigCEEYEQCAGIAI2AhAMAQsgBiACNgIUCyACRQ0BCyACIAY2AhggBCgCECIBBEAgAiABNgIQIAEgAjYCGAsgBCgCFCIBRQ0AIAIgATYCFCABIAI2AhgLIAQgCGoiBCgCBCEBIAAgCGohAAsgBCABQX5xNgIEIAMgAEEBcjYCBCAAIANqIAA2AgAgAEH/AU0EQCAAQXhxQYDRB2ohAgJ/QdjQBygCACIBQQEgAEEDdnQiAHFFBEBB2NAHIAAgAXI2AgAgAgwBCyACKAIICyEAIAIgAzYCCCAAIAM2AgwgAyACNgIMIAMgADYCCAwBC0EfIQIgAEH///8HTQRAIABBJiAAQQh2ZyICa3ZBAXEgAkEBdGtBPmohAgsgAyACNgIcIANCADcCECACQQJ0QYjTB2ohAQJAAkBB3NAHKAIAIgVBASACdCIEcUUEQEHc0AcgBCAFcjYCACABIAM2AgAMAQsgAEEZIAJBAXZrQQAgAkEfRxt0IQIgASgCACEFA0AgBSIBKAIEQXhxIABGDQIgAkEddiEFIAJBAXQhAiABIAVBBHFqIgQoAhAiBQ0ACyAEIAM2AhALIAMgATYCGCADIAM2AgwgAyADNgIIDAELIAEoAggiAiADNgIMIAEgAzYCCCADQQA2AhggAyABNgIMIAMgAjYCCAsgB0EIaguODAcBfwF/AX8BfwF/AX8BfwJAIABFDQAgAEEIayIDIABBBGsoAgAiAUF4cSIAaiEEAkAgAUEBcQ0AIAFBAnFFDQEgAyADKAIAIgJrIgNB6NAHKAIASQ0BIAAgAmohAAJAAkACQEHs0AcoAgAgA0cEQCADKAIMIQEgAkH/AU0EQCABIAMoAggiBUcNAkHY0AdB2NAHKAIAQX4gAkEDdndxNgIADAULIAMoAhghBiABIANHBEAgAygCCCICIAE2AgwgASACNgIIDAQLIAMoAhQiAgR/IANBFGoFIAMoAhAiAkUNAyADQRBqCyEFA0AgBSEHIAIiAUEUaiEFIAEoAhQiAg0AIAFBEGohBSABKAIQIgINAAsgB0EANgIADAMLIAQoAgQiAUEDcUEDRw0DQeDQByAANgIAIAQgAUF+cTYCBCADIABBAXI2AgQgBCAANgIADwsgBSABNgIMIAEgBTYCCAwCC0EAIQELIAZFDQACQCADKAIcIgVBAnRBiNMHaiICKAIAIANGBEAgAiABNgIAIAENAUHc0AdB3NAHKAIAQX4gBXdxNgIADAILAkAgAyAGKAIQRgRAIAYgATYCEAwBCyAGIAE2AhQLIAFFDQELIAEgBjYCGCADKAIQIgIEQCABIAI2AhAgAiABNgIYCyADKAIUIgJFDQAgASACNgIUIAIgATYCGAsgAyAETw0AIAQoAgQiAkEBcUUNAAJAAkACQAJAIAJBAnFFBEBB8NAHKAIAIARGBEBB8NAHIAM2AgBB5NAHQeTQBygCACAAaiIANgIAIAMgAEEBcjYCBCADQezQBygCAEcNBkHg0AdBADYCAEHs0AdBADYCAA8LQezQBygCACAERgRAQezQByADNgIAQeDQB0Hg0AcoAgAgAGoiADYCACADIABBAXI2AgQgACADaiAANgIADwsgAkF4cSAAaiEAIAQoAgwhASACQf8BTQRAIAQoAggiBSABRgRAQdjQB0HY0AcoAgBBfiACQQN2d3E2AgAMBQsgBSABNgIMIAEgBTYCCAwECyAEKAIYIQYgASAERwRAIAQoAggiAiABNgIMIAEgAjYCCAwDCyAEKAIUIgIEfyAEQRRqBSAEKAIQIgJFDQIgBEEQagshBQNAIAUhByACIgFBFGohBSABKAIUIgINACABQRBqIQUgASgCECICDQALIAdBADYCAAwCCyAEIAJBfnE2AgQgAyAAQQFyNgIEIAAgA2ogADYCAAwDC0EAIQELIAZFDQACQCAEKAIcIgVBAnRBiNMHaiICKAIAIARGBEAgAiABNgIAIAENAUHc0AdB3NAHKAIAQX4gBXdxNgIADAILAkAgBCAGKAIQRgRAIAYgATYCEAwBCyAGIAE2AhQLIAFFDQELIAEgBjYCGCAEKAIQIgIEQCABIAI2AhAgAiABNgIYCyAEKAIUIgJFDQAgASACNgIUIAIgATYCGAsgAyAAQQFyNgIEIAAgA2ogADYCACADQezQBygCAEcNAEHg0AcgADYCAA8LIABB/wFNBEAgAEF4cUGA0QdqIQECf0HY0AcoAgAiAkEBIABBA3Z0IgBxRQRAQdjQByAAIAJyNgIAIAEMAQsgASgCCAshACABIAM2AgggACADNgIMIAMgATYCDCADIAA2AggPC0EfIQEgAEH///8HTQRAIABBJiAAQQh2ZyIBa3ZBAXEgAUEBdGtBPmohAQsgAyABNgIcIANCADcCECABQQJ0QYjTB2ohBQJ/AkACf0Hc0AcoAgAiAkEBIAF0IgRxRQRAQdzQByACIARyNgIAIAUgAzYCAEEYIQFBCAwBCyAAQRkgAUEBdmtBACABQR9HG3QhASAFKAIAIQUDQCAFIgIoAgRBeHEgAEYNAiABQR12IQUgAUEBdCEBIAIgBUEEcWoiBCgCECIFDQALIAQgAzYCEEEYIQEgAiEFQQgLIQAgAyECIAMMAQsgAigCCCIFIAM2AgwgAiADNgIIQRghAEEIIQFBAAshBCABIANqIAU2AgAgAyACNgIMIAAgA2ogBDYCAEH40AdB+NAHKAIAQQFrIgNBfyADGzYCAAsLhwECAX8BfyAARQRAIAEQwBQPCyABQUBPBEAQnhNBMDYCAEEADwsgAEEIa0EQIAFBC2pBeHEgAUELSRsQxBQiAgRAIAJBCGoPCyABEMAUIgJFBEBBAA8LIAIgAEF8QXggAEEEaygCACIDQQNxGyADQXhxaiIDIAEgASADSxsQlxMaIAAQwhQgAguaBwkBfwF/AX8BfwF/AX8BfwF/AX8gACgCBCIFQXhxIQICQCAFQQNxRQRAIAFBgAJJDQEgAUEEaiACTQRAIAAhAyACIAFrQbjUBygCAEEBdE0NAgtBAA8LIAAgAmohBAJAIAEgAk0EQCACIAFrIgJBEEkNASAAIAEgBUEBcXJBAnI2AgQgACABaiIBIAJBA3I2AgQgBCAEKAIEQQFyNgIEIAEgAhDHFAwBC0Hw0AcoAgAgBEYEQEHk0AcoAgAgAmoiAiABTQ0CIAAgASAFQQFxckECcjYCBCAAIAFqIgUgAiABayIBQQFyNgIEQeTQByABNgIAQfDQByAFNgIADAELQezQBygCACAERgRAQeDQBygCACACaiICIAFJDQICQCACIAFrIgNBEE8EQCAAIAEgBUEBcXJBAnI2AgQgACABaiIBIANBAXI2AgQgACACaiICIAM2AgAgAiACKAIEQX5xNgIEDAELIAAgBUEBcSACckECcjYCBCAAIAJqIgEgASgCBEEBcjYCBEEAIQNBACEBC0Hs0AcgATYCAEHg0AcgAzYCAAwBCyAEKAIEIgZBAnENASAGQXhxIAJqIgggAUkNASAIIAFrIQkgBCgCDCECAkAgBkH/AU0EQCAEKAIIIgMgAkYEQEHY0AdB2NAHKAIAQX4gBkEDdndxNgIADAILIAMgAjYCDCACIAM2AggMAQsgBCgCGCEHAkAgAiAERwRAIAQoAggiAyACNgIMIAIgAzYCCAwBCwJAIAQoAhQiAwR/IARBFGoFIAQoAhAiA0UNASAEQRBqCyEGA0AgBiEKIAMiAkEUaiEGIAIoAhQiAw0AIAJBEGohBiACKAIQIgMNAAsgCkEANgIADAELQQAhAgsgB0UNAAJAIAQoAhwiBkECdEGI0wdqIgMoAgAgBEYEQCADIAI2AgAgAg0BQdzQB0Hc0AcoAgBBfiAGd3E2AgAMAgsCQCAEIAcoAhBGBEAgByACNgIQDAELIAcgAjYCFAsgAkUNAQsgAiAHNgIYIAQoAhAiAwRAIAIgAzYCECADIAI2AhgLIAQoAhQiA0UNACACIAM2AhQgAyACNgIYCyAJQQ9NBEAgACAFQQFxIAhyQQJyNgIEIAAgCGoiASABKAIEQQFyNgIEDAELIAAgASAFQQFxckECcjYCBCAAIAFqIgEgCUEDcjYCBCAAIAhqIgIgAigCBEEBcjYCBCABIAkQxxQLIAAhAwsgAwsXACAAQQhNBEAgARDAFA8LIAAgARDGFAunAwUBfwF/AX8BfwF/QRAhAgJAQRAgACAAQRBNGyIDIANBAWtxRQRAIAMhAAwBCwNAIAIiAEEBdCECIAAgA0kNAAsLQUAgAGsgAU0EQBCeE0EwNgIAQQAPC0EQIAFBC2pBeHEgAUELSRsiASAAakEMahDAFCICRQRAQQAPCyACQQhrIQMCQCAAQQFrIAJxRQRAIAMhAAwBCyACQQRrIgUoAgAiBkF4cSAAIAJqQQFrQQAgAGtxQQhrIgIgAEEAIAIgA2tBD00baiIAIANrIgJrIQQgBkEDcUUEQCADKAIAIQMgACAENgIEIAAgAiADajYCAAwBCyAAIAQgACgCBEEBcXJBAnI2AgQgACAEaiIEIAQoAgRBAXI2AgQgBSACIAUoAgBBAXFyQQJyNgIAIAIgA2oiBCAEKAIEQQFyNgIEIAMgAhDHFAsCQCAAKAIEIgJBA3FFDQAgAkF4cSIDIAFBEGpNDQAgACABIAJBAXFyQQJyNgIEIAAgAWoiAiADIAFrIgFBA3I2AgQgACADaiIDIAMoAgRBAXI2AgQgAiABEMcUCyAAQQhqC64LBgF/AX8BfwF/AX8BfyAAIAFqIQQCQAJAIAAoAgQiAkEBcQ0AIAJBAnFFDQEgACgCACIDIAFqIQECQAJAAkAgACADayIAQezQBygCAEcEQCAAKAIMIQIgA0H/AU0EQCACIAAoAggiBUcNAkHY0AdB2NAHKAIAQX4gA0EDdndxNgIADAULIAAoAhghBiAAIAJHBEAgACgCCCIDIAI2AgwgAiADNgIIDAQLIAAoAhQiAwR/IABBFGoFIAAoAhAiA0UNAyAAQRBqCyEFA0AgBSEHIAMiAkEUaiEFIAIoAhQiAw0AIAJBEGohBSACKAIQIgMNAAsgB0EANgIADAMLIAQoAgQiAkEDcUEDRw0DQeDQByABNgIAIAQgAkF+cTYCBCAAIAFBAXI2AgQgBCABNgIADwsgBSACNgIMIAIgBTYCCAwCC0EAIQILIAZFDQACQCAAKAIcIgVBAnRBiNMHaiIDKAIAIABGBEAgAyACNgIAIAINAUHc0AdB3NAHKAIAQX4gBXdxNgIADAILAkAgACAGKAIQRgRAIAYgAjYCEAwBCyAGIAI2AhQLIAJFDQELIAIgBjYCGCAAKAIQIgMEQCACIAM2AhAgAyACNgIYCyAAKAIUIgNFDQAgAiADNgIUIAMgAjYCGAsCQAJAAkACQCAEKAIEIgNBAnFFBEBB8NAHKAIAIARGBEBB8NAHIAA2AgBB5NAHQeTQBygCACABaiIBNgIAIAAgAUEBcjYCBCAAQezQBygCAEcNBkHg0AdBADYCAEHs0AdBADYCAA8LQezQBygCACAERgRAQezQByAANgIAQeDQB0Hg0AcoAgAgAWoiATYCACAAIAFBAXI2AgQgACABaiABNgIADwsgA0F4cSABaiEBIAQoAgwhAiADQf8BTQRAIAQoAggiBSACRgRAQdjQB0HY0AcoAgBBfiADQQN2d3E2AgAMBQsgBSACNgIMIAIgBTYCCAwECyAEKAIYIQYgAiAERwRAIAQoAggiAyACNgIMIAIgAzYCCAwDCyAEKAIUIgMEfyAEQRRqBSAEKAIQIgNFDQIgBEEQagshBQNAIAUhByADIgJBFGohBSACKAIUIgMNACACQRBqIQUgAigCECIDDQALIAdBADYCAAwCCyAEIANBfnE2AgQgACABQQFyNgIEIAAgAWogATYCAAwDC0EAIQILIAZFDQACQCAEKAIcIgVBAnRBiNMHaiIDKAIAIARGBEAgAyACNgIAIAINAUHc0AdB3NAHKAIAQX4gBXdxNgIADAILAkAgBCAGKAIQRgRAIAYgAjYCEAwBCyAGIAI2AhQLIAJFDQELIAIgBjYCGCAEKAIQIgMEQCACIAM2AhAgAyACNgIYCyAEKAIUIgNFDQAgAiADNgIUIAMgAjYCGAsgACABQQFyNgIEIAAgAWogATYCACAAQezQBygCAEcNAEHg0AcgATYCAA8LIAFB/wFNBEAgAUF4cUGA0QdqIQICf0HY0AcoAgAiA0EBIAFBA3Z0IgFxRQRAQdjQByABIANyNgIAIAIMAQsgAigCCAshASACIAA2AgggASAANgIMIAAgAjYCDCAAIAE2AggPC0EfIQIgAUH///8HTQRAIAFBJiABQQh2ZyICa3ZBAXEgAkEBdGtBPmohAgsgACACNgIcIABCADcCECACQQJ0QYjTB2ohAwJAAkBB3NAHKAIAIgVBASACdCIEcUUEQEHc0AcgBCAFcjYCACADIAA2AgAMAQsgAUEZIAJBAXZrQQAgAkEfRxt0IQIgAygCACEFA0AgBSIDKAIEQXhxIAFGDQIgAkEddiEFIAJBAXQhAiADIAVBBHFqIgQoAhAiBQ0ACyAEIAA2AhALIAAgAzYCGCAAIAA2AgwgACAANgIIDwsgAygCCCIBIAA2AgwgAyAANgIIIABBADYCGCAAIAM2AgwgACABNgIICwt1AQF+IAAgASAEfiACIAN+fCADQiCIIgIgAUIgiCIEfnwgA0L/////D4MiAyABQv////8PgyIBfiIFQiCIIAMgBH58IgNCIIh8IAEgAn4gA0L/////D4N8IgFCIIh8NwMIIAAgBUL/////D4MgAUIghoQ3AwALUAEBfgJAIANBwABxBEAgASADQUBqrYYhAkIAIQEMAQsgA0UNACACIAOtIgSGIAFBwAAgA2utiIQhAiABIASGIQELIAAgATcDACAAIAI3AwgLUAEBfgJAIANBwABxBEAgAiADQUBqrYghAUIAIQIMAQsgA0UNACACQcAAIANrrYYgASADrSIEiIQhASACIASIIQILIAAgATcDACAAIAI3AwgL/QMHAX4BfwF/AX4BfwF/AX8jAEEgayIEJAAgAUL///////8/gyECAn4gAUIwiEL//wGDIgWnIgNBgfgAa0H9D00EQCACQgSGIABCPIiEIQIgA0GA+ABrrSEFAkAgAEL//////////w+DIgBCgYCAgICAgIAIWgRAIAJCAXwhAgwBCyAAQoCAgICAgICACFINACACQgGDIAJ8IQILQgAgAiACQv////////8HViIDGyEAIAOtIAV8DAELIAAgAoRQIAVC//8BUnJFBEAgAkIEhiAAQjyIhEKAgICAgICABIQhAEL/DwwBCyADQf6HAUsEQEIAIQBC/w8MAQtBgPgAQYH4ACAFUCIHGyIIIANrIgZB8ABKBEBCACEAQgAMAQsgBEEQaiAAIAIgAkKAgICAgIDAAIQgBxsiAkGAASAGaxDJFCAEIAAgAiAGEMoUIAQpAwhCBIYgBCkDACICQjyIhCEAAkAgAyAIRyAEKQMQIAQpAxiEQgBSca0gAkL//////////w+DhCICQoGAgICAgICACFoEQCAAQgF8IQAMAQsgAkKAgICAgICAgAhSDQAgAEIBgyAAfCEACyAAQoCAgICAgIAIhSAAIABC/////////wdWIgMbIQAgA60LIQIgBEEgaiQAIAFCgICAgICAgICAf4MgAkI0hoQgAIS/CwYAIAAkAAsSAQF/IwAgAGtBcHEiASQAIAELBAAjAAsLx84FnwMAQYAgC4HhAjMuNDguMAB7fQAlcyIlcyI6IHsib2Zmc2V0IjolZCwic2l6ZW9mIjogJWQsInNpZ25hdHVyZSI6IiVzIn0AJXN7ACVzImNoYW5nZXNldCI6IHsAJXMic3RtdFN0YXR1cyI6IHsAJXMiZGJTdGF0dXMiOiB7ACVzInNxbGl0ZTNTdGF0dXMiOiB7ACVzImxpbWl0cyI6IHsAJXMiYWNjZXNzIjogewAlcyJibG9iRmluYWxpemVycyI6IHsALCJtZW1iZXJzIjogewAlcyJlbmNvZGluZ3MiOiB7ACVzIm9wZW5GbGFncyI6IHsAJXMidWRmRmxhZ3MiOiB7ACVzInByZXBhcmVGbGFncyI6IHsAJXMic3luY0ZsYWdzIjogewAlcyJkYXRhVHlwZXMiOiB7ACVzInJlc3VsdENvZGVzIjogewAlcyJhdXRob3JpemVyIjogewAlcyJpb0NhcCI6IHsAJXMic2Vzc2lvbiI6IHsAJXMidmVyc2lvbiI6IHsAJXMiZmNudGwiOiB7ACVzImZsb2NrIjogewAlcyJjb25maWciOiB7ACVzImRiQ29uZmlnIjogewAlcyJzZXJpYWxpemUiOiB7ACVzInR4blN0YXRlIjogewAlcyJ0cmFjZSI6IHsAJXMidnRhYiI6IHsAcGdzegAleiVzJXoAJXMuJXoASW4gUlRyZWUgJXMuJXM6CiV6AGpzb25fcHJldHR5AGluZmluaXR5AGFmZmluaXR5AFJlYWxBZmZpbml0eQBidXN5AHRlbXBfc3RvcmVfZGlyZWN0b3J5AG5vdCBhIHdyaXRhYmxlIGRpcmVjdG9yeQBvcGVuRGlyZWN0b3J5AHNocmlua19tZW1vcnkAb3V0IG9mIG1lbW9yeQBmYWlsZWQgdG8gYWxsb2NhdGUgJXUgYnl0ZXMgb2YgbWVtb3J5AEhBVklORyBjbGF1c2Ugb24gYSBub24tYWdncmVnYXRlIHF1ZXJ5AHRlbXBvcmFyeQBJbnRDb3B5AFNDb3B5AHhEZXN0cm95AFZEZXN0cm95AFNBVkVQT0lOVCBjaGFuZ2VzZXRfYXBwbHkAUk9MTEJBQ0sgVE8gY2hhbmdlc2V0X2FwcGx5AFJFTEVBU0UgY2hhbmdlc2V0X2FwcGx5AE11bHRpcGx5AHF1ZXJ5X29ubHkAcmVhZC1vbmx5AHVubGlrZWx5AHRhYmxlICIlcyIgaGFzIG1vcmUgdGhhbiBvbmUgcHJpbWFyeSBrZXkAZm9yZWlnbiBrZXkAanNvbl9ncm91cF9hcnJheQBqc29uYl9ncm91cF9hcnJheQBqc29uX2FycmF5AGpzb25iX2FycmF5AGp1bGlhbmRheQBuT3JkZXJCeQBhT3JkZXJCeQB2YWN1dW1fJTAxNmxseAB1bml4AHNxbGl0ZV9yZW5hbWVfcXVvdGVmaXgAcHJlZml4AExJS0Ugb3IgR0xPQiBwYXR0ZXJuIHRvbyBjb21wbGV4AHVuaGV4AE9wZW5BdXRvaW5kZXgAYXV0b21hdGljX2luZGV4AGF1dG8taW5kZXgAb3JwaGFuIGluZGV4AGFyZ3ZJbmRleAB4QmVzdEluZGV4AERyb3BJbmRleAB0YmwsIGlkeABSZW9wZW5JZHgAbWF4AE1lbU1heAAlcyUuM3grJS42eAAlMDJ4AC0rICAgMFgweAAtMFgrMFggMFgtMHgrMHggMHgAQ1JFQVRFIFRBQkxFIHgAcncAcHNvdwBpbXBsaWVzX25vbm51bGxfcm93AHBvdwBub3cAaW50ZWdlciBvdmVyZmxvdwBmdHM1OiBwYXJzZXIgc3RhY2sgb3ZlcmZsb3cAd2luZG93AHNoYWRvdwBSZXN1bHRSb3cASWZOdWxsUm93AG5ldwBubyBzdWNoIHZpZXcAY2Fubm90IG1vZGlmeSAlcyBiZWNhdXNlIGl0IGlzIGEgdmlldwBDYW5ub3QgYWRkIGEgY29sdW1uIHRvIGEgdmlldwBjYW5ub3QgVVBTRVJUIGEgdmlldwBQcmV2AGsgUFJJTUFSWSBLRVksIHYAICVsbHUAJWMldQBGYWlsZWQgdG8gcmVhZCBwdHJtYXAga2V5PSV1ACUuKno6JXUAT2Zmc2V0ICV1IG91dCBvZiByYW5nZSAldS4uJXUAaW52YWxpZCBwYWdlIG51bWJlciAldQBmYWlsZWQgdG8gZ2V0IHBhZ2UgJXUAMm5kIHJlZmVyZW5jZSB0byBwYWdlICV1AEZyYWdtZW50YXRpb24gb2YgJXUgYnl0ZXMgcmVwb3J0ZWQgYXMgJXUgb24gcGFnZSAldQBmcmVlbGlzdCBsZWFmIGNvdW50IHRvbyBiaWcgb24gcGFnZSAldQBNdWx0aXBsZSB1c2VzIGZvciBieXRlICV1IG9mIHBhZ2UgJXUAJXMgaXMgJXUgYnV0IHNob3VsZCBiZSAldQB1bmFibGUgdG8gdXNlIGZ1bmN0aW9uICVzIGluIHRoZSByZXF1ZXN0ZWQgY29udGV4dAB4TmV4dABTb3J0ZXJOZXh0AHBOZXh0AFZOZXh0AGluY29tcGxldGUgaW5wdXQAYnVzeV90aW1lb3V0AGxvY2FsaG9zdABlc3RpbWF0ZWRDb3N0AGNhbm5vdCBkcm9wIGNvbHVtbiAiJXMiOiBubyBvdGhlciBjb2x1bW5zIGV4aXN0AHBlcnNpc3QAZm9yZWlnbl9rZXlfbGlzdABpbmRleF9saXN0AGZ1bmN0aW9uX2xpc3QAY29sbGF0aW9uX2xpc3QAZGF0YWJhc2VfbGlzdABtb2R1bGVfbGlzdABQUkFHTUEgdGFibGVfbGlzdABwcmFnbWFfbGlzdABzZXQgbGlzdABWYWx1ZUxpc3QAc3FsaXRlX3JlbmFtZV90ZXN0AFJvd1NldFRlc3QAU2VxdWVuY2VUZXN0AEF1eGlsaWFyeSBydHJlZSBjb2x1bW5zIG11c3QgYmUgbGFzdABmYXN0AExhc3QAQ2FzdABzcXJ0AFNvcnRlclNvcnQAIlwvYmZucnQAanNvbl9pbnNlcnQAanNvbmJfaW5zZXJ0AGNhbm5vdCBpbnNlcnQASWR4SW5zZXJ0AFNvcnRlckluc2VydAByZXN0YXJ0AERpbWVuc2lvbiAlZCBvZiBjZWxsICVkIG9uIG5vZGUgJWxsZCBpcyBjb3JydXB0AEJpdE5vdABJZk5vdABQYWdlY291bnQAZnJlZWxpc3RfY291bnQAbWF4X3BhZ2VfY291bnQAUFJBR01BICIldyIucGFnZV9jb3VudABSZXNldENvdW50AHdhbF9hdXRvY2hlY2twb2ludAB3YWxfY2hlY2twb2ludABDaGVja3BvaW50AHhTYXZlcG9pbnQAYSBDSEVDSyBjb25zdHJhaW50ACVzT04gQ09ORkxJQ1QgY2xhdXNlIGRvZXMgbm90IG1hdGNoIGFueSBQUklNQVJZIEtFWSBvciBVTklRVUUgY29uc3RyYWludABuQ29uc3RyYWludABhQ29uc3RyYWludABDdXJzb3JIaW50AGNvbnRlbnQAJV9wYXJlbnQARGltZW5zaW9uICVkIG9mIGNlbGwgJWQgb24gbm9kZSAlbGxkIGlzIGNvcnJ1cHQgcmVsYXRpdmUgdG8gcGFyZW50AERJU1RJTkNUIGFnZ3JlZ2F0ZXMgbXVzdCBoYXZlIGV4YWN0bHkgb25lIGFyZ3VtZW50AGNvbW1lbnQAQVBJIGNhbGxlZCB3aXRoIGZpbmFsaXplZCBwcmVwYXJlZCBzdGF0ZW1lbnQAQVBJIGNhbGxlZCB3aXRoIE5VTEwgcHJlcGFyZWQgc3RhdGVtZW50AGFyZ3VtZW50IHRvICVzKCkgaXMgbm90IGEgdmFsaWQgU1FMIHN0YXRlbWVudABNYXhQZ2NudABkZWZhdWx0IHZhbHVlIG9mIGNvbHVtbiBbJXNdIGlzIG5vdCBjb25zdGFudABNdXN0QmVJbnQAc3FsaXRlX3N0bXQAQ2Fubm90IGFkZCBhIGNvbHVtbiB3aXRoIG5vbi1jb25zdGFudCBkZWZhdWx0AEhhbHQAc3RhdF9pbml0AEluaXQAb21pdAB4Q29tbWl0AEF1dG9Db21taXQAYW5hbHlzaXNfbGltaXQAc29mdF9oZWFwX2xpbWl0AGhhcmRfaGVhcF9saW1pdABqb3VybmFsX3NpemVfbGltaXQAT2Zmc2V0TGltaXQAU2Vla0hpdABPTiBjbGF1c2UgcmVmZXJlbmNlcyB0YWJsZXMgdG8gaXRzIHJpZ2h0AGhpZ2hsaWdodABTaGlmdFJpZ2h0AGhnaHQAU2hpZnRMZWZ0AHNxbGl0ZV9vZmZzZXQAaVRlcm1PZmZzZXQAcmVzZXQAU0FWRVBPSU5UIGNoYW5nZXNldABSRUxFQVNFIGNoYW5nZXNldABqc29uX3NldABqc29uYl9zZXQAdG9vIG1hbnkgY29sdW1ucyBpbiByZXN1bHQgc2V0ACVyIE9SREVSIEJZIHRlcm0gZG9lcyBub3QgbWF0Y2ggYW55IGNvbHVtbiBpbiB0aGUgcmVzdWx0IHNldABzbmlwcGV0AHN0YXRfZ2V0AHNxbGl0ZV9jb21waWxlb3B0aW9uX2dldABzdHJpY3QATm9Db25mbGljdAB4RGlzY29ubmVjdAB4Q29ubmVjdABqc29uX2dyb3VwX29iamVjdABqc29uYl9ncm91cF9vYmplY3QAanNvbl9vYmplY3QAanNvbmJfb2JqZWN0AGpzb25fZXh0cmFjdABqc29uYl9leHRyYWN0AFN1YnRyYWN0AGxzdGF0AGZzdGF0AGRic3RhdAB0YmwsaWR4LHN0YXQAdGJsLCA/Miwgc3RhdAB1bnN1cHBvcnRlZCBmaWxlIGZvcm1hdABncm91cF9jb25jYXQAQ29uY2F0AEx0AEd0AGRlZmVyX2ZvcmVpZ25fa2V5cwBhbHdheXMAZXN0aW1hdGVkUm93cwBwYXJhbWV0ZXJzIGFyZSBub3QgYWxsb3dlZCBpbiB2aWV3cwBjb25jYXRfd3MAc3RhdHVzAHN5bmNocm9ub3VzAGluZGV4ICVzIGFscmVhZHkgZXhpc3RzAG91dHB1dCBmaWxlIGFscmVhZHkgZXhpc3RzACVzICVUIGFscmVhZHkgZXhpc3RzAHRyaWdnZXIgJVQgYWxyZWFkeSBleGlzdHMATm90RXhpc3RzAGlnbm9yZV9jaGVja19jb25zdHJhaW50cwBDSEVDSyBjb25zdHJhaW50cwBleHByZXNzaW9ucyBwcm9oaWJpdGVkIGluIFBSSU1BUlkgS0VZIGFuZCBVTklRVUUgY29uc3RyYWludHMAanNvbl9vYmplY3QoKSByZXF1aXJlcyBhbiBldmVuIG51bWJlciBvZiBhcmd1bWVudHMAanNvbl8lcygpIG5lZWRzIGFuIG9kZCBudW1iZXIgb2YgYXJndW1lbnRzAHdyb25nIG51bWJlciBvZiB2dGFibGUgYXJndW1lbnRzAHVuYWJsZSB0byBkZWxldGUvbW9kaWZ5IHVzZXItZnVuY3Rpb24gZHVlIHRvIGFjdGl2ZSBzdGF0ZW1lbnRzAHVuYWJsZSB0byBkZWxldGUvbW9kaWZ5IGNvbGxhdGlvbiBzZXF1ZW5jZSBkdWUgdG8gYWN0aXZlIHN0YXRlbWVudHMAcmV2ZXJzZV91bm9yZGVyZWRfc2VsZWN0cwBpaXNzc3NzcwBpc3MAY2Fubm90IG9wZW4gc2F2ZXBvaW50IC0gU1FMIHN0YXRlbWVudHMgaW4gcHJvZ3Jlc3MAY2Fubm90IHJlbGVhc2Ugc2F2ZXBvaW50IC0gU1FMIHN0YXRlbWVudHMgaW4gcHJvZ3Jlc3MAY2Fubm90IGNvbW1pdCB0cmFuc2FjdGlvbiAtIFNRTCBzdGF0ZW1lbnRzIGluIHByb2dyZXNzAGNhbm5vdCBWQUNVVU0gLSBTUUwgc3RhdGVtZW50cyBpbiBwcm9ncmVzcwBvdXNuZXNzAHhSYW5kb21uZXNzAGZ1bG5lc3MAaXZlbmVzcwBhY2Nlc3MAeEFjY2VzcwBzZXBhcmF0b3JzAHBhcmFtZXRlcnMAcmVjdXJzaXZlX3RyaWdnZXJzAHRoZSBJTkRFWEVEIEJZIGNsYXVzZSBpcyBub3QgYWxsb3dlZCBvbiBVUERBVEUgb3IgREVMRVRFIHN0YXRlbWVudHMgd2l0aGluIHRyaWdnZXJzAHRoZSBOT1QgSU5ERVhFRCBjbGF1c2UgaXMgbm90IGFsbG93ZWQgb24gVVBEQVRFIG9yIERFTEVURSBzdGF0ZW1lbnRzIHdpdGhpbiB0cmlnZ2VycwBxdWFsaWZpZWQgdGFibGUgbmFtZXMgYXJlIG5vdCBhbGxvd2VkIG9uIElOU0VSVCwgVVBEQVRFLCBhbmQgREVMRVRFIHN0YXRlbWVudHMgd2l0aGluIHRyaWdnZXJzAENoaWxkIHBhZ2UgZGVwdGggZGlmZmVycwB0b2tlbmNoYXJzAHVuYWJsZSB0byBjbG9zZSBkdWUgdG8gdW5maW5hbGl6ZWQgc3RhdGVtZW50cyBvciB1bmZpbmlzaGVkIGJhY2t1cHMAYWNvcwBJZlBvcwBjb21waWxlX29wdGlvbnMARElTVElOQ1QgaXMgbm90IHN1cHBvcnRlZCBmb3Igd2luZG93IGZ1bmN0aW9ucwBGSUxURVIgY2xhdXNlIG1heSBvbmx5IGJlIHVzZWQgd2l0aCBhZ2dyZWdhdGUgd2luZG93IGZ1bmN0aW9ucwBub24tZGV0ZXJtaW5pc3RpYyBmdW5jdGlvbnMAaW5kZXggZXhwcmVzc2lvbnMAU0VMRUNUcyB0byB0aGUgbGVmdCBhbmQgcmlnaHQgb2YgJXMgZG8gbm90IGhhdmUgdGhlIHNhbWUgbnVtYmVyIG9mIHJlc3VsdCBjb2x1bW5zAHZpcnR1YWwgdGFibGVzIGNhbm5vdCB1c2UgY29tcHV0ZWQgY29sdW1ucwBnZW5lcmF0ZWQgY29sdW1ucwB0YWJsZSAlcyBoYXMgJWQgdmFsdWVzIGZvciAlZCBjb2x1bW5zAHJhZGlhbnMAYWxsIFZBTFVFUyBtdXN0IGhhdmUgdGhlIHNhbWUgbnVtYmVyIG9mIHRlcm1zAGVtcHR5X3Jlc3VsdF9jYWxsYmFja3MATG9hZEFuYWx5c2lzAGZsZ3MAZmxhZ3MAaWR4RmxhZ3MAZmlsZTpzZXNzaW9uP3Zmcz1rdnZmcwBmaWxlOmxvY2FsP3Zmcz1rdnZmcwBtdWx0aXBsZSBjb250ZW50PS4uLiBkaXJlY3RpdmVzAG11bHRpcGxlIHRva2VuaXplPS4uLiBkaXJlY3RpdmVzAG11bHRpcGxlIGNvbnRlbnRfcm93aWQ9Li4uIGRpcmVjdGl2ZXMAJWQgY29sdW1ucyBhc3NpZ25lZCAlZCB2YWx1ZXMASlNPTiBjYW5ub3QgaG9sZCBCTE9CIHZhbHVlcwBmYWlsZWQgbWVtb3J5IHJlc2l6ZSAldSB0byAldSBieXRlcwBwYXJ0aWFsIGluZGV4IFdIRVJFIGNsYXVzZXMAc2hvcnRfY29sdW1uX25hbWVzAGZ1bGxfY29sdW1uX25hbWVzAHVuYWJsZSB0byBvcGVuIGEgdGVtcG9yYXJ5IGRhdGFiYXNlIGZpbGUgZm9yIHN0b3JpbmcgdGVtcG9yYXJ5IHRhYmxlcwBjYW5ub3QgY3JlYXRlIHRyaWdnZXJzIG9uIHNoYWRvdyB0YWJsZXMAY2Fubm90IGNyZWF0ZSB0cmlnZ2VycyBvbiB2aXJ0dWFsIHRhYmxlcwAlcyBSRVRVUk5JTkcgaXMgbm90IGF2YWlsYWJsZSBvbiB2aXJ0dWFsIHRhYmxlcwBjYW5ub3Qgam9pbiB1c2luZyBjb2x1bW4gJXMgLSBjb2x1bW4gbm90IHByZXNlbnQgaW4gYm90aCB0YWJsZXMAQVVUT0lOQ1JFTUVOVCBub3QgYWxsb3dlZCBvbiBXSVRIT1VUIFJPV0lEIHRhYmxlcwAlcyBjYW5ub3QgdXNlIHZhcmlhYmxlcwB0b28gbWFueSBTUUwgdmFyaWFibGVzAGNhdGVnb3JpZXMAc3VicXVlcmllcwBjYW5ub3QgdXNlIHdpbmRvdyBmdW5jdGlvbnMgaW4gcmVjdXJzaXZlIHF1ZXJpZXMAY291bnRfY2hhbmdlcwB0b3RhbF9jaGFuZ2VzAGRlZ3JlZXMAUkVUVVJOSU5HIG1heSBub3QgdXNlICJUQUJMRS4qIiB3aWxkY2FyZHMAcE1ldGhvZHMAdGhyZWFkcwB4RGV2aWNlQ2hhcmFjdGVyaXN0aWNzAHJlbW92ZV9kaWFjcml0aWNzAGFicwAleiUuKnMALiUuKnMALCUuKnMAQ1JFQVRFICVzICUuKnMAQ1JFQVRFJXMgSU5ERVggJS4qcwBpbnZhbGlkIHVyaSBhdXRob3JpdHk6ICUuKnMAdW5rbm93biBzcGVjaWFsIHF1ZXJ5OiAlLipzAHVua25vd24gdGFibGUgb3B0aW9uOiAlLipzACUuKnMlcwAsJXMlcyVzAFNDQU4gJXMlcyVzAHNxbGl0ZV9hbHRlcnRhYl8lcwBTQ0FOICVkIENPTlNUQU5UIFJPVyVzACVRJXMAMHgleDolcwAlZDolcwAlczogJXMuJXMuJXMAcmVjdXJzaXZlIGRlZmluaXRpb24gZm9yICVzLiVzAG1pc3NpbmcgZGF0YXR5cGUgZm9yICVzLiVzAGNhbm5vdCBzdG9yZSAlcyB2YWx1ZSBpbiAlcyBjb2x1bW4gJXMuJXMAbm9uLSVzIHZhbHVlIGluICVzLiVzAFRFWFQgdmFsdWUgaW4gJXMuJXMATlVMTCB2YWx1ZSBpbiAlcy4lcwBOVU1FUklDIHZhbHVlIGluICVzLiVzAG1hbGZvcm1lZCBpbnZlcnRlZCBpbmRleCBmb3IgRlRTNSB0YWJsZSAlcy4lcwAlczogJXMuJXMAbm8gc3VjaCB0YWJsZSBjb2x1bW46ICVzLiVzAG5vIHN1Y2ggZnRzNSB0YWJsZTogJXMuJXMAVU5JUVVFIGNvbnN0cmFpbnQgZmFpbGVkOiAlcy4lcwBERUxFVEUgRlJPTSAlUS4lcwAuLiVzACUuMThzLSVzAGt2dmZzLSVzLSVzAHN1YnJ0bnNpZzolZCwlcwBDUkVBVEUgVEFCTEUgJVEuJyVxXyVxJyglcyklcwAgVVNJTkcgSU5URUdFUiBQUklNQVJZIEtFWSAoJXMAdXNlIERST1AgVklFVyB0byBkZWxldGUgdmlldyAlcwByb3cgbm90IGluIFBSSU1BUlkgS0VZIG9yZGVyIGZvciAlcwBtaXN1c2Ugb2YgYWxpYXNlZCB3aW5kb3cgZnVuY3Rpb24gJXMAdG9vIG1hbnkgY29sdW1ucyBvbiAlcwB0b28gbWFueSBjb2x1bW5zIGluICVzACVzIHByb2hpYml0ZWQgaW4gJXMAQ0hFQ0sgY29uc3RyYWludCBmYWlsZWQgaW4gJXMAbm9uLWRldGVybWluaXN0aWMgdXNlIG9mICVzKCkgaW4gJXMAcmVjb3ZlcmVkICVkIHBhZ2VzIGZyb20gJXMAbWlzdXNlIG9mIGFsaWFzZWQgYWdncmVnYXRlICVzACVzICVUIGNhbm5vdCByZWZlcmVuY2Ugb2JqZWN0cyBpbiBkYXRhYmFzZSAlcwBjYW5ub3QgZGV0YWNoIGRhdGFiYXNlICVzAGEgSk9JTiBjbGF1c2UgaXMgcmVxdWlyZWQgYmVmb3JlICVzAGNhbm5vdCBvcGVuIHZhbHVlIG9mIHR5cGUgJXMAY2Fubm90IGZzdGF0IGRiIGZpbGUgJXMAcmVjb3ZlcmVkICVkIGZyYW1lcyBmcm9tIFdBTCBmaWxlICVzAGZ0czU6IG1pc3Npbmcgcm93ICVsbGQgZnJvbSBjb250ZW50IHRhYmxlICVzAHNxbGl0ZTNjaGFuZ2VzZXRfYXBwbHkoKTogcHJpbWFyeSBrZXkgbWlzbWF0Y2ggZm9yIHRhYmxlICVzAFBSSU1BUlkgS0VZIG1pc3Npbmcgb24gdGFibGUgJXMAdXNlIERST1AgVEFCTEUgdG8gZGVsZXRlIHRhYmxlICVzAHRoZXJlIGlzIGFscmVhZHkgYW4gaW5kZXggbmFtZWQgJXMAdGFibGUgJVMgaGFzIG5vIGNvbHVtbiBuYW1lZCAlcwB0aGVyZSBpcyBhbHJlYWR5IGEgdGFibGUgbmFtZWQgJXMAc3RhdGVtZW50IGFib3J0cyBhdCAlZDogWyVzXSAlcwBDT1ZFUklORyBJTkRFWCAlcwBTRUxFQ1QgJXMAdW5zdXBwb3J0ZWQgdXNlIG9mIE5VTExTICVzAEFUVEFDSCAlUSBBUyAlcwBVU0UgVEVNUCBCLVRSRUUgRk9SICVzAC0tIFRSSUdHRVIgJXMAUklHSFQtSk9JTiAlcwA+PyBBTkQgJXMAJXo6ICVzAHJlY3Vyc2l2ZSByZWZlcmVuY2UgaW4gYSBzdWJxdWVyeTogJXMAdnRhYmxlIGNvbnN0cnVjdG9yIGNhbGxlZCByZWN1cnNpdmVseTogJXMAbm8gc3VjaCBpbmRleDogJXMAbm8gc3VjaCB3aW5kb3c6ICVzAGNhbm5vdCBvdmVycmlkZSAlcyBvZiB3aW5kb3c6ICVzAGNhbm5vdCBvcGVuIHZpZXc6ICVzAG5vIHN1Y2ggc2F2ZXBvaW50OiAlcwBjYW5ub3Qgb3BlbiB0YWJsZSB3aXRoIGdlbmVyYXRlZCBjb2x1bW5zOiAlcwBubyBzdWNoIHZmczogJXMAbXVsdGlwbGUgcmVjdXJzaXZlIHJlZmVyZW5jZXM6ICVzAGVycm9yIGluICVzICVzJXMlczogJXMAZnRzNTogZXJyb3IgY3JlYXRpbmcgc2hhZG93IHRhYmxlICVxXyVzOiAlcwB1bmFibGUgdG8gdmFsaWRhdGUgdGhlIGludmVydGVkIGluZGV4IGZvciBGVFM1IHRhYmxlICVzLiVzOiAlcwBlcnJvciBpbiAlcyAlcyBhZnRlciAlczogJXMAbm8gc3VjaCB0b2tlbml6ZXI6ICVzAHVucmVjb2duaXplZCBjb2x1bW4gb3B0aW9uOiAlcwBwYXJzZSBlcnJvciBpbiByYW5rIGZ1bmN0aW9uOiAlcwBubyBzdWNoIGZ1bmN0aW9uOiAlcwBubyBzdWNoIGNvbHVtbjogJXMAZmlsZSByZW5hbWVkIHdoaWxlIG9wZW46ICVzAGZpbGUgdW5saW5rZWQgd2hpbGUgb3BlbjogJXMAY2Fubm90IGxpbWl0IFdBTCBzaXplOiAlcwBNSiBkZWxldGU6ICVzAHRhcmdldCBvYmplY3QvYWxpYXMgbWF5IG5vdCBhcHBlYXIgaW4gRlJPTSBjbGF1c2U6ICVzAG9iamVjdCBuYW1lIHJlc2VydmVkIGZvciBpbnRlcm5hbCB1c2U6ICVzAHVua25vd24gZGF0YWJhc2U6ICVzAHVuYWJsZSB0byBvcGVuIGRhdGFiYXNlOiAlcwBubyBzdWNoIGRhdGFiYXNlOiAlcwB0aGVyZSBpcyBhbHJlYWR5IGFub3RoZXIgdGFibGUgb3IgaW5kZXggd2l0aCB0aGlzIG5hbWU6ICVzAGR1cGxpY2F0ZSBjb2x1bW4gbmFtZTogJXMAcmVzZXJ2ZWQgZnRzNSBjb2x1bW4gbmFtZTogJXMAZHVwbGljYXRlIFdJVEggdGFibGUgbmFtZTogJXMAcmVzZXJ2ZWQgZnRzNSB0YWJsZSBuYW1lOiAlcwBubyBzdWNoIG1vZHVsZTogJXMAbXVsdGlwbGUgbGlua3MgdG8gZmlsZTogJXMAY2Fubm90IG9wZW4gdmlydHVhbCB0YWJsZTogJXMAc3FsaXRlM2NoYW5nZXNldF9hcHBseSgpOiBubyBzdWNoIHRhYmxlOiAlcwBtdWx0aXBsZSByZWZlcmVuY2VzIHRvIHJlY3Vyc2l2ZSB0YWJsZTogJXMAJXMgYSBzdWJzZXQgb2YgY29sdW1ucyBvbiBmdHM1IGNvbnRlbnRsZXNzLWRlbGV0ZSB0YWJsZTogJXMAJXMgY29udGVudGxlc3MgZnRzNSB0YWJsZTogJXMAY2Fubm90IERFTEVURSBmcm9tIGNvbnRlbnRsZXNzIGZ0czUgdGFibGU6ICVzAG5vIHN1Y2ggJXMgbW9kZTogJXMATUogY29sbGlkZTogJXMAbm8gc3VjaCBjb2xsYXRpb24gc2VxdWVuY2U6ICVzAGNpcmN1bGFyIHJlZmVyZW5jZTogJXMAY2Fubm90IG9wZW4gdGFibGUgd2l0aG91dCByb3dpZDogJXMAJXMgbW9kZSBub3QgYWxsb3dlZDogJXMAdnRhYmxlIGNvbnN0cnVjdG9yIGZhaWxlZDogJXMAYXV0b21hdGljIGV4dGVuc2lvbiBsb2FkaW5nIGZhaWxlZDogJXMAdnRhYmxlIGNvbnN0cnVjdG9yIGRpZCBub3QgZGVjbGFyZSBzY2hlbWE6ICVzAGFib3J0IGF0ICVkIGluIFslc106ICVzAC0tICVzACV6IC0gJXMAb3NfdW5peC5jOiVkOiAoJWQpICVzKCVzKSAtICVzAFNFTEVDVCByb3dpZCwgcmFuayBGUk9NICVRLiVRIE9SREVSIEJZICVzKCIldyIlcyVzKSAlcwB3cgBpbnN0cgBjc3RyAHN1YnN0cgBmdHM1X2FwaV9wdHIAaWR4U3RyAG5lZWRUb0ZyZWVJZHhTdHIAZXhwcl9pbXBsaWVzX2V4cHIAZXJyb3IgaW4gdG9rZW5pemVyIGNvbnN0cnVjdG9yAHRoZSAiLiIgb3BlcmF0b3IAbmVhciAiJVQiOiBzeW50YXggZXJyb3IAaW50ZXJuYWwgcXVlcnkgcGxhbm5lciBlcnJvcgB1bmtub3duIGVycm9yAG5vdCBhbiBlcnJvcgBTUUwgbG9naWMgZXJyb3IAZGlzayBJL08gZXJyb3IAeEdldExhc3RFcnJvcgB4RGxFcnJvcgBmbG9vcgBybWRpcgBta2RpcgBwb3dlcgBsb3dlcgBzcWxpdGVfdGVtcF9tYXN0ZXIAc3FsaXRlX21hc3RlcgBwb3J0ZXIAUmVzZXRTb3J0ZXIARmtDb3VudGVyAHN0bXQtcG9pbnRlcgBBUEkgY2FsbCB3aXRoICVzIGRhdGFiYXNlIGNvbm5lY3Rpb24gcG9pbnRlcgB4RmlsdGVyAFZGaWx0ZXIARVNDQVBFIGV4cHJlc3Npb24gbXVzdCBiZSBhIHNpbmdsZSBjaGFyYWN0ZXIAdXBwZXIAeFNobUJhcnJpZXIAY2Fubm90IHVzZSBSRVRVUk5JTkcgaW4gYSB0cmlnZ2VyAERyb3BUcmlnZ2VyAHNlY29uZCBhcmd1bWVudCB0byBudGhfdmFsdWUgbXVzdCBiZSBhIHBvc2l0aXZlIGludGVnZXIAYXJndW1lbnQgb2YgbnRpbGUgbXVzdCBiZSBhIHBvc2l0aXZlIGludGVnZXIAZnJhbWUgc3RhcnRpbmcgb2Zmc2V0IG11c3QgYmUgYSBub24tbmVnYXRpdmUgaW50ZWdlcgBmcmFtZSBlbmRpbmcgb2Zmc2V0IG11c3QgYmUgYSBub24tbmVnYXRpdmUgaW50ZWdlcgBJbnRlZ2VyAFJvd2lkICVsbGQgb3V0IG9mIG9yZGVyAFJlbWFpbmRlcgBmcmFtZSBzdGFydGluZyBvZmZzZXQgbXVzdCBiZSBhIG5vbi1uZWdhdGl2ZSBudW1iZXIAZnJhbWUgZW5kaW5nIG9mZnNldCBtdXN0IGJlIGEgbm9uLW5lZ2F0aXZlIG51bWJlcgBiYWQgcGFnZSBudW1iZXIAYWRkcgBjaGFyAHllYXIAQ2xlYXIAQml0T3IAc2VxAENvbGxTZXEARWxzZUVxACVxAHJlZ2V4cABPcGVuRHVwAE5vb3AAU0FWRVBPSU5UIHJlcGxhY2Vfb3AAUkVMRUFTRSByZXBsYWNlX29wAEp1bXAAL3Vzci90bXAAL3Zhci90bXAAdGVtcABjdXJyZW50X3RpbWVzdGFtcABBZ2dTdGVwAHhTbGVlcABtdW5tYXAAeFNobVVubWFwAG1tYXAAbXJlbWFwAHhTaG1NYXAAc3FsaXRlX3JldHVybmluZ18lcAB2dGFiOiVwAGF1dG8AR290bwBpbnRvAGluY3JlbWVudGFsX3ZhY3V1bSBlbmFibGVkIHdpdGggYSBtYXggcm9vdHBhZ2Ugb2YgemVybwBJZk5vdFplcm8ARGVjckp1bXBaZXJvAEZrSWZaZXJvAHNlcW5vAElOU0VSVCBJTlRPIiV3Ii4iJXdfcm93aWQiKHJvd2lkLG5vZGVubylWQUxVRVMoPzEsPzIpT04gQ09ORkxJQ1Qocm93aWQpRE8gVVBEQVRFIFNFVCBub2Rlbm89ZXhjbHVkZWQubm9kZW5vAENSRUFURSBUQUJMRSAiJXciLiIld19yb3dpZCIocm93aWQgSU5URUdFUiBQUklNQVJZIEtFWSxub2Rlbm8AaGVsbG8AaW5kZXhfeGluZm8AdGFibGVfeGluZm8AaW5kZXhfaW5mbwB0YWJsZV9pbmZvAE9wZW5Qc2V1ZG8AeFJvbGxiYWNrVG8ATCogTiogQ28AdW5rbm93bgBmY2hvd24AQmVnaW5TdWJydG4AUmV0dXJuAGpzb24Abm8gcXVlcnkgc29sdXRpb24AaW5kZXggY29ycnVwdGlvbgBkYXRhYmFzZSBjb3JydXB0aW9uAGZyZWUgc3BhY2UgY29ycnVwdGlvbgBqc29uX2Vycm9yX3Bvc2l0aW9uAHVua25vd24gY29sdW1uICIlcyIgaW4gZm9yZWlnbiBrZXkgZGVmaW5pdGlvbgAlcy54QmVzdEluZGV4IG1hbGZ1bmN0aW9uAGF1dGhvcml6ZXIgbWFsZnVuY3Rpb24AJSNUKCkgbWF5IG5vdCBiZSB1c2VkIGFzIGEgd2luZG93IGZ1bmN0aW9uACclcycgaXMgbm90IGEgZnVuY3Rpb24AeEZpbmRGdW5jdGlvbgBmYWlsZWQgdG8gb3BlbiB0cmFuc2FjdGlvbgBjYW5ub3Qgc3RhcnQgYSB0cmFuc2FjdGlvbiB3aXRoaW4gYSB0cmFuc2FjdGlvbgBjYW5ub3QgY2hhbmdlICVzIHdhbCBtb2RlIGZyb20gd2l0aGluIGEgdHJhbnNhY3Rpb24AdGVtcG9yYXJ5IHN0b3JhZ2UgY2Fubm90IGJlIGNoYW5nZWQgZnJvbSB3aXRoaW4gYSB0cmFuc2FjdGlvbgBjYW5ub3QgVkFDVVVNIGZyb20gd2l0aGluIGEgdHJhbnNhY3Rpb24AU2FmZXR5IGxldmVsIG1heSBub3QgYmUgY2hhbmdlZCBpbnNpZGUgYSB0cmFuc2FjdGlvbgBUcmFuc2FjdGlvbgBpemF0aW9uAFBlcm11dGF0aW9uAHVua25vd24gb3BlcmF0aW9uAHVuc3VwcG9ydGVkIGZyYW1lIHNwZWNpZmljYXRpb24Ac2Vzc2lvbgBSQU5HRSB3aXRoIG9mZnNldCBQUkVDRURJTkcvRk9MTE9XSU5HIHJlcXVpcmVzIG9uZSBPUkRFUiBCWSBleHByZXNzaW9uAHRvbyBtYW55IGxldmVscyBvZiB0cmlnZ2VyIHJlY3Vyc2lvbgB1c2VyX3ZlcnNpb24Ac3FsaXRlX3ZlcnNpb24AUFJBR01BICVRLmRhdGFfdmVyc2lvbgBzY2hlbWFfdmVyc2lvbgBpVmVyc2lvbgBzcWxpdGVfZHJvcF9jb2x1bW4Ac3FsaXRlX3JlbmFtZV9jb2x1bW4AYWZ0ZXIgZHJvcCBjb2x1bW4Abm8gc3VjaCBjb2x1bW4AbXVzdCBoYXZlIGF0IGxlYXN0IG9uZSBub24tZ2VuZXJhdGVkIGNvbHVtbgBjYW5ub3QgdXNlIERFRkFVTFQgb24gYSBnZW5lcmF0ZWQgY29sdW1uAGFkZCBjb2x1bW4AQ2Fubm90IGFkZCBhIFBSSU1BUlkgS0VZIGNvbHVtbgBDYW5ub3QgYWRkIGEgVU5JUVVFIGNvbHVtbgBjYW5ub3QgYWRkIGEgU1RPUkVEIGNvbHVtbgB4Q29sdW1uAGlDb2x1bW4AVkNvbHVtbgBsbgBidWlsdGluAGFzaW4AYXQgbW9zdCAlZCB0YWJsZXMgaW4gYSBqb2luAG1pbgAsb3JpZ2luAHhCZWdpbgBWQmVnaW4AbWFpbgBleHBsYWluAEV4cGxhaW4Ac2lnbgBvcGVuAHhPcGVuAElmTm90T3BlbgBTb3J0ZXJPcGVuAHhEbE9wZW4AVk9wZW4AZnRzNV9pbnN0dG9rZW4ASWZTaXplQmV0d2VlbgBoaWRkZW4AYXRhbgBuYW4AU2Vla1NjYW4AVkluaXRJbgB4RGxTeW0AYXV0b192YWN1dW0AaW5jcmVtZW50YWxfdmFjdXVtAEluY3JWYWN1dW0Ac3VtAGZsZXhudW0AaWR4TnVtAGFsaXNtAHBtAGRyb3AgY29sdW1uIGZyb20AL2Rldi91cmFuZG9tAEFkZEltbQBydHJpbQBsdHJpbQByZWFkb25seV9zaG0AJXMtc2htAFJBSVNFKCkgbWF5IG9ubHkgYmUgdXNlZCB3aXRoaW4gYSB0cmlnZ2VyLXByb2dyYW0AUHJvZ3JhbQB0cmlncmFtAFBhcmFtAGZ1bABmY250bABpb2N0bAB4RmlsZUNvbnRyb2wAbG9ja2luZyBwcm90b2NvbABuY29sAGpybmwAbm90bnVsbABpZm51bGwAL2Rldi9udWxsAGRhdGFiYXNlIG9yIGRpc2sgaXMgZnVsbABOb3ROdWxsAFNvZnROdWxsAElzTnVsbABaZXJvT3JOdWxsAEhhbHRJZk51bGwAY29sbABjYWNoZV9zcGlsbABSb3dDZWxsAHhOZXh0U3lzdGVtQ2FsbAB4U2V0U3lzdGVtQ2FsbAB4R2V0U3lzdGVtQ2FsbABkZWxldGUtYWxsAGNlaWwAZGV0YWlsAHVuaXgtZXhjbAB0YmwAd2FsAHZpcnR1YWwAdG90YWwAaW5jcmVtZW50YWwAT3BlbkVwaGVtZXJhbABzZXNzaW9uLWpvdXJuYWwAbG9jYWwtam91cm5hbABpbnRlcm5hbABhdGlvbmFsAEFnZ0ZpbmFsAG5vcm1hbABwYXJ0aWFsAHJlYWwAUmVhbABsb2NhbABwawBvawB1bmxpbmsAcmVhZGxpbmsARmluaXNoU2VlawBEZWZlcnJlZFNlZWsAbm9sb2NrAHhVbmxvY2sAQ3Vyc29yVW5sb2NrAGJsb2NrACVzLmxvY2sAeExvY2sAQ3Vyc29yTG9jawB4U2htTG9jawBUYWJsZUxvY2sAeENoZWNrUmVzZXJ2ZWRMb2NrAHJ0cmVlY2hlY2sAaW50ZWdyaXR5X2NoZWNrAGZvcmVpZ25fa2V5X2NoZWNrAHF1aWNrX2NoZWNrAGNlbGxfc2l6ZV9jaGVjawBpbnRlZ3JpdHktY2hlY2sARmtDaGVjawBUeXBlQ2hlY2sAVkNoZWNrAHhSb2xsYmFjawBJbnRlZ3JpdHlDawBqAGl2aXRpAGJpbGl0aQBhbGl0aQBpY2l0aQBpc3Npc2kAaXNpc2kAcGkAZW50bGkAb3VzbGkAZWxpAGJsaQBzaXNzaWkAaXNzaXNpaQBzc3NpaWkAYXNjaWkAcnRyZWVkZXB0aABtb250aABqc29uX2FycmF5X2xlbmd0aABvY3RldF9sZW5ndGgAb3ZlcmZsb3cgbGlzdCBsZW5ndGgAd2R0aABzdGF0X3B1c2gAZmx1c2gAYWNvc2gAYXNpbmgAYXRhbmgAeFVuZmV0Y2gAeEZldGNoAGpzb25fcGF0Y2gAanNvbmJfcGF0Y2gAZGF0YXR5cGUgbWlzbWF0Y2gAdGFibGUgc2NoZW1hcyBkbyBub3QgbWF0Y2gAYWJicmV2aWF0ZWQgcXVlcnkgYWxnb3JpdGhtIHNlYXJjaAB1bml4ZXBvY2gAc3FsaXRlX2F0dGFjaABzcWxpdGVfZGV0YWNoAGpzb25fZWFjaABhdmcAekVyck1zZwBuYXJnAFJ0cmVlTWF0Y2hBcmcAc3FsaXRlX2xvZwBzdGF0ZW1lbnQgdG9vIGxvbmcAY2Fubm90IG9wZW4gJXMgY29sdW1uIGZvciB3cml0aW5nAHN1YnN0cmluZwB1bnRlcm1pbmF0ZWQgc3RyaW5nAFN0cmluZwAlczogdGFibGUgZG9lcyBub3Qgc3VwcG9ydCBzY2FubmluZwBjZWlsaW5nAGNvbmZpZwBzdHJpbmcgb3IgYmxvYiB0b28gYmlnAHN0cmluZ19hZ2cAUmVsZWFzZVJlZwAlLjE2ZwAlITAuMTVnACUhLjE1ZwAgJWcAcHJpbnRmAHR5cGVvZgBtb2Rlb2YAeEVvZgBvdXQgb2YAcmVuYW1lIGNvbHVtbnMgb2YAaW5mAC1JbmYAbnVsbGlmAGlpZgBvZmYAdGltZWRpZmYAMDEyMzQ1Njc4OWFiY2RlZgBuUmVmAGxlYWYASWYAJWMlMDRkLSUwMmQtJTAyZCAlMDJkOiUwMmQ6JTA2LjNmACUuM2YANTBmADQwZgAlIS4qZgBjb2x1bW5zaXplAGhhc2hzaXplAGdldHBhZ2VzaXplAGRvY3NpemUAbW1hcF9zaXplAGNhY2hlX3NpemUAUFJBR01BICVRLnBhZ2Vfc2l6ZQB0b2tlbml6ZQBvcHRpbWl6ZQBhbGl6ZQBuS2V5U2l6ZQB4U2VjdG9yU2l6ZQB4RmlsZVNpemUAanNvbl9yZW1vdmUAanNvbmJfcmVtb3ZlAE1vdmUAY2FzZV9zZW5zaXRpdmUAcGFyc2UgZXJyb3IgaW4gdG9rZW5pemUgZGlyZWN0aXZlAG1hbGZvcm1lZCBwcmVmaXg9Li4uIGRpcmVjdGl2ZQBtYWxmb3JtZWQgZGV0YWlsPS4uLiBkaXJlY3RpdmUAbWFsZm9ybWVkIGNvbHVtbnNpemU9Li4uIGRpcmVjdGl2ZQBtYWxmb3JtZWQgY29udGVudGxlc3NfZGVsZXRlPS4uLiBkaXJlY3RpdmUAbWFsZm9ybWVkIGxvY2FsZT0uLi4gZGlyZWN0aXZlAG1hbGZvcm1lZCB0b2tlbmRhdGE9Li4uIGRpcmVjdGl2ZQBjYW5ub3QgY29tbWl0IC0gbm8gdHJhbnNhY3Rpb24gaXMgYWN0aXZlAGNhbm5vdCByb2xsYmFjayAtIG5vIHRyYW5zYWN0aW9uIGlzIGFjdGl2ZQBhdGl2ZQBleGNsdXNpdmUAdHJ1ZQBJc1RydWUAdW5pcXVlAGRmbHRfdmFsdWUAQ2Fubm90IGFkZCBhIFJFRkVSRU5DRVMgY29sdW1uIHdpdGggbm9uLU5VTEwgZGVmYXVsdCB2YWx1ZQBiYWQgcGFnZSB2YWx1ZQBBZ2dWYWx1ZQBqc29uX3F1b3RlAHB3cml0ZQB4V3JpdGUAT3BlbldyaXRlAGNvbnRlbnRsZXNzX2RlbGV0ZQBvbl9kZWxldGUAc2VjdXJlX2RlbGV0ZQBzZWN1cmUtZGVsZXRlAGNhbm5vdCBkZWxldGUASWR4RGVsZXRlAHByaXZhdGUAYWdncmVnYXRlAGNyZWF0ZQB4Q3JlYXRlAFZDcmVhdGUAb25fdXBkYXRlAHhVcGRhdGUAVlVwZGF0ZQBjdXJyZW50X2RhdGUAZmFsbG9jYXRlAGZ0cnVuY2F0ZQB4VHJ1bmNhdGUAaWNhdGUAYmFkIHBhcmFtZXRlciBvciBvdGhlciBBUEkgbWlzdXNlAHRvbyBtYW55IHRlcm1zIGluICVzIEJZIGNsYXVzZQB0b28gbWFueSB0ZXJtcyBpbiBPUkRFUiBCWSBjbGF1c2UAYWdncmVnYXRlIGZ1bmN0aW9ucyBhcmUgbm90IGFsbG93ZWQgaW4gdGhlIEdST1VQIEJZIGNsYXVzZQBQQVJUSVRJT04gY2xhdXNlAGEgTkFUVVJBTCBqb2luIG1heSBub3QgaGF2ZSBhbiBPTiBvciBVU0lORyBjbGF1c2UAZGF0YWJhc2UgJXMgaXMgYWxyZWFkeSBpbiB1c2UAQWdnSW52ZXJzZQBjbG9zZQB4Q2xvc2UAeERsQ2xvc2UAZmFsc2UAcGhyYXNlAHhSZWxlYXNlAGF0dGVtcHQgdG8gd3JpdGUgYSByZWFkb25seSBkYXRhYmFzZQBjb3JydXB0IGRhdGFiYXNlAGF0dGFjaGVkIGRhdGFiYXNlcyBtdXN0IHVzZSB0aGUgc2FtZSB0ZXh0IGVuY29kaW5nIGFzIG1haW4gZGF0YWJhc2UATm9kZSAlbGxkIG1pc3NpbmcgZnJvbSBkYXRhYmFzZQBmaWxlIGlzIG5vdCBhIGRhdGFiYXNlAHRlbXBfc3RvcmUAc3FsaXRlM2NoYW5nZXNldF9hcHBseSgpOiB0YWJsZSAlcyBoYXMgJWQgY29sdW1ucywgZXhwZWN0ZWQgJWQgb3IgbW9yZQAlcyBjbGF1c2Ugc2hvdWxkIGNvbWUgYWZ0ZXIgJXMgbm90IGJlZm9yZQBFeHBpcmUAZXhwcl9jb21wYXJlAFNvcnRlckNvbXBhcmUAc3VidHlwZQBTZXRTdWJ0eXBlAEdldFN1YnR5cGUAQ2xyU3VidHlwZQBqc29uX3R5cGUASXNUeXBlAElmTm9Ib3BlAHVuaXgtbm9uZQBJbml0Q29yb3V0aW5lAEVuZENvcm91dGluZQBsb2NhbHRpbWUAc3RyZnRpbWUAZGF0ZXRpbWUAY3VycmVudF90aW1lAHhDdXJyZW50VGltZQBteFBhdGhuYW1lAHhGdWxsUGF0aG5hbWUAYWZ0ZXIgcmVuYW1lAG5vbi10ZXh0IGZpbGVuYW1lAHhSZW5hbWUAVlJlbmFtZQBhbWJpZ3VvdXMgY29sdW1uIG5hbWUAdGVtcG9yYXJ5IHRyaWdnZXIgbWF5IG5vdCBoYXZlIHF1YWxpZmllZCBuYW1lACBPUkRFUiBCWSBuYW1lAHpOYW1lAHhTaGFkb3dOYW1lAHBNb2R1bGUAdW5peC1kb3RmaWxlAGNhbm5vdCBvcGVuIGZpbGUAdW5hYmxlIHRvIG9wZW4gZGF0YWJhc2UgZmlsZQBzek9zRmlsZQBpbW11dGFibGUAQWJvcnRhYmxlAGxlZ2FjeV9hbHRlcl90YWJsZQBzcWxpdGVfcmVuYW1lX3RhYmxlAHJlY3Vyc2l2ZWx5IGRlZmluZWQgZnRzNSBjb250ZW50IHRhYmxlAGNvbnRlbnRsZXNzX2RlbGV0ZT0xIHJlcXVpcmVzIGEgY29udGVudGxlc3MgdGFibGUAY29udGVudGxlc3NfdW5pbmRleGVkPTEgcmVxdWlyZXMgYSBjb250ZW50bGVzcyB0YWJsZQBNYXBwaW5nICglbGxkIC0+ICVsbGQpIG1pc3NpbmcgZnJvbSAlcyB0YWJsZQBjYW5ub3QgY3JlYXRlIHRyaWdnZXIgb24gc3lzdGVtIHRhYmxlAHZpcnR1YWwgdGFibGUAbm8gc3VjaCB0YWJsZQBUb28gbWFueSBjb2x1bW5zIGZvciBhbiBydHJlZSB0YWJsZQBUb28gZmV3IGNvbHVtbnMgZm9yIGFuIHJ0cmVlIHRhYmxlAFdyb25nIG51bWJlciBvZiBjb2x1bW5zIGZvciBhbiBydHJlZSB0YWJsZQBudW1iZXIgb2YgY29sdW1ucyBpbiBmb3JlaWduIGtleSBkb2VzIG5vdCBtYXRjaCB0aGUgbnVtYmVyIG9mIGNvbHVtbnMgaW4gdGhlIHJlZmVyZW5jZWQgdGFibGUAJ2RlbGV0ZS1hbGwnIG1heSBvbmx5IGJlIHVzZWQgd2l0aCBhIGNvbnRlbnRsZXNzIG9yIGV4dGVybmFsIGNvbnRlbnQgZnRzNSB0YWJsZQAncmVidWlsZCcgbWF5IG5vdCBiZSB1c2VkIHdpdGggYSBjb250ZW50bGVzcyBmdHM1IHRhYmxlACdkZWxldGUnIG1heSBub3QgYmUgdXNlZCB3aXRoIGEgY29udGVudGxlc3NfZGVsZXRlPTEgdGFibGUAdXNhYmxlAGxvY2FsIHRpbWUgdW5hdmFpbGFibGUAYW5vdGhlciByb3cgYXZhaWxhYmxlAG5vIG1vcmUgcm93cyBhdmFpbGFibGUAVmFyaWFibGUARHJvcFRhYmxlAGZ0czVfZ2V0X2xvY2FsZQBmdHM1X2xvY2FsZQB1dGYxNmxlAGNhc2Vfc2Vuc2l0aXZlX2xpa2UAU2V0Q29va2llAFJlYWRDb29raWUAY2FjaGUAY3Jpc2lzbWVyZ2UAdXNlcm1lcmdlAGF1dG9tZXJnZQBkZWxldGVtZXJnZQBjb2x1bW4gaW5kZXggb3V0IG9mIHJhbmdlAG5vdGlmaWNhdGlvbiBtZXNzYWdlAHdhcm5pbmcgbWVzc2FnZQBhQ29uc3RyYWludFVzYWdlAGludmFsaWQgcm9vdHBhZ2UAc3FsaXRlX2RicGFnZQBFeHRlbmRzIG9mZiBlbmQgb2YgcGFnZQBNQVhfUEFHRV9DT1VOVD0weGZmZmZmZmZlAFNjaGVtYSBjb3JydXB0IG9yIG5vdCBhbiBydHJlZQBqc29uX3RyZWUAQ3JlYXRlQnRyZWUAcnRyZWVub2RlAF9ub2RlAGpvdXJuYWxfbW9kZQBsb2NraW5nX21vZGUAb3Bjb2RlAHVuaWNvZGUAYnl0ZWNvZGUASm91cm5hbE1vZGUARGl2aWRlAGNvYWxlc2NlAHNxbGl0ZV9zZXF1ZW5jZQBTZXF1ZW5jZQBpbnN0YW5jZQBPbmNlAFRyYWNlAGpzb25fcmVwbGFjZQBqc29uYl9yZXBsYWNlAHV0ZjE2YmUATmUATGUAR2UAMjBjOjIwZQAyMGI6MjBlACUhMC4yMGUAZ2V0Y3dkAE1ha2VSZWNvcmQAdGhzdG5kcmQAbGlrZWxpaG9vZABmY2htb2QAcm91bmQATm90Rm91bmQAc3Vic2Vjb25kAFJld2luZABlbmQAU2Vla0VuZABCaXRBbmQAb2xkAHslbGxkAFdyb25nIG51bWJlciBvZiBlbnRyaWVzIGluICUlJXMgdGFibGUgLSBleHBlY3RlZCAlbGxkLCBhY3R1YWwgJWxsZABubyBzdWNoIGN1cnNvcjogJWxsZABubyBzdWNoIHJvd2lkOiAlbGxkACwiU1FMSVRFX1dBU01fREVBTExPQyI6ICVsbGQAcmVidWlsZABZaWVsZABsYXN0X2luc2VydF9yb3dpZABjb250ZW50X3Jvd2lkACVfcm93aWQAJXMucm93aWQAU0VMRUNUKkZST00iJXciLiVzIE9SREVSIEJZIHJvd2lkAFNFTEVDVCpGUk9NIiV3Ii4lcyBXSEVSRSAlcyBPUkRFUiBCWSByb3dpZABJZHhSb3dpZABOZXdSb3dpZABTZWVrUm93aWQAZ2V0ZXVpZABpbnZhbGlkAGpzb25fdmFsaWQAZmtpZABjaWQAYXBwbGljYXRpb25faWQAc3FsaXRlX3NvdXJjZV9pZABmdHM1X3NvdXJjZV9pZABub3QgYXV0aG9yaXplZABjb250ZW50bGVzc191bmluZGV4ZWQAdW5hYmxlIHRvIGlkZW50aWZ5IHRoZSBvYmplY3QgdG8gYmUgcmVpbmRleGVkAHZpZXdzIG1heSBub3QgYmUgaW5kZXhlZAB2aXJ0dWFsIHRhYmxlcyBtYXkgbm90IGJlIGluZGV4ZWQAdGFibGUgJXMgbWF5IG5vdCBiZSBpbmRleGVkAHJlYWRfdW5jb21taXR0ZWQAcmVjdXJzaXZlIGFnZ3JlZ2F0ZSBxdWVyaWVzIG5vdCBzdXBwb3J0ZWQAcXVlcnkgYWJvcnRlZAByb3dzIGluc2VydGVkAGNvcnJ1cHRlZABpbnRlcnJ1cHRlZABjaGVja3BvaW50ZWQAYWNjZXNzIHRvICV6IGlzIHByb2hpYml0ZWQAYWNjZXNzIHRvIHZpZXcgIiVzIiBwcm9oaWJpdGVkAHJvd3MgZGVsZXRlZABnZW5lcmF0ZWQAcm93cyB1cGRhdGVkAG5vdHVzZWQAcm93IHZhbHVlIG1pc3VzZWQAdGFibGVzX3VzZWQAc3FsaXRlX2NvbXBpbGVvcHRpb25fdXNlZABQYWdlICV1OiBuZXZlciB1c2VkAENvbHVtbnNVc2VkAGNvbFVzZWQAc3RvcmVkAHZpcnR1YWwgdGFibGVzIG1heSBub3QgYmUgYWx0ZXJlZAB2aWV3ICVzIG1heSBub3QgYmUgYWx0ZXJlZAB0YWJsZSAlcyBtYXkgbm90IGJlIGFsdGVyZWQAc2hhcmVkAGluZGV4IGFzc29jaWF0ZWQgd2l0aCBVTklRVUUgb3IgUFJJTUFSWSBLRVkgY29uc3RyYWludCBjYW5ub3QgYmUgZHJvcHBlZAB0YWJsZSAlcyBtYXkgbm90IGJlIGRyb3BwZWQAdmlldyAlcyBpcyBjaXJjdWxhcmx5IGRlZmluZWQAdW5vcGVuZWQAb3JkZXJCeUNvbnN1bWVkAGRhdGFiYXNlIGRpc2sgaW1hZ2UgaXMgbWFsZm9ybWVkACVzIGNvbnN0cmFpbnQgZmFpbGVkAEZPUkVJR04gS0VZIGNvbnN0cmFpbnQgZmFpbGVkAGRhdGFiYXNlICVzIGlzIGxvY2tlZABkYXRhYmFzZSBpcyBsb2NrZWQAZGF0YWJhc2UgdGFibGUgaXMgbG9ja2VkAGF1dGhvcml6YXRpb24gZGVuaWVkAGFjY2VzcyBwZXJtaXNzaW9uIGRlbmllZAB0YWJsZSAlUyBoYXMgJWQgY29sdW1ucyBidXQgJWQgdmFsdWVzIHdlcmUgc3VwcGxpZWQAdGVtcG9yYXJ5IHRhYmxlIG5hbWUgbXVzdCBiZSB1bnF1YWxpZmllZAB0YWJsZSAlcyBtYXkgbm90IGJlIG1vZGlmaWVkAGNvbmZsaWN0aW5nIE9OIENPTkZMSUNUIGNsYXVzZXMgc3BlY2lmaWVkAG5vIHRhYmxlcyBzcGVjaWZpZWQAZGF0YWJhc2UgaXMgYWxyZWFkeSBhdHRhY2hlZABkYXRhYmFzZSBzY2hlbWEgaGFzIGNoYW5nZWQAZWVkAGV4Y2x1ZGVkAFBhZ2UgJXU6IHBvaW50ZXIgbWFwIHJlZmVyZW5jZWQAUm93U2V0QWRkAEZpbHRlckFkZABwcmVhZAB4UmVhZABSb3dTZXRSZWFkAE9wZW5SZWFkACUwNGQAJTAzZAAlMDJkOiUwMmQ6JTAyZAAlMDRkLSUwMmQtJTAyZAAlMmQANDBmLTIxYS0yMWQANTBmLTIwYS0yMGQANDBmLTIwYS0yMGQAc3FsaXRlX3N0YXQlZABjb2x1bW4lZAAsIFQubCVkACwgbCVkACwgVC5jJWQALCBjJWQALGElZABzcWxpdGVfYXV0b2luZGV4XyVzXyVkACV6JXM/JWQAYSVkPT8lZAAleiw/JWQAdmFyaWFibGUgbnVtYmVyIG11c3QgYmUgYmV0d2VlbiA/MSBhbmQgPyVkAHVuYWJsZSB0byBnZXQgdGhlIHBhZ2UuIGVycm9yIGNvZGU9JWQAayglZABVUERBVEUgJVEuc3FsaXRlX21hc3RlciBTRVQgcm9vdHBhZ2U9JWQgV0hFUkUgIyVkIEFORCByb290cGFnZT0jJWQAVVBEQVRFICVRLnNxbGl0ZV9tYXN0ZXIgU0VUIHR5cGU9JyVzJywgbmFtZT0lUSwgdGJsX25hbWU9JVEsIHJvb3RwYWdlPSMlZCwgc3FsPSVRIFdIRVJFIHJvd2lkPSMlZABVUERBVEUgJVEuc3FsaXRlX21hc3RlciBTRVQgdHlwZT0ndGFibGUnLCBuYW1lPSVRLCB0YmxfbmFtZT0lUSwgcm9vdHBhZ2U9MCwgc3FsPSVRIFdIRVJFIHJvd2lkPSMlZAB0b28gbWFueSBhdHRhY2hlZCBkYXRhYmFzZXMgLSBtYXggJWQAdG9vIG1hbnkgYXJndW1lbnRzIG9uICVzKCkgLSBtYXggJWQAZXhwZWN0ZWQgJWQgY29sdW1ucyBmb3IgJyVzJyBidXQgZ290ICVkAGF0dGVtcHQgdG8gb3BlbiAiJXMiIGFzIGZpbGUgZGVzY3JpcHRvciAlZABidHJlZUluaXRQYWdlKCkgcmV0dXJucyBlcnJvciBjb2RlICVkACVyICVzIEJZIHRlcm0gb3V0IG9mIHJhbmdlIC0gc2hvdWxkIGJlIGJldHdlZW4gMSBhbmQgJWQAc3ViLXNlbGVjdCByZXR1cm5zICVkIGNvbHVtbnMgLSBleHBlY3RlZCAlZABJTiguLi4pIGVsZW1lbnQgaGFzICVkIHRlcm0lcyAtIGV4cGVjdGVkICVkACVzTElTVCBTVUJRVUVSWSAlZABSRVVTRSBMSVNUIFNVQlFVRVJZICVkACVzU0NBTEFSIFNVQlFVRVJZICVkAFJFVVNFIFNVQlFVRVJZICVkAElOREVYICVkAHRvbyBtYW55IEZST00gY2xhdXNlIHRlcm1zLCBtYXg6ICVkACVzIiVzIjogJWQAInNpemVvZiI6ICVkAHJ3YwB1dGMAZGVzYwBjaGVja3BvaW50X2Z1bGxmc3luYwBmdWxsX2ZzeW5jAHhTeW5jAHRydW5jAHhGdW5jAFB1cmVGdW5jAGVuYwBudW1lcmljAFNxbEV4ZWMAc3Vic2VjACUuNGMlcyUuMTZjAGFwaS9zcWxpdGUzLXdhc20uYwAlcy9ldGlscXNfJWxseCVjAHdiAEdvc3ViAHJiAGdsb2IAemVyb2Jsb2IAcmFuZG9tYmxvYgBCbG9iAGpzb25iAG1lbWRiAHBWdGFiAGZ0czV2b2NhYgByd2EAdG9rZW5kYXRhACVzX2RhdGEAUm93RGF0YQBTb3J0ZXJEYXRhAHBBcHBEYXRhAHNxbGl0ZV90ZW1wX3NjaGVtYQBzcWxpdGVfc2NoZW1hAHdyaXRhYmxlX3NjaGVtYQB0cnVzdGVkX3NjaGVtYQBjb3JydXB0IHNjaGVtYQBubyBzdWNoIHNjaGVtYQBQYXJzZVNjaGVtYQBzcWxpdGVfAHByYWdtYV8AU1FMSVRFXwBfUk9XSURfACVzIGF0IGxpbmUgJWQgb2YgWyUuMTBzXQBiaW5kIG9uIGEgYnVzeSBwcmVwYXJlZCBzdGF0ZW1lbnQ6IFslc10AWyVsbGRdAFtdACwgInN0cnVjdHMiOiBbAFNRTElURV9DT05GSUdfUENBQ0hFX0hEUlNaAFNRTElURV9DT05GSUdfUE1BU1oAU1FMSVRFX0VNUFRZAFNRTElURV9CVVNZAFNRTElURV9GQ05UTF9XSU4zMl9BVl9SRVRSWQBTUUxJVEVfRVJST1JfUkVUUlkAU1FMSVRFX1JFQURPTkxZX0RJUkVDVE9SWQBTUUxJVEVfT1BFTl9NRU1PUlkAU1FMSVRFX0JVU1lfUkVDT1ZFUlkAU1FMSVRFX1JFQURPTkxZX1JFQ09WRVJZAExFRlQtTU9TVCBTVUJRVUVSWQBDT01QT1VORCBRVUVSWQBTUUxJVEVfU0VSSUFMSVpFX05PQ09QWQBTUUxJVEVfREVOWQBBTlkAU1FMSVRFX09LX0xPQURfUEVSTUFORU5UTFkAU1FMSVRFX0RJUkVDVE9OTFkAU1FMSVRFX1ZUQUJfRElSRUNUT05MWQBTUUxJVEVfT1BFTl9SRUFET05MWQBTUUxJVEVfREVTRVJJQUxJWkVfUkVBRE9OTFkAU1FMSVRFX1JFQURPTkxZAFNRTElURV9TWU5DX0RBVEFPTkxZAFNRTElURV9DSEFOR0VTRVRfRk9SRUlHTl9LRVkAU1FMSVRFX0NPTlNUUkFJTlRfUFJJTUFSWUtFWQBTUUxJVEVfQ09OU1RSQUlOVF9GT1JFSUdOS0VZAFNRTElURV9EQkNPTkZJR19FTkFCTEVfRktFWQBnZW5lcmF0ZWQgY29sdW1ucyBjYW5ub3QgYmUgcGFydCBvZiB0aGUgUFJJTUFSWSBLRVkAQVVUT0lOQ1JFTUVOVCBpcyBvbmx5IGFsbG93ZWQgb24gYW4gSU5URUdFUiBQUklNQVJZIEtFWQBpZCBJTlRFR0VSIFBSSU1BUlkgS0VZAEZPUkVJR04gS0VZAFVTRSBURU1QIEItVFJFRSBGT1IgJXNPUkRFUiBCWQBVU0UgVEVNUCBCLVRSRUUgRk9SIExBU1QgJWQgVEVSTVMgT0YgT1JERVIgQlkAR1JPVVAgQlkAaWlzWABpc2lYAFNRTElURV9DT05GSUdfTVVURVgAU1FMSVRFX0NPTkZJR19HRVRNVVRFWABTUUxJVEVfT1BFTl9OT01VVEVYAFNRTElURV9PUEVOX0ZVTExNVVRFWABTUUxJVEVfQ09SUlVQVF9JTkRFWABTUUxJVEVfRFJPUF9JTkRFWABTUUxJVEVfRFJPUF9URU1QX0lOREVYAFNRTElURV9DUkVBVEVfVEVNUF9JTkRFWABTUUxJVEVfQ1JFQVRFX0lOREVYAFNRTElURV9TVE1UU1RBVFVTX0FVVE9JTkRFWABTUUxJVEVfV0FSTklOR19BVVRPSU5ERVgAU1FMSVRFX1JFSU5ERVgAQVVUT01BVElDIFBBUlRJQUwgQ09WRVJJTkcgSU5ERVgAQVVUT01BVElDIENPVkVSSU5HIElOREVYAFNRTElURV9EQlNUQVRVU19NQVgAU1FMSVRFX0RCQ09ORklHX01BWAAtbWolMDZYOSUwMlgAU1FMSVRFX1JPVwBTUUxJVEVfVFJBQ0VfUk9XAFNDQU4gQ09OU1RBTlQgUk9XAFNRTElURV9PUEVOX05PRk9MTE9XAFNRTElURV9TVEFUVVNfUEFHRUNBQ0hFX09WRVJGTE9XAFNRTElURV9EUk9QX1ZJRVcAU1FMSVRFX0RST1BfVEVNUF9WSUVXAFNRTElURV9DUkVBVEVfVEVNUF9WSUVXAFNRTElURV9DUkVBVEVfVklFVwBTUUxJVEVfREJDT05GSUdfRU5BQkxFX1ZJRVcAcHBWAFNRTElURV9GQ05UTF9SQlUAU1FMSVRFX1RFWFQAanNvbl9vYmplY3QoKSBsYWJlbHMgbXVzdCBiZSBURVhUAFNRTElURV9CVVNZX1RJTUVPVVQAU1FMSVRFX0ZDTlRMX0xPQ0tfVElNRU9VVABGSVJTVABMQVNUAFNRTElURV9TVE1UU1RBVFVTX1NPUlQAU1FMSVRFX1ZUQUJfQ09OU1RSQUlOVF9TVVBQT1JUAFNRTElURV9DSEFOR0VTRVRfQUJPUlQAU1FMSVRFX0FCT1JUAFNRTElURV9DSEFOR0VTRVRBUFBMWV9JTlZFUlQAU1FMSVRFX0NIQU5HRVNFVFNUQVJUX0lOVkVSVABTUUxJVEVfSU5TRVJUAFNRTElURV9GQ05UTF9DS1BUX1NUQVJUAFNRTElURV9DT1JSVVBUAFNRTElURV9JTlRFUlJVUFQARVhDRVBUAFNRTElURV9JTkRFWF9DT05TVFJBSU5UX0lTTk9UAFNRTElURV9CVVNZX1NOQVBTSE9UAFNRTElURV9FUlJPUl9TTkFQU0hPVABTUUxJVEVfU1RBVFVTX01BTExPQ19DT1VOVABTUUxJVEVfU0FWRVBPSU5UAFNRTElURV9DSEFOR0VTRVRBUFBMWV9OT1NBVkVQT0lOVABTUUxJVEVfRkNOVExfU0laRV9ISU5UAFNRTElURV9DSEFOR0VTRVRfQ09OU1RSQUlOVABTUUxJVEVfQ09OU1RSQUlOVAAsJS4qcyBJTlQAQ1JFQVRFIFRBQkxFIHgoJS4qcyBJTlQAU1FMSVRFX1BSRVBBUkVfUEVSU0lTVEVOVABTUUxJVEVfSU9FUlJfREVMRVRFX05PRU5UAFNRTElURV9UUkFDRV9TVE1UAElkeExUAFNlZWtMVABTUUxJVEVfSU5ERVhfQ09OU1RSQUlOVF9MVABTRVQgREVGQVVMVABTUUxJVEVfUkVBRE9OTFlfQ0FOVElOSVQATVVURVhfT01JVABTUUxJVEVfQ0hBTkdFU0VUX09NSVQAQ09NTUlUAFNRTElURV9JTkRFWF9DT05TVFJBSU5UX0xJTUlUAFNRTElURV9GQ05UTF9TSVpFX0xJTUlUAFNRTElURV9TVE1UU1RBVFVTX0ZJTFRFUl9ISVQAU1FMSVRFX0RCU1RBVFVTX0NBQ0hFX0hJVABTUUxJVEVfREJTVEFUVVNfTE9PS0FTSURFX0hJVABSSUdIVABJZHhHVABTZWVrR1QAU1FMSVRFX0lOREVYX0NPTlNUUkFJTlRfR1QATEVGVABTUUxJVEVfSU5ERVhfQ09OU1RSQUlOVF9PRkZTRVQARElTVElOQ1QAUkVTVFJJQ1QAU1FMSVRFX0NIQU5HRVNFVF9DT05GTElDVABJTlRFUlNFQ1QAU1FMSVRFX1NFTEVDVABTUUxJVEVfTUFYX0NPTVBPVU5EX1NFTEVDVABTUUxJVEVfTElNSVRfQ09NUE9VTkRfU0VMRUNUAHRvbyBtYW55IHRlcm1zIGluIGNvbXBvdW5kIFNFTEVDVABTUUxJVEVfSU9FUlJfRlNUQVQAU1FMSVRFX0ZMT0FUAFNRTElURV9GT1JNQVQAU1FMSVRFX0RCQ09ORklHX0xFR0FDWV9GSUxFX0ZPUk1BVAB1bmtub3duIGpvaW4gdHlwZTogJVQlcyVUJXMlVAAtJVQAdG9vIG1hbnkgYXJndW1lbnRzIG9uIGZ1bmN0aW9uICVUAHVua25vd24gZGF0YWJhc2UgJVQAZm9yZWlnbiBrZXkgb24gJXMgc2hvdWxkIHJlZmVyZW5jZSBvbmx5IG9uZSBjb2x1bW4gb2YgdGFibGUgJVQAQ1JFQVRFIFZJUlRVQUwgVEFCTEUgJVQAaGV4IGxpdGVyYWwgdG9vIGJpZzogJXMlI1QAbm8gc3VjaCBmdW5jdGlvbjogJSNUAG5vdCBhdXRob3JpemVkIHRvIHVzZSBmdW5jdGlvbjogJSNUAFNFTEVDVCAlcyBGUk9NICVzIEFTIFQAU1FMSVRFX0RCQ09ORklHX1NUTVRfU0NBTlNUQVRVUwBTUUxJVEVfQ09ORklHX01FTVNUQVRVUwBTUUxJVEVfSU5OT0NVT1VTAFNRTElURV9WVEFCX0lOTk9DVU9VUwBTUUxJVEVfQUNDRVNTX0VYSVNUUwBTUUxJVEVfU1RNVFNUQVRVU19GSUxURVJfTUlTUwBTUUxJVEVfREJTVEFUVVNfQ0FDSEVfTUlTUwBTUUxJVEVfSU9FUlJfQUNDRVNTAERFRkFVTFRfUkVDVVJTSVZFX1RSSUdHRVJTAEVOQUJMRV9NQVRIX0ZVTkNUSU9OUwBTUUxJVEVfREJTVEFUVVNfREVGRVJSRURfRktTAFNRTElURV9JTkRFWF9DT05TVFJBSU5UX0lTAFNRTElURV9GQ05UTF9aSVBWRlMAU1FMSVRFX0lPRVJSX0NPUlJVUFRGUwBTUUxJVEVfTk9MRlMAU1FMSVRFX0ZDTlRMX1JFU0VSVkVfQllURVMAU1FMSVRFX01BWF9XT1JLRVJfVEhSRUFEUwBTUUxJVEVfTElNSVRfV09SS0VSX1RIUkVBRFMAU1FMSVRFX1ZUQUJfVVNFU19BTExfU0NIRU1BUwAlcyAlUwBTQ0FOICVTAG5vIHN1Y2ggaW5kZXg6ICVTAGNhbm5vdCBjcmVhdGUgJXMgdHJpZ2dlciBvbiB2aWV3OiAlUwBubyBzdWNoIHRyaWdnZXI6ICVTAGNhbm5vdCBjcmVhdGUgSU5TVEVBRCBPRiB0cmlnZ2VyIG9uIHRhYmxlOiAlUwBNQVRFUklBTElaRSAlIVMAQ08tUk9VVElORSAlIVMAU1FMSVRFX0lPRVJSAFVTSU5HIElOREVYICVzIEZPUiBJTi1PUEVSQVRPUgBVU0lORyBST1dJRCBTRUFSQ0ggT04gVEFCTEUgJXMgRk9SIElOLU9QRVJBVE9SAFNRTElURV9FUlJPUgBFTkFCTEVfQVBJX0FSTU9SAE1VTFRJLUlOREVYIE9SAFNRTElURV9DQU5UT1BFTl9JU0RJUgBTUUxJVEVfVE1QRElSAFNRTElURV9DQU5UT1BFTl9OT1RFTVBESVIAU1FMSVRFX0ZDTlRMX1ZGU19QT0lOVEVSAFNRTElURV9GQ05UTF9KT1VSTkFMX1BPSU5URVIAU1FMSVRFX0ZDTlRMX0ZJTEVfUE9JTlRFUgBDUkVBVEUgQkxPT00gRklMVEVSAEFGVEVSAFNRTElURV9BVVRIX1VTRVIAU1FMSVRFX0ZDTlRMX0JVU1lIQU5ETEVSAFNRTElURV9DT05TVFJBSU5UX1RSSUdHRVIAU1FMSVRFX0RST1BfVFJJR0dFUgBTUUxJVEVfRFJPUF9URU1QX1RSSUdHRVIAU1FMSVRFX0NSRUFURV9URU1QX1RSSUdHRVIAU1FMSVRFX0NSRUFURV9UUklHR0VSAFNRTElURV9EQkNPTkZJR19FTkFCTEVfVFJJR0dFUgBTUUxJVEVfSU5URUdFUgBpZCBJTlRFR0VSIFBSSU1BUlkgS0VZLCBzeiBCTE9CLCBvcmlnaW4gSU5URUdFUgBTUUxJVEVfREJDT05GSUdfUkVWRVJTRV9TQ0FOT1JERVIAU1FMSVRFX0ZDTlRMX0VYVEVSTkFMX1JFQURFUgBTUUxJVEVfVkVSU0lPTl9OVU1CRVIAU1FMSVRFX01BWF9WQVJJQUJMRV9OVU1CRVIAU1FMSVRFX0xJTUlUX1ZBUklBQkxFX05VTUJFUgBORUFSAFNRTElURV9JTkRFWF9DT05TVFJBSU5UX0VRAFNRTElURV9FUlJPUl9NSVNTSU5HX0NPTExTRVEAJXolcyVRAERFTEVURSBGUk9NICVRLiVzIFdIRVJFICVzPSVRAG5hbWU9JVEgQU5EIHNxbD0lUQBERUxFVEUgRlJPTSAlUS5zcWxpdGVfc2VxdWVuY2UgV0hFUkUgbmFtZT0lUQAsIFQuJVEAU0VMRUNUICogRlJPTSAlUS4lUQBBVFRBQ0ggeCBBUyAlUQBVUERBVEUgIiV3Ii5zcWxpdGVfc2VxdWVuY2Ugc2V0IG5hbWUgPSAlUSBXSEVSRSBuYW1lID0gJVEAVVBEQVRFICIldyIuc3FsaXRlX21hc3RlciBTRVQgc3FsID0gcHJpbnRmKCclJS4lZHMsICcsc3FsKSB8fCAlUSB8fCBzdWJzdHIoc3FsLDErbGVuZ3RoKHByaW50ZignJSUuJWRzJyxzcWwpKSkgV0hFUkUgdHlwZSA9ICd0YWJsZScgQU5EIG5hbWUgPSAlUQBiYWQgSlNPTiBwYXRoOiAlUQBmdHM1dm9jYWI6IHVua25vd24gdGFibGUgdHlwZTogJVEAU1FMSVRFX0lOREVYX0NPTlNUUkFJTlRfUkVHRVhQAFNFVFVQAEdST1VQAFNRTElURV9EQkNPTkZJR19UUklHR0VSX0VRUABTUUxJVEVfTUFYX1ZEQkVfT1AAU1FMSVRFX0xJTUlUX1ZEQkVfT1AAU1FMSVRFX0NIQU5HRVNFVEFQUExZX0lHTk9SRU5PT1AAU1FMSVRFX1NUTVRTVEFUVVNfRlVMTFNDQU5fU1RFUABTUUxJVEVfU1RNVFNUQVRVU19WTV9TVEVQAFJFQ1VSU0lWRSBTVEVQAFNRTElURV9JT0VSUl9NTUFQAFNRTElURV9JT0VSUl9TSE1NQVAAU1FMSVRFX0NPTkZJR19IRUFQAFNRTElURV9GQ05UTF9DT01NSVRfUEhBU0VUV08AU1FMSVRFX0ZDTlRMX0xBU1RfRVJSTk8AU05hTgBRTmFOAFNRTElURV9TVE1UU1RBVFVTX1JVTgBtYWxmb3JtZWQgSlNPTgBTUUxJVEVfSU5ERVhfQ09OU1RSQUlOVF9GVU5DVElPTgBTUUxJVEVfQ09OU1RSQUlOVF9GVU5DVElPTgBFTkFCTEVfVU5LTk9XTl9TUUxfRlVOQ1RJT04AU1FMSVRFX0ZVTkNUSU9OAFNRTElURV9UUkFOU0FDVElPTgBOTyBBQ1RJT04ARU5BQkxFX1NFU1NJT04AU1FMSVRFX1ZFUlNJT04AU1FMSVRFX0ZDTlRMX0RBVEFfVkVSU0lPTgBPTUlUX0xPQURfRVhURU5TSU9OAFNRTElURV9EQkNPTkZJR19FTkFCTEVfTE9BRF9FWFRFTlNJT04AVU5JT04AU1FMSVRFX01BWF9DT0xVTU4AU1FMSVRFX0xJTUlUX0NPTFVNTgAgTEVGVC1KT0lOAEJFR0lOAFNRTElURV9JT0NBUF9VTkRFTEVUQUJMRV9XSEVOX09QRU4AU1FMSVRFX0NBTlRPUEVOAFNRTElURV9JT0VSUl9TSE1PUEVOACxhcmcgSElEREVOACxzY2hlbWEgSElEREVOAE5BTgBTUUxJVEVfQ09ORklHX0NPVkVSSU5HX0lOREVYX1NDQU4AREVGQVVMVF9BVVRPVkFDVVVNACBOVU0AU1FMSVRFX1BFUk0AUE0AUlRSSU0AU1FMSVRFX0lPRVJSX05PTUVNAFNRTElURV9OT01FTQBBTQBTUUxJVEVfUFJPVE9DT0wAU1FMSVRFX0RCQ09ORklHX0RRU19ETUwAU1FMSVRFX05VTEwAU1FMSVRFX0NPTlNUUkFJTlRfTk9UTlVMTABTUUxJVEVfSU5ERVhfQ09OU1RSQUlOVF9JU05PVE5VTEwAU1FMSVRFX0lOREVYX0NPTlNUUkFJTlRfSVNOVUxMAENhbm5vdCBhZGQgYSBOT1QgTlVMTCBjb2x1bW4gd2l0aCBkZWZhdWx0IHZhbHVlIE5VTEwATk9UIE5VTEwAU0VUIE5VTEwALCBOVUxMAFNRTElURV9EQlNUQVRVU19MT09LQVNJREVfTUlTU19GVUxMAFNRTElURV9GVUxMAFNRTElURV9TWU5DX0ZVTEwAU1FMSVRFX0NPTkZJR19TVE1USlJOTF9TUElMTABTUUxJVEVfREJTVEFUVVNfQ0FDSEVfU1BJTEwAVU5JT04gQUxMAFNRTElURV9GQUlMAFNRTElURV9EQkNPTkZJR19EUVNfRERMAFNRTElURV9GQ05UTF9QRVJTSVNUX1dBTABTUUxJVEVfTk9USUNFX1JFQ09WRVJfV0FMAFNRTElURV9PUEVOX1dBTABTUUxJVEVfT1BFTl9TVVBFUl9KT1VSTkFMAFNRTElURV9PUEVOX1RFTVBfSk9VUk5BTABTUUxJVEVfT1BFTl9NQUlOX0pPVVJOQUwAU1FMSVRFX09QRU5fU1VCSk9VUk5BTABTUUxJVEVfSU5URVJOQUwAU1FMSVRFX1NZTkNfTk9STUFMAFNRTElURV9JT0NBUF9TRVFVRU5USUFMACwlLipzIFJFQUwAU1FMSVRFX09LAEVOQUJMRV9QUkVVUERBVEVfSE9PSwBTUUxJVEVfQ09OU1RSQUlOVF9DT01NSVRIT09LAFNRTElURV9DQU5UT1BFTl9TWU1MSU5LAFNRTElURV9JT0VSUl9TRUVLAFNRTElURV9JT0VSUl9MT0NLAFNRTElURV9SRUFET05MWV9DQU5UTE9DSwBTUUxJVEVfSU9FUlJfVU5MT0NLAFNRTElURV9JT0VSUl9TSE1MT0NLAFNRTElURV9JT0VSUl9SRExPQ0sAU1FMSVRFX0lPRVJSX0NIRUNLUkVTRVJWRURMT0NLAFNRTElURV9GQ05UTF9XQUxfQkxPQ0sAU1FMSVRFX0NPTlNUUkFJTlRfQ0hFQ0sAU1FMSVRFX1NUQVRVU19QQVJTRVJfU1RBQ0sAU1FMSVRFX1JFQURPTkxZX1JPTExCQUNLAFNRTElURV9BQk9SVF9ST0xMQkFDSwBTUUxJVEVfTk9USUNFX1JFQ09WRVJfUk9MTEJBQ0sAU1FMSVRFX1JPTExCQUNLAGFib3J0IGR1ZSB0byBST0xMQkFDSwBTUUxJVEVfSU9DQVBfQVRPTUlDOEsAU1FMSVRFX0lPQ0FQX0FUT01JQzE2SwBTUUxJVEVfSU9DQVBfQVRPTUlDNEsAU1FMSVRFX0lPQ0FQX0FUT01JQzY0SwBTUUxJVEVfSU9DQVBfQVRPTUlDMksAU1FMSVRFX0lPQ0FQX0FUT01JQzMySwBTUUxJVEVfSU9DQVBfQVRPTUlDMUsAU1FMSVRFX09QRU5fVVJJAFNRTElURV9DT05GSUdfVVJJAFVTRV9VUkkAU1FMSVRFX0lPRVJSX0FVVEgAU1FMSVRFX0FVVEgAU1FMSVRFX01BWF9FWFBSX0RFUFRIAFNRTElURV9MSU1JVF9FWFBSX0RFUFRIAFNRTElURV9NQVhfVFJJR0dFUl9ERVBUSABTUUxJVEVfTElNSVRfVFJJR0dFUl9ERVBUSABTUUxJVEVfTUFYX0xFTkdUSABTUUxJVEVfTElNSVRfTEVOR1RIAFNRTElURV9NQVhfTElLRV9QQVRURVJOX0xFTkdUSABTUUxJVEVfTElNSVRfTElLRV9QQVRURVJOX0xFTkdUSABTUUxJVEVfTUFYX1NRTF9MRU5HVEgAU1FMSVRFX0xJTUlUX1NRTF9MRU5HVEgAU1FMSVRFX0lPRVJSX0NPTlZQQVRIAFNRTElURV9DQU5UT1BFTl9DT05WUEFUSABTUUxJVEVfSU9FUlJfR0VUVEVNUFBBVEgAU1FMSVRFX0NBTlRPUEVOX0ZVTExQQVRIAFNRTElURV9DT05GSUdfU0NSQVRDSABTUUxJVEVfSU5ERVhfQ09OU1RSQUlOVF9NQVRDSABTUUxJVEVfTUlTTUFUQ0gAU0VBUkNIAFNRTElURV9BVFRBQ0gAU1FMSVRFX0RFVEFDSABTUUxJVEVfREJDT05GSUdfRU5BQkxFX1FQU0cAU1FMSVRFX01BWF9GVU5DVElPTl9BUkcAU1FMSVRFX0xJTUlUX0ZVTkNUSU9OX0FSRwBTUUxJVEVfQ09ORklHX0xPRwBTUUxJVEVfQ09ORklHX1NRTExPRwBVU0lORwBTUUxJVEVfV0FSTklORwBTUUxJVEVfTE9DS19QRU5ESU5HAFNRTElURV9UT09CSUcASU5GADAxMjM0NTY3ODlBQkNERUYAU1FMSVRFX0FOQUxZWkUAU1FMSVRFX0RCU1RBVFVTX0xPT0tBU0lERV9NSVNTX1NJWkUAU1FMSVRFX0ZDTlRMX01NQVBfU0laRQBTUUxJVEVfQ09ORklHX01NQVBfU0laRQBTUUxJVEVfTUFYX0FMTE9DQVRJT05fU0laRQBTUUxJVEVfRkNOVExfQ0hVTktfU0laRQBTUUxJVEVfU0VTU0lPTl9PQkpDT05GSUdfU0laRQBTUUxJVEVfQ09ORklHX1NPUlRFUlJFRl9TSVpFAFNRTElURV9TVEFUVVNfUEFHRUNBQ0hFX1NJWkUAU1FMSVRFX1NUQVRVU19NQUxMT0NfU0laRQBTUUxJVEVfQ09ORklHX01FTURCX01BWFNJWkUAU1FMSVRFX0NPTkZJR19XSU4zMl9IRUFQU0laRQBTUUxJVEVfU0VTU0lPTl9DT05GSUdfU1RSTVNJWkUAU1FMSVRFX0lPRVJSX1NITVNJWkUAU1FMSVRFX1BSRVBBUkVfTk9STUFMSVpFAFNRTElURV9PUEVOX0VYQ0xVU0lWRQBTUUxJVEVfTE9DS19FWENMVVNJVkUAU1FMSVRFX1JFQ1VSU0lWRQBTUUxJVEVfREJDT05GSUdfREVGRU5TSVZFAFNRTElURV9DT05TVFJBSU5UX1VOSVFVRQBTUUxJVEVfSU5ERVhfU0NBTl9VTklRVUUAIFVOSVFVRQBTUUxJVEVfSU9FUlJfV1JJVEUAU1FMSVRFX1RYTl9XUklURQBTUUxJVEVfREJTVEFUVVNfQ0FDSEVfV1JJVEUAU1FMSVRFX0ZDTlRMX0NPTU1JVF9BVE9NSUNfV1JJVEUAU1FMSVRFX0ZDTlRMX0JFR0lOX0FUT01JQ19XUklURQBTUUxJVEVfRkNOVExfUk9MTEJBQ0tfQVRPTUlDX1dSSVRFAFNRTElURV9GQ05UTF9PVkVSV1JJVEUAU1FMSVRFX0lPQ0FQX1BPV0VSU0FGRV9PVkVSV1JJVEUAU1FMSVRFX0ZDTlRMX1BPV0VSU0FGRV9PVkVSV1JJVEUAU1FMSVRFX0FDQ0VTU19SRUFEV1JJVEUAU1FMSVRFX09QRU5fUkVBRFdSSVRFAFNRTElURV9JT0VSUl9ERUxFVEUAU1FMSVRFX0RFTEVURQBTUUxJVEVfRkNOVExfTE9DS1NUQVRFAFNRTElURV9PUEVOX0NSRUFURQBTUUxJVEVfVVBEQVRFAGNhbm5vdCBVUERBVEUAU1FMSVRFX0lPRVJSX1RSVU5DQVRFAFNRTElURV9NSVNVU0UAJXUtUk9XIFZBTFVFUyBDTEFVU0UAU1FMSVRFX0lPRVJSX0NMT1NFAFNRTElURV9JT0VSUl9ESVJfQ0xPU0UAU1FMSVRFX0RCQ09ORklHX05PX0NLUFRfT05fQ0xPU0UAU1FMSVRFX1RSQUNFX0NMT1NFAFNRTElURV9PUEVOX0RFTEVURU9OQ0xPU0UAU1FMSVRFX0RFU0VSSUFMSVpFX0ZSRUVPTkNMT1NFAFJFTEVBU0UATk9DQVNFAFNRTElURV9EQkNPTkZJR19SRVNFVF9EQVRBQkFTRQBTUUxJVEVfSUdOT1JFAEJFRk9SRQBTUUxJVEVfU1RNVFNUQVRVU19SRVBSRVBBUkUAU1FMSVRFX1JFU1VMVF9TVUJUWVBFAFNRTElURV9TVUJUWVBFAFNRTElURV9DT05TVFJBSU5UX0RBVEFUWVBFAFNRTElURV9JTkRFWF9DT05TVFJBSU5UX05FAFNRTElURV9UWE5fTk9ORQBTUUxJVEVfTE9DS19OT05FAFNRTElURV9GQ05UTF9DS1BUX0RPTkUAU1FMSVRFX0RPTkUAU1FMSVRFX0ZDTlRMX1ZGU05BTUUAU1FMSVRFX0ZDTlRMX1RFTVBGSUxFTkFNRQBTUUxJVEVfREJDT05GSUdfTUFJTkRCTkFNRQBJZHhMRQBTZWVrTEUAU1FMSVRFX0lOREVYX0NPTlNUUkFJTlRfTEUAU1FMSVRFX0ZDTlRMX0NLU01fRklMRQBTUUxJVEVfRkNOVExfU0VUX0xPQ0tQUk9YWUZJTEUAU1FMSVRFX0ZDTlRMX0dFVF9MT0NLUFJPWFlGSUxFAFNRTElURV9UUkFDRV9QUk9GSUxFAFNRTElURV9GQ05UTF9XSU4zMl9TRVRfSEFORExFAFNRTElURV9GQ05UTF9XSU4zMl9HRVRfSEFORExFAFNRTElURV9EQkNPTkZJR19MRUdBQ1lfQUxURVJfVEFCTEUAU1FMSVRFX0FMVEVSX1RBQkxFAFNRTElURV9EUk9QX1RBQkxFAFNRTElURV9EUk9QX1RFTVBfVEFCTEUAU1FMSVRFX0NSRUFURV9URU1QX1RBQkxFAFNRTElURV9DUkVBVEVfVEFCTEUAU1FMSVRFX0RST1BfVlRBQkxFAFNRTElURV9DUkVBVEVfVlRBQkxFAFNRTElURV9JT0NBUF9JTU1VVEFCTEUAU1FMSVRFX0RFU0VSSUFMSVpFX1JFU0laRUFCTEUAU1FMSVRFX1VURjE2TEUAU1FMSVRFX0lOREVYX0NPTlNUUkFJTlRfTElLRQBTUUxJVEVfRkNOVExfUkVTRVRfQ0FDSEUAT01JVF9TSEFSRURfQ0FDSEUAU1FMSVRFX0NPTkZJR19QQ0FDSEUAU1FMSVRFX0NPTkZJR19HRVRQQ0FDSEUAU1FMSVRFX09QRU5fUFJJVkFURUNBQ0hFAFNRTElURV9DT05GSUdfUEFHRUNBQ0hFAFNRTElURV9PUEVOX1NIQVJFRENBQ0hFAFNRTElURV9MT0NLRURfU0hBUkVEQ0FDSEUASWR4R0UAU2Vla0dFAFNRTElURV9JTkRFWF9DT05TVFJBSU5UX0dFAFNRTElURV9SQU5HRQBFTkFCTEVfUlRSRUUAJXMgVVNJTkcgVEVNUCBCLVRSRUUAU1FMSVRFX0lPRVJSX1ZOT0RFAFNRTElURV9PUEVOX0VYUkVTQ09ERQBTUUxJVEVfQ09ORklHX0xPT0tBU0lERQBTUUxJVEVfREJDT05GSUdfTE9PS0FTSURFAENBU0NBREUAU1FMSVRFX0NPUlJVUFRfU0VRVUVOQ0UAU1FMSVRFX05PVElDRQBTUUxJVEVfRkNOVExfVFJBQ0UAU1FMSVRFX0NIQU5HRVNFVF9SRVBMQUNFAFNRTElURV9SRVBMQUNFAFNRTElURV9VVEYxNkJFAFNRTElURV9DSEFOR0VTRVRfTk9URk9VTkQAU1FMSVRFX05PVEZPVU5EAFNRTElURV9JT0NBUF9TQUZFX0FQUEVORABBTkQAU1FMSVRFX1NPVVJDRV9JRABTUUxJVEVfQ09OU1RSQUlOVF9ST1dJRAAgV0lUSE9VVCBST1dJRABPSUQAU1FMSVRFX0NPTkZJR19TRVJJQUxJWkVEAFNRTElURV9MT0NLX1JFU0VSVkVEAFNRTElURV9GQ05UTF9IQVNfTU9WRUQAU1FMSVRFX1JFQURPTkxZX0RCTU9WRUQAU1FMSVRFX0ZDTlRMX1NZTkNfT01JVFRFRABPTUlUX0RFUFJFQ0FURUQAU1FMSVRFX1NUQVRVU19NRU1PUllfVVNFRABTUUxJVEVfREJTVEFUVVNfU1RNVF9VU0VEAFNRTElURV9EQlNUQVRVU19DQUNIRV9VU0VEAFNRTElURV9TVEFUVVNfUEFHRUNBQ0hFX1VTRUQAU1FMSVRFX0RCU1RBVFVTX0xPT0tBU0lERV9VU0VEAFNRTElURV9EQlNUQVRVU19TQ0hFTUFfVVNFRABTUUxJVEVfU1RNVFNUQVRVU19NRU1VU0VEAFNRTElURV9MT0NLX1NIQVJFRABTUUxJVEVfREJTVEFUVVNfQ0FDSEVfVVNFRF9TSEFSRUQAU1FMSVRFX0NPTlNUUkFJTlRfUElOTkVEAFNRTElURV9VVEYxNl9BTElHTkVEAFNRTElURV9MT0NLRUQAU1FMSVRFX0lPRVJSX0JMT0NLRUQAU1FMSVRFX01BWF9BVFRBQ0hFRABTUUxJVEVfTElNSVRfQVRUQUNIRUQARElSRUNUX09WRVJGTE9XX1JFQUQAU1FMSVRFX0lPRVJSX1NIT1JUX1JFQUQAU1FMSVRFX0FDQ0VTU19SRUFEAFNRTElURV9JT0VSUl9SRUFEAFNRTElURV9UWE5fUkVBRABTUUxJVEVfUkVBRABTUUxJVEVfQ09ORklHX01VTFRJVEhSRUFEAFNRTElURV9DT05GSUdfU0lOR0xFVEhSRUFEAFNFTEVDVCAlcyBGUk9NICVzIFQgV0hFUkUgVC4lUSA8PSA/IEFORCBULiVRID49ID8gT1JERVIgQlkgVC4lUSBERVNDAFNFTEVDVCAlcyBGUk9NICVzIFQgV0hFUkUgVC4lUSA+PSA/IEFORCBULiVRIDw9ID8gT1JERVIgQlkgVC4lUSBBU0MAU1lTVEVNX01BTExPQwBTUUxJVEVfQ09ORklHX1NNQUxMX01BTExPQwBTUUxJVEVfQ09ORklHX01BTExPQwBTUUxJVEVfQ09ORklHX0dFVE1BTExPQwBTUUxJVEVfRkNOVExfU1lOQwBTUUxJVEVfSU9FUlJfRlNZTkMAU1FMSVRFX0lPRVJSX0RJUl9GU1lOQwBFTkFCTEVfT0ZGU0VUX1NRTF9GVU5DAFNRTElURV9ERVRFUk1JTklTVElDAFNRTElURV9JT0VSUl9DT01NSVRfQVRPTUlDAFNRTElURV9JT0NBUF9BVE9NSUMAU1FMSVRFX0lPRVJSX0JFR0lOX0FUT01JQwBTUUxJVEVfSU9FUlJfUk9MTEJBQ0tfQVRPTUlDAFNRTElURV9JT0NBUF9CQVRDSF9BVE9NSUMAU1FMSVRFX0lOREVYX0NPTlNUUkFJTlRfR0xPQgBTUUxJVEVfQkxPQgBpZCBJTlRFR0VSIFBSSU1BUlkgS0VZLCBzeiBCTE9CAGlkIElOVEVHRVIgUFJJTUFSWSBLRVksIGJsb2NrIEJMT0IAU1FMSVRFX09QRU5fVFJBTlNJRU5UX0RCAFNRTElURV9PUEVOX1RFTVBfREIAU1FMSVRFX09QRU5fTUFJTl9EQgBTUUxJVEVfRkNOVExfUERCAFNRTElURV9OT1RBREIAQkJCAFNRTElURV9DT1JSVVBUX1ZUQUIAU1FMSVRFX0NPTlNUUkFJTlRfVlRBQgBFTkFCTEVfREJTVEFUX1ZUQUIAU1FMSVRFX1BSRVBBUkVfTk9fVlRBQgBFTkFCTEVfREJQQUdFX1ZUQUIARU5BQkxFX0JZVEVDT0RFX1ZUQUIAU1FMSVRFX0xPQ0tFRF9WVEFCAEVOQUJMRV9TVE1UVlRBQgBTUUxJVEVfQ0hBTkdFU0VUX0RBVEEAU1FMSVRFX0lPRVJSX0RBVEEAU1FMSVRFX0ZDTlRMX1BSQUdNQQBTUUxJVEVfUFJBR01BAFNRTElURV9TQ0hFTUEAU1FMSVRFX0RCQ09ORklHX1dSSVRBQkxFX1NDSEVNQQBTUUxJVEVfREJDT05GSUdfVFJVU1RFRF9TQ0hFTUEAQAAlczogIiVzIiAtIHNob3VsZCB0aGlzIGJlIGEgc3RyaW5nIGxpdGVyYWwgaW4gc2luZ2xlLXF1b3Rlcz8AJXM9PwBTRUxFQ1QgZGF0YSBGUk9NICVRLiclcV9ub2RlJyBXSEVSRSBub2Rlbm89PwByb3dpZD0/AERFTEVURSBGUk9NICclcScuJyVxX2lkeCcgV0hFUkUgc2VnaWQ9PwBERUxFVEUgRlJPTSAlUS4nJXFfY29udGVudCcgV0hFUkUgaWQ9PwBTRUxFQ1Qgc3olcyBGUk9NICVRLiclcV9kb2NzaXplJyBXSEVSRSBpZD0/AERFTEVURSBGUk9NICVRLiclcV9kb2NzaXplJyBXSEVSRSBpZD0/AFNFTEVDVCAlcyBGUk9NICVzIFQgV0hFUkUgVC4lUT0/AERFTEVURSBGUk9NICclcScuJyVxX2RhdGEnIFdIRVJFIGlkPj0/IEFORCBpZDw9PwAsPwApIFZBTFVFUyg/ACBBTkQgKD8AIElTID8AID0gPwAsID8APGV4cHI+AC0+PgAtPgA8AEJFR0lOIElNTUVESUFURTsgQ09NTUlUOwBDUkVBVEUgVEFCTEUgIiV3Ii4iJXdfcGFyZW50Iihub2Rlbm8gSU5URUdFUiBQUklNQVJZIEtFWSxwYXJlbnRub2RlKTsAKTtDUkVBVEUgVEFCTEUgIiV3Ii4iJXdfbm9kZSIobm9kZW5vIElOVEVHRVIgUFJJTUFSWSBLRVksZGF0YSk7AElOU0VSVCBJTlRPICVRLnNxbGl0ZV9tYXN0ZXIgVkFMVUVTKCdpbmRleCcsJVEsJVEsIyVkLCVRKTsAQ1JFQVRFIFRBQkxFIHgodHlwZSBURVhULHNjaGVtYSBURVhULG5hbWUgVEVYVCx3ciBJTlQsc3VicHJvZyBURVhULHN0bXQgSElEREVOKTsAQ1JFQVRFIFRBQkxFIHgoYWRkciBJTlQsb3Bjb2RlIFRFWFQscDEgSU5ULHAyIElOVCxwMyBJTlQscDQgVEVYVCxwNSBJTlQsY29tbWVudCBURVhULHN1YnByb2cgVEVYVCxuZXhlYyBJTlQsbmN5Y2xlIElOVCxzdG10IEhJRERFTik7AFVQREFURSAlUS5zcWxpdGVfbWFzdGVyIFNFVCB0YmxfbmFtZSA9ICVRLCBuYW1lID0gQ0FTRSBXSEVOIHR5cGU9J3RhYmxlJyBUSEVOICVRIFdIRU4gbmFtZSBMSUtFICdzcWxpdGVYX2F1dG9pbmRleCUlJyBFU0NBUEUgJ1gnICAgICAgQU5EIHR5cGU9J2luZGV4JyBUSEVOICdzcWxpdGVfYXV0b2luZGV4XycgfHwgJVEgfHwgc3Vic3RyKG5hbWUsJWQrMTgpIEVMU0UgbmFtZSBFTkQgV0hFUkUgdGJsX25hbWU9JVEgQ09MTEFURSBub2Nhc2UgQU5EICh0eXBlPSd0YWJsZScgT1IgdHlwZT0naW5kZXgnIE9SIHR5cGU9J3RyaWdnZXInKTsAREVMRVRFIEZST00gJVEuJyVxX2RhdGEnO0RFTEVURSBGUk9NICVRLiclcV9pZHgnOwBEUk9QIFRBQkxFIElGIEVYSVNUUyAlUS4nJXFfY29udGVudCc7AERFTEVURSBGUk9NICVRLiclcV9jb250ZW50JzsARFJPUCBUQUJMRSAnJXEnLiclcV9ub2RlJztEUk9QIFRBQkxFICclcScuJyVxX3Jvd2lkJztEUk9QIFRBQkxFICclcScuJyVxX3BhcmVudCc7AEFMVEVSIFRBQkxFICVRLiclcV8lcycgUkVOQU1FIFRPICclcV8lcyc7AERST1AgVEFCTEUgSUYgRVhJU1RTICVRLiclcV9kYXRhJztEUk9QIFRBQkxFIElGIEVYSVNUUyAlUS4nJXFfaWR4JztEUk9QIFRBQkxFIElGIEVYSVNUUyAlUS4nJXFfY29uZmlnJzsARFJPUCBUQUJMRSBJRiBFWElTVFMgJVEuJyVxX2RvY3NpemUnOwBERUxFVEUgRlJPTSAlUS4nJXFfZG9jc2l6ZSc7AEFMVEVSIFRBQkxFICVRLiclcV9ub2RlJyAgIFJFTkFNRSBUTyAiJXdfbm9kZSI7QUxURVIgVEFCTEUgJVEuJyVxX3BhcmVudCcgUkVOQU1FIFRPICIld19wYXJlbnQiO0FMVEVSIFRBQkxFICVRLiclcV9yb3dpZCcgIFJFTkFNRSBUTyAiJXdfcm93aWQiOwA6bWVtb3J5OgBmaWxlOgA6c2Vzc2lvblN0b3JhZ2U6ADpsb2NhbFN0b3JhZ2U6AC05ZTk5OQA5LjBlOTk5ACstIAoJMDEyMzQ1Njc4OQBcdTAwMDkAdjgAU3RyaW5nOAB1dGY4AFNRTElURV9VVEY4AERFRkFVTFRfU0VDVE9SX1NJWkU9NDA5NgBNQVhfVkFSSUFCTEVfTlVNQkVSPTMyNzY2AE1BWF9QQUdFX1NJWkU9NjU1MzYAT01JVF9VVEYxNgBTUUxJVEVfVVRGMTYAZnRzNQBwNQBFTkFCTEVfRlRTNQB0b28gbWFueSByZWZlcmVuY2VzIHRvICIlcyI6IG1heCA2NTUzNQBibTI1AEZMQUdTIHBhcmFtZXRlciB0byBqc29uX3ZhbGlkKCkgbXVzdCBiZSBiZXR3ZWVuIDEgYW5kIDE1AHY0AHNxbGl0ZV9zdGF0NABwNABERUZBVUxUX0ZJTEVfRk9STUFUPTQAREVGQVVMVF9DQUNIRV9TSVpFPS0xNjM4NAB4Q3VycmVudFRpbWVJbnQ2NABwd3JpdGU2NABwcmVhZDY0AE1BTExPQ19TT0ZUX0xJTUlUPTEwMjQAc3FsaXRlX3N0YXQzAHAzAHAyAGF0YW4yAGxvZzIAU1FMSVRFX0NPTkZJR19QQ0FDSEUyAFNRTElURV9DT05GSUdfR0VUUENBQ0hFMgBERUZBVUxUX1NZTkNIUk9OT1VTPTIAREVGQVVMVF9XQUxfU1lOQ0hST05PVVM9MgBURU1QX1NUT1JFPTIATUFYX0RFRkFVTFRfUEFHRV9TSVpFPTgxOTIAcnRyZWVfaTMyAFNRTElURV9JT0NBUF9BVE9NSUM1MTIAU0VMRUNUIHNlZ2lkLCB0ZXJtLCAocGdubz4+MSksIChwZ25vJjEpIEZST00gJVEuJyVxX2lkeCcgV0hFUkUgc2VnaWQ9JWQgT1JERVIgQlkgMSwgMgBTRUxFQ1QgdGJsLGlkeCxzdGF0IEZST00gJVEuc3FsaXRlX3N0YXQxAEFnZ1N0ZXAxAFNFTEVDVCBwYXJlbnRub2RlIEZST00gJVEuJyVxX3BhcmVudCcgV0hFUkUgbm9kZW5vPT8xAFNFTEVDVCBub2Rlbm8gRlJPTSAlUS4nJXFfcm93aWQnIFdIRVJFIHJvd2lkPT8xAFNFTEVDVCAqIEZST00gIiV3Ii4iJXdfcm93aWQiIFdIRVJFIHJvd2lkPT8xAFNFTEVDVCBwYXJlbnRub2RlIEZST00gJyVxJy4nJXFfcGFyZW50JyBXSEVSRSBub2Rlbm8gPSA/MQBERUxFVEUgRlJPTSAnJXEnLiclcV9wYXJlbnQnIFdIRVJFIG5vZGVubyA9ID8xAERFTEVURSBGUk9NICclcScuJyVxX25vZGUnIFdIRVJFIG5vZGVubyA9ID8xAFNFTEVDVCBub2Rlbm8gRlJPTSAnJXEnLiclcV9yb3dpZCcgV0hFUkUgcm93aWQgPSA/MQBERUxFVEUgRlJPTSAnJXEnLiclcV9yb3dpZCcgV0hFUkUgcm93aWQgPSA/MQBmdHM1X2xvY2FsZSgpIHJlcXVpcmVzIGxvY2FsZT0xAEFUT01JQ19JTlRSSU5TSUNTPTEAdW5pY29kZTYxAERFRkFVTFRfSk9VUk5BTF9TSVpFX0xJTUlUPS0xACJTUUxJVEVfU1RBVElDIjowLCAiU1FMSVRFX1RSQU5TSUVOVCI6LTEAU0VMRUNUIHBnbm8gRlJPTSAnJXEnLiclcV9pZHgnIFdIRVJFIHNlZ2lkPT8gQU5EIHRlcm08PT8gT1JERVIgQlkgdGVybSBERVNDIExJTUlUIDEAU0VMRUNUIHBnbm8gRlJPTSAnJXEnLiclcV9pZHgnIFdIRVJFIHNlZ2lkPT8gQU5EIHRlcm0+PyBPUkRFUiBCWSB0ZXJtIEFTQyBMSU1JVCAxAFBSQUdNQSBkZWZlcl9mb3JlaWduX2tleXMgPSAxAFNFTEVDVCBsZW5ndGgoZGF0YSkgRlJPTSAnJXEnLiclcV9ub2RlJyBXSEVSRSBub2Rlbm8gPSAxACwgMQBTRUxFQ1QnSU5TRVJUIElOVE8gJXMuJ3x8cXVvdGUobmFtZSl8fCcgU0VMRUNUKkZST00iJXciLid8fHF1b3RlKG5hbWUpRlJPTSAlcy5zcWxpdGVfc2NoZW1hIFdIRVJFIHR5cGU9J3RhYmxlJ0FORCBjb2FsZXNjZShyb290cGFnZSwxKT4wAFNFTEVDVCBzcWwgRlJPTSAiJXciLnNxbGl0ZV9zY2hlbWEgV0hFUkUgdHlwZT0ndGFibGUnQU5EIG5hbWU8PidzcWxpdGVfc2VxdWVuY2UnIEFORCBjb2FsZXNjZShyb290cGFnZSwxKT4wAGNvbnRlbnRsZXNzX2RlbGV0ZT0xIGlzIGluY29tcGF0aWJsZSB3aXRoIGNvbHVtbnNpemU9MABEUVM9MABNQVhfV09SS0VSX1RIUkVBRFM9MABERUZBVUxUX1dPUktFUl9USFJFQURTPTAATUFYX01NQVBfU0laRT0wAERFRkFVTFRfTU1BUF9TSVpFPTAAVEhSRUFEU0FGRT0wADkyMjMzNzIwMzY4NTQ3NzU4MABERUZBVUxUX1BDQUNIRV9JTklUU1o9MjAAbG9nMTAATUFYX0FUVEFDSEVEPTEwAGZ0czU6IDIwMjUtMDEtMTQgMTE6MDU6MDAgZDJmZTZiMDVmMzhkOWQ3Y2Q3OGM1ZDI1MmU5OWFjNTlmMWFlYTA3MWQ2Njk4MzBjMWZmZTRlODk2NmU4NDAxMABcdTAwAE1BWF9DT01QT1VORF9TRUxFQ1Q9NTAwAE1BWF9DT0xVTU49MjAwMABERUZBVUxUX1dBTF9BVVRPQ0hFQ0tQT0lOVD0xMDAwAE1BWF9FWFBSX0RFUFRIPTEwMDAATUFYX1RSSUdHRVJfREVQVEg9MTAwMABNQVhfRlVOQ1RJT05fQVJHPTEwMDAAXHUwMDAwAE1BWF9MSUtFX1BBVFRFUk5fTEVOR1RIPTUwMDAwAE1BWF9WREJFX09QPTI1MDAwMDAwMABNQVhfTEVOR1RIPTEwMDAwMDAwMDAATUFYX1NRTF9MRU5HVEg9MTAwMDAwMDAwMABzZWNvbmQgYXJndW1lbnQgdG8gJSNUKCkgbXVzdCBiZSBhIGNvbnN0YW50IGJldHdlZW4gMC4wIGFuZCAxLjAAQ09NUElMRVI9Y2xhbmctMjAuMC4wAFNFTEVDVCAwLCAndGJsJywgICcnLCAwLCAnJywgMSAgICAgVU5JT04gQUxMIFNFTEVDVCAxLCAnaWR4JywgICcnLCAwLCAnJywgMiAgICAgVU5JT04gQUxMIFNFTEVDVCAyLCAnc3RhdCcsICcnLCAwLCAnJywgMAAlcyUuM3gvAC9wcm9jL3NlbGYvZmQvAElOU0VSVCBJTlRPIG1haW4uAERFTEVURSBGUk9NIG1haW4uAFVQREFURSBtYWluLgAlUS4ATi4ALQAibmFtZSI6ICJzcWxpdGUzX2luZGV4X29yZGVyYnkiLAAibmFtZSI6ICJzcWxpdGUzX2luZGV4X2NvbnN0cmFpbnQiLAAibmFtZSI6ICJXYXNtVGVzdFN0cnVjdCIsACJuYW1lIjogInNxbGl0ZTNfdmZzIiwAIm5hbWUiOiAic3FsaXRlM19rdnZmc19tZXRob2RzIiwAIm5hbWUiOiAic3FsaXRlM19pb19tZXRob2RzIiwAIm5hbWUiOiAic3FsaXRlM192dGFiX2N1cnNvciIsACJuYW1lIjogInNxbGl0ZTNfaW5kZXhfaW5mbyIsACJuYW1lIjogInNxbGl0ZTNfbW9kdWxlIiwAIm5hbWUiOiAic3FsaXRlM19maWxlIiwAIm5hbWUiOiAic3FsaXRlM19pbmRleF9jb25zdHJhaW50X3VzYWdlIiwAIm5hbWUiOiAic3FsaXRlM192dGFiIiwAbm9za2lwc2NhbioAdW5vcmRlcmVkKgBzej1bMC05XSoAX3Jvd2lkXywgKgBTRUxFQ1QgJXMsJXMgRlJPTSAiJXciLiIldyIsICIldyIuIiV3IiBXSEVSRSAlcyBBTkQgKCV6KQAgQU5EICg/JWQgT1IgPyVkIElTICV3LiV3KQAoc3VicXVlcnktJXUpAChqb2luLSV1KQBCYWQgcHRyIG1hcCBlbnRyeSBrZXk9JXUgZXhwZWN0ZWQ9KCV1LCV1KSBnb3Q9KCV1LCV1KQBtYXggcm9vdHBhZ2UgKCV1KSBkaXNhZ3JlZXMgd2l0aCBoZWFkZXIgKCV1KQBDUkVBVEUgVEFCTEUgeCh0eXBlIHRleHQsbmFtZSB0ZXh0LHRibF9uYW1lIHRleHQscm9vdHBhZ2UgaW50LHNxbCB0ZXh0KQBDUkVBVEUgVEFCbEUgdm9jYWIodGVybSwgZG9jLCBjbnQpAENSRUFURSBUQUJsRSB2b2NhYih0ZXJtLCBjb2wsIGRvYywgY250KQBDUkVBVEUgVEFCbEUgdm9jYWIodGVybSwgZG9jLCBjb2wsIG9mZnNldCkAIEFORCAoPzYgT1IgPzMgSVMgc3RhdCkAaShzc3MpAGkoc3MpAGkocHMpAE5vZGUgJWxsZCBpcyB0b28gc21hbGwgKCVkIGJ5dGVzKQBOb2RlICVsbGQgaXMgdG9vIHNtYWxsIGZvciBjZWxsIGNvdW50IG9mICVkICglZCBieXRlcykAaShzKQBSRVBMQUNFIElOVE8gJVEuJyVxX2RvY3NpemUnIFZBTFVFUyg/LD8lcykAcnRyZWUgY29uc3RyYWludCBmYWlsZWQ6ICVzLiglczw9JXMpAENSRUFURSBUQUJMRSAlUS4lcyglcykAYXV0b21hdGljIGluZGV4IG9uICVzKCVzKQBBTlkoJXMpAElOU0VSVCBJTlRPICVRLiclcV9jb250ZW50JyBWQUxVRVMoJXMpAFJFUExBQ0UgSU5UTyAlUS4nJXFfY29udGVudCcgVkFMVUVTKCVzKQBtYWxmb3JtZWQgZGF0YWJhc2Ugc2NoZW1hICglcykAU0VMRUNUICVzJXMgRlJPTSAlUS4lUSBXSEVSRSAoJXMpIElTICglcykATUVSR0UgKCVzKQBTRUxFQ1QgJXMgRlJPTSAiJXciLiIldyIgV0hFUkUgTk9UIEVYSVNUUyAoICBTRUxFQ1QgMSBGUk9NICIldyIuIiV3IiBXSEVSRSAlcykAQ1JFQVRFIFRBQkxFICVRLnNxbGl0ZV9zZXF1ZW5jZShuYW1lLHNlcSkAaShwaXNwcCkAaShwcGlwcHApAGkocHBwKQBpKHBpcHApAHYocHApAHAocHApAGkocHApAGkocGpwKQBpKHBpc2lwKQBpKHBwcGlwKQBpKHBwaXApAHAocGlwKQBpKHBpcCkAaShwamlwKQBpKHBpaWlwKQB2KHApAGkocCkAc2VnaWQsIHRlcm0sIHBnbm8sIFBSSU1BUlkgS0VZKHNlZ2lkLCB0ZXJtKQBDUkVBVEUgVEFCTEUgeChzcWwsbmNvbCxybyxidXN5LG5zY2FuLG5zb3J0LG5haWR4LG5zdGVwLHJlcHJlcCxydW4sbWVtKQAobnVsbCkAZnRzNTogJXMgcXVlcmllcyBhcmUgbm90IHN1cHBvcnRlZCAoZGV0YWlsIT1mdWxsKQBpKHBqKQBpKHBwaWopAGkoc3NwaSkAaShwcGkpAGkocGkpAGkocGlpaSkAVVBEQVRFICIldyIuc3FsaXRlX21hc3RlciBTRVQgc3FsID0gc3FsaXRlX2Ryb3BfY29sdW1uKCVkLCBzcWwsICVkKSBXSEVSRSAodHlwZT09J3RhYmxlJyBBTkQgdGJsX25hbWU9JVEgQ09MTEFURSBub2Nhc2UpAGZ0czU6IGNvbHVtbiBxdWVyaWVzIGFyZSBub3Qgc3VwcG9ydGVkIChkZXRhaWw9bm9uZSkAbWVtZGIoJXAsJWxsZCkARm91bmQgKCVsbGQgLT4gJWxsZCkgaW4gJXMgdGFibGUsIGV4cGVjdGVkICglbGxkIC0+ICVsbGQpACVzKCVkKQB6ZXJvYmxvYiglZCkAUnRyZWUgZGVwdGggb3V0IG9mIHJhbmdlICglZCkAdG9vIG1hbnkgcHJlZml4IGluZGV4ZXMgKG1heCAlZCkAZnRzNSBleHByZXNzaW9uIHRyZWUgaXMgdG9vIGxhcmdlIChtYXhpbXVtIGRlcHRoICVkKQBFeHByZXNzaW9uIHRyZWUgaXMgdG9vIGxhcmdlIChtYXhpbXVtIGRlcHRoICVkKQBSRVBMQUNFIElOVE8gJVEuJyVxX2NvbmZpZycgVkFMVUVTICgndmVyc2lvbicsICVkKQAoYmxvYikAVVNFIFRFTVAgQi1UUkVFIEZPUiAlcyhPUkRFUiBCWSkAVVNFIFRFTVAgQi1UUkVFIEZPUiAlcyhESVNUSU5DVCkAVVBEQVRFICIldyIuc3FsaXRlX21hc3RlciBTRVQgc3FsID0gc3FsaXRlX3JlbmFtZV9jb2x1bW4oc3FsLCB0eXBlLCBuYW1lLCAlUSwgJVEsICVkLCAlUSwgJWQsICVkKSBXSEVSRSBuYW1lIE5PVCBMSUtFICdzcWxpdGVYXyUlJyBFU0NBUEUgJ1gnICBBTkQgKHR5cGUgIT0gJ2luZGV4JyBPUiB0YmxfbmFtZSA9ICVRKQBDUkVBVEUgVEFCTEUgeChrZXksdmFsdWUsdHlwZSxhdG9tLGlkLHBhcmVudCxmdWxsa2V5LHBhdGgsanNvbiBISURERU4scm9vdCBISURERU4pACV6LCAlUSBISURERU4sICVzIEhJRERFTikAQ1JFQVRFIFRBQkxFIHgocGdubyBJTlRFR0VSIFBSSU1BUlkgS0VZLCBkYXRhIEJMT0IsIHNjaGVtYSBISURERU4pAChOVUxMKQAoRkspAD8xLCAoQ0FTRSBXSEVOID8yPVgnJyBUSEVOIE5VTEwgRUxTRSA/MiBFTkQpACVjPykASU5TRVJUIElOVE8gJyVxJy4nJXFfaWR4JyhzZWdpZCx0ZXJtLHBnbm8pIFZBTFVFUyg/LD8sPykAUkVQTEFDRSBJTlRPICclcScuJyVxX2RhdGEnKGlkLCBibG9jaykgVkFMVUVTKD8sPykAUkVQTEFDRSBJTlRPICVRLiclcV9jb25maWcnIFZBTFVFUyg/LD8pAHByZWZpeCBsZW5ndGggb3V0IG9mIHJhbmdlIChtYXggOTk5KQBERUxFVEUgRlJPTSBtYWluLnNxbGl0ZV9zdGF0MSBXSEVSRSB0Ymw9PzEgQU5EIGlkeCBJUyBDQVNFIFdIRU4gbGVuZ3RoKD8yKT0wIEFORCB0eXBlb2YoPzIpPSdibG9iJyBUSEVOIE5VTEwgRUxTRSA/MiBFTkQgQU5EICg/NCBPUiBzdGF0IElTID8zKQBJTlNFUlQgSU5UTyBtYWluLnNxbGl0ZV9zdGF0MSBWQUxVRVMoPzEsIENBU0UgV0hFTiBsZW5ndGgoPzIpPTAgQU5EIHR5cGVvZig/Mik9J2Jsb2InIFRIRU4gTlVMTCBFTFNFID8yIEVORCwgPzMpAElOU0VSVCBPUiBSRVBMQUNFIElOVE8gJyVxJy4nJXFfcGFyZW50JyBWQUxVRVMoPzEsID8yKQBJTlNFUlQgT1IgUkVQTEFDRSBJTlRPICclcScuJyVxX25vZGUnIFZBTFVFUyg/MSwgPzIpAElOU0VSVCBPUiBSRVBMQUNFIElOVE8gJyVxJy4nJXFfcm93aWQnIFZBTFVFUyg/MSwgPzIpAERFTEVURSBGUk9NICclcScuJyVxX2lkeCcgV0hFUkUgKHNlZ2lkLCAocGduby8yKSkgPSAoPzEsID8yKQBJTlNFUlQgSU5UTyAlcy5zcWxpdGVfc2NoZW1hIFNFTEVDVCpGUk9NICIldyIuc3FsaXRlX3NjaGVtYSBXSEVSRSB0eXBlIElOKCd2aWV3JywndHJpZ2dlcicpIE9SKHR5cGU9J3RhYmxlJ0FORCByb290cGFnZT0wKQBTRUxFQ1QgKiBGUk9NIChTRUxFQ1QgJ3NxbGl0ZV9zY2hlbWEnIEFTIG5hbWUsMSBBUyByb290cGFnZSwndGFibGUnIEFTIHR5cGUgVU5JT04gQUxMIFNFTEVDVCBuYW1lLHJvb3RwYWdlLHR5cGUgRlJPTSAiJXciLnNxbGl0ZV9zY2hlbWEgV0hFUkUgcm9vdHBhZ2UhPTApAElOU0VSVCBJTlRPICIldyIuIiV3X25vZGUiVkFMVUVTKDEsemVyb2Jsb2IoJWQpKQB3cm9uZyBudW1iZXIgb2YgYXJndW1lbnRzIHRvIGZ1bmN0aW9uIGhpZ2hsaWdodCgpAHdyb25nIG51bWJlciBvZiBhcmd1bWVudHMgdG8gZnVuY3Rpb24gc25pcHBldCgpAG1pc3VzZSBvZiBzcWxpdGUzX3Jlc3VsdF9zdWJ0eXBlKCkgYnkgJXMoKQBtaXN1c2Ugb2YgYWdncmVnYXRlOiAlcygpAHAoKQB3cm9uZyBudW1iZXIgb2YgYXJndW1lbnRzIHRvIGZ1bmN0aW9uIHJ0cmVlY2hlY2soKQBJbnZhbGlkIGFyZ3VtZW50IHRvIHJ0cmVlZGVwdGgoKQB3cm9uZyBudW1iZXIgb2YgYXJndW1lbnRzIHRvIGZ1bmN0aW9uIGZ0czVfZ2V0X2xvY2FsZSgpAG5vbi1pbnRlZ2VyIGFyZ3VtZW50IHBhc3NlZCB0byBmdW5jdGlvbiBmdHM1X2dldF9sb2NhbGUoKQBtaXN1c2Ugb2YgJXMgZnVuY3Rpb24gJSNUKCkAd3JvbmcgbnVtYmVyIG9mIGFyZ3VtZW50cyB0byBmdW5jdGlvbiAlI1QoKQB1bnNhZmUgdXNlIG9mICUjVCgpAE9SREVSIEJZIG1heSBub3QgYmUgdXNlZCB3aXRoIG5vbi1hZ2dyZWdhdGUgJSNUKCkARklMVEVSIG1heSBub3QgYmUgdXNlZCB3aXRoIG5vbi1hZ2dyZWdhdGUgJSNUKCkAdW5rbm93biBmdW5jdGlvbjogJSNUKCkAbWlzdXNlIG9mIGFnZ3JlZ2F0ZTogJSNUKCkAYW1iaWd1b3VzIHJlZmVyZW5jZSB0byAlcyBpbiBVU0lORygpAFVQREFURSB0ZW1wLnNxbGl0ZV9tYXN0ZXIgU0VUIHNxbCA9IHNxbGl0ZV9yZW5hbWVfY29sdW1uKHNxbCwgdHlwZSwgbmFtZSwgJVEsICVRLCAlZCwgJVEsICVkLCAxKSBXSEVSRSB0eXBlIElOICgndHJpZ2dlcicsICd2aWV3JykAVVBEQVRFIHNxbGl0ZV90ZW1wX3NjaGVtYSBTRVQgc3FsID0gc3FsaXRlX3JlbmFtZV90YWJsZSglUSwgdHlwZSwgbmFtZSwgc3FsLCAlUSwgJVEsIDEpLCB0YmxfbmFtZSA9IENBU0UgV0hFTiB0YmxfbmFtZT0lUSBDT0xMQVRFIG5vY2FzZSBBTkQgICBzcWxpdGVfcmVuYW1lX3Rlc3QoJVEsIHNxbCwgdHlwZSwgbmFtZSwgMSwgJ2FmdGVyIHJlbmFtZScsIDApIFRIRU4gJVEgRUxTRSB0YmxfbmFtZSBFTkQgV0hFUkUgdHlwZSBJTiAoJ3ZpZXcnLCAndHJpZ2dlcicpAFBSQUdNQSAnJXEnLnRhYmxlX2luZm8oJyVxJykASU5TRVJUIElOVE8gJVEuc3FsaXRlX21hc3RlciBWQUxVRVMoJ3RyaWdnZXInLCVRLCVRLDAsJ0NSRUFURSBUUklHR0VSICVxJykACikAQ1JFQVRFIFRBQkxFIHgoAEJMT09NIEZJTFRFUiBPTiAlUyAoAFNFTEVDVCBzcWwgRlJPTSAiJXciLnNxbGl0ZV9zY2hlbWEgV0hFUkUgdHlwZT0naW5kZXgnAERFTEVURSBGUk9NICVRLnNxbGl0ZV9tYXN0ZXIgV0hFUkUgbmFtZT0lUSBBTkQgdHlwZT0naW5kZXgnAG5hbWU9JyVxJyBBTkQgdHlwZT0naW5kZXgnAFNFTEVDVCBjb3VudCgqKSBGUk9NICVRLiclcSVzJwBTRUxFQ1QgY291bnQoKikgRlJPTSAlUS4nJXFfJXMnAERFTEVURSBGUk9NICVRLnNxbGl0ZV9tYXN0ZXIgV0hFUkUgbmFtZT0lUSBBTkQgdHlwZT0ndHJpZ2dlcicAREVMRVRFIEZST00gJVEuc3FsaXRlX21hc3RlciBXSEVSRSB0YmxfbmFtZT0lUSBhbmQgdHlwZSE9J3RyaWdnZXInAHRibF9uYW1lPSclcScgQU5EIHR5cGUhPSd0cmlnZ2VyJwAnJS4qcScAdHlwZT0ndHJpZ2dlcicgQU5EIG5hbWU9JyVxJwBpbmRleCAnJXEnAFNFTEVDVCBrLCB2IEZST00gJVEuJyVxX2NvbmZpZycAaW52YWxpZCBmdHM1IGZpbGUgZm9ybWF0IChmb3VuZCAlZCwgZXhwZWN0ZWQgJWQgb3IgJWQpIC0gcnVuICdyZWJ1aWxkJwBTRUxFQ1QgKiBGUk9NICVRLiclcV9yb3dpZCcAU0VMRUNUIHN0YXQgRlJPTSAlUS5zcWxpdGVfc3RhdDEgV0hFUkUgdGJsID0gJyVxX3Jvd2lkJwBTRUxFQ1QgdC4lUSBGUk9NICVRLiVRIEFTIHQgV0hFUkUgdC4lUSBNQVRDSCAnKmlkJwBVUERBVEUgIiV3Ii5zcWxpdGVfbWFzdGVyIFNFVCBzcWwgPSBzcWxpdGVfcmVuYW1lX3RhYmxlKCVRLCB0eXBlLCBuYW1lLCBzcWwsICVRLCAlUSwgJWQpIFdIRVJFICh0eXBlIT0naW5kZXgnIE9SIHRibF9uYW1lPSVRIENPTExBVEUgbm9jYXNlKUFORCAgIG5hbWUgTk9UIExJS0UgJ3NxbGl0ZVhfJSUnIEVTQ0FQRSAnWCcAU0VMRUNUIENBU0UgV0hFTiBxdWlja19jaGVjayBHTE9CICdDSEVDSyonIFRIRU4gcmFpc2UoQUJPUlQsJ0NIRUNLIGNvbnN0cmFpbnQgZmFpbGVkJykgV0hFTiBxdWlja19jaGVjayBHTE9CICdub24tKiB2YWx1ZSBpbionIFRIRU4gcmFpc2UoQUJPUlQsJ3R5cGUgbWlzbWF0Y2ggb24gREVGQVVMVCcpIEVMU0UgcmFpc2UoQUJPUlQsJ05PVCBOVUxMIGNvbnN0cmFpbnQgZmFpbGVkJykgRU5EICBGUk9NIHByYWdtYV9xdWlja19jaGVjayglUSwlUSkgV0hFUkUgcXVpY2tfY2hlY2sgR0xPQiAnQ0hFQ0sqJyBPUiBxdWlja19jaGVjayBHTE9CICdOVUxMKicgT1IgcXVpY2tfY2hlY2sgR0xPQiAnbm9uLSogdmFsdWUgaW4qJwBVUERBVEUgIiV3Ii5zcWxpdGVfbWFzdGVyIFNFVCBzcWwgPSBzcWxpdGVfcmVuYW1lX3F1b3RlZml4KCVRLCBzcWwpV0hFUkUgbmFtZSBOT1QgTElLRSAnc3FsaXRlWF8lJScgRVNDQVBFICdYJyBBTkQgc3FsIE5PVCBMSUtFICdjcmVhdGUgdmlydHVhbCUlJwBVUERBVEUgdGVtcC5zcWxpdGVfbWFzdGVyIFNFVCBzcWwgPSBzcWxpdGVfcmVuYW1lX3F1b3RlZml4KCd0ZW1wJywgc3FsKVdIRVJFIG5hbWUgTk9UIExJS0UgJ3NxbGl0ZVhfJSUnIEVTQ0FQRSAnWCcgQU5EIHNxbCBOT1QgTElLRSAnY3JlYXRlIHZpcnR1YWwlJScAc3FsaXRlXF8lACQAIwBTRUxFQ1QqRlJPTSIldyIAU0VMRUNUKkZST00iJXciLiIldyIAJXolcyIldyIuIiV3Ii4iJXciACV6JXMiJXciLiIldyIuIiV3Ij0iJXciLiIldyIuIiV3IgAleiVzIiV3Ii4iJXciLiIldyIgSVMgTk9UICIldyIuIiV3Ii4iJXciAFNFTEVDVCByYWlzZShBQk9SVCwlUSkgRlJPTSAiJXciLiIldyIAQU5BTFlaRSAiJXciLiIldyIAZm9yZWlnbiBrZXkgbWlzbWF0Y2ggLSAiJXciIHJlZmVyZW5jaW5nICIldyIAZG91YmxlLXF1b3RlZCBzdHJpbmcgbGl0ZXJhbDogIiV3IgBmdHM1OiBzeW50YXggZXJyb3IgbmVhciAiJS4xcyIALiIlLipzIgBleHBlY3RlZCBpbnRlZ2VyLCBnb3QgIiUuKnMiAGZ0czU6IHN5bnRheCBlcnJvciBuZWFyICIlLipzIgBzeW50YXggZXJyb3IgYWZ0ZXIgY29sdW1uIG5hbWUgIiUuKnMiAHVucmVjb2duaXplZCBvcHRpb246ICIlLipzIgAlYyIlcyIAKCIlcyIAY2Fubm90ICVzICVzICIlcyIAZ2VuZXJhdGVkIGNvbHVtbiBsb29wIG9uICIlcyIAY2Fubm90IElOU0VSVCBpbnRvIGdlbmVyYXRlZCBjb2x1bW4gIiVzIgBlcnJvciBpbiBnZW5lcmF0ZWQgY29sdW1uICIlcyIAY2Fubm90IFVQREFURSBnZW5lcmF0ZWQgY29sdW1uICIlcyIAJXMgaW4gIiVzIgBwYXJzZSBlcnJvciBpbiAiJXMiAHRyaWdnZXIgIiVzIiBtYXkgbm90IHdyaXRlIHRvIHNoYWRvdyB0YWJsZSAiJXMiAFVQU0VSVCBub3QgaW1wbGVtZW50ZWQgZm9yIHZpcnR1YWwgdGFibGUgIiVzIgB1bnNhZmUgdXNlIG9mIHZpcnR1YWwgdGFibGUgIiVzIgBjYW5ub3QgY3JlYXRlIGEgVEVNUCBpbmRleCBvbiBub24tVEVNUCB0YWJsZSAiJXMiAG5vIHN1Y2ggaW5kZXg6ICIlcyIAdW5rbm93biBkYXRhdHlwZSBmb3IgJXMuJXM6ICIlcyIAY2Fubm90IGRyb3AgJXMgY29sdW1uOiAiJXMiAG5vIHN1Y2ggY29sdW1uOiAiJXMiAHVucmVjb2duaXplZCB0b2tlbjogIiVzIgAlcyIlcyI6ICIlcyIAdW5kZXJzaXplIFJUcmVlIGJsb2JzIGluICIlcV9ub2RlIgBcIgBubyBzdWNoIGNvbHVtbjogIiVUIgB1bnJlY29nbml6ZWQgdG9rZW46ICIlVCIALiIAd2Vla2RheSAAbm9uLXVuaXF1ZSBlbnRyeSBpbiBpbmRleCAAd3JvbmcgIyBvZiBlbnRyaWVzIGluIGluZGV4IAAgdmFsdWVzIGRpZmZlciBmcm9tIGluZGV4IAAgbWlzc2luZyBmcm9tIGluZGV4IAAgb2YgaW5kZXggAHJvd2lkIG5vdCBh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RlNFVFJJR0dFUkFOR0VORVJBVEVERVRBQ0hBVklOR0xPQkVHSU5ORVJFRkVSRU5DRVNVTklRVUVSWVdJVEhPVVRFUkVMRUFTRUFUVEFDSEJFVFdFRU5PVEhJTkdST1VQU0NBU0NBREVGQVVMVENBU0VDT0xMQVRFQ1JFQVRFQ1VSUkVOVF9EQVRFSU1NRURJQVRFSk9JTlNFUlRNQVRDSFBMQU5BTFlaRVBSQUdNQVRFUklBTElaRURFRkVSUkVESVNUSU5DVFVQREFURVZBTFVFU1ZJUlRVQUxXQVlTV0hFTldIRVJFQ1VSU0lWRUFCT1JUQUZURVJFTkFNRUFORFJPUEFSVElUSU9OQVVUT0lOQ1JFTUVOVENBU1RDT0xVTU5DT01NSVRDT05GTElDVENST1NTQ1VSUkVOVF9USU1FU1RBTVBSRUNFRElOR0ZBSUxBU1RGSUxURVJFUExBQ0VGSVJTVEZPTExPV0lOR0ZST01GVUxMSU1JVElGT1JERVJFU1RSSUNUT1RIRVJTT1ZFUkVUVVJOSU5HUklHSFRST0xMQkFDS1JPV1NVTkJPVU5ERURVTklPTlVTSU5HVkFDVVVNVklFV0lORE9XQllJTklUSUFMTFlQUklNQVJZAEGUjQMLpAICAAIACAAJAA4AEAAUABcAGQAZAB0AIQAkACkALgAwADUANgA7AD4AQQBDAEUATgBRAFYAWgBaAF4AYwBlAGkAbwB3AHsAewB7AH4AgQCEAIkAjgCSAJMAmACcAKAAqACuALUAuAC4ALsAvQDDAMYAzgDTANgA2wDeAOIA7ADvAPQA9AD4APwAAwEJAQ8BFQEVARsBHAEgAScBKwEyATgBRAFNAU8BVQFaAVwBYwFnAXIBeQF6AYEBhwGNAZIBmAGcAZ8BqAGtAbEBtwG5AbwBxQHHAckB0gHWAdwB4gHqAe8B7wHvAf8BCAILAg8CFAIbAiACKQItAjACNQI3AjsCQwJJAkwCVQJaAmICYgJmAm8CdAJ5An8CggKFAogCigKPApMCAEHBjwMLkwEHBwUEBgQFAwYHAwYGBwcDCAIGBQQEAwoEBwYJBAIGBQkJBAcDAgQEBgsGAgcFBQkGCgQGAgMHBQkGBgQFBQoGBQcEBQcGBwcGBQcDBwQHBgwJBAYFBAcGDAgIAgYGBwYEBQkFBQYDBAkNAgIEBgYIBREMBwkEBAYHBQkEBAUCBQgGBAkFCAQDCQUFBgQGAgIJAwcAQeCQAwuIBAEAAgMEAgICAQECAwQCAgIBAgICAgICAgEDAwIEAgICAQQCAgIEBQIGBQUFBQUFBQYGBQUFBQUHAQcFBQUFBQXqAwAAAEAAAOsDAAAAAAQA9wMAAAAAAIDsAwAAAABAAO0DAAAAAAEA7gMAAAAIAADvAwAAAACAAPADAAAAAAAB8QMAAAAAAALyAwAAAAAAEPMDAAABAAAI9AMAAAAAAAT2AwAAAAAAIPUDAAAAAABA+AMAAAIAAAD5AwAAgAAAAPoDAAAABAAA+wMAAAAQAAAAypo7AMqaO9AHAADoAwAA9AEAAICy5g7oAwAACgAAAFDDAAD+fwAA6AMAAAAAAAD///////////////////////////////////////////////////////////////8AAQIDBAUGBwgJ/////////woLDA0OD///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////2dUF+SChY9cAQZCVAwvZAVNRTGl0ZSBmb3JtYXQgMwBCSU5BUlkAAAAAAAECAAICAAECAQEBAgECEAEBAQEBAQIBARAQABAAAgIAAAAAAAAAAQIDBAYICAAAAAAAAAEBAgIDAwQEBQUGBgcHCAgJCQoKCwsMDA0NDg4PDxAQERESEhMTFBQVFRYWFxcYGBkZGhobGxwcHR0eHh8fICAhISIiIyMkJCUlJiYnJygoKSkqKisrLCwtLS4uLy8wMDExMjIzMzQ0NTU2Njc3ODg5ORBAAkAAAAECAwQGCAAAAAAhACAAHgAcABoAQfKWAwsJAQEDAAUABgAIAEGQlwMLAQEAQbSXAwudARAAQQCBAQGBg4MBAQMDARIBycnJyQFJSUlJyUnBAUFBwQFBQUFBQSYmQSMLgQEDAwMLCwsLCwsBAwMBQQEAAAICCAAQEBAAEAAQEAAAEBAA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cQBxAJ8InwhWA1YDVgPvAv0C/QL9Av0CSARIBNUCJAFyA4gDVgJWAlYCVgJWAlYCVgJWAlYCVgJWAlYCVgJWAlYCVgJWAlYCVgL5BAgECARWApMASgRKBFsCWwL8BPwEawGfCJ8InwifCJ8InwifCNUBaQJpAiEDUAHNASQDYANnAnsDkQNWAlYCVgJWAlYCVgJWAlYCVgJWAo0CVgJWAlYCVgJWAlYCVgJWAlYCVgJWAlYCUQRRBFEEVgJWAlYCqgRWAlYCVgK/BOEEVgJJBVYCVgJWAlYCVgJWAlYCVgKlAsEBhgM6BToFOgU6BeAEhgOGA0YBfwQXBPMC7QJbBcADWwXvA4oE7QLtAooE7QLAA+8D+gTiAtcAFAUUBRQFcwVzBXMFcwVYBVgFCQSGBWsFUQXfBt8GlQaVBgAHAAeVBpMGlgYWBwUHIQchByEHIQeVBiwHqwaWBpYGqwYWBwUHqwYFB6sGlQYsB64GDweVBiwHPgeVBiwHlQYsBz4H6QbpBukGHgdOB04HPgfpBuYG6QYeB+kG6QbBBlEH+Qb5Bj4HlQYfBx8HMAcwB/IG9gZ1B5UG8wbyBv0GCAerBn8HkweTB5wHnAecB58InwifCJ8InwifCJ8InwifCJ8InwifCJ8InwifCEUADQRPAEAEiwKsBIcF3QWfBVkFrAWPA7sE9AW9BQ8GHwYiBlgGaAZsBtsFoAUkBrgFPQYTAQ4DMgZwBo4GEQaSBpcGbAXeBaAGqgY0Bs4Fswe3B6UHHAe0B7UHrQevBzsHMQdFB7EHsQe2BzwHuAc/B70HzgdCB08HsQdQB5YHsAexB0AHoAehB6MHpAdZB2gHvAdSB94H3wfNB3EHRAeiB88HrAeeB8oHZgeBB+QH4gfqB3sHgwfsB8AH9Af4B/8H+QfTB9wHAgi7BwEICAjbB/wHCQgACI4HDwgQCBEIDQgSCBQIyQenBxUIFwi6Bw4IGwimBxkIFggYCBwIHgjaB+sH5gcaCO8H4wchCCIILggtCC8IMAglCL8Hwgc0CBkINQg4CDsIPQg8CD4IPwhCCEkIQwhECEUIRghKCEsITAjXB9QH1QfWB00IUAhZCFoIaAgAABQBFQEWAfAA8QDgAMIA4gDCAPAA8QDCANgA3ADCAOoA/QDCAP8AEwDgACkB/QDCAP8AzQDUANUAzQDZANoAHwDNAMIA2QDaAMIA2QDaACcA2QDaADgBKwAsAC0APAEvADAAMQAyADMANAA1ADYANwA4ADkAOgATAPAA8QDCAPAA8QDCAP4A8ADxABQBFQEWAekA/QD+AP8A/QD+AP8A2QD9AO8A/wArACwALQAHAS8AMAAxADIAMwA0ADUANgA3ADgAOQA6AA4BHgEWABcAZwBoAGkAagBrAGwAbQBuAG8AcABxAHIAUgAvADAAMQAyALoAuwC8AL0AvgC/AL0AVwC/AFkAxAATAMYAxAA9AcYAPwEZAMIAzQAqAQ4BzQBnAGgAaQBqAGsAbABtAG4AbwBwAHEAcgArACwALQALAC8AMAAxADIAMwA0ADUANgA3ADgAOQA6ADwAiwCMAPAA8QDWAPAA8QA3ATgBZgBGAO8APAHCABMA/QBNAP8A/QB6AP8ANwA4ADkAOgA7AM8AWADCAFoADAHCAF0ADAFrAGwAbQBuAG8AcABxAHIALwBnAGgAaQBqAGsAbABtAG4AbwBwAHEAcgByAHUAdgB3ABQBFQEWASwBEwDCACwBFAEVARYBZwBoAGkAagBrAGwAbQBuAG8AcABxAHIANwA4ADkAOgCSAMIAKwAsAC0ALwAvADAAMQAyADMANAA1ADYANwA4ADkAOgBSAIEAggA8AIEAggDZANoAdABEABkAZwBoAGkAagBrAGwAbQBuAG8AcABxAHIAFwCEACYBZwBoAGkAagBrAGwAbQBuAG8AcABxAHIA2QB5ADIBwgA0ARoAZwBoAGkAagBrAGwAbQBuAG8AcABxAHIAdACLAIwA2QB1AHYAdwB4ABMAwgB7AHwAfQAYAG0AbgBvAHAAcQByAIUAPAA3ATgB+gDCAPwAPAETAMIApgCnACsALAAtAM0ALwAwADEAMgAzADQANQA2ADcAOAA5ADoA2QDaAD0BPgErACwALQAIAS8AMAAxADIAMwA0ADUANgA3ADgAOQA6AIsAjADwAPEAiwCMALwAvQC+AL8AdQB2AHcA5wDEAP0AxgD/AMIAwgACAQMBkgDNAGcAaABpAGoAawBsAG0AbgBvAHAAcQByAG0A1ADVAOwA7QDZANoAwgBnAGgAaQBqAGsAbABtAG4AbwBwAHEAcgDCAHgA8ADxAHsAfAB9AIgAwgATAEoAPACNABcAhQD9AMIA/wBSAMIANQE2Af4AHQA9AT4BwgAhABYAxwAMAQcB7wArACwALQCXAC8AMAAxADIAMwA0ADUANgA3ADgAOQA6ANkA2gDCADwAEwCSAB4B8gAXAGsAbABCAMwALAHOAIAASQA8AHQAdQB2AHcACQF5AKUAPACLAIwAKwAsAC0AgQAvADAAMQAyADMANAA1ADYANwA4ADkAOgBnAGgAaQBqAGsAbABtAG4AbwBwAHEAcgCaAMIAnADCAHUAdgB3ABgBGwHNAGUA3AAfARMAFAAyARYANAF1AHYAdwDTANQA1QDZANoAdQB2AOwA7QAkAHoAZwBoAGkAagBrAGwAbQBuAG8AcABxAHIA8ADxAMIAPADCAMIAwgDCABMAwgA8AMIAFwD9AM4A/wBJAP4AEwCaAJsAnABIABQBFQEWAQcB2QDaANkA2gAPASsALAAtAA8BLwAwADEAMgAzADQANQA2ADcAOAA5ADoAtwDCAB0BZQATANYAPADyABcAawBsAG0AdQB2AHcAEAD+AHMA/gB1AHYAdwDCADwAegAHAc0ACAErACwALQAIAS8AMAAxADIAMwA0ADUANgA3ADgAOQA6AGcAaABpAGoAawBsAG0AbgBvAHAAcQByAJoAmwCcAJ0AngDwAPEAdQB2AHcAZQDNAHUAEwAUADIBFgA0Af0ASgD/AE4AzQBQAHUAdgB3AHYAJQG3ACQAegBnAGgAaQBqAGsAbABtAG4AbwBwAHEAcgDCACYB8ADxANMA1ADVAJAAEwAXADwAGQAXAPAA8QD9APUA/wAPAJoAmwCcAEgA2QDaAMIA/QAAAf8AgACBAIIAKwAsAC0AFgAvADAAMQAyADMANAA1ADYANwA4ADkAOgC3ABMATQBlABMAgACBAIIAFwBrAGwAPAD+AFgAFQBaAD0AcwBdAHUAdgB3AO8AFgB6ADwAwgDNACsALAAtAM0ALwAwADEAMgAzADQANQA2ADcAOAA5ADoAZwBoAGkAagBrAGwAbQBuAG8AcABxAHIAmgCbAJwAnQCeADwA8ADxADwAdADwAPEAdQB2AHcAkgDCABMAUQD9ABMB/wAYAP0AYgD/AHUAdgB3ALcAFgDCAGcAaABpAGoAawBsAG0AbgBvAHAAcQByAJcAwgAOAZgAFgAXAMIAGQATAMoA2QDaABcAbQDPADoBOwF8AHUAdgB3AHUAdgB3ADwA6AAWABcAEwAZAC8BMAErACwALQAWAC8AMAAxADIAMwA0ADUANgA3ADgAOQA6AA4B4wBgADwAKwAsAC0AogAvADAAMQAyADMANAA1ADYANwA4ADkAOgByAHAAcQByAMIAPAB4AHkAegB7AHwAfQB+AHUAdgB3AGYAGQCEAGsAbADCAMIA4wBnAGgAaQBqAGsAbABtAG4AbwBwAHEAcgDCAMIAZgDCAHUAdgB3AOkAZwBoAGkAagBrAGwAbQBuAG8AcABxAHIAwgDCABMAwgDZANoAdQB2AHcA8QCaAJAAnACHAPIAiQCKAIIAEwDoAMIA/QAXAP8A2QDaANkA2gDyABAABwAIAAkAGQAFAQYBCQHCABMA6ACZAOgAKwAsAC0AoAAvADAAMQAyADMANAA1ADYANwA4ADkAOgDCAOMA2QDaACsALAAtAMIALwAwADEAMgAzADQANQA2ADcAOAA5ADoAMgGPADQB2QDaACYBDABNABYAFwDZANoAwgBOADIBUAA0AcIA6AD+AFoAGwB1AF0AZwBoAGkAagBrAGwAbQBuAG8AcABxAHIAKgDCACMAwgDZANoA1gDCAGcAaABpAGoAawBsAG0AbgBvAHAAcQByAMIA7wBAAMIA2QDaANkA2gDRANIA2QDaAEoAzwBDABYAwgBNABMA6AD1AOgASwAYADgB6ADZANoAPAEZAFoAAAFmAF0AnwDlAKEA5wATANkA2gCiACsALAAtAKAALwAwADEAMgAzADQANQA2ADcAOAA5ADoAEwAXACABGQArACwALQAlAS8AMAAxADIAMwA0ADUANgA3ADgAOQA6AIMAFgATARgAKwAsAC0AwgAvADAAMQAyADMANAA1ADYANwA4ADkAOgDCAMIAawBsAGcAaABpAGoAawBsAG0AbgBvAHAAcQByAMIAGQDCADwAwgA6ATsBwgBnAGgAaQBqAGsAbABtAG4AbwBwAHEAcgATAMIAwgDZANoA2QDaABkAZwBoAGkAagBrAGwAbQBuAG8AcABxAHIAlgB3AAkBOAFDANkA2gA8ARMA7wDCAMIAgACBAIIACQEJAdEA0gAfAP4AdgD+AFYAPADCAJAAJwATAIIAEwE4AV8ALAAtADwBLwAwADEAMgAzADQANQA2ADcAOAA5ADoA2QDaABgAwgCZAAwALQB3AC8AMAAxADIAMwA0ADUANgA3ADgAOQA6ABsAOgE7ARYAOAEYANkA2gA8AXQAdQAWAJAAGQB2ACoAkwDCADwAEwAUAH8AFgDCAGcAaABpAGoAawBsAG0AbgBvAHAAcQByACQAQACRAMIA2QDaAMIANgBnAGgAaQBqAGsAbABtAG4AbwBwAHEAcgDCABYANgEZADwAwgDZANoAwgDZANoAwgAEAcIALQEuAUgABgEGAcIAdgAKAQoB2QDaAMIAUgD1ANkA2gDCANkA2gDCANkA2gDZANoAAAE8ABgAwgDZANoAwgBlAMIA9QDZANoAwgBrAGwA2QDaABYA2QDaAAABcwD1AHUAdgB3ANkA2gB6ANkA2gDZANoAAAEWANkA2gB0AAIBAwGSABMAFADCABYAiwCMAJYAlwCIABcAwgAZAMIAjQDCAMIAPgAkAHYAmgCbAJwAnQCeAGQAkQDCAJoAwgCcADEAwgAXAMIAGQDZANoA2QDaAMIAAQE8AI8AwgA8AMIAeQB6ALcA2QDaANkA2gBIANkA2gDZANoAhgAXAMIAGQDZANoABwAIAEEBVgDZANoAwgB6AFsAEwAUABcAFgAZABcAjgAZAIQAZQDZANoAwgDCAMIAawBsACQAwgDCANkA2gDCAHMAwgB1AHYAdwDCAHYAegDCABcAwgAZANkA2gDZANoAwgCOADwA2QDaAMIA2QDaANkA2gBUAFUA2QDaAEgA2QDaANkA2gA8ABcAPAAZAJoAmwCcAJ0AngBWAJoAwgCcAMIAWwATABQAFwAWABkAwgAXAMIAGQBlABcAwgAZAMIAwgBrAGwAJAC3ANkA2gDZANoAcwDCAHUAdgB3ANkA2gB6AMIA7QDCANkA2gDZANoAwgDCABcAPAAZAHYAFwB2ABkA2QDaABcAwgAZAMIASADZANoA2QDaABcAwgAZAMIAmgCbAJwAnQCeAFYAFwDCABkAwgBbANkA2gDZANoAwgDCAMIAwgDCAGUAwgDZANoAIgHCAGsAbADCALcA2QDaAMIAwgBzAMIAdQB2AHcAwgDzAHoAwgAhAcIAwgDCAMIAAQEBAQEB9AABAcAAEQHXAA0B9gArAQ0BJwH3ABEB9wD2ACcB5gAFAeIABQEFAREBEQGaAJsAnACdAJ4AAAABAAIA3QDcAAUA3AD6ANwABQEKAAsADAANAA4A+gAaAREAxQA9ABMAFAD2ABYAtwD0AI4AyQDJACYAHgArASAAyQCYABYAlwAkACsBKwAoAOsAEgDuAB0B7gDuACgB7gDJACgBEgEQARIAyADrAJYA6wD3APcA9wA8APcAEgESARAByQDIAJ8APwAkAUcAyQBIAMgAFgDJAN4AyABPAMkA3gBSACMBdADbAEEAyADbANsA5AAWAH8A4QCmAN4AGADhAHIAYwAcAd0AZQAcAeQAMwE7AdsAawBsANsA2wDbAMkAXABAAXMAQAF1AHYAdwDeAFMAegALAQsBlQCSABMAFAAWABYAFwH6AIYAyQCUAJ8A+QCLAIwA+wCNABkAGQEkAJMA+wD4APcAywANAMMABgDDAJoAmwCcAJ0AngDBADEBwQCjAMEAMQEuAdYA0AA8ANYA0ADfAN8ABADWANYAAwAWANcA1gBIANAApAC3ANcADwAXABAAFwCMAIMAmAAZAI8AFAAQABgAAQCRAI8AgwCDAD4AJQA2ADYAmAA2ADYAZQCDAHUAIgABAI4AawBsABYABQB0AKIARQAZAHMATAB1AHYAdwABAAIAegBFAAUAKQCOAHQAFAAKAAsADAANAA4AGAATABEAhAAFAH4AFgCNAEQACgALAAwADQAOABYAHgARACAAFgAWAJoAmwCcAJ0AngAoABcARAA8AB4AGAAgAGEAHAAWAEQAFwAlACIAKACWABYAGQAXABcAFwAWAGIAFwC3ABcAdQAiABYAGQBZAEcAjgCQAEwAIgAXACIATABPAFcAIgBSACIAXgBHACIAFgAYACwAIgAZABkATwAXABcAUgCPABcAYwCPABcAFgALABkAFwAZABYAFgAWAAEAFwAXAGMAiAAWABYAjgCOAI4AGQAZABcADwABAEIBQgFCAUIBQgFCAUIBQgFCAYYAQgFCAUIBQgGLAIwAQgFCAUIBQgFCAUIBQgGGAEIBQgFCAUIBiwCMAEIBQgFCAUIBQgFCAUIBQgGjAEIBQgFCAUIBQgFCAUIBQgFCAUIBQgFCAUIBowBCAUIBQgFCAUIBQgFCAUIBQgFCAUIBQgFCAUIBQgFCAUIBQgFCAUIBQgFCAUIBQgFCAUIBQgFCAUIBQgFCAUIBQgFCAUIBQgFCAUIBQgFCAUIBQgFCAUIBQgFCAUIBQgFCAUIBQgFCAUIBQgFCAUIBQgFCAUIBQgFCAUIBQgFCAUIBQgFCAUIBQgFCAUIBQgFCAUIBQgFCAUIBQgFCAUIBQgFCAUIBQgFCAUIBQgFCAUIBQgFCAUIBQgFCAUIBQgFCAUIBQgFCAUIBQgFCAUIBQgFCAUIBQgFCAUIBQgFCAUIBQgFCAUIBQgFCAUIBQgFCAUIBQgFCAUIBQgFCAUIBQgFCAUIBQgFCAboAugC6ALoAugC6ALoAugC6ALoAugC6ALoAugC6ALoAugC6ALoAugC6ALoAugC6ALoAugC6ALoAugC6ALoAugC6ALoAugC6ALoAugC6ALoAugC6ALoAugC6ALoAugC6ALoAugC6ALoAugBB8NMDC9ErggB/AOoAGgEaATAFQAIbBcwBIQEhAUACVgZ9AUACMAU9AkACMgKdARQFBgY9AuEBMgIMAswBywEuAlIAUgDXAyYBdwEzADMA8gE9AD0A2ANSAFIAKQaJAIoAWwAHAMwEzAQnBCoEHQQdBIcAhwCIAIgAiACIAJ0BIAEgAbYAIAEgAeEBGAIgASABggB/AOoAsAE9Ag0CMgI9Ai0CMgIKBT0CpQEyAokAigBbAC8CzATMBCcEKgQdBB0EhwCHAIgAiACIAIgAKAHMAY4B4QSGAIYAhgCGAIUAhQCEAIQAhACDAIAAwwEsABoEGgQoBCsE5wQBAAEARgICAOsERQKWBOsElgRBAZ0BmwBBATAGmwB7AXAA8gE9BcgBKwE9BYYAhgCGAIYAhQCFAIQAhACEAIMAgADDAYkAigBbAFEEzATMBCcEKgQdBB0EhwCHAIgAiACIAIgAtARAATcCIAEgARsBIAEgAQsCCwLiBIsABQYHANYA9wE9ApEEMgI9Ah4EMgKIAIgAiACIAIEAkQEjAucBkQT1ACAGkQT1AIUAhQCEAIQAhACDAIAAwwEFAYYAhgCGAIYAhQCFAIQAhACEAIMAgADDAcMBtAS1BLQEggB/AOoAxwGdAbYAxwGCAH8A6gCGAIYAhgCGAIUAhQCEAIQAhACDAIAAwwGIAIgAiACIABoCQAKJAIoAWwAFAcwEzAQnBCoEHQQdBIcAhwCIAIgAiACIACwA2AFaAbQE2AFaATMAMwCiAV0AnQCGAIYAhgCGAIUAhQCEAIQAhACDAIAAwwGmAGsBKgGGAIYAhgCGAIUAhQCEAIQAhACDAIAAwwENBc0BIganAXkBEwGGAIYAhgCGAIUAhQCEAIQAhACDAIAAwwGiAUABNwIMBbQEtQS0BAEBnQHjAf8B/AH7AV4AhACEAIQAgwCAAMMB+gG0BCQCJAKEAUACgAEHAJ0BJgLlAAoCiQCKAFsAEgLMBMwEJwQqBB0EHQSHAIcAiACIAIgAiAAzADMALgZ8AYkAigBbAEsBzATMBCcEKgQdBB0EhwCHAIgAiACIAIgAQAE3AiABIAFAATcCQgZGAgIA6wS0BLUEtARcBkEBPQKbADICQALnBQgB5wAIAj0FhgCGAIYAhgCFAIUAhACEAIQAgwCAAMMBBwLnBekFNQU1BVIAUgDyAYYAhgCGAIYAhQCFAIQAhACEAIMAgADDAZsFAQEgASAB/wH8AfsBsAMgBp0B+wO0BK8DaAH6AT0CPgYyAiwAPwInAicCLQJTBC4GIAJAAlMEKAChAfUAEwLhBYkAigBbANsAzATMBCcEKgQdBB0EhwCHAIgAiACIAIgAUQBRAAEFtASdASkC5wUwAAACwAG/Ae0BQgLHAUICWAEtALQE0QS0BLUEtASsAdMEngByA0ABNwKJAIoAWwDSBMwEzAQnBCoEHQQdBIcAhwCIAIgAiACIAIYAhgCGAIYAhQCFAIQAhACEAIMAgADDAdQEQALUBEkBtAS1BLQEgwHsAZMBEAR+AekBewA4AiEGBAB5AbQEtQS0BDoCOgI6AlIAUgByAwUEMwUzBTsCBASGAIYAhgCGAIUAhQCEAIQAhACDAIAAwwEgASABAQW0BEACpwFAAiAGnQGnAcQBegF2Az0C/wQyAi4ALQIUAgQEBAQGBDUCggB/AOoALAJSAFIAUgBSAN8BiQCKAFsAzgHMBMwEJwQqBB0EHQSHAIcAiACIAIgAiACkBOcB4gUQBJ0BBgC0BDIAbwN5AHkAtAO0BLUEtARmAS0CegA8AcQBQQLEARcCtAQEBLcBLwHUAIkAigBbANUAzATMBCcEKgQdBB0EhwCHAIgAiACIAIgAhgCGAIYAhgCFAIUAhACEAIQAgwCAAMMBBAQEBAYEBwQjACABIAG0BLUEtAQQBDsFFQJ7ADgCIQYEAHkBPQL7AzICYQH9BGQBtAS1BLQEBQToAaQEOwIEBIYAhgCGAIYAhQCFAIQAhACEAIMAgADDAUACVwEgASABwQHBAcEBywOdAVsGxAGPA6MEIAEgAT0C0AEyAu4ABAQEBAYENQJSAFIA8gE9ApsBMgJYAdMBTAGJAIoAWwDFAMwEzAQnBCoEHQQdBIcAhwCIAIgAiACIAKQEEAKRBBAEnQFWBFYE7wERBHkAeQC0BD0BHAJeA5EE3AR6AJEExAFBAsQBPAXGAAQEtAThAQ4CiQCKAFsAMALMBMwEJwQqBB0EHQSHAIcAiACIAIgAiACGAIYAhgCGAIUAhQCEAIQAhACDAIAAwwEEBAQEBgQHBCMAtAQgASABtATdASABIAG0BLUEtAQbAuEBtQHWAT0CqwUyAmwBPQKBBDICtAS1BLQEpAQFAEAChgCGAIYAhgCFAIUAhACEAIQAgwCAAMMB3QDWAC4BYAB9BHkG6AB5Bp0BiAETABMAAAS1A5YBdQE7Bj0EtAS1BLQEtAS1BLQEtASqAX0EegadAXoGewaPAYkAigBbAAMAzATMBCcEKgQdBB0EhwCHAIgAiACIAIgAMAEfBQICtASJAIoAWwDaBcwEzAQnBCoEHQQdBIcAhwCIAIgAiACIALIBgwCAAMMBdwG0BBIBIwF0AQUCbwEEAgYBtAS1BLQEewTjAGsBwAG/AZsFIAYeBYYAhgCGAIYAhQCFAIQAhACEAIMAgADDASAGQAJ7BOcBtAS1BLQEugGGAIYAhgCGAIUAhQCEAIQAhACDAIAAwwGCAUAC5QFAAhMAEwC0BLUEtARBBdQEygPUBD4CLwCoA6gD2QGdAa8BEAY9AmUEMgITABMAEwATADEAUAFSA1MDVANvAFgFOwGtAUACnQGxAVUBMgGJAIoAWwBzAMwEzAQnBCoEHQQdBIcAhwCIAIgAiACIAEACHQVSAFIAiQCKAFsAEQLMBMwEJwQqBB0EHQSHAIcAiACIAIgAiAAhBt4AeQETABMAMQFmBJEEjgF8BBYAFgDyAU0BIQZPAXkBQAK2Ab0BkQRnBOYBkQSGAIYAhgCGAIUAhQCEAIQAhACDAIAAwwFoBEAChgNAApEAkQAGAEAChgCGAIYAhgCFAIUAhACEAIQAgwCAAMMB1gA4BZoDQAITABMAEwATAAIFowETABMAmwOcAQMCjQBAApEEnQHOANEBzwCHA9cAJwYoApMAkwAHAOMAkQSbAeIEkQR4ADMBdQAzAZ0BQgBCAE4BiQCKAFsAdwDMBMwEJwQqBB0EHQSHAIcAiACIAIgAiACdAR0B0QDJA4kAigBbANcBzATMBCcEKgQdBB0EhwCHAIgAiACIAIgAswEKAKoFCwGJAH4AWwCbBcwEzAQnBCoEHQQdBIcAhwCIAIgAiACIAJsFmwWaAZkBhgCGAIYAhgCFAIUAhACEAIQAgwCAAMMBQALJA0ACyATyAXUBOwYSBoYAhgCGAIYAhQCFAIQAhACEAIMAgADDARQCyQFAAlIAUgBSAFIAbwCGAIYAhgCGAIUAhQCEAIQAhACDAIAAwwFtAOkArgEoBiICQwBDAAcAnQFfASYCDgYEAQMBAgHuAbsBOQKjAdcDvgHIBMIBIQK3BEACyQPYA50B2wGpBSYGnASKAFsABwDMBMwEJwQqBB0EHQSHAIcAiACIAIgAiAAVABUACwFAAiwBZgRbAOkAzATMBCcEKgQdBB0EhwCHAIgAiACIAIgAZwR1ATsGoQAlBhAANQA1AAcAbAAVAiYAyQN9ALcEaAScBEACyAR7ADgCfQMEAEQBhgCGAIYAhgCFAIUAhACEAIQAgwCAAMMBOwI0AhYCQAJEAEQAQAInAIYAhgCGAIYAhQCFAIQAhACEAIMAgADDAUACoAAjBscExAFAAjYANgBAAkUARQBAAlYFQAKkAbgANQLPASkBQALIBM8BKQFGAEYAQAIsANoBRwBHAEACSABIAEACSQBJADcANwCbAWoD8gBAAjgAOABAAhAEQALeATkAOQBAAnkAeQA7ADsAFwA8ADwAmwF6AD8BxAFBAsQBSgBKAAQESwBLAEwATACbASIBFAAUAGwAHwHnACkCewA4AkUBBABAATcCYQDaALADeARIAZABQAKvA0ACZAWoATsCagMEBAQEBgQHBCMAJQEWAkACUARAAlAECQBAAlYBQAJvAE0ATQCPAI8AQALNAMQB3gBjBXkDQAKFA4QDpASQAJAATgBOADUCPgA+AE8ATwBDAf0DQAIKAT8APwCMA40DNQYeAlAAUABAAnMBHQJ7ADgC4AEEAAoB4gH0AAoBcgEQBEAAQABAAtIBQAJ5AHkAOwIVBkACqgCqAEACegBAAsQBQQLEAUACeQMEBEACpQBAAm8AqwCrAFcAVwBRAVAGxAFBAEEA+gVTAFMAkgCSANoD2wNUAFQANQKoAKgAlACUAEQEWwEIBG8ABAQEBAYEBwQjAB4CTwRAAk8EQAIfAnsAOAL4AQQABwFAAmkB+QVvABAEQARAAgcBQALqAXkAeQA7AqQEjgCOAKkAqQB6AEACxAFBAsQBogCiAAQEQAIzAkACmACYAJcAlwBcAWAFzgPEAQoBRASuAwgEfQCVAJUAqwNAAn0AQAI1ApYAlgBWAFYAaANgAZ8AQAIEBAQEBgQHBCMAHgKtA0ACfQBjAR0CWABYAFUAVQBlAWcBLAUcBW4BEAR4ATQANADzAW0FeQB5AJoFpAQ6ADoAUgVeBXoAnwXEAUECxAEJBacABAQABRgB9ATzBPUESQZPBTgBOQEMADoBjQGNBeAAiAUnAe0AgQVTAVQBkgUtAVkB5AHkAFsFGwVcBVoFkQWUAQQEBAQGBAcEIwBBBqgExgH9AXEBJAHeBdIA3QVZBYwBjAGLARUBiQHTADYCWwNMBtwEewA4AocBBACkBN8ADgENBgsG2QTvALoARwGmAWAAwwDcADsC6wC0AEYBvADUAb4A4wW/AMAAXADBANUBXwCOBQ0A9gH3AJYFbQDHAJIB3AGVAcQB2AWUBZMFDgDrAfsAZgDxAe4F8QAZATUC/QDLAGIB9AH+AK8A9gSXASsAXgEGAi8FtAH/AC4FLQUmBWgAfQNaBuUAmAG4AVkGuQHwADYBEAUQBDcBJQUPAjoGEQV5AHkAcAEPBVgGDAENASwGegArBsQBQQLEAXYBvAEEBHIFcQWMACkCWgA4AgsABADLBX8BngGBAW4AdADYAEABNwJGBSsCKgA+ATsCGQJFBYUBhgFDAq4EFAEXARYBBAQEBAYEBwQjAEQCnwHxBMoB7ASgAbkA/gWsAMQB/wWtAJwANAFOA/0F/AXFAdkA4QBZADUCrgBCAaQE4gDsAE4EmgBMBEoBsAC7AMcEvQCdA1IB8wBcBPYAwgCxALIAqQGrAWIAYwDEAGQAZQAQBLMAXwT4AFsE+QB5AHkAGACjAPoAXQFUBAoBegDWBMQBQQLEAagExgEEBMgAJAHwAfwAyQBdA4wBjAGLARUBiQEPAPUBWwNyASQBAAHKACoC+QGMAYwBiwEVAYkBZwDvAFsDRwEZABoABAQEBAYEBwQjAEYBagH+AXsD7wBtAUcBAQKIA2kANQGkALUAGwBGAWoACQJrAKEELQSDBBEAggQcAaQEHgHSAwkBzAB9AJME8QDmAMwDlwQcAIgEHQCbBK8AlQQeACsAHwCaBPEAIAApACUCCAAhANAAbwCvADsELgQrAHEALATwAHIAMAQiADEEMQJkBHYADwEkABIAqgQJBGkD8ACnA3wAJQAQAREBUQY8ArcAmQCKAakE6AToBOgE6AToBOgE6AToBOgEngHoBOgE6AToBEABNwLoBOgE6AToBOgE6AToBJ4B6AToBOgE6ARAATcC6AToBOgE6AToBOgE6AToBMoB6AToBOgE6AToBOgE6AToBOgE6AToBOgE6ATKAQAAfwZ/Bn8G0wXmBFcF5gTmBOYE5gTTBdMF0wXmBOYE5gTmBOYE5gR1BXUFCAYHBeYE5gTmBOYE5gTmBOYE5gTmBOYE5gTmBNIF5gTmBOYE5gQqBioG5gTmBOYE5gTmBBsGGgbmBOYE5gR+BeYEhQXmBOYE5gTmBOYE1AXVBeYE5gTmBOYEBwYJBuQFjAWLBYoFiQX2BWkFgwV8BYAFzwXQBc4FaQbVBdQF5gR/Ba8FvwWuBeYE5gTmBOYE5gTmBOYE5gTmBOYE5gTmBOYE5gTmBOYE5gTmBOYE5gTmBOYE5gTmBOYE5gTmBOYE5gTmBOYE5gTmBOYE5gTmBOYE5gTmBOYE5gTmBOYE5gTmBOYE5gTmBOYE5gTmBOYE5gS3Bb4FvQW8BcUFuwW4BbEFsAWyBbMF/gTmBPsEMQXmBOYE5gTmBOYEtAUHBagFpwWmBeYEwgW1BcEFwAUPBk8GTgblBeYE5gTmBOYE5gTmBCoG5gTmBOYE5gTmBOYE5gTmBOYE5gTmBOYE5gTmBOYE5gTmBOYE5gTmBOYE5gRrBSoGKgbmBAcFKgYqBmwFbAUDBQMFbwUWBk4FTgVOBU4FVwVOBeYE5gTmBOYE5gTmBOYE5gTmBOYE5gTmBOYE5gTmBAwGCgbmBOYE5gTmBOYE5gTmBOYE5gTmBOYE5gTmBOYE5gTmBOYE5gTmBOYE5gTmBOYE5gTmBOYE5gRTBeYE5gTmBOYE5gTmBOYE5gTmBOYESAbmBPEFPwVTBVMFUwVTBVUFQAU+BU0FCAXtBHcGjwWEBVQFhAV0BoIFjwWPBYIFjwVUBXQGGAVeBhMFdQV1BXUFawVrBWsFawVvBW8F0QVUBU0F5gR3BncGXQVdBXYGdgZdBeUFZgaYBTQFOgU6BToFOgVdBfgEggVmBmYGggWYBTQFggU0BYIFXQX4BPUFcQZdBfgE2wVdBfgEXQX4BNsFMgUyBTIFJwXmBOYE2wUyBRgFMgUnBTIFMgU8BuYE3wXfBdsFXQU0BjQGeAV4BX0FbwXWBV0F5gR9BXsFeQWCBSoFSwZLBkcGRwZHBnwGfAYWBlcGBwUHBQcFBwVXBhoFGgUIBQgFBwVXBuYE5gTmBOYE5gTmBFIG5gQRBuYFYQXmBOYE5gTmBOYE5gTmBOYE5gTmBOYE5gTmBOYE5gTmBBwG5gTmBOYE5gTmBOYE5gTmBOYE5gTmBJ0F5gTpBBMG5gTmBOYE5gTmBOYE5gTmBIYFhwViBeYE5gTmBOYE5gTmBOYElQXmBOYE5gSQBeYE5gTmBOYE5gTmBOYE5gRzBuYE5gTmBOYE5gTmBPQF8wXmBOYEXwXmBOYE5gTmBOYE5gTmBOYE5gTmBOYE5gTmBBYF5gTmBOYE5gTmBOYE5gTmBOYE5gTmBOYE5gTmBOYE5gTmBOYE5gTmBOYE5gTmBHoF5gTmBOYE5gTmBOYE5gTmBOYE5gTmBOYE5gTmBDkGcAXmBOYE5gTmBGoG5gTmBOYE5gRIBeYE5gTmBOYE5gTmBOYE5gTmBOYEYgZCBZ4F5gShBfwE5gTyBOYE5gQAAAkAQeD/AwuyBr4AvgC9AL8AwADAAMAAwAC/AL8AvwC/AL8AxADGAMgAyADHAMcAxQDFAMwAzADOAM4AzwDRANEA0QDSANYA1wDYANgA2ADYANgA2ADYANgA2ADYANgA2ADYAOEA4QDdAN0A3wDfAOIA4gDiAOIA4wDjAOMA4wDjAOAA4ADkAOQA5ADLAOYA5wDnAOcA5wDnAOoA2wDbAOsA6wDsAOwAvwDuAO4AvwC/AL8AzQDNAM0A8ADzAPMA8wDxAPEA/QDxAP8A/wD0APQA9AAAAfUA9QD1AAEBAQH2APYAAwEDAQIBAgECAQIBAgHJAMkA7wDvAAgBCAEIAQgBBAEEAQQBBAEFAQUBBQEKAQYBBgH6APoA6ADoANwA3ADcAAsBCwELAfgA+AD5APkA+wD7APsA+wC/APcA9wANAQ0BDQENAb8ADgEOAQ4BDgG/AL8AEQERAREBEQERAREBEgEPAQ8BEAEQAQkBCQHaANoA2gDaANkA2QDZANoA2gDaANoA2gDaANoA2gDaANkA2gDaANoA2gDaANoA2gDaANoAFAHaANoA2gDaANoA2gDaANoA2gDaANoA2gAVARUB2gAWARYB2gDaANoA2gDaANoAGQEZARoBGgEYAQcB/gD+ABcBFwG/ABsBGwHeAN4A6QDpABwBHAG/AL8AvwAdAR0BvwC/AL8AvwC/ANQA1QC/AB8BIQEhASEBIgEiASIBJAEkASABIAEmAScBJwElASUBJQElAdoA2gDtAO0A7QC/AL8AvwApASkBvwC/AL8AvwC/AL8AvwAqAb8AvwC/ACwBLgEvAS8BMAEMAQwBMwEzATMBMgE0AfIA8gA1ATYBNwE3ATcBNwE3ATgBOAE4ATwBPgE+AT8BPwE9AT0BQAFAAUEBQQFBAfwAEwETARMBOwE7AToB2QC6ALsAuwC8ALwAvADBAMEAwQDDAMMAvwDMAMoAygDCAMIA0QDSANMA0wDQANAA2ADYANgAywDlAOUA5gDqAOwA8ADxAAABAQEKARIB2gAUARgBBwEeAR4BHgEeAR4B1AAjASMBJgEnASgBKAErASsBLQEtAS4BMQExATEBDAE1ATcBAEGghgQL8QFLAAAAJAAKAF4AAAA1AAkAhwAAAF4AAQBWAAAAUAAAAAkACwAnAAIARwAAAHoAAABCAEMARABFAEYAAgQIBgYAAAAAAHJvd19udW1iZXIAZGVuc2VfcmFuawBwZXJjZW50X3JhbmsAY3VtZV9kaXN0AG50aWxlAGxlYWQAbGFnAENBRERFQgMEAwcEBAAAAAAKCgkJCAgHBwcGBgYFBQUEBAQEAwMDAwMDAgICAgICAm50aF92YWx1ZQBmaXJzdF92YWx1ZQA6OBgWFRcAACQgGBUXFi0pKConJiQgAAAAADoAAAA6AAAANwAAADoAAAA6AEGgiAQLIW5hdHVyYWxlZnRvdXRlcmlnaHRmdWxsaW5uZXJjcm9zcwBB0YgECxQHBAYEKAoFIA4FMBMEOBcFARwFAwBB8IgECxE0AAIAfwAAAGEAAgCAAAAAegBBkIkEC4YBAgABAGMAAQQQAQAARgACAGQABwAfGBERExQAAAAAAABWAQAAPAEEAHYAAwBUAwEARgAAAHYAAwAJAAMAAgABAGQAAAACAAAAYwABAFQBAQBvbm9mZmFsc2V5ZXN0cnVleHRyYWZ1bGwAAAECBAkMDxQCAgMFAwQFBAEAAAABAQMCJV8AAHgAQaCKBAvUB77/2QDB/0//TP+hAGwBQABJ/6IA3wBvAZ4BU//ZAQICDQJuAnICMf9fAez+2v+1AisDPwNBA3gDRP+xA7MDoAEuArcDYwMfATYEOARG/+AAfP8qAMQDDQGhARwDKgMT/xn/E/8Z/9P/0//T/9P/0//T/9P/0//T/9P/0//T/9P/0//T/9P/0//T/9P/0//T/9P/0//T/9P/0//T/9P/0//T/9P/0//T/9P/0//T/9P/0/9/A50DxwPUA0wEdwSRBLMEyQTMBNoE3wTiBOUE5wTtBPME+AT7BAMFBgUIBQwFNQU3BUMFRQVIBUoFUAVWBWUFbwV+BYAFhQWIBYoFjgWRBZMFtwW5BcAFxgXIBdMF2gXcBe0F7wX4BQAG0//T/9P/0//T/9P/0//T/9P/0//T/zgBYv8dASX/CQCmAHIBIQLDAtP/ogNZAsMDKwQYA9P/0//T/9P/NP80/zT/cQFV/3//eAKmAsoAYAHy/pwBcwJzAvf/egCfAaMByP/4AEcCmAMGAAUBywEbAxkELQMmBDoEX/8KAycEHQNmA+sDaAS7AQcEMASnBKgEvQNgBGkAfQQLAqUDwgTWBOYE4wR2/2AAdQCSALUAFQEYAaUB4AHIAj4DUgM9BEsEaQS5BCsFMwU4BVQFfwVwAYQFmQWeBcIFyQXhBeIF9gUCBggGCQYKBtIC/AJYAwsGDAYOBqQEEgYVBhkGEgXsBBoGsAUcBhgBIAYjBiUGJgYnBigGsQXFBfAF6gXrBewF7gWkBPAF8AX6BRsGMAbKBeAF5gX+BekF0AUBBugF8QUDBvIFBQbVBS8GFwYdBjEGMwY1BvkF+wX8BQ0GFgYeBv8FKQYuBlYG/QUEBlsGXAYQBhMGYQYYBioGLQZHBkYGSAZJBksGcQZ3BkwGNgY3Bk0GOgZVBk4GVwZQBoIGhAYrBjkGiAaLBngGjAaPBpAGmAZ8BoMGhgaHBn8GhQaJBooGmQaRBpwGjQadBp4GOAY/BlEGVAakBrEGPAY+BnoGewabBpQGdgbHBoAGoQaaBqUGpwbUBt4G4AboBuoG7AZ5Bn0GgQbhBtoG3QbiBuMG5AbWBtcG5QbrBucG7wYAAAEAAAAwMTIzNDU2Nzg5QUJDREVGbGFzdF92YWx1ZQAADAAOABgAHwA7AHg5AAAAAAAAAAAGc2Vjb25kACQg01cAAIA/Bm1pbnV0ZQDZM+FUAABwQgRob3VyAAAAsDnwUQAAYUUDZGF5AAAAAFr8o0oAwKhHBW1vbnRoAACAaCxIADQeSgR5ZWFyAAAAAORlRsCZ8EsJCg0gAEGgkgQL4AEBAQABAQEBAAEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEAAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQBBiZQECwUBAQAAAQBBoJQECwEBAEGAlgQLAgsMAEGYlgQLBmJ0bgBmcgBBsJYECxwBAgUKDxQZGRkyMmQAAQMIEiE1TmeAsuRyYW5rAEHqlgQLAQEAQYCXBAuTAQEBAQEBAQEBAQEAAAAAAAAAAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEAAAAAAQABAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQAAAAAA//z9//7+//39/fv9///+//3//vv//gD+/P7/AAAAAAAsLCwsLCwzTSsMDlNSDhcXHx9HSk5RVlsGNTU8QEQ1V1w1XQBBoJgEC6MBEBESExQWFhgYERITFAcWCRgREhMUCRYJGA0REhMUGhYYGBESExQPFgkYERITFBoWFRgGBwkJCgwMBgcVCRgZDBIFFA4WBRgDAQIDAQIDAAECAwsCAwsJCgUMFxgKCggJCQ8PCAkJGxsLGxsbGxsbGxsbGxsbGxsbGwAAAAAAAABQUFBQUFBfUFBpUG5uUG5uUFBQUFBbUFBQZWRQUFpnUFBoUABB0JkEC6IBURRgBhxjYhoaEmAGHBFiOBoTYAYcDmIOGh9cYAYcbGIZGhVgBhxOYjoaHWAGHGtiFhoYEAwLAQ0NGBAXCyEiDWEIGyBiBxoDBAUDBAUDUwQFAz8FAz4MAlYNCR4KCjY5S05ONTkPUlJHAAAAAAAAABAUFBQUFRURERERERETExISFhYWFxcZGRgYGhoAAAAA8PgACREZLu/vJUMEBAgEFBsmAEGAmwQLyRsBBD0AdQA3AHUANgAyADUAOQA1ADEAVQBNAVUAeQBVAEkDNgA1ADIAOAAwADgARQM2ADkAMgA5ACEEPQA1AJcAOgA1ADgAOgAnADQAOQAiADoAOAA6ADkATwA4ACUAVQA4AC8AJwAzAG8ANQDpAjkA6QAFAzkABQEeByUAHgIlAP4F3gBFAEkAJQB+AH4ASQBFAIkAJQBJACUAaQBlAEkAJQBJACUAvgCeACUAfgB+AEkAJQB+AF4AJQAnAF4ARQCHACkAKAAlACkAKAAlACkAKAAlAB4CJQBeAiUAKQAoACUAfgBJACUAXgfFAEkAJQBJAEUAfgBpACUAHgGFCCcAZQNGApgAhgHYAaYA+AAmADgAJgA4AgwOngAmADgAXgAmAGUANQBYACkANQBpACkASQAlACkCKQFlBF4AJQBpAGUAHgOFAF4AOQB+AF4AJQBpBgUGXgQ6AKwASwD+Bt4BJQAeC8kEJgDVAOUENQAxADcArAUxACwANQBMADUATAA1ACwAZwNnAFUAogB5AFUANwBVAFoAbAE1AFUABwQmAEcBrAJNAZUARwAsAGcMNQAnAOwAIgA6AMwARgBMADoAjABHAE0BZwBaACcA1QEiACcALADHA2wDJwtsAScATQEnBCwBRgA6AHUAJgDHAowAJgAsASYAbAAmAKwA9QEnA2wANQAnAGcBbANsACoAxwYsACoALAAnAGoADAGKACwASgAnAOwARwFMAFUATQE1ACYAxwDnACwASgAHAUcAxwLnACcAhwAsACcAagCMAEoASgAsACcAKgBHAGcATABNAUcAVwDPADoANwBMACoAxwBHAMcC5wBHAEcARwAsAGoATABMAGwALACHACcATQFMAGcALABMACoAJwFnAMcC5wBHAKcALAAnAGoArABMACoASgAsACcARwBMAE0BNQA3ACwASgAHAUcAxwLnAEcApwAsACcAKgAsACoAjABKAEoALAAsACoARwBnAEwATQE6ACcAzwAsACcAxwBnAIcARwAnAEcARwBnAIcBSgAsAEoAagBqACwAJwAqAE0BbwDaADcAOgBqAAcBZwDnAkcBpwAnAGwAigBsAIwATABHAEcATABNAe8AOgBKAAcBZwDnAkcBpwAsACcAKgAsAKoALABKAEoATABKACcARwBMAE0BRwBKAAcBZwAnBScAagCMAGoAagAsACcAKgBHAEwATQHPADoAxwBKAEcCBwMnAScA5wAsAGoAbAAsAAoBSgA1AAcGLABHAOwANwDHACYADAE1AE0BVQBHACcARwAnACcAhwDnAGcAJwAnAEcAhwAsAEcAzABMACcApwAmAMwATQGHACcAegD1AToANQB6AEwA2gBNAU8BOgAsADoALAA6ACwANgAyADYAMgBKAAcBhwTMASoArAA1AEwApwBsAYwEGgEsANoAWgC1AJoAVQBnBUoAjAAqAMwAKgBMAEoATAAnAE0B1QDHAEoATACHAGwAJwBqAEcA6gBnAIwApwEsAEoATADKACwAJwAqAE0BagAsAFoAyQQpACkAZwU1ACYAhymHAOcAJwCHACcFhwAnBIcA5wAnAIcA5wEnB4cAZwhsADUBjwIHAloBpwoxAIdNVQAnAj0ARwM2ADIAZwl1AG4ApwGHAGwARwJsAFUARwJMAKcBZwBMAIcGTAAqAOwACgEsAEoAbAF1ACYAdQA3ACcALABNAU8B1QAxAJUAbAA9AE0BZwQmAIcGJwUsACcAxwinA2wAigBMAGoASgAsAMoAbAA6AFUATQHHA6cAhwUqAucASgBNAS8AWgTnAkwAagBVAKcGKgAsACoA7AAsACoALABKAAwBygBMASwATQFNAfUAJgDVAIwAKgDnBSwAKgCsACoALACqACwASgDnAE0B9QBaASwBOgFMACoAxwMqAIwASgBMACoALABKAEcATQGHBSwAKgBMAGoALAAqAGwASgCVAIcECgEMAUoATAC1AE0BZwBNAccDxgBVABUBbAA1AKwBKgDsAIcALACHAEoALABHAIUF5gelASYARQSmBOwEjADeEgUBXgwFAQkBxQDJAAUBCQEFAQkBxQDJAAUBKQApACkAXgDlAAkBxQEFAQgBBQEIAQUBCAGlAEUAiQAoADgAJQB4AGUARQCJACgAeACFAEUAiQB4AAUBqQB4AGUARQCJACgAWAB9AaIA0QBVADQAMwA2AFQAMwA2ADQAFQE7ADwAogA9ADUBNAAzAJUAUAB1ADkANgAyAHUBOQA1ADAAVQE9AKIAwgAvACYAzwB5ADYAMgAmAE8BeQA2ADIApgFXA6wBiwAsAGsAjAFaACkAmgApAFoAJQBpAEUAaQAlADoAKQBaADkAqQDaACkAOgApADoAKQA6AIkAOgAlAIkAJQCHACUAWgBFAEkAuQBeAGUAOgA5AFoAJQA6AA8CbgReAI4ALwC5ALoAWQCaADkAWgA5AFoAOQD6ADkA+gNZAFoAOQA6ADkA+gOZIRoBmQCaAlkA+gA2ADIAOgo5ANoDOQMaBdkAWgL6BHoBjwfaCc8C+hY5ADoBOQDaBhkB+g05ABoS+gw2ADIANgAyADYAMgA2ADIANgAyADYAMgA2ADIAzwOaBbkANgAyAPkDNgAyADYAMgA2ADIANgAyADYAMgAZAhogeRA2ADIANgAyADYAMgA2ADIANgAyADYAMgA2ADIANgAyADYAMgA2ADIANgAyAPkHNgAyADYAMgAZBDYAMgBZIBoGuQJaANkAWgHpBeUFfgBJAEUA/gBpACUAXgAlAF4ApQBGAGkAJQBeDCUA2gCeAGwAXgCVAC8AVQDFBCUAJQAHByYANQAsAOcC5wDnAOcA5wDnAOcA5wDnAAwEVQA0ADMANAAzAHUANAAzADUANAAzADUBMQBVADEANQA0ADMAVQA0ADMANgAyADYAMgA2ADIANgAyALUAJgBVAVEAWgM6C9oamgE9AHUAOgAmACcALgA2ADIANgAyADYAMgA2ADIANgAyAFoANgAyADYAMgA2ADIANgAyADEANgBSADoALgGMAEoAMQCmAFoAbgAmACcANQBaAMcKTABYAEYAJwAxAEcLNQBmACcAJwXHC1oAjwBaAWcDmgQHAvoDTwHaAw8BOgDvARoETwH6BO8B+gcaICcAJwAaCCcAJwCnAiYA5476BgcFxgBVAIchJgB1AAcCTQFHAN4FJwAsAGsANQBMATUAJgAeAywAxwhOAUwA1QD4AiYBWADeAUUA3gcmAAUBvgBeASYAWACeAJ4AfgFGACUA5wAsAGcALACHACwA5wJKAEwAKgCaAM8AWgA3ADoAhwaVAEoARwYKAiwAVQBNAUwCxwB1ACcATQGHAwwBVQDnAmwBSgA1AKcDbAAqAOcFLABKAIwASgAsAIoAtQEmAE0BVQAnBcwASgBMAEoATABnACwABwEsACoATQGVAAcCJgDHAHoAJwAqAAcGLAAnAGwARwBMAKcATAAnACwAJwBHACYAVQBnASoATABKAFUAJwBGACoALADHAMcAxwDnAOcAZwRKACwASgAsAEoANQAqACwATQEnACcA5wInBiQARABEACQAPwA/AMctRw3lAKUAJwAsAEcBOQCnAacAJwBHAEcAhw0YAmctNgAyAAcIxwaHATcAOgAMAvUANgAyADUA7AA1AFEAUAA2ADIANgAyADYAMgA2ADIANgAyADYAMgA2ADIANgAyAFUANgAyAJUAcAB1AJUAMQA2ADIANgAyADYAMgB1ADkAMQB5ADUANwBVAKcA5xAiAHUANwB1ADYAMgA1ADkANQAxAFUATQFVAHkAVQBJAzYANQAyADgAMAA4AEUDNgA5ADIAOQA2ADIANQA2ADIAVQBHASYApwVGAOcDxwDHAMcAZwBXADkAOAA6AFcAOgCZAFoAYgBaAIcBRwNnAkcA5wHHAWcPdQCvBToBrgaPADoCLwCaAboFLACnAycG5wOPACcCLgAHAS4AxwM1AIcEBwE1AK4ACQUFBccJTQHHACcAhwVHACcA5wI1AA8BxwLPADUARwM1AAcHRwAnAGwATACMAIcAZwBnA2wALAAPATUBpwNPADUAxwb1AMcCDwFnAg8BJwnvAyoALAAqAKcG7AH1AI8CTQFMACoApwVqAIwASgBMAFUAIgCVACcDTQFsAIcErAAqAAwBTQGVAEwAKgAHBmoALAFKAIcAlQBNAWcFLAAqACwASgDMACoALABNAedtbgyVAOeFJ0enCCcAygWMAKYBRwDaHvoEmgdKAGwAegDKAAIBDAFaAOwA2gOMABoGWghsADoA+gpPAkkDRQNJA+UARQJJA0UDKQBJACkASQCJAAkBhQAlAOUAZQFJA0UDSQCJAAkB6QBFA0kAiQCpACkA6QBFA0kDRQNJA0UDSQNFA0kDRQNJA0UDSQOFAykDOQAlAzkAxQApAzkAJQM5AMUAKQM5ACUDOQDFACkDOQAlAzkAxQApAzkAJQM5AMUAXgBNBocAZwNHACcAJwBHAYcAJwAnACcAJwAnACcAZwBHACcAJwAnACcAJwAnAEcAJwCHAOcAhwCHACcARwEnAmcApwAnAlkAmgWaDPoB2gH6AfoBbwH6A5oHegW6A3oFOgFaADoE2gDaCJoCugS6ADoC+gc6ANoWmgDaB5oAGgPaCHoB2giaDicAJwAnACcAJwAnAMdDIgACDAwePwA/AEHStgQLIL8F2QbgBuAG4AbgBuAG4AbgBuAG4AbgBuAG4AbjBuUGAEGCtwQL/CQgACEAJAAlACgAKQAqACsALAAtAC4AMAA6ADwAPwBBAFsAXABdAF4AXwBgAGEAewB8AH0AfgB/AKAAoQCiAKYApwCoAKkAqgCrAKwArQCuAK8AsACxALIAtAC1ALYAuAC5ALoAuwC8AL8AwADXANgA3wD3APgAAAE4ATkBSQFKAXkBfwGBAYMBhAGHAYoBjAGOAZIBkwGVAZYBmQGcAZ4BnwGhAaIBpwGrAawBrwGyAbQBtQG4AboBuwG8Ab4BwAHEAcUBxgHHAcgByQHKAcsBzAHNAd0B3gHwAfEB8gHzAfQB9wH5AfoBNAI6AjwCPQI/AkECRAJHAkgCUAKUApUCsALCAsYC0gLgAuUC7ALtAu4C7wIAA3ADdAN1A3YDegN7A34DhAOGA4cDiAOMA44DkAORA6MDrAPPA9ED0gPVA9gD8AP0A/YD9wP6A/wD/QMwBGAEggSDBIgEigTBBM8E0AQxBVkFWgVhBYkFigWPBZEFvgW/BcAFwQXDBcQFxgXHBdAF8AXzBQAGBgYJBgsGDAYOBhAGGwYeBiAGQAZBBksGYAZqBm4GcAZxBtQG1QbWBt0G3gbfBuUG5wbpBuoG7gbwBvoG/Qb/BgAHDwcQBxEHEgcwB00HpgexB8AHygfrB/QH9gf3B/oHAAgWCBoIGwgkCCUIKAgpCDAIQAhZCF4IoAiiCOQIAAkDCQQJOgk7CTwJPQk+CUEJSQlNCU4JUAlRCVgJYglkCWYJcAlxCXIJeQmBCYIJhQmPCZMJqgmyCbYJvAm9Cb4JwQnHCcsJzQnOCdcJ3AnfCeIJ5gnwCfIJ9An6CfsJAQoDCgUKDwoTCioKMgo1CjgKPAo+CkEKRwpLClEKWQpeCmYKcApyCnUKgQqDCoUKjwqTCqoKsgq1CrwKvQq+CsEKxwrJCssKzQrQCuAK4grmCvAK8QoBCwILBQsPCxMLKgsyCzULPAs9Cz4LPwtAC0ELRwtLC00LVgtXC1wLXwtiC2YLcAtxC3ILgguDC4ULjguSC5kLnAueC6MLqAuuC74LwAvBC8YLygvNC9AL1wvmC/AL8wv5C/oLAQwFDA4MEgwqDDUMPQw+DEEMRgxKDFUMWAxgDGIMZgx4DH8MggyFDI4MkgyqDLUMvAy9DL4MvwzADMYMxwzKDMwM1QzeDOAM4gzmDPEMAg0FDQ4NEg09DT4NQQ1GDUoNTQ1ODVcNYA1iDWYNcA15DXoNgg2FDZoNsw29DcANyg3PDdIN1g3YDfIN9A0BDjEOMg40Dj8OQA5GDkcOTw5QDloOgQ6EDocOig6NDpQOmQ6hDqUOpw6qDq0OsQ6yDrQOuw69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8okNCIdP7z+nBz2mhaN0PIek+9wYWO8/DyJAIJ6RgryYg8kW42DvP6ySwdVQWo48hTLbA+Zp7z9LawGsWTqEPGC0AfMhc+8/Hz60ByHVgrxfm3szl3zvP8kNRzu5Kom8KaH1FEaG7z/TiDpgBLZ0PPY/i+cukO8/cXKdUezFgzyDTMf7UZrvP/CR048S94+82pCkoq+k7z99dCPimK6NvPFnji1Ir+8/CCCqQbzDjjwnWmHuG7rvPzLrqcOUK4Q8l7prNyvF7z/uhdExqWSKPEBFblt20O8/7eM75Lo3jrwUvpyt/dvvP53NkU07iXc82JCegcHn7z+JzGBBwQVTPPFxjyvC8+8/Tm8gZXJyb3IgaW5mb3JtYXRpb24ASWxsZWdhbCBieXRlIHNlcXVlbmNlAERvbWFpbiBlcnJvcgBSZXN1bHQgbm90IHJlcHJlc2VudGFibGUATm90IGEgdHR5AFBlcm1pc3Npb24gZGVuaWVkAE9wZXJhdGlvbiBub3QgcGVybWl0dGVkAE5vIHN1Y2ggZmlsZSBvciBkaXJlY3RvcnkATm8gc3VjaCBwcm9jZXNzAEZpbGUgZXhpc3RzAFZhbHVlIHRvbyBsYXJnZSBmb3IgZGF0YSB0eXBlAE5vIHNwYWNlIGxlZnQgb24gZGV2aWNlAE91dCBvZiBtZW1vcnkAUmVzb3VyY2UgYnVzeQBJbnRlcnJ1cHRlZCBzeXN0ZW0gY2FsbABSZXNvdXJjZSB0ZW1wb3JhcmlseSB1bmF2YWlsYWJsZQBJbnZhbGlkIHNlZWsAQ3Jvc3MtZGV2aWNlIGxpbmsAUmVhZC1vbmx5IGZpbGUgc3lzdGVtAERpcmVjdG9yeSBub3QgZW1wdHkAQ29ubmVjdGlvbiByZXNldCBieSBwZWVyAE9wZXJhdGlvbiB0aW1lZCBvdXQAQ29ubmVjdGlvbiByZWZ1c2VkAEhvc3QgaXMgZG93bgBIb3N0IGlzIHVucmVhY2hhYmxlAEFkZHJlc3MgaW4gdXNlAEJyb2tlbiBwaXBlAEkvTyBlcnJvcgBObyBzdWNoIGRldmljZSBvciBhZGRyZXNzAEJsb2NrIGRldmljZSByZXF1aXJlZABObyBzdWNoIGRldmljZQBOb3QgYSBkaXJlY3RvcnkASXMgYSBkaXJlY3RvcnkAVGV4dCBmaWxlIGJ1c3kARXhlYyBmb3JtYXQgZXJyb3IASW52YWxpZCBhcmd1bWVudABBcmd1bWVudCBsaXN0IHRvbyBsb25nAFN5bWJvbGljIGxpbmsgbG9vcABGaWxlbmFtZSB0b28gbG9uZwBUb28gbWFueSBvcGVuIGZpbGVzIGluIHN5c3RlbQBObyBmaWxlIGRlc2NyaXB0b3JzIGF2YWlsYWJsZQBCYWQgZmlsZSBkZXNjcmlwdG9yAE5vIGNoaWxkIHByb2Nlc3MAQmFkIGFkZHJlc3MARmlsZSB0b28gbGFyZ2UAVG9vIG1hbnkgbGlua3MATm8gbG9ja3MgYXZhaWxhYmxlAFJlc291cmNlIGRlYWRsb2NrIHdvdWxkIG9jY3VyAFN0YXRlIG5vdCByZWNvdmVyYWJsZQBQcmV2aW91cyBvd25lciBkaWVkAE9wZXJhdGlvbiBjYW5jZWxlZABGdW5jdGlvbiBub3QgaW1wbGVtZW50ZWQATm8gbWVzc2FnZSBvZiBkZXNpcmVkIHR5cGUASWRlbnRpZmllciByZW1vdmVkAERldmljZSBub3QgYSBzdHJlYW0ATm8gZGF0YSBhdmFpbGFibGUARGV2aWNlIHRpbWVvdXQAT3V0IG9mIHN0cmVhbXMgcmVzb3VyY2VzAExpbmsgaGFzIGJlZW4gc2V2ZXJlZABQcm90b2NvbCBlcnJvcgBCYWQgbWVzc2FnZQBGaWxlIGRlc2NyaXB0b3IgaW4gYmFkIHN0YXRlAE5vdCBhIHNvY2tldABEZXN0aW5hdGlvbiBhZGRyZXNzIHJlcXVpcmVkAE1lc3NhZ2UgdG9vIGxhcmdlAFByb3RvY29sIHdyb25nIHR5cGUgZm9yIHNvY2tldABQcm90b2NvbCBub3QgYXZhaWxhYmxlAFByb3RvY29sIG5vdCBzdXBwb3J0ZWQAU29ja2V0IHR5cGUgbm90IHN1cHBvcnRlZABOb3Qgc3VwcG9ydGVkAFByb3RvY29sIGZhbWlseSBub3Qgc3VwcG9ydGVkAEFkZHJlc3MgZmFtaWx5IG5vdCBzdXBwb3J0ZWQgYnkgcHJvdG9jb2wAQWRkcmVzcyBub3QgYXZhaWxhYmxlAE5ldHdvcmsgaXMgZG93bgBOZXR3b3JrIHVucmVhY2hhYmxlAENvbm5lY3Rpb24gcmVzZXQg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";
var wasmBinary = base64ToArrayBuffer(sqliteWasmBase64);

// ../../../packages/sqlite-wasm-kysely/dist/util/createInMemoryDatabase.js
globalThis.sqlite3ApiConfig = {
  warn: (message, details) => {
    if (message === "Ignoring inability to install OPFS sqlite3_vfs:") {
      return;
    }
    console.log(message + " " + details);
  }
};
var sqlite3;
var createInMemoryDatabase = async ({ readOnly = false }) => {
  if (sqlite3 === void 0) {
    sqlite3 = await sqlite_wasm_default({
      // @ts-expect-error
      wasmBinary,
      // https://github.com/opral/inlang-sdk/issues/170#issuecomment-2334768193
      locateFile: () => "sqlite3.wasm"
    });
  }
  const flags = [
    readOnly ? "r" : "cw",
    // read and write
    ""
    // non verbose
  ].join("");
  const db = new sqlite3.oo1.DB(":memory:", flags);
  db.sqlite3 = sqlite3;
  return db;
};

// ../../../packages/sqlite-wasm-kysely/dist/util/importDatabase.js
init_define_ENV_DEFINED_IN_BUILD_STEP();
var importDatabase = ({ db, content, schema = "main", readOnly = false }) => {
  const deserializeFlag = readOnly ? db.sqlite3.capi.SQLITE_DESERIALIZE_READONLY : db.sqlite3.capi.SQLITE_DESERIALIZE_FREEONCLOSE | db.sqlite3.capi.SQLITE_DESERIALIZE_RESIZEABLE;
  const contentPointer = db.sqlite3.wasm.allocFromTypedArray(content);
  const deserializeReturnCode = db.sqlite3.capi.sqlite3_deserialize(
    db.pointer,
    schema,
    contentPointer,
    content.byteLength,
    // db size
    content.byteLength,
    // content size
    deserializeFlag
  );
  db.checkRc(deserializeReturnCode);
  return db;
};

// ../../../packages/sqlite-wasm-kysely/dist/util/loadDatabaseInMemory.js
init_define_ENV_DEFINED_IN_BUILD_STEP();

// ../../../packages/sqlite-wasm-kysely/dist/dialect.js
init_define_ENV_DEFINED_IN_BUILD_STEP();

// ../../../packages/sqlite-wasm-kysely/dist/kysely/SqliteWasmDriver.js
init_define_ENV_DEFINED_IN_BUILD_STEP();

// ../../../packages/sqlite-wasm-kysely/dist/kysely/ConnectionMutex.js
init_define_ENV_DEFINED_IN_BUILD_STEP();
var __classPrivateFieldGet = function(receiver, state, kind, f2) {
  if (kind === "a" && !f2)
    throw new TypeError("Private accessor was defined without a getter");
  if (typeof state === "function" ? receiver !== state || !f2 : !state.has(receiver))
    throw new TypeError("Cannot read private member from an object whose class did not declare it");
  return kind === "m" ? f2 : kind === "a" ? f2.call(receiver) : f2 ? f2.value : state.get(receiver);
};
var __classPrivateFieldSet = function(receiver, state, value, kind, f2) {
  if (kind === "m")
    throw new TypeError("Private method is not writable");
  if (kind === "a" && !f2)
    throw new TypeError("Private accessor was defined without a setter");
  if (typeof state === "function" ? receiver !== state || !f2 : !state.has(receiver))
    throw new TypeError("Cannot write private member to an object whose class did not declare it");
  return kind === "a" ? f2.call(receiver, value) : f2 ? f2.value = value : state.set(receiver, value), value;
};
var _ConnectionMutex_promise;
var _ConnectionMutex_resolve;
var ConnectionMutex = class {
  constructor() {
    _ConnectionMutex_promise.set(this, void 0);
    _ConnectionMutex_resolve.set(this, void 0);
  }
  async lock() {
    while (__classPrivateFieldGet(this, _ConnectionMutex_promise, "f")) {
      await __classPrivateFieldGet(this, _ConnectionMutex_promise, "f");
    }
    __classPrivateFieldSet(this, _ConnectionMutex_promise, new Promise((resolve2) => {
      __classPrivateFieldSet(this, _ConnectionMutex_resolve, resolve2, "f");
    }), "f");
  }
  unlock() {
    const resolve2 = __classPrivateFieldGet(this, _ConnectionMutex_resolve, "f");
    __classPrivateFieldSet(this, _ConnectionMutex_promise, void 0, "f");
    __classPrivateFieldSet(this, _ConnectionMutex_resolve, void 0, "f");
    resolve2 == null ? void 0 : resolve2();
  }
};
_ConnectionMutex_promise = /* @__PURE__ */ new WeakMap(), _ConnectionMutex_resolve = /* @__PURE__ */ new WeakMap();

// ../../../packages/sqlite-wasm-kysely/dist/kysely/SqliteWasmConnection.js
init_define_ENV_DEFINED_IN_BUILD_STEP();
var __classPrivateFieldSet2 = function(receiver, state, value, kind, f2) {
  if (kind === "m")
    throw new TypeError("Private method is not writable");
  if (kind === "a" && !f2)
    throw new TypeError("Private accessor was defined without a setter");
  if (typeof state === "function" ? receiver !== state || !f2 : !state.has(receiver))
    throw new TypeError("Cannot write private member to an object whose class did not declare it");
  return kind === "a" ? f2.call(receiver, value) : f2 ? f2.value = value : state.set(receiver, value), value;
};
var __classPrivateFieldGet2 = function(receiver, state, kind, f2) {
  if (kind === "a" && !f2)
    throw new TypeError("Private accessor was defined without a getter");
  if (typeof state === "function" ? receiver !== state || !f2 : !state.has(receiver))
    throw new TypeError("Cannot read private member from an object whose class did not declare it");
  return kind === "m" ? f2 : kind === "a" ? f2.call(receiver) : f2 ? f2.value : state.get(receiver);
};
var _SqliteWasmConnection_db;
var SqliteWasmConnection = class {
  constructor(db) {
    _SqliteWasmConnection_db.set(this, void 0);
    __classPrivateFieldSet2(this, _SqliteWasmConnection_db, db, "f");
  }
  executeQuery(compiledQuery) {
    const { sql: sql2, parameters } = compiledQuery;
    const statementData = {
      rows: [],
      columns: []
    };
    const totalChangesBefore = __classPrivateFieldGet2(this, _SqliteWasmConnection_db, "f").changes(true);
    const rows = __classPrivateFieldGet2(this, _SqliteWasmConnection_db, "f").exec({
      sql: sql2,
      bind: parameters,
      returnValue: "resultRows",
      rowMode: "object",
      columnNames: statementData.columns
    });
    const lastInsertId = __classPrivateFieldGet2(this, _SqliteWasmConnection_db, "f").sqlite3.capi.sqlite3_last_insert_rowid(__classPrivateFieldGet2(this, _SqliteWasmConnection_db, "f"));
    const changes = totalChangesBefore === __classPrivateFieldGet2(this, _SqliteWasmConnection_db, "f").changes(true) ? 0 : __classPrivateFieldGet2(this, _SqliteWasmConnection_db, "f").changes();
    return Promise.resolve({
      numAffectedRows: changes,
      insertId: lastInsertId,
      // queries with result
      rows
    });
  }
  // eslint-disable-next-line require-yield
  async *streamQuery() {
    throw new Error("not supported for wasm driver yet");
  }
};
_SqliteWasmConnection_db = /* @__PURE__ */ new WeakMap();

// ../../../packages/sqlite-wasm-kysely/dist/kysely/SqliteWasmDriver.js
var __classPrivateFieldSet3 = function(receiver, state, value, kind, f2) {
  if (kind === "m")
    throw new TypeError("Private method is not writable");
  if (kind === "a" && !f2)
    throw new TypeError("Private accessor was defined without a setter");
  if (typeof state === "function" ? receiver !== state || !f2 : !state.has(receiver))
    throw new TypeError("Cannot write private member to an object whose class did not declare it");
  return kind === "a" ? f2.call(receiver, value) : f2 ? f2.value = value : state.set(receiver, value), value;
};
var __classPrivateFieldGet3 = function(receiver, state, kind, f2) {
  if (kind === "a" && !f2)
    throw new TypeError("Private accessor was defined without a getter");
  if (typeof state === "function" ? receiver !== state || !f2 : !state.has(receiver))
    throw new TypeError("Cannot read private member from an object whose class did not declare it");
  return kind === "m" ? f2 : kind === "a" ? f2.call(receiver) : f2 ? f2.value : state.get(receiver);
};
var _SqliteWasmDriver_config;
var _SqliteWasmDriver_connectionMutex;
var _SqliteWasmDriver_db;
var _SqliteWasmDriver_connection;
var SqliteWasmDriver = class {
  constructor(config) {
    _SqliteWasmDriver_config.set(this, void 0);
    _SqliteWasmDriver_connectionMutex.set(this, new ConnectionMutex());
    _SqliteWasmDriver_db.set(this, void 0);
    _SqliteWasmDriver_connection.set(this, void 0);
    __classPrivateFieldSet3(this, _SqliteWasmDriver_config, { ...config }, "f");
  }
  async init() {
    __classPrivateFieldSet3(this, _SqliteWasmDriver_db, typeof __classPrivateFieldGet3(this, _SqliteWasmDriver_config, "f").database === "function" ? await __classPrivateFieldGet3(this, _SqliteWasmDriver_config, "f").database() : __classPrivateFieldGet3(this, _SqliteWasmDriver_config, "f").database, "f");
    __classPrivateFieldSet3(this, _SqliteWasmDriver_connection, new SqliteWasmConnection(__classPrivateFieldGet3(this, _SqliteWasmDriver_db, "f")), "f");
    if (__classPrivateFieldGet3(this, _SqliteWasmDriver_config, "f").onCreateConnection) {
      await __classPrivateFieldGet3(this, _SqliteWasmDriver_config, "f").onCreateConnection(__classPrivateFieldGet3(this, _SqliteWasmDriver_connection, "f"));
    }
  }
  async acquireConnection() {
    await __classPrivateFieldGet3(this, _SqliteWasmDriver_connectionMutex, "f").lock();
    return __classPrivateFieldGet3(this, _SqliteWasmDriver_connection, "f");
  }
  async beginTransaction(connection) {
    await connection.executeQuery(CompiledQuery.raw("begin"));
  }
  async commitTransaction(connection) {
    await connection.executeQuery(CompiledQuery.raw("commit"));
  }
  async rollbackTransaction(connection) {
    await connection.executeQuery(CompiledQuery.raw("rollback"));
  }
  async releaseConnection() {
    __classPrivateFieldGet3(this, _SqliteWasmDriver_connectionMutex, "f").unlock();
  }
  async destroy() {
    var _a8;
    (_a8 = __classPrivateFieldGet3(this, _SqliteWasmDriver_db, "f")) == null ? void 0 : _a8.close();
  }
};
_SqliteWasmDriver_config = /* @__PURE__ */ new WeakMap(), _SqliteWasmDriver_connectionMutex = /* @__PURE__ */ new WeakMap(), _SqliteWasmDriver_db = /* @__PURE__ */ new WeakMap(), _SqliteWasmDriver_connection = /* @__PURE__ */ new WeakMap();

// ../../../packages/sqlite-wasm-kysely/dist/dialect.js
var createDialect = (args) => {
  return {
    createAdapter: () => new SqliteAdapter(),
    createDriver: () => new SqliteWasmDriver({
      database: args.database
    }),
    createIntrospector: (db) => new SqliteIntrospector(db),
    createQueryCompiler: () => new SqliteQueryCompiler()
  };
};

// ../../../packages/lix-sdk/dist/database/init-db.js
init_define_ENV_DEFINED_IN_BUILD_STEP();

// ../../../node_modules/.pnpm/uuid@10.0.0/node_modules/uuid/dist/esm-node/index.js
init_define_ENV_DEFINED_IN_BUILD_STEP();

// ../../../node_modules/.pnpm/uuid@10.0.0/node_modules/uuid/dist/esm-node/stringify.js
init_define_ENV_DEFINED_IN_BUILD_STEP();
var byteToHex = [];
for (let i2 = 0; i2 < 256; ++i2) {
  byteToHex.push((i2 + 256).toString(16).slice(1));
}
function unsafeStringify(arr, offset = 0) {
  return (byteToHex[arr[offset + 0]] + byteToHex[arr[offset + 1]] + byteToHex[arr[offset + 2]] + byteToHex[arr[offset + 3]] + "-" + byteToHex[arr[offset + 4]] + byteToHex[arr[offset + 5]] + "-" + byteToHex[arr[offset + 6]] + byteToHex[arr[offset + 7]] + "-" + byteToHex[arr[offset + 8]] + byteToHex[arr[offset + 9]] + "-" + byteToHex[arr[offset + 10]] + byteToHex[arr[offset + 11]] + byteToHex[arr[offset + 12]] + byteToHex[arr[offset + 13]] + byteToHex[arr[offset + 14]] + byteToHex[arr[offset + 15]]).toLowerCase();
}

// ../../../node_modules/.pnpm/uuid@10.0.0/node_modules/uuid/dist/esm-node/rng.js
init_define_ENV_DEFINED_IN_BUILD_STEP();
import crypto2 from "node:crypto";
var rnds8Pool = new Uint8Array(256);
var poolPtr = rnds8Pool.length;
function rng() {
  if (poolPtr > rnds8Pool.length - 16) {
    crypto2.randomFillSync(rnds8Pool);
    poolPtr = 0;
  }
  return rnds8Pool.slice(poolPtr, poolPtr += 16);
}

// ../../../node_modules/.pnpm/uuid@10.0.0/node_modules/uuid/dist/esm-node/v4.js
init_define_ENV_DEFINED_IN_BUILD_STEP();

// ../../../node_modules/.pnpm/uuid@10.0.0/node_modules/uuid/dist/esm-node/native.js
init_define_ENV_DEFINED_IN_BUILD_STEP();
import crypto3 from "node:crypto";
var native_default = {
  randomUUID: crypto3.randomUUID
};

// ../../../node_modules/.pnpm/uuid@10.0.0/node_modules/uuid/dist/esm-node/v4.js
function v4(options, buf, offset) {
  if (native_default.randomUUID && !buf && !options) {
    return native_default.randomUUID();
  }
  options = options || {};
  const rnds = options.random || (options.rng || rng)();
  rnds[6] = rnds[6] & 15 | 64;
  rnds[8] = rnds[8] & 63 | 128;
  if (buf) {
    offset = offset || 0;
    for (let i2 = 0; i2 < 16; ++i2) {
      buf[offset + i2] = rnds[i2];
    }
    return buf;
  }
  return unsafeStringify(rnds);
}
var v4_default = v4;

// ../../../node_modules/.pnpm/uuid@10.0.0/node_modules/uuid/dist/esm-node/v7.js
init_define_ENV_DEFINED_IN_BUILD_STEP();
var _seqLow = null;
var _seqHigh = null;
var _msecs = 0;
function v7(options, buf, offset) {
  options = options || {};
  let i2 = buf && offset || 0;
  const b = buf || new Uint8Array(16);
  const rnds = options.random || (options.rng || rng)();
  const msecs = options.msecs !== void 0 ? options.msecs : Date.now();
  let seq = options.seq !== void 0 ? options.seq : null;
  let seqHigh = _seqHigh;
  let seqLow = _seqLow;
  if (msecs > _msecs && options.msecs === void 0) {
    _msecs = msecs;
    if (seq !== null) {
      seqHigh = null;
      seqLow = null;
    }
  }
  if (seq !== null) {
    if (seq > 2147483647) {
      seq = 2147483647;
    }
    seqHigh = seq >>> 19 & 4095;
    seqLow = seq & 524287;
  }
  if (seqHigh === null || seqLow === null) {
    seqHigh = rnds[6] & 127;
    seqHigh = seqHigh << 8 | rnds[7];
    seqLow = rnds[8] & 63;
    seqLow = seqLow << 8 | rnds[9];
    seqLow = seqLow << 5 | rnds[10] >>> 3;
  }
  if (msecs + 1e4 > _msecs && seq === null) {
    if (++seqLow > 524287) {
      seqLow = 0;
      if (++seqHigh > 4095) {
        seqHigh = 0;
        _msecs++;
      }
    }
  } else {
    _msecs = msecs;
  }
  _seqHigh = seqHigh;
  _seqLow = seqLow;
  b[i2++] = _msecs / 1099511627776 & 255;
  b[i2++] = _msecs / 4294967296 & 255;
  b[i2++] = _msecs / 16777216 & 255;
  b[i2++] = _msecs / 65536 & 255;
  b[i2++] = _msecs / 256 & 255;
  b[i2++] = _msecs & 255;
  b[i2++] = seqHigh >>> 4 & 15 | 112;
  b[i2++] = seqHigh & 255;
  b[i2++] = seqLow >>> 13 & 63 | 128;
  b[i2++] = seqLow >>> 5 & 255;
  b[i2++] = seqLow << 3 & 255 | rnds[10] & 7;
  b[i2++] = rnds[11];
  b[i2++] = rnds[12];
  b[i2++] = rnds[13];
  b[i2++] = rnds[14];
  b[i2++] = rnds[15];
  return buf || unsafeStringify(b);
}
var v7_default = v7;

// ../../../packages/lix-sdk/dist/database/apply-schema.js
init_define_ENV_DEFINED_IN_BUILD_STEP();

// ../../../packages/lix-sdk/dist/version/database-schema.js
init_define_ENV_DEFINED_IN_BUILD_STEP();

// ../../../packages/lix-sdk/dist/query-filter/change-set-has-label.js
init_define_ENV_DEFINED_IN_BUILD_STEP();
function changeSetHasLabel(label) {
  return (eb) => eb("change_set.id", "in", (subquery) => subquery.selectFrom("change_set_label").innerJoin("label", "label.id", "change_set_label.label_id").select("change_set_label.change_set_id").$if("name" in label, (eb2) => eb2.where("label.name", "=", label.name)).$if("id" in label, (eb2) => eb2.where("label.id", "=", label.id)));
}

// ../../../packages/lix-sdk/dist/version/database-schema.js
function applyVersionV2DatabaseSchema(sqlite2, db) {
  sqlite2.createFunction({
    name: "handle_update_working_change_set",
    arity: -1,
    // @ts-expect-error - sqlite wasm type mismatch
    xFunc: (_ctx, id, change_set_id, working_change_set_id) => handleUpdateWorkingChangeSet({
      db,
      sqlite: sqlite2,
      id,
      change_set_id,
      working_change_set_id
    })
  });
  const mainVersionId = "019328cc-ccb0-7f51-96e8-524df4597ac6";
  const workingChangeSetId = "h2h09ha92jfaw2";
  const initialChangeSetId = "2j9jm90ajc9j90";
  const sql2 = `
  CREATE TABLE IF NOT EXISTS version (
    id TEXT PRIMARY KEY DEFAULT (uuid_v7()),
    name TEXT UNIQUE DEFAULT (human_id()),
    change_set_id TEXT NOT NULL,
    working_change_set_id TEXT NOT NULL UNIQUE,

    FOREIGN KEY(change_set_id) REFERENCES change_set(id) ON DELETE CASCADE,
    FOREIGN KEY(working_change_set_id) REFERENCES change_set(id) ON DELETE CASCADE
  ) STRICT;

  -- only one version can be active at a time
  -- hence, the table has only one row
  CREATE TABLE IF NOT EXISTS active_version (
    version_id TEXT NOT NULL PRIMARY KEY,

    FOREIGN KEY(version_id) REFERENCES version(id)
  ) STRICT;

  -- Insert the default change set if missing
  -- (this is a workaround for not having a separate creation and migration schema's)
  INSERT INTO change_set (id, immutable_elements)
  SELECT '${initialChangeSetId}', 1
  WHERE NOT EXISTS (SELECT 1 FROM change_set WHERE id = '${initialChangeSetId}');

  -- Insert the default working change set if missing
  -- (this is a workaround for not having a separate creation and migration schema's)
  INSERT INTO change_set (id, immutable_elements)
  SELECT '${workingChangeSetId}', 0
  WHERE NOT EXISTS (SELECT 1 FROM change_set WHERE id = '${workingChangeSetId}');

  -- Insert the default version if missing
  -- (this is a workaround for not having a separate creation and migration schema's)
  INSERT INTO version (id, name, change_set_id, working_change_set_id)
  SELECT '${mainVersionId}', 'main', '${initialChangeSetId}', '${workingChangeSetId}'
  WHERE NOT EXISTS (SELECT 1 FROM version);

  -- Set the default current version to 'main' if both tables are empty
  -- (this is a workaround for not having a separata creation and migration schema's)
  INSERT INTO active_version (version_id)
  SELECT '${mainVersionId}'
  WHERE NOT EXISTS (SELECT 1 FROM active_version);

  CREATE TRIGGER IF NOT EXISTS update_working_change_set 
  AFTER UPDATE OF change_set_id ON version
  FOR EACH ROW
  WHEN OLD.change_set_id != NEW.change_set_id
  AND NOT EXISTS (SELECT 1 FROM key_value WHERE key = 'lix_skip_update_working_change_set')
  BEGIN
    SELECT handle_update_working_change_set(NEW.id, NEW.change_set_id, NEW.working_change_set_id);
  END;

  CREATE TRIGGER IF NOT EXISTS prevent_immutable_working_change_set
  BEFORE UPDATE OF immutable_elements ON change_set
  FOR EACH ROW
  WHEN NEW.immutable_elements = 1 AND OLD.immutable_elements = 0 AND EXISTS (SELECT 1 FROM version WHERE working_change_set_id = NEW.id)
  BEGIN
      SELECT RAISE(FAIL, 'Cannot set immutable_elements to true for working change sets.');
  END;
`;
  return sqlite2.exec(sql2);
}
function handleUpdateWorkingChangeSet(args) {
  const newElements = executeSync({
    lix: { sqlite: args.sqlite },
    query: args.db.selectFrom("change_set_element").where("change_set_element.change_set_id", "=", args.change_set_id).selectAll()
  });
  for (const element of newElements) {
    const [change] = executeSync({
      lix: { sqlite: args.sqlite },
      query: args.db.selectFrom("change").where("id", "=", element.change_id).select(["snapshot_id", "id"])
    });
    if (change.snapshot_id === "no-content") {
      const [lastCheckpoint] = executeSync({
        lix: { sqlite: args.sqlite },
        query: args.db.selectFrom("change_set").where(changeSetIsAncestorOf({ id: args.change_set_id })).where(changeSetHasLabel({ name: "checkpoint" })).limit(1).select("change_set.id")
      });
      const [existing] = lastCheckpoint ? executeSync({
        lix: { sqlite: args.sqlite },
        query: args.db.selectFrom("change_set_element").innerJoin("change", "change.id", "change_set_element.change_id").innerJoin("change_set", "change_set.id", "change_set_element.change_set_id").where(changeSetIsAncestorOf({ id: lastCheckpoint.id }, { includeSelf: true })).where("change.entity_id", "=", element.entity_id).where("change.file_id", "=", element.file_id).where("change.schema_key", "=", element.schema_key).where("change.snapshot_id", "!=", "no-content").limit(1).select(["change.snapshot_id", "change.id"])
      }) : [];
      if (!existing) {
        executeSync({
          lix: { sqlite: args.sqlite },
          query: args.db.deleteFrom("change_set_element").where("change_set_element.entity_id", "=", element.entity_id).where("change_set_element.file_id", "=", element.file_id).where("change_set_element.schema_key", "=", element.schema_key).where("change_set_element.change_set_id", "=", args.working_change_set_id)
        });
        return true;
      }
    }
    executeSync({
      lix: { sqlite: args.sqlite },
      query: args.db.insertInto("change_set_element").values({
        ...element,
        change_set_id: args.working_change_set_id
      }).onConflict((oc) => oc.doUpdateSet((eb) => ({
        change_id: eb.ref("excluded.change_id")
      })))
    });
  }
  return true;
}

// ../../../packages/lix-sdk/dist/snapshot/database-schema.js
init_define_ENV_DEFINED_IN_BUILD_STEP();

// ../../../packages/lix-sdk/dist/snapshot/json-sha-256.js
init_define_ENV_DEFINED_IN_BUILD_STEP();
var import_js_sha256 = __toESM(require_sha256(), 1);
function jsonSha256(content) {
  const sortedContent = deepSortObject(content);
  return (0, import_js_sha256.sha256)(JSON.stringify(sortedContent));
}
function deepSortObject(obj) {
  if (Array.isArray(obj)) {
    return obj.map((item) => typeof item === "object" && item !== null ? deepSortObject(item) : item);
  } else if (typeof obj === "object" && obj !== null) {
    return Object.keys(obj).sort().reduce((acc, key) => {
      acc[key] = deepSortObject(obj[key]);
      return acc;
    }, {});
  }
  return obj;
}

// ../../../packages/lix-sdk/dist/snapshot/database-schema.js
function applySnapshotDatabaseSchema(sqlite2) {
  sqlite2.createFunction({
    name: "json_sha256",
    arity: 1,
    xFunc: (_ctx, value) => {
      if (!value) {
        return "no-content";
      }
      const json = sqlite2.exec("SELECT json(?)", {
        bind: [value],
        returnValue: "resultRows"
      })[0][0];
      const parsed = JSON.parse(json);
      return jsonSha256(parsed);
    },
    deterministic: true
  });
  sqlite2.exec(`
  CREATE TABLE IF NOT EXISTS snapshot (
    id TEXT GENERATED ALWAYS AS (json_sha256(content)) STORED UNIQUE,
    content BLOB
  ) STRICT;

  -- Create the default 'no-content' snapshot
  -- to avoid foreign key constraint violations in tests
  INSERT OR IGNORE INTO snapshot (content) VALUES (NULL);

  CREATE INDEX IF NOT EXISTS idx_content_hash ON snapshot (id);
`);
  return sqlite2;
}

// ../../../packages/lix-sdk/dist/own-change-control/database-triggers.js
init_define_ENV_DEFINED_IN_BUILD_STEP();
var LIX_OWN_CHANGE_CONTROL_CHANGE_SET_ID = "pending-own-change-control";
function applyOwnChangeControlTriggers(sqlite2, db) {
  const tableInfos = {};
  let isFlushing = false;
  for (const table of Object.keys(changeControlledTableIds)) {
    tableInfos[table] = sqlite2.exec({
      sql: `PRAGMA table_info(${table});`,
      returnValue: "resultRows",
      rowMode: "object"
    });
  }
  sqlite2.createFunction({
    name: "handle_lix_own_change_control",
    arity: -1,
    // @ts-expect-error - dynamic function
    xFunc: (_ctx, tableName, operation, ...value) => {
      return handleLixOwnChange(db, sqlite2, tableName, tableInfos, operation, ...value);
    }
  });
  for (const table of Object.keys(changeControlledTableIds)) {
    const tableInfo = tableInfos[table];
    const commonSkipCheck = `NOT (
			EXISTS (SELECT 1 FROM key_value WHERE key IN (
				'lix_skip_own_change_control',
				'lix_flushing_own_changes',
				'lix_skip_handle_own_change_trigger'
			))
		)`;
    let insertWhenClause = `WHEN ${commonSkipCheck}`;
    let updateWhenClause = `WHEN ${commonSkipCheck}`;
    const deleteWhenClause = `WHEN ${commonSkipCheck}`;
    if (table === "key_value") {
      insertWhenClause += ` AND NEW.skip_change_control IS NOT TRUE`;
      updateWhenClause += ` AND NEW.skip_change_control IS NOT TRUE`;
    }
    if (table === "file") {
      updateWhenClause += ` AND (
			  OLD.id IS NOT NEW.id OR
				OLD.path IS NOT NEW.path OR 
				OLD.metadata IS NOT NEW.metadata
			)`;
    }
    try {
      sqlite2.exec(`
					CREATE TEMP TRIGGER IF NOT EXISTS ${table}_change_control_insert
					AFTER INSERT ON ${table}
					${insertWhenClause}
					BEGIN
						SELECT handle_lix_own_change_control('${table}', 'insert', ${tableInfo.map((c3) => "NEW." + c3.name).join(", ")});
					END;

					CREATE TEMP TRIGGER IF NOT EXISTS ${table}_change_control_update
					AFTER UPDATE ON ${table}
					${updateWhenClause}
					BEGIN
						SELECT handle_lix_own_change_control('${table}', 'update', ${tableInfo.map((c3) => "NEW." + c3.name).join(", ")});
					END;

					CREATE TEMP TRIGGER IF NOT EXISTS ${table}_change_control_delete
					AFTER DELETE ON ${table}
					${deleteWhenClause}
					BEGIN
						SELECT handle_lix_own_change_control('${table}', 'delete', ${tableInfo.map((c3) => "OLD." + c3.name).join(", ")});
					END;
			`);
    } catch {
    }
  }
  sqlite2.exec(`
    CREATE TEMP TRIGGER IF NOT EXISTS flush_system_changes_before_version_update
    BEFORE UPDATE OF change_set_id ON version
    BEGIN
    	INSERT OR REPLACE INTO key_value (key, value, skip_change_control)
      VALUES ('lix_flushing_own_changes', jsonb(json_quote('true')), true);

      -- ensure new change_set exists and is mutable
			UPDATE change_set SET immutable_elements = false WHERE id = NEW.change_set_id;


      -- move pending elements
      INSERT INTO change_set_element (change_set_id, change_id, entity_id, file_id, schema_key)
      SELECT NEW.change_set_id, change_id, entity_id, file_id, schema_key
      FROM change_set_element
      WHERE change_set_id = '${LIX_OWN_CHANGE_CONTROL_CHANGE_SET_ID}';

      -- mark new change_set as immutable
      UPDATE change_set
      SET immutable_elements = true
      WHERE id = NEW.change_set_id;

      -- delete pending elements and pending change_set
      DELETE FROM change_set_element WHERE change_set_id = '${LIX_OWN_CHANGE_CONTROL_CHANGE_SET_ID}';
      DELETE FROM change_set WHERE id = '${LIX_OWN_CHANGE_CONTROL_CHANGE_SET_ID}';

      -- delete the flushing flag
      DELETE FROM key_value WHERE key = 'lix_flushing_own_changes';
    END;
  `);
  sqlite2.sqlite3.capi.sqlite3_commit_hook(sqlite2, () => {
    if (isFlushing)
      return 0;
    queueMicrotask(() => {
      isFlushing = true;
      try {
        const pending = sqlite2.exec(`SELECT 1 FROM change_set_element WHERE change_set_id = '${LIX_OWN_CHANGE_CONTROL_CHANGE_SET_ID}' LIMIT 1`, {
          returnValue: "resultRows"
        });
        if (pending.length === 0)
          return;
        sqlite2.exec(`
          INSERT OR REPLACE INTO key_value (key, value, skip_change_control)
          VALUES ('lix_flushing_own_changes', jsonb(json_quote('true')), true);

          INSERT INTO change_set (immutable_elements)
          VALUES (true);

          INSERT INTO change_set_edge (parent_id, child_id)
          SELECT change_set_id, (SELECT id FROM change_set ORDER BY rowid DESC LIMIT 1)
          FROM version
          WHERE id = (SELECT version_id FROM active_version)
          AND change_set_id IN (
            SELECT id FROM change_set WHERE immutable_elements = true
          );

          UPDATE version
          SET change_set_id = (SELECT id FROM change_set ORDER BY rowid DESC LIMIT 1)
          WHERE id = (SELECT version_id FROM active_version);

          DELETE FROM key_value WHERE key = 'lix_flushing_own_changes';
        `);
      } finally {
        isFlushing = false;
      }
    });
    return 0;
  }, 0);
}
function handleLixOwnChange(db, sqlite2, tableName, tableInfos, operation, ...values) {
  const lix = { db, sqlite: sqlite2 };
  if (tableName === "key_value" && values[2]) {
    return;
  }
  const entityId = entityIdForRow(tableName, ...values);
  const authors = executeSync({
    lix,
    query: db.selectFrom("active_account").selectAll()
  });
  if (authors.length === 0) {
    throw new Error("At least one author is required");
  }
  let snapshotContent;
  if (operation === "delete") {
    snapshotContent = null;
  } else {
    snapshotContent = {};
    for (const [index, column] of tableInfos[tableName].entries()) {
      snapshotContent[column.name] = values[index];
    }
  }
  if (tableName === "file" && snapshotContent) {
    const json = sqlite2.exec("SELECT json(?)", {
      bind: [snapshotContent.metadata],
      returnValue: "resultRows"
    })[0][0];
    snapshotContent["metadata"] = JSON.parse(json);
    delete snapshotContent.data;
  } else if (tableName === "thread_comment" && snapshotContent) {
    const json = sqlite2.exec("SELECT json(?)", {
      bind: [snapshotContent.body],
      returnValue: "resultRows"
    })[0][0];
    snapshotContent["body"] = JSON.parse(json);
  } else if (tableName === "key_value" && snapshotContent) {
    const json = sqlite2.exec("SELECT json(?)", {
      bind: [snapshotContent.value],
      returnValue: "resultRows"
    })[0][0];
    snapshotContent["value"] = JSON.parse(json);
  }
  executeSync({
    lix,
    query: db.insertInto("key_value").values({
      key: "lix_skip_handle_own_change_trigger",
      value: "true",
      skip_change_control: true
    })
  });
  const insertedChange = createChange({
    lix,
    authors,
    entityId,
    fileId: "lix_own_change_control",
    pluginKey: "lix_own_change_control",
    schemaKey: `lix_${tableName}_table`,
    snapshotContent
  });
  executeSync({
    lix,
    query: db.insertInto("change_set").values({
      id: LIX_OWN_CHANGE_CONTROL_CHANGE_SET_ID,
      immutable_elements: false
    }).onConflict((oc) => oc.doNothing())
  });
  executeSync({
    lix,
    query: db.insertInto("change_set_element").values([
      {
        change_set_id: LIX_OWN_CHANGE_CONTROL_CHANGE_SET_ID,
        change_id: insertedChange.id,
        entity_id: insertedChange.entity_id,
        file_id: insertedChange.file_id,
        schema_key: insertedChange.schema_key
      }
    ]).onConflict((oc) => oc.doUpdateSet((eb) => ({ change_id: eb.ref("excluded.change_id") })))
  });
  executeSync({
    lix,
    query: db.deleteFrom("key_value").where("key", "=", "lix_skip_handle_own_change_trigger")
  });
}

// ../../../packages/lix-sdk/dist/thread/database-schema.js
init_define_ENV_DEFINED_IN_BUILD_STEP();

// ../../../packages/zettel/zettel-ast/dist/index.js
init_define_ENV_DEFINED_IN_BUILD_STEP();

// ../../../packages/zettel/zettel-ast/dist/schema.js
init_define_ENV_DEFINED_IN_BUILD_STEP();

// ../../../node_modules/.pnpm/@sinclair+typebox@0.34.33/node_modules/@sinclair/typebox/build/esm/type/clone/type.mjs
init_define_ENV_DEFINED_IN_BUILD_STEP();

// ../../../node_modules/.pnpm/@sinclair+typebox@0.34.33/node_modules/@sinclair/typebox/build/esm/type/clone/value.mjs
init_define_ENV_DEFINED_IN_BUILD_STEP();

// ../../../node_modules/.pnpm/@sinclair+typebox@0.34.33/node_modules/@sinclair/typebox/build/esm/type/guard/value.mjs
var value_exports = {};
__export(value_exports, {
  HasPropertyKey: () => HasPropertyKey,
  IsArray: () => IsArray,
  IsAsyncIterator: () => IsAsyncIterator,
  IsBigInt: () => IsBigInt,
  IsBoolean: () => IsBoolean,
  IsDate: () => IsDate,
  IsFunction: () => IsFunction,
  IsIterator: () => IsIterator,
  IsNull: () => IsNull,
  IsNumber: () => IsNumber,
  IsObject: () => IsObject,
  IsRegExp: () => IsRegExp,
  IsString: () => IsString,
  IsSymbol: () => IsSymbol,
  IsUint8Array: () => IsUint8Array,
  IsUndefined: () => IsUndefined
});
init_define_ENV_DEFINED_IN_BUILD_STEP();
function HasPropertyKey(value, key) {
  return key in value;
}
function IsAsyncIterator(value) {
  return IsObject(value) && !IsArray(value) && !IsUint8Array(value) && Symbol.asyncIterator in value;
}
function IsArray(value) {
  return Array.isArray(value);
}
function IsBigInt(value) {
  return typeof value === "bigint";
}
function IsBoolean(value) {
  return typeof value === "boolean";
}
function IsDate(value) {
  return value instanceof globalThis.Date;
}
function IsFunction(value) {
  return typeof value === "function";
}
function IsIterator(value) {
  return IsObject(value) && !IsArray(value) && !IsUint8Array(value) && Symbol.iterator in value;
}
function IsNull(value) {
  return value === null;
}
function IsNumber(value) {
  return typeof value === "number";
}
function IsObject(value) {
  return typeof value === "object" && value !== null;
}
function IsRegExp(value) {
  return value instanceof globalThis.RegExp;
}
function IsString(value) {
  return typeof value === "string";
}
function IsSymbol(value) {
  return typeof value === "symbol";
}
function IsUint8Array(value) {
  return value instanceof globalThis.Uint8Array;
}
function IsUndefined(value) {
  return value === void 0;
}

// ../../../node_modules/.pnpm/@sinclair+typebox@0.34.33/node_modules/@sinclair/typebox/build/esm/type/clone/value.mjs
function ArrayType(value) {
  return value.map((value2) => Visit(value2));
}
function DateType(value) {
  return new Date(value.getTime());
}
function Uint8ArrayType(value) {
  return new Uint8Array(value);
}
function RegExpType(value) {
  return new RegExp(value.source, value.flags);
}
function ObjectType(value) {
  const result = {};
  for (const key of Object.getOwnPropertyNames(value)) {
    result[key] = Visit(value[key]);
  }
  for (const key of Object.getOwnPropertySymbols(value)) {
    result[key] = Visit(value[key]);
  }
  return result;
}
function Visit(value) {
  return IsArray(value) ? ArrayType(value) : IsDate(value) ? DateType(value) : IsUint8Array(value) ? Uint8ArrayType(value) : IsRegExp(value) ? RegExpType(value) : IsObject(value) ? ObjectType(value) : value;
}
function Clone(value) {
  return Visit(value);
}

// ../../../node_modules/.pnpm/@sinclair+typebox@0.34.33/node_modules/@sinclair/typebox/build/esm/type/clone/type.mjs
function CloneType(schema, options) {
  return options === void 0 ? Clone(schema) : Clone({ ...options, ...schema });
}

// ../../../node_modules/.pnpm/@sinclair+typebox@0.34.33/node_modules/@sinclair/typebox/build/esm/type/create/type.mjs
init_define_ENV_DEFINED_IN_BUILD_STEP();

// ../../../node_modules/.pnpm/@sinclair+typebox@0.34.33/node_modules/@sinclair/typebox/build/esm/system/policy.mjs
init_define_ENV_DEFINED_IN_BUILD_STEP();

// ../../../node_modules/.pnpm/@sinclair+typebox@0.34.33/node_modules/@sinclair/typebox/build/esm/value/guard/guard.mjs
init_define_ENV_DEFINED_IN_BUILD_STEP();
function IsAsyncIterator2(value) {
  return IsObject2(value) && globalThis.Symbol.asyncIterator in value;
}
function IsIterator2(value) {
  return IsObject2(value) && globalThis.Symbol.iterator in value;
}
function IsPromise(value) {
  return value instanceof globalThis.Promise;
}
function IsDate2(value) {
  return value instanceof Date && globalThis.Number.isFinite(value.getTime());
}
function IsUint8Array2(value) {
  return value instanceof globalThis.Uint8Array;
}
function HasPropertyKey2(value, key) {
  return key in value;
}
function IsObject2(value) {
  return value !== null && typeof value === "object";
}
function IsArray2(value) {
  return globalThis.Array.isArray(value) && !globalThis.ArrayBuffer.isView(value);
}
function IsUndefined2(value) {
  return value === void 0;
}
function IsNull2(value) {
  return value === null;
}
function IsBoolean2(value) {
  return typeof value === "boolean";
}
function IsNumber2(value) {
  return typeof value === "number";
}
function IsInteger(value) {
  return globalThis.Number.isInteger(value);
}
function IsBigInt2(value) {
  return typeof value === "bigint";
}
function IsString2(value) {
  return typeof value === "string";
}
function IsFunction2(value) {
  return typeof value === "function";
}
function IsSymbol2(value) {
  return typeof value === "symbol";
}
function IsValueType(value) {
  return IsBigInt2(value) || IsBoolean2(value) || IsNull2(value) || IsNumber2(value) || IsString2(value) || IsSymbol2(value) || IsUndefined2(value);
}

// ../../../node_modules/.pnpm/@sinclair+typebox@0.34.33/node_modules/@sinclair/typebox/build/esm/system/policy.mjs
var TypeSystemPolicy;
(function(TypeSystemPolicy2) {
  TypeSystemPolicy2.InstanceMode = "default";
  TypeSystemPolicy2.ExactOptionalPropertyTypes = false;
  TypeSystemPolicy2.AllowArrayObject = false;
  TypeSystemPolicy2.AllowNaN = false;
  TypeSystemPolicy2.AllowNullVoid = false;
  function IsExactOptionalProperty(value, key) {
    return TypeSystemPolicy2.ExactOptionalPropertyTypes ? key in value : value[key] !== void 0;
  }
  TypeSystemPolicy2.IsExactOptionalProperty = IsExactOptionalProperty;
  function IsObjectLike(value) {
    const isObject2 = IsObject2(value);
    return TypeSystemPolicy2.AllowArrayObject ? isObject2 : isObject2 && !IsArray2(value);
  }
  TypeSystemPolicy2.IsObjectLike = IsObjectLike;
  function IsRecordLike(value) {
    return IsObjectLike(value) && !(value instanceof Date) && !(value instanceof Uint8Array);
  }
  TypeSystemPolicy2.IsRecordLike = IsRecordLike;
  function IsNumberLike(value) {
    return TypeSystemPolicy2.AllowNaN ? IsNumber2(value) : Number.isFinite(value);
  }
  TypeSystemPolicy2.IsNumberLike = IsNumberLike;
  function IsVoidLike(value) {
    const isUndefined2 = IsUndefined2(value);
    return TypeSystemPolicy2.AllowNullVoid ? isUndefined2 || value === null : isUndefined2;
  }
  TypeSystemPolicy2.IsVoidLike = IsVoidLike;
})(TypeSystemPolicy || (TypeSystemPolicy = {}));

// ../../../node_modules/.pnpm/@sinclair+typebox@0.34.33/node_modules/@sinclair/typebox/build/esm/type/create/immutable.mjs
init_define_ENV_DEFINED_IN_BUILD_STEP();
function ImmutableArray(value) {
  return globalThis.Object.freeze(value).map((value2) => Immutable(value2));
}
function ImmutableDate(value) {
  return value;
}
function ImmutableUint8Array(value) {
  return value;
}
function ImmutableRegExp(value) {
  return value;
}
function ImmutableObject(value) {
  const result = {};
  for (const key of Object.getOwnPropertyNames(value)) {
    result[key] = Immutable(value[key]);
  }
  for (const key of Object.getOwnPropertySymbols(value)) {
    result[key] = Immutable(value[key]);
  }
  return globalThis.Object.freeze(result);
}
function Immutable(value) {
  return IsArray(value) ? ImmutableArray(value) : IsDate(value) ? ImmutableDate(value) : IsUint8Array(value) ? ImmutableUint8Array(value) : IsRegExp(value) ? ImmutableRegExp(value) : IsObject(value) ? ImmutableObject(value) : value;
}

// ../../../node_modules/.pnpm/@sinclair+typebox@0.34.33/node_modules/@sinclair/typebox/build/esm/type/create/type.mjs
function CreateType(schema, options) {
  const result = options !== void 0 ? { ...options, ...schema } : schema;
  switch (TypeSystemPolicy.InstanceMode) {
    case "freeze":
      return Immutable(result);
    case "clone":
      return Clone(result);
    default:
      return result;
  }
}

// ../../../node_modules/.pnpm/@sinclair+typebox@0.34.33/node_modules/@sinclair/typebox/build/esm/type/error/error.mjs
init_define_ENV_DEFINED_IN_BUILD_STEP();
var TypeBoxError = class extends Error {
  constructor(message) {
    super(message);
  }
};

// ../../../node_modules/.pnpm/@sinclair+typebox@0.34.33/node_modules/@sinclair/typebox/build/esm/type/guard/index.mjs
init_define_ENV_DEFINED_IN_BUILD_STEP();

// ../../../node_modules/.pnpm/@sinclair+typebox@0.34.33/node_modules/@sinclair/typebox/build/esm/type/guard/kind.mjs
init_define_ENV_DEFINED_IN_BUILD_STEP();

// ../../../node_modules/.pnpm/@sinclair+typebox@0.34.33/node_modules/@sinclair/typebox/build/esm/type/symbols/symbols.mjs
init_define_ENV_DEFINED_IN_BUILD_STEP();
var TransformKind = Symbol.for("TypeBox.Transform");
var ReadonlyKind = Symbol.for("TypeBox.Readonly");
var OptionalKind = Symbol.for("TypeBox.Optional");
var Hint = Symbol.for("TypeBox.Hint");
var Kind = Symbol.for("TypeBox.Kind");

// ../../../node_modules/.pnpm/@sinclair+typebox@0.34.33/node_modules/@sinclair/typebox/build/esm/type/guard/kind.mjs
function IsReadonly(value) {
  return IsObject(value) && value[ReadonlyKind] === "Readonly";
}
function IsOptional(value) {
  return IsObject(value) && value[OptionalKind] === "Optional";
}
function IsAny(value) {
  return IsKindOf(value, "Any");
}
function IsArgument(value) {
  return IsKindOf(value, "Argument");
}
function IsArray3(value) {
  return IsKindOf(value, "Array");
}
function IsAsyncIterator3(value) {
  return IsKindOf(value, "AsyncIterator");
}
function IsBigInt3(value) {
  return IsKindOf(value, "BigInt");
}
function IsBoolean3(value) {
  return IsKindOf(value, "Boolean");
}
function IsComputed(value) {
  return IsKindOf(value, "Computed");
}
function IsConstructor(value) {
  return IsKindOf(value, "Constructor");
}
function IsDate3(value) {
  return IsKindOf(value, "Date");
}
function IsFunction3(value) {
  return IsKindOf(value, "Function");
}
function IsInteger2(value) {
  return IsKindOf(value, "Integer");
}
function IsIntersect(value) {
  return IsKindOf(value, "Intersect");
}
function IsIterator3(value) {
  return IsKindOf(value, "Iterator");
}
function IsKindOf(value, kind) {
  return IsObject(value) && Kind in value && value[Kind] === kind;
}
function IsLiteralValue(value) {
  return IsBoolean(value) || IsNumber(value) || IsString(value);
}
function IsLiteral(value) {
  return IsKindOf(value, "Literal");
}
function IsMappedKey(value) {
  return IsKindOf(value, "MappedKey");
}
function IsMappedResult(value) {
  return IsKindOf(value, "MappedResult");
}
function IsNever(value) {
  return IsKindOf(value, "Never");
}
function IsNot(value) {
  return IsKindOf(value, "Not");
}
function IsNull3(value) {
  return IsKindOf(value, "Null");
}
function IsNumber3(value) {
  return IsKindOf(value, "Number");
}
function IsObject3(value) {
  return IsKindOf(value, "Object");
}
function IsPromise2(value) {
  return IsKindOf(value, "Promise");
}
function IsRecord(value) {
  return IsKindOf(value, "Record");
}
function IsRef(value) {
  return IsKindOf(value, "Ref");
}
function IsRegExp2(value) {
  return IsKindOf(value, "RegExp");
}
function IsString3(value) {
  return IsKindOf(value, "String");
}
function IsSymbol3(value) {
  return IsKindOf(value, "Symbol");
}
function IsTemplateLiteral(value) {
  return IsKindOf(value, "TemplateLiteral");
}
function IsThis(value) {
  return IsKindOf(value, "This");
}
function IsTransform(value) {
  return IsObject(value) && TransformKind in value;
}
function IsTuple(value) {
  return IsKindOf(value, "Tuple");
}
function IsUndefined3(value) {
  return IsKindOf(value, "Undefined");
}
function IsUnion(value) {
  return IsKindOf(value, "Union");
}
function IsUint8Array3(value) {
  return IsKindOf(value, "Uint8Array");
}
function IsUnknown(value) {
  return IsKindOf(value, "Unknown");
}
function IsUnsafe(value) {
  return IsKindOf(value, "Unsafe");
}
function IsVoid(value) {
  return IsKindOf(value, "Void");
}
function IsKind(value) {
  return IsObject(value) && Kind in value && IsString(value[Kind]);
}
function IsSchema(value) {
  return IsAny(value) || IsArgument(value) || IsArray3(value) || IsBoolean3(value) || IsBigInt3(value) || IsAsyncIterator3(value) || IsComputed(value) || IsConstructor(value) || IsDate3(value) || IsFunction3(value) || IsInteger2(value) || IsIntersect(value) || IsIterator3(value) || IsLiteral(value) || IsMappedKey(value) || IsMappedResult(value) || IsNever(value) || IsNot(value) || IsNull3(value) || IsNumber3(value) || IsObject3(value) || IsPromise2(value) || IsRecord(value) || IsRef(value) || IsRegExp2(value) || IsString3(value) || IsSymbol3(value) || IsTemplateLiteral(value) || IsThis(value) || IsTuple(value) || IsUndefined3(value) || IsUnion(value) || IsUint8Array3(value) || IsUnknown(value) || IsUnsafe(value) || IsVoid(value) || IsKind(value);
}

// ../../../node_modules/.pnpm/@sinclair+typebox@0.34.33/node_modules/@sinclair/typebox/build/esm/type/guard/type.mjs
var type_exports = {};
__export(type_exports, {
  IsAny: () => IsAny2,
  IsArgument: () => IsArgument2,
  IsArray: () => IsArray4,
  IsAsyncIterator: () => IsAsyncIterator4,
  IsBigInt: () => IsBigInt4,
  IsBoolean: () => IsBoolean4,
  IsComputed: () => IsComputed2,
  IsConstructor: () => IsConstructor2,
  IsDate: () => IsDate4,
  IsFunction: () => IsFunction4,
  IsImport: () => IsImport,
  IsInteger: () => IsInteger3,
  IsIntersect: () => IsIntersect2,
  IsIterator: () => IsIterator4,
  IsKind: () => IsKind2,
  IsKindOf: () => IsKindOf2,
  IsLiteral: () => IsLiteral2,
  IsLiteralBoolean: () => IsLiteralBoolean,
  IsLiteralNumber: () => IsLiteralNumber,
  IsLiteralString: () => IsLiteralString,
  IsLiteralValue: () => IsLiteralValue2,
  IsMappedKey: () => IsMappedKey2,
  IsMappedResult: () => IsMappedResult2,
  IsNever: () => IsNever2,
  IsNot: () => IsNot2,
  IsNull: () => IsNull4,
  IsNumber: () => IsNumber4,
  IsObject: () => IsObject4,
  IsOptional: () => IsOptional2,
  IsPromise: () => IsPromise3,
  IsProperties: () => IsProperties,
  IsReadonly: () => IsReadonly2,
  IsRecord: () => IsRecord2,
  IsRecursive: () => IsRecursive,
  IsRef: () => IsRef2,
  IsRegExp: () => IsRegExp3,
  IsSchema: () => IsSchema2,
  IsString: () => IsString4,
  IsSymbol: () => IsSymbol4,
  IsTemplateLiteral: () => IsTemplateLiteral2,
  IsThis: () => IsThis2,
  IsTransform: () => IsTransform2,
  IsTuple: () => IsTuple2,
  IsUint8Array: () => IsUint8Array4,
  IsUndefined: () => IsUndefined4,
  IsUnion: () => IsUnion2,
  IsUnionLiteral: () => IsUnionLiteral,
  IsUnknown: () => IsUnknown2,
  IsUnsafe: () => IsUnsafe2,
  IsVoid: () => IsVoid2,
  TypeGuardUnknownTypeError: () => TypeGuardUnknownTypeError
});
init_define_ENV_DEFINED_IN_BUILD_STEP();
var TypeGuardUnknownTypeError = class extends TypeBoxError {
};
var KnownTypes = [
  "Argument",
  "Any",
  "Array",
  "AsyncIterator",
  "BigInt",
  "Boolean",
  "Computed",
  "Constructor",
  "Date",
  "Enum",
  "Function",
  "Integer",
  "Intersect",
  "Iterator",
  "Literal",
  "MappedKey",
  "MappedResult",
  "Not",
  "Null",
  "Number",
  "Object",
  "Promise",
  "Record",
  "Ref",
  "RegExp",
  "String",
  "Symbol",
  "TemplateLiteral",
  "This",
  "Tuple",
  "Undefined",
  "Union",
  "Uint8Array",
  "Unknown",
  "Void"
];
function IsPattern(value) {
  try {
    new RegExp(value);
    return true;
  } catch {
    return false;
  }
}
function IsControlCharacterFree(value) {
  if (!IsString(value))
    return false;
  for (let i2 = 0; i2 < value.length; i2++) {
    const code = value.charCodeAt(i2);
    if (code >= 7 && code <= 13 || code === 27 || code === 127) {
      return false;
    }
  }
  return true;
}
function IsAdditionalProperties(value) {
  return IsOptionalBoolean(value) || IsSchema2(value);
}
function IsOptionalBigInt(value) {
  return IsUndefined(value) || IsBigInt(value);
}
function IsOptionalNumber(value) {
  return IsUndefined(value) || IsNumber(value);
}
function IsOptionalBoolean(value) {
  return IsUndefined(value) || IsBoolean(value);
}
function IsOptionalString(value) {
  return IsUndefined(value) || IsString(value);
}
function IsOptionalPattern(value) {
  return IsUndefined(value) || IsString(value) && IsControlCharacterFree(value) && IsPattern(value);
}
function IsOptionalFormat(value) {
  return IsUndefined(value) || IsString(value) && IsControlCharacterFree(value);
}
function IsOptionalSchema(value) {
  return IsUndefined(value) || IsSchema2(value);
}
function IsReadonly2(value) {
  return IsObject(value) && value[ReadonlyKind] === "Readonly";
}
function IsOptional2(value) {
  return IsObject(value) && value[OptionalKind] === "Optional";
}
function IsAny2(value) {
  return IsKindOf2(value, "Any") && IsOptionalString(value.$id);
}
function IsArgument2(value) {
  return IsKindOf2(value, "Argument") && IsNumber(value.index);
}
function IsArray4(value) {
  return IsKindOf2(value, "Array") && value.type === "array" && IsOptionalString(value.$id) && IsSchema2(value.items) && IsOptionalNumber(value.minItems) && IsOptionalNumber(value.maxItems) && IsOptionalBoolean(value.uniqueItems) && IsOptionalSchema(value.contains) && IsOptionalNumber(value.minContains) && IsOptionalNumber(value.maxContains);
}
function IsAsyncIterator4(value) {
  return IsKindOf2(value, "AsyncIterator") && value.type === "AsyncIterator" && IsOptionalString(value.$id) && IsSchema2(value.items);
}
function IsBigInt4(value) {
  return IsKindOf2(value, "BigInt") && value.type === "bigint" && IsOptionalString(value.$id) && IsOptionalBigInt(value.exclusiveMaximum) && IsOptionalBigInt(value.exclusiveMinimum) && IsOptionalBigInt(value.maximum) && IsOptionalBigInt(value.minimum) && IsOptionalBigInt(value.multipleOf);
}
function IsBoolean4(value) {
  return IsKindOf2(value, "Boolean") && value.type === "boolean" && IsOptionalString(value.$id);
}
function IsComputed2(value) {
  return IsKindOf2(value, "Computed") && IsString(value.target) && IsArray(value.parameters) && value.parameters.every((schema) => IsSchema2(schema));
}
function IsConstructor2(value) {
  return IsKindOf2(value, "Constructor") && value.type === "Constructor" && IsOptionalString(value.$id) && IsArray(value.parameters) && value.parameters.every((schema) => IsSchema2(schema)) && IsSchema2(value.returns);
}
function IsDate4(value) {
  return IsKindOf2(value, "Date") && value.type === "Date" && IsOptionalString(value.$id) && IsOptionalNumber(value.exclusiveMaximumTimestamp) && IsOptionalNumber(value.exclusiveMinimumTimestamp) && IsOptionalNumber(value.maximumTimestamp) && IsOptionalNumber(value.minimumTimestamp) && IsOptionalNumber(value.multipleOfTimestamp);
}
function IsFunction4(value) {
  return IsKindOf2(value, "Function") && value.type === "Function" && IsOptionalString(value.$id) && IsArray(value.parameters) && value.parameters.every((schema) => IsSchema2(schema)) && IsSchema2(value.returns);
}
function IsImport(value) {
  return IsKindOf2(value, "Import") && HasPropertyKey(value, "$defs") && IsObject(value.$defs) && IsProperties(value.$defs) && HasPropertyKey(value, "$ref") && IsString(value.$ref) && value.$ref in value.$defs;
}
function IsInteger3(value) {
  return IsKindOf2(value, "Integer") && value.type === "integer" && IsOptionalString(value.$id) && IsOptionalNumber(value.exclusiveMaximum) && IsOptionalNumber(value.exclusiveMinimum) && IsOptionalNumber(value.maximum) && IsOptionalNumber(value.minimum) && IsOptionalNumber(value.multipleOf);
}
function IsProperties(value) {
  return IsObject(value) && Object.entries(value).every(([key, schema]) => IsControlCharacterFree(key) && IsSchema2(schema));
}
function IsIntersect2(value) {
  return IsKindOf2(value, "Intersect") && (IsString(value.type) && value.type !== "object" ? false : true) && IsArray(value.allOf) && value.allOf.every((schema) => IsSchema2(schema) && !IsTransform2(schema)) && IsOptionalString(value.type) && (IsOptionalBoolean(value.unevaluatedProperties) || IsOptionalSchema(value.unevaluatedProperties)) && IsOptionalString(value.$id);
}
function IsIterator4(value) {
  return IsKindOf2(value, "Iterator") && value.type === "Iterator" && IsOptionalString(value.$id) && IsSchema2(value.items);
}
function IsKindOf2(value, kind) {
  return IsObject(value) && Kind in value && value[Kind] === kind;
}
function IsLiteralString(value) {
  return IsLiteral2(value) && IsString(value.const);
}
function IsLiteralNumber(value) {
  return IsLiteral2(value) && IsNumber(value.const);
}
function IsLiteralBoolean(value) {
  return IsLiteral2(value) && IsBoolean(value.const);
}
function IsLiteral2(value) {
  return IsKindOf2(value, "Literal") && IsOptionalString(value.$id) && IsLiteralValue2(value.const);
}
function IsLiteralValue2(value) {
  return IsBoolean(value) || IsNumber(value) || IsString(value);
}
function IsMappedKey2(value) {
  return IsKindOf2(value, "MappedKey") && IsArray(value.keys) && value.keys.every((key) => IsNumber(key) || IsString(key));
}
function IsMappedResult2(value) {
  return IsKindOf2(value, "MappedResult") && IsProperties(value.properties);
}
function IsNever2(value) {
  return IsKindOf2(value, "Never") && IsObject(value.not) && Object.getOwnPropertyNames(value.not).length === 0;
}
function IsNot2(value) {
  return IsKindOf2(value, "Not") && IsSchema2(value.not);
}
function IsNull4(value) {
  return IsKindOf2(value, "Null") && value.type === "null" && IsOptionalString(value.$id);
}
function IsNumber4(value) {
  return IsKindOf2(value, "Number") && value.type === "number" && IsOptionalString(value.$id) && IsOptionalNumber(value.exclusiveMaximum) && IsOptionalNumber(value.exclusiveMinimum) && IsOptionalNumber(value.maximum) && IsOptionalNumber(value.minimum) && IsOptionalNumber(value.multipleOf);
}
function IsObject4(value) {
  return IsKindOf2(value, "Object") && value.type === "object" && IsOptionalString(value.$id) && IsProperties(value.properties) && IsAdditionalProperties(value.additionalProperties) && IsOptionalNumber(value.minProperties) && IsOptionalNumber(value.maxProperties);
}
function IsPromise3(value) {
  return IsKindOf2(value, "Promise") && value.type === "Promise" && IsOptionalString(value.$id) && IsSchema2(value.item);
}
function IsRecord2(value) {
  return IsKindOf2(value, "Record") && value.type === "object" && IsOptionalString(value.$id) && IsAdditionalProperties(value.additionalProperties) && IsObject(value.patternProperties) && ((schema) => {
    const keys = Object.getOwnPropertyNames(schema.patternProperties);
    return keys.length === 1 && IsPattern(keys[0]) && IsObject(schema.patternProperties) && IsSchema2(schema.patternProperties[keys[0]]);
  })(value);
}
function IsRecursive(value) {
  return IsObject(value) && Hint in value && value[Hint] === "Recursive";
}
function IsRef2(value) {
  return IsKindOf2(value, "Ref") && IsOptionalString(value.$id) && IsString(value.$ref);
}
function IsRegExp3(value) {
  return IsKindOf2(value, "RegExp") && IsOptionalString(value.$id) && IsString(value.source) && IsString(value.flags) && IsOptionalNumber(value.maxLength) && IsOptionalNumber(value.minLength);
}
function IsString4(value) {
  return IsKindOf2(value, "String") && value.type === "string" && IsOptionalString(value.$id) && IsOptionalNumber(value.minLength) && IsOptionalNumber(value.maxLength) && IsOptionalPattern(value.pattern) && IsOptionalFormat(value.format);
}
function IsSymbol4(value) {
  return IsKindOf2(value, "Symbol") && value.type === "symbol" && IsOptionalString(value.$id);
}
function IsTemplateLiteral2(value) {
  return IsKindOf2(value, "TemplateLiteral") && value.type === "string" && IsString(value.pattern) && value.pattern[0] === "^" && value.pattern[value.pattern.length - 1] === "$";
}
function IsThis2(value) {
  return IsKindOf2(value, "This") && IsOptionalString(value.$id) && IsString(value.$ref);
}
function IsTransform2(value) {
  return IsObject(value) && TransformKind in value;
}
function IsTuple2(value) {
  return IsKindOf2(value, "Tuple") && value.type === "array" && IsOptionalString(value.$id) && IsNumber(value.minItems) && IsNumber(value.maxItems) && value.minItems === value.maxItems && // empty
  (IsUndefined(value.items) && IsUndefined(value.additionalItems) && value.minItems === 0 || IsArray(value.items) && value.items.every((schema) => IsSchema2(schema)));
}
function IsUndefined4(value) {
  return IsKindOf2(value, "Undefined") && value.type === "undefined" && IsOptionalString(value.$id);
}
function IsUnionLiteral(value) {
  return IsUnion2(value) && value.anyOf.every((schema) => IsLiteralString(schema) || IsLiteralNumber(schema));
}
function IsUnion2(value) {
  return IsKindOf2(value, "Union") && IsOptionalString(value.$id) && IsObject(value) && IsArray(value.anyOf) && value.anyOf.every((schema) => IsSchema2(schema));
}
function IsUint8Array4(value) {
  return IsKindOf2(value, "Uint8Array") && value.type === "Uint8Array" && IsOptionalString(value.$id) && IsOptionalNumber(value.minByteLength) && IsOptionalNumber(value.maxByteLength);
}
function IsUnknown2(value) {
  return IsKindOf2(value, "Unknown") && IsOptionalString(value.$id);
}
function IsUnsafe2(value) {
  return IsKindOf2(value, "Unsafe");
}
function IsVoid2(value) {
  return IsKindOf2(value, "Void") && value.type === "void" && IsOptionalString(value.$id);
}
function IsKind2(value) {
  return IsObject(value) && Kind in value && IsString(value[Kind]) && !KnownTypes.includes(value[Kind]);
}
function IsSchema2(value) {
  return IsObject(value) && (IsAny2(value) || IsArgument2(value) || IsArray4(value) || IsBoolean4(value) || IsBigInt4(value) || IsAsyncIterator4(value) || IsComputed2(value) || IsConstructor2(value) || IsDate4(value) || IsFunction4(value) || IsInteger3(value) || IsIntersect2(value) || IsIterator4(value) || IsLiteral2(value) || IsMappedKey2(value) || IsMappedResult2(value) || IsNever2(value) || IsNot2(value) || IsNull4(value) || IsNumber4(value) || IsObject4(value) || IsPromise3(value) || IsRecord2(value) || IsRef2(value) || IsRegExp3(value) || IsString4(value) || IsSymbol4(value) || IsTemplateLiteral2(value) || IsThis2(value) || IsTuple2(value) || IsUndefined4(value) || IsUnion2(value) || IsUint8Array4(value) || IsUnknown2(value) || IsUnsafe2(value) || IsVoid2(value) || IsKind2(value));
}

// ../../../node_modules/.pnpm/@sinclair+typebox@0.34.33/node_modules/@sinclair/typebox/build/esm/type/patterns/patterns.mjs
init_define_ENV_DEFINED_IN_BUILD_STEP();
var PatternBoolean = "(true|false)";
var PatternNumber = "(0|[1-9][0-9]*)";
var PatternString = "(.*)";
var PatternNever = "(?!.*)";
var PatternBooleanExact = `^${PatternBoolean}$`;
var PatternNumberExact = `^${PatternNumber}$`;
var PatternStringExact = `^${PatternString}$`;
var PatternNeverExact = `^${PatternNever}$`;

// ../../../node_modules/.pnpm/@sinclair+typebox@0.34.33/node_modules/@sinclair/typebox/build/esm/type/registry/index.mjs
init_define_ENV_DEFINED_IN_BUILD_STEP();

// ../../../node_modules/.pnpm/@sinclair+typebox@0.34.33/node_modules/@sinclair/typebox/build/esm/type/registry/format.mjs
var format_exports = {};
__export(format_exports, {
  Clear: () => Clear,
  Delete: () => Delete,
  Entries: () => Entries,
  Get: () => Get,
  Has: () => Has,
  Set: () => Set2
});
init_define_ENV_DEFINED_IN_BUILD_STEP();
var map = /* @__PURE__ */ new Map();
function Entries() {
  return new Map(map);
}
function Clear() {
  return map.clear();
}
function Delete(format) {
  return map.delete(format);
}
function Has(format) {
  return map.has(format);
}
function Set2(format, func) {
  map.set(format, func);
}
function Get(format) {
  return map.get(format);
}

// ../../../node_modules/.pnpm/@sinclair+typebox@0.34.33/node_modules/@sinclair/typebox/build/esm/type/registry/type.mjs
var type_exports2 = {};
__export(type_exports2, {
  Clear: () => Clear2,
  Delete: () => Delete2,
  Entries: () => Entries2,
  Get: () => Get2,
  Has: () => Has2,
  Set: () => Set3
});
init_define_ENV_DEFINED_IN_BUILD_STEP();
var map2 = /* @__PURE__ */ new Map();
function Entries2() {
  return new Map(map2);
}
function Clear2() {
  return map2.clear();
}
function Delete2(kind) {
  return map2.delete(kind);
}
function Has2(kind) {
  return map2.has(kind);
}
function Set3(kind, func) {
  map2.set(kind, func);
}
function Get2(kind) {
  return map2.get(kind);
}

// ../../../node_modules/.pnpm/@sinclair+typebox@0.34.33/node_modules/@sinclair/typebox/build/esm/type/sets/set.mjs
init_define_ENV_DEFINED_IN_BUILD_STEP();
function SetIncludes(T3, S3) {
  return T3.includes(S3);
}
function SetDistinct(T3) {
  return [...new Set(T3)];
}
function SetIntersect(T3, S3) {
  return T3.filter((L3) => S3.includes(L3));
}
function SetIntersectManyResolve(T3, Init) {
  return T3.reduce((Acc, L3) => {
    return SetIntersect(Acc, L3);
  }, Init);
}
function SetIntersectMany(T3) {
  return T3.length === 1 ? T3[0] : T3.length > 1 ? SetIntersectManyResolve(T3.slice(1), T3[0]) : [];
}
function SetUnionMany(T3) {
  const Acc = [];
  for (const L3 of T3)
    Acc.push(...L3);
  return Acc;
}

// ../../../node_modules/.pnpm/@sinclair+typebox@0.34.33/node_modules/@sinclair/typebox/build/esm/type/any/any.mjs
init_define_ENV_DEFINED_IN_BUILD_STEP();
function Any(options) {
  return CreateType({ [Kind]: "Any" }, options);
}

// ../../../node_modules/.pnpm/@sinclair+typebox@0.34.33/node_modules/@sinclair/typebox/build/esm/type/array/array.mjs
init_define_ENV_DEFINED_IN_BUILD_STEP();
function Array2(items, options) {
  return CreateType({ [Kind]: "Array", type: "array", items }, options);
}

// ../../../node_modules/.pnpm/@sinclair+typebox@0.34.33/node_modules/@sinclair/typebox/build/esm/type/argument/argument.mjs
init_define_ENV_DEFINED_IN_BUILD_STEP();
function Argument2(index) {
  return CreateType({ [Kind]: "Argument", index });
}

// ../../../node_modules/.pnpm/@sinclair+typebox@0.34.33/node_modules/@sinclair/typebox/build/esm/type/async-iterator/async-iterator.mjs
init_define_ENV_DEFINED_IN_BUILD_STEP();
function AsyncIterator(items, options) {
  return CreateType({ [Kind]: "AsyncIterator", type: "AsyncIterator", items }, options);
}

// ../../../node_modules/.pnpm/@sinclair+typebox@0.34.33/node_modules/@sinclair/typebox/build/esm/type/awaited/awaited.mjs
init_define_ENV_DEFINED_IN_BUILD_STEP();

// ../../../node_modules/.pnpm/@sinclair+typebox@0.34.33/node_modules/@sinclair/typebox/build/esm/type/computed/computed.mjs
init_define_ENV_DEFINED_IN_BUILD_STEP();
function Computed(target, parameters, options) {
  return CreateType({ [Kind]: "Computed", target, parameters }, options);
}

// ../../../node_modules/.pnpm/@sinclair+typebox@0.34.33/node_modules/@sinclair/typebox/build/esm/type/intersect/intersect-evaluated.mjs
init_define_ENV_DEFINED_IN_BUILD_STEP();

// ../../../node_modules/.pnpm/@sinclair+typebox@0.34.33/node_modules/@sinclair/typebox/build/esm/type/discard/discard.mjs
init_define_ENV_DEFINED_IN_BUILD_STEP();
function DiscardKey(value, key) {
  const { [key]: _3, ...rest } = value;
  return rest;
}
function Discard(value, keys) {
  return keys.reduce((acc, key) => DiscardKey(acc, key), value);
}

// ../../../node_modules/.pnpm/@sinclair+typebox@0.34.33/node_modules/@sinclair/typebox/build/esm/type/never/never.mjs
init_define_ENV_DEFINED_IN_BUILD_STEP();
function Never(options) {
  return CreateType({ [Kind]: "Never", not: {} }, options);
}

// ../../../node_modules/.pnpm/@sinclair+typebox@0.34.33/node_modules/@sinclair/typebox/build/esm/type/optional/optional-from-mapped-result.mjs
init_define_ENV_DEFINED_IN_BUILD_STEP();

// ../../../node_modules/.pnpm/@sinclair+typebox@0.34.33/node_modules/@sinclair/typebox/build/esm/type/mapped/mapped-result.mjs
init_define_ENV_DEFINED_IN_BUILD_STEP();
function MappedResult(properties) {
  return CreateType({
    [Kind]: "MappedResult",
    properties
  });
}

// ../../../node_modules/.pnpm/@sinclair+typebox@0.34.33/node_modules/@sinclair/typebox/build/esm/type/mapped/mapped.mjs
init_define_ENV_DEFINED_IN_BUILD_STEP();

// ../../../node_modules/.pnpm/@sinclair+typebox@0.34.33/node_modules/@sinclair/typebox/build/esm/type/constructor/constructor.mjs
init_define_ENV_DEFINED_IN_BUILD_STEP();
function Constructor(parameters, returns, options) {
  return CreateType({ [Kind]: "Constructor", type: "Constructor", parameters, returns }, options);
}

// ../../../node_modules/.pnpm/@sinclair+typebox@0.34.33/node_modules/@sinclair/typebox/build/esm/type/function/function.mjs
init_define_ENV_DEFINED_IN_BUILD_STEP();
function Function2(parameters, returns, options) {
  return CreateType({ [Kind]: "Function", type: "Function", parameters, returns }, options);
}

// ../../../node_modules/.pnpm/@sinclair+typebox@0.34.33/node_modules/@sinclair/typebox/build/esm/type/indexed/indexed-from-mapped-key.mjs
init_define_ENV_DEFINED_IN_BUILD_STEP();

// ../../../node_modules/.pnpm/@sinclair+typebox@0.34.33/node_modules/@sinclair/typebox/build/esm/type/indexed/indexed.mjs
init_define_ENV_DEFINED_IN_BUILD_STEP();

// ../../../node_modules/.pnpm/@sinclair+typebox@0.34.33/node_modules/@sinclair/typebox/build/esm/type/union/union-evaluated.mjs
init_define_ENV_DEFINED_IN_BUILD_STEP();

// ../../../node_modules/.pnpm/@sinclair+typebox@0.34.33/node_modules/@sinclair/typebox/build/esm/type/union/union-create.mjs
init_define_ENV_DEFINED_IN_BUILD_STEP();
function UnionCreate(T3, options) {
  return CreateType({ [Kind]: "Union", anyOf: T3 }, options);
}

// ../../../node_modules/.pnpm/@sinclair+typebox@0.34.33/node_modules/@sinclair/typebox/build/esm/type/union/union-evaluated.mjs
function IsUnionOptional(types) {
  return types.some((type) => IsOptional(type));
}
function RemoveOptionalFromRest(types) {
  return types.map((left) => IsOptional(left) ? RemoveOptionalFromType(left) : left);
}
function RemoveOptionalFromType(T3) {
  return Discard(T3, [OptionalKind]);
}
function ResolveUnion(types, options) {
  const isOptional = IsUnionOptional(types);
  return isOptional ? Optional(UnionCreate(RemoveOptionalFromRest(types), options)) : UnionCreate(RemoveOptionalFromRest(types), options);
}
function UnionEvaluated(T3, options) {
  return T3.length === 1 ? CreateType(T3[0], options) : T3.length === 0 ? Never(options) : ResolveUnion(T3, options);
}

// ../../../node_modules/.pnpm/@sinclair+typebox@0.34.33/node_modules/@sinclair/typebox/build/esm/type/union/union.mjs
init_define_ENV_DEFINED_IN_BUILD_STEP();
function Union(types, options) {
  return types.length === 0 ? Never(options) : types.length === 1 ? CreateType(types[0], options) : UnionCreate(types, options);
}

// ../../../node_modules/.pnpm/@sinclair+typebox@0.34.33/node_modules/@sinclair/typebox/build/esm/type/indexed/indexed-property-keys.mjs
init_define_ENV_DEFINED_IN_BUILD_STEP();

// ../../../node_modules/.pnpm/@sinclair+typebox@0.34.33/node_modules/@sinclair/typebox/build/esm/type/template-literal/finite.mjs
init_define_ENV_DEFINED_IN_BUILD_STEP();

// ../../../node_modules/.pnpm/@sinclair+typebox@0.34.33/node_modules/@sinclair/typebox/build/esm/type/template-literal/parse.mjs
init_define_ENV_DEFINED_IN_BUILD_STEP();
var TemplateLiteralParserError = class extends TypeBoxError {
};
function Unescape(pattern) {
  return pattern.replace(/\\\$/g, "$").replace(/\\\*/g, "*").replace(/\\\^/g, "^").replace(/\\\|/g, "|").replace(/\\\(/g, "(").replace(/\\\)/g, ")");
}
function IsNonEscaped(pattern, index, char) {
  return pattern[index] === char && pattern.charCodeAt(index - 1) !== 92;
}
function IsOpenParen(pattern, index) {
  return IsNonEscaped(pattern, index, "(");
}
function IsCloseParen(pattern, index) {
  return IsNonEscaped(pattern, index, ")");
}
function IsSeparator(pattern, index) {
  return IsNonEscaped(pattern, index, "|");
}
function IsGroup(pattern) {
  if (!(IsOpenParen(pattern, 0) && IsCloseParen(pattern, pattern.length - 1)))
    return false;
  let count = 0;
  for (let index = 0; index < pattern.length; index++) {
    if (IsOpenParen(pattern, index))
      count += 1;
    if (IsCloseParen(pattern, index))
      count -= 1;
    if (count === 0 && index !== pattern.length - 1)
      return false;
  }
  return true;
}
function InGroup(pattern) {
  return pattern.slice(1, pattern.length - 1);
}
function IsPrecedenceOr(pattern) {
  let count = 0;
  for (let index = 0; index < pattern.length; index++) {
    if (IsOpenParen(pattern, index))
      count += 1;
    if (IsCloseParen(pattern, index))
      count -= 1;
    if (IsSeparator(pattern, index) && count === 0)
      return true;
  }
  return false;
}
function IsPrecedenceAnd(pattern) {
  for (let index = 0; index < pattern.length; index++) {
    if (IsOpenParen(pattern, index))
      return true;
  }
  return false;
}
function Or(pattern) {
  let [count, start] = [0, 0];
  const expressions = [];
  for (let index = 0; index < pattern.length; index++) {
    if (IsOpenParen(pattern, index))
      count += 1;
    if (IsCloseParen(pattern, index))
      count -= 1;
    if (IsSeparator(pattern, index) && count === 0) {
      const range2 = pattern.slice(start, index);
      if (range2.length > 0)
        expressions.push(TemplateLiteralParse(range2));
      start = index + 1;
    }
  }
  const range = pattern.slice(start);
  if (range.length > 0)
    expressions.push(TemplateLiteralParse(range));
  if (expressions.length === 0)
    return { type: "const", const: "" };
  if (expressions.length === 1)
    return expressions[0];
  return { type: "or", expr: expressions };
}
function And(pattern) {
  function Group(value, index) {
    if (!IsOpenParen(value, index))
      throw new TemplateLiteralParserError(`TemplateLiteralParser: Index must point to open parens`);
    let count = 0;
    for (let scan = index; scan < value.length; scan++) {
      if (IsOpenParen(value, scan))
        count += 1;
      if (IsCloseParen(value, scan))
        count -= 1;
      if (count === 0)
        return [index, scan];
    }
    throw new TemplateLiteralParserError(`TemplateLiteralParser: Unclosed group parens in expression`);
  }
  function Range(pattern2, index) {
    for (let scan = index; scan < pattern2.length; scan++) {
      if (IsOpenParen(pattern2, scan))
        return [index, scan];
    }
    return [index, pattern2.length];
  }
  const expressions = [];
  for (let index = 0; index < pattern.length; index++) {
    if (IsOpenParen(pattern, index)) {
      const [start, end] = Group(pattern, index);
      const range = pattern.slice(start, end + 1);
      expressions.push(TemplateLiteralParse(range));
      index = end;
    } else {
      const [start, end] = Range(pattern, index);
      const range = pattern.slice(start, end);
      if (range.length > 0)
        expressions.push(TemplateLiteralParse(range));
      index = end - 1;
    }
  }
  return expressions.length === 0 ? { type: "const", const: "" } : expressions.length === 1 ? expressions[0] : { type: "and", expr: expressions };
}
function TemplateLiteralParse(pattern) {
  return IsGroup(pattern) ? TemplateLiteralParse(InGroup(pattern)) : IsPrecedenceOr(pattern) ? Or(pattern) : IsPrecedenceAnd(pattern) ? And(pattern) : { type: "const", const: Unescape(pattern) };
}
function TemplateLiteralParseExact(pattern) {
  return TemplateLiteralParse(pattern.slice(1, pattern.length - 1));
}

// ../../../node_modules/.pnpm/@sinclair+typebox@0.34.33/node_modules/@sinclair/typebox/build/esm/type/template-literal/finite.mjs
var TemplateLiteralFiniteError = class extends TypeBoxError {
};
function IsNumberExpression(expression) {
  return expression.type === "or" && expression.expr.length === 2 && expression.expr[0].type === "const" && expression.expr[0].const === "0" && expression.expr[1].type === "const" && expression.expr[1].const === "[1-9][0-9]*";
}
function IsBooleanExpression(expression) {
  return expression.type === "or" && expression.expr.length === 2 && expression.expr[0].type === "const" && expression.expr[0].const === "true" && expression.expr[1].type === "const" && expression.expr[1].const === "false";
}
function IsStringExpression(expression) {
  return expression.type === "const" && expression.const === ".*";
}
function IsTemplateLiteralExpressionFinite(expression) {
  return IsNumberExpression(expression) || IsStringExpression(expression) ? false : IsBooleanExpression(expression) ? true : expression.type === "and" ? expression.expr.every((expr) => IsTemplateLiteralExpressionFinite(expr)) : expression.type === "or" ? expression.expr.every((expr) => IsTemplateLiteralExpressionFinite(expr)) : expression.type === "const" ? true : (() => {
    throw new TemplateLiteralFiniteError(`Unknown expression type`);
  })();
}
function IsTemplateLiteralFinite(schema) {
  const expression = TemplateLiteralParseExact(schema.pattern);
  return IsTemplateLiteralExpressionFinite(expression);
}

// ../../../node_modules/.pnpm/@sinclair+typebox@0.34.33/node_modules/@sinclair/typebox/build/esm/type/template-literal/generate.mjs
init_define_ENV_DEFINED_IN_BUILD_STEP();
var TemplateLiteralGenerateError = class extends TypeBoxError {
};
function* GenerateReduce(buffer) {
  if (buffer.length === 1)
    return yield* buffer[0];
  for (const left of buffer[0]) {
    for (const right of GenerateReduce(buffer.slice(1))) {
      yield `${left}${right}`;
    }
  }
}
function* GenerateAnd(expression) {
  return yield* GenerateReduce(expression.expr.map((expr) => [...TemplateLiteralExpressionGenerate(expr)]));
}
function* GenerateOr(expression) {
  for (const expr of expression.expr)
    yield* TemplateLiteralExpressionGenerate(expr);
}
function* GenerateConst(expression) {
  return yield expression.const;
}
function* TemplateLiteralExpressionGenerate(expression) {
  return expression.type === "and" ? yield* GenerateAnd(expression) : expression.type === "or" ? yield* GenerateOr(expression) : expression.type === "const" ? yield* GenerateConst(expression) : (() => {
    throw new TemplateLiteralGenerateError("Unknown expression");
  })();
}
function TemplateLiteralGenerate(schema) {
  const expression = TemplateLiteralParseExact(schema.pattern);
  return IsTemplateLiteralExpressionFinite(expression) ? [...TemplateLiteralExpressionGenerate(expression)] : [];
}

// ../../../node_modules/.pnpm/@sinclair+typebox@0.34.33/node_modules/@sinclair/typebox/build/esm/type/template-literal/syntax.mjs
init_define_ENV_DEFINED_IN_BUILD_STEP();

// ../../../node_modules/.pnpm/@sinclair+typebox@0.34.33/node_modules/@sinclair/typebox/build/esm/type/literal/literal.mjs
init_define_ENV_DEFINED_IN_BUILD_STEP();
function Literal(value, options) {
  return CreateType({
    [Kind]: "Literal",
    const: value,
    type: typeof value
  }, options);
}

// ../../../node_modules/.pnpm/@sinclair+typebox@0.34.33/node_modules/@sinclair/typebox/build/esm/type/boolean/boolean.mjs
init_define_ENV_DEFINED_IN_BUILD_STEP();
function Boolean2(options) {
  return CreateType({ [Kind]: "Boolean", type: "boolean" }, options);
}

// ../../../node_modules/.pnpm/@sinclair+typebox@0.34.33/node_modules/@sinclair/typebox/build/esm/type/bigint/bigint.mjs
init_define_ENV_DEFINED_IN_BUILD_STEP();
function BigInt2(options) {
  return CreateType({ [Kind]: "BigInt", type: "bigint" }, options);
}

// ../../../node_modules/.pnpm/@sinclair+typebox@0.34.33/node_modules/@sinclair/typebox/build/esm/type/number/number.mjs
init_define_ENV_DEFINED_IN_BUILD_STEP();
function Number2(options) {
  return CreateType({ [Kind]: "Number", type: "number" }, options);
}

// ../../../node_modules/.pnpm/@sinclair+typebox@0.34.33/node_modules/@sinclair/typebox/build/esm/type/string/string.mjs
init_define_ENV_DEFINED_IN_BUILD_STEP();
function String2(options) {
  return CreateType({ [Kind]: "String", type: "string" }, options);
}

// ../../../node_modules/.pnpm/@sinclair+typebox@0.34.33/node_modules/@sinclair/typebox/build/esm/type/template-literal/syntax.mjs
function* FromUnion(syntax) {
  const trim4 = syntax.trim().replace(/"|'/g, "");
  return trim4 === "boolean" ? yield Boolean2() : trim4 === "number" ? yield Number2() : trim4 === "bigint" ? yield BigInt2() : trim4 === "string" ? yield String2() : yield (() => {
    const literals = trim4.split("|").map((literal) => Literal(literal.trim()));
    return literals.length === 0 ? Never() : literals.length === 1 ? literals[0] : UnionEvaluated(literals);
  })();
}
function* FromTerminal(syntax) {
  if (syntax[1] !== "{") {
    const L3 = Literal("$");
    const R3 = FromSyntax(syntax.slice(1));
    return yield* [L3, ...R3];
  }
  for (let i2 = 2; i2 < syntax.length; i2++) {
    if (syntax[i2] === "}") {
      const L3 = FromUnion(syntax.slice(2, i2));
      const R3 = FromSyntax(syntax.slice(i2 + 1));
      return yield* [...L3, ...R3];
    }
  }
  yield Literal(syntax);
}
function* FromSyntax(syntax) {
  for (let i2 = 0; i2 < syntax.length; i2++) {
    if (syntax[i2] === "$") {
      const L3 = Literal(syntax.slice(0, i2));
      const R3 = FromTerminal(syntax.slice(i2));
      return yield* [L3, ...R3];
    }
  }
  yield Literal(syntax);
}
function TemplateLiteralSyntax(syntax) {
  return [...FromSyntax(syntax)];
}

// ../../../node_modules/.pnpm/@sinclair+typebox@0.34.33/node_modules/@sinclair/typebox/build/esm/type/template-literal/pattern.mjs
init_define_ENV_DEFINED_IN_BUILD_STEP();
var TemplateLiteralPatternError = class extends TypeBoxError {
};
function Escape(value) {
  return value.replace(/[.*+?^${}()|[\]\\]/g, "\\$&");
}
function Visit2(schema, acc) {
  return IsTemplateLiteral(schema) ? schema.pattern.slice(1, schema.pattern.length - 1) : IsUnion(schema) ? `(${schema.anyOf.map((schema2) => Visit2(schema2, acc)).join("|")})` : IsNumber3(schema) ? `${acc}${PatternNumber}` : IsInteger2(schema) ? `${acc}${PatternNumber}` : IsBigInt3(schema) ? `${acc}${PatternNumber}` : IsString3(schema) ? `${acc}${PatternString}` : IsLiteral(schema) ? `${acc}${Escape(schema.const.toString())}` : IsBoolean3(schema) ? `${acc}${PatternBoolean}` : (() => {
    throw new TemplateLiteralPatternError(`Unexpected Kind '${schema[Kind]}'`);
  })();
}
function TemplateLiteralPattern(kinds) {
  return `^${kinds.map((schema) => Visit2(schema, "")).join("")}$`;
}

// ../../../node_modules/.pnpm/@sinclair+typebox@0.34.33/node_modules/@sinclair/typebox/build/esm/type/template-literal/union.mjs
init_define_ENV_DEFINED_IN_BUILD_STEP();
function TemplateLiteralToUnion(schema) {
  const R3 = TemplateLiteralGenerate(schema);
  const L3 = R3.map((S3) => Literal(S3));
  return UnionEvaluated(L3);
}

// ../../../node_modules/.pnpm/@sinclair+typebox@0.34.33/node_modules/@sinclair/typebox/build/esm/type/template-literal/template-literal.mjs
init_define_ENV_DEFINED_IN_BUILD_STEP();
function TemplateLiteral(unresolved, options) {
  const pattern = IsString(unresolved) ? TemplateLiteralPattern(TemplateLiteralSyntax(unresolved)) : TemplateLiteralPattern(unresolved);
  return CreateType({ [Kind]: "TemplateLiteral", type: "string", pattern }, options);
}

// ../../../node_modules/.pnpm/@sinclair+typebox@0.34.33/node_modules/@sinclair/typebox/build/esm/type/indexed/indexed-property-keys.mjs
function FromTemplateLiteral(templateLiteral) {
  const keys = TemplateLiteralGenerate(templateLiteral);
  return keys.map((key) => key.toString());
}
function FromUnion2(types) {
  const result = [];
  for (const type of types)
    result.push(...IndexPropertyKeys(type));
  return result;
}
function FromLiteral(literalValue) {
  return [literalValue.toString()];
}
function IndexPropertyKeys(type) {
  return [...new Set(IsTemplateLiteral(type) ? FromTemplateLiteral(type) : IsUnion(type) ? FromUnion2(type.anyOf) : IsLiteral(type) ? FromLiteral(type.const) : IsNumber3(type) ? ["[number]"] : IsInteger2(type) ? ["[number]"] : [])];
}

// ../../../node_modules/.pnpm/@sinclair+typebox@0.34.33/node_modules/@sinclair/typebox/build/esm/type/indexed/indexed-from-mapped-result.mjs
init_define_ENV_DEFINED_IN_BUILD_STEP();
function FromProperties(type, properties, options) {
  const result = {};
  for (const K2 of Object.getOwnPropertyNames(properties)) {
    result[K2] = Index(type, IndexPropertyKeys(properties[K2]), options);
  }
  return result;
}
function FromMappedResult(type, mappedResult, options) {
  return FromProperties(type, mappedResult.properties, options);
}
function IndexFromMappedResult(type, mappedResult, options) {
  const properties = FromMappedResult(type, mappedResult, options);
  return MappedResult(properties);
}

// ../../../node_modules/.pnpm/@sinclair+typebox@0.34.33/node_modules/@sinclair/typebox/build/esm/type/indexed/indexed.mjs
function FromRest(types, key) {
  return types.map((type) => IndexFromPropertyKey(type, key));
}
function FromIntersectRest(types) {
  return types.filter((type) => !IsNever(type));
}
function FromIntersect(types, key) {
  return IntersectEvaluated(FromIntersectRest(FromRest(types, key)));
}
function FromUnionRest(types) {
  return types.some((L3) => IsNever(L3)) ? [] : types;
}
function FromUnion3(types, key) {
  return UnionEvaluated(FromUnionRest(FromRest(types, key)));
}
function FromTuple(types, key) {
  return key in types ? types[key] : key === "[number]" ? UnionEvaluated(types) : Never();
}
function FromArray(type, key) {
  return key === "[number]" ? type : Never();
}
function FromProperty(properties, propertyKey) {
  return propertyKey in properties ? properties[propertyKey] : Never();
}
function IndexFromPropertyKey(type, propertyKey) {
  return IsIntersect(type) ? FromIntersect(type.allOf, propertyKey) : IsUnion(type) ? FromUnion3(type.anyOf, propertyKey) : IsTuple(type) ? FromTuple(type.items ?? [], propertyKey) : IsArray3(type) ? FromArray(type.items, propertyKey) : IsObject3(type) ? FromProperty(type.properties, propertyKey) : Never();
}
function IndexFromPropertyKeys(type, propertyKeys) {
  return propertyKeys.map((propertyKey) => IndexFromPropertyKey(type, propertyKey));
}
function FromSchema(type, propertyKeys) {
  return UnionEvaluated(IndexFromPropertyKeys(type, propertyKeys));
}
function Index(type, key, options) {
  if (IsRef(type) || IsRef(key)) {
    const error = `Index types using Ref parameters require both Type and Key to be of TSchema`;
    if (!IsSchema(type) || !IsSchema(key))
      throw new TypeBoxError(error);
    return Computed("Index", [type, key]);
  }
  if (IsMappedResult(key))
    return IndexFromMappedResult(type, key, options);
  if (IsMappedKey(key))
    return IndexFromMappedKey(type, key, options);
  return CreateType(IsSchema(key) ? FromSchema(type, IndexPropertyKeys(key)) : FromSchema(type, key), options);
}

// ../../../node_modules/.pnpm/@sinclair+typebox@0.34.33/node_modules/@sinclair/typebox/build/esm/type/indexed/indexed-from-mapped-key.mjs
function MappedIndexPropertyKey(type, key, options) {
  return { [key]: Index(type, [key], Clone(options)) };
}
function MappedIndexPropertyKeys(type, propertyKeys, options) {
  return propertyKeys.reduce((result, left) => {
    return { ...result, ...MappedIndexPropertyKey(type, left, options) };
  }, {});
}
function MappedIndexProperties(type, mappedKey, options) {
  return MappedIndexPropertyKeys(type, mappedKey.keys, options);
}
function IndexFromMappedKey(type, mappedKey, options) {
  const properties = MappedIndexProperties(type, mappedKey, options);
  return MappedResult(properties);
}

// ../../../node_modules/.pnpm/@sinclair+typebox@0.34.33/node_modules/@sinclair/typebox/build/esm/type/iterator/iterator.mjs
init_define_ENV_DEFINED_IN_BUILD_STEP();
function Iterator(items, options) {
  return CreateType({ [Kind]: "Iterator", type: "Iterator", items }, options);
}

// ../../../node_modules/.pnpm/@sinclair+typebox@0.34.33/node_modules/@sinclair/typebox/build/esm/type/object/object.mjs
init_define_ENV_DEFINED_IN_BUILD_STEP();
function RequiredKeys(properties) {
  const keys = [];
  for (let key in properties) {
    if (!IsOptional(properties[key]))
      keys.push(key);
  }
  return keys;
}
function _Object(properties, options) {
  const required = RequiredKeys(properties);
  const schematic = required.length > 0 ? { [Kind]: "Object", type: "object", properties, required } : { [Kind]: "Object", type: "object", properties };
  return CreateType(schematic, options);
}
var Object2 = _Object;

// ../../../node_modules/.pnpm/@sinclair+typebox@0.34.33/node_modules/@sinclair/typebox/build/esm/type/promise/promise.mjs
init_define_ENV_DEFINED_IN_BUILD_STEP();
function Promise2(item, options) {
  return CreateType({ [Kind]: "Promise", type: "Promise", item }, options);
}

// ../../../node_modules/.pnpm/@sinclair+typebox@0.34.33/node_modules/@sinclair/typebox/build/esm/type/readonly/readonly-from-mapped-result.mjs
init_define_ENV_DEFINED_IN_BUILD_STEP();

// ../../../node_modules/.pnpm/@sinclair+typebox@0.34.33/node_modules/@sinclair/typebox/build/esm/type/readonly/readonly.mjs
init_define_ENV_DEFINED_IN_BUILD_STEP();
function RemoveReadonly(schema) {
  return CreateType(Discard(schema, [ReadonlyKind]));
}
function AddReadonly(schema) {
  return CreateType({ ...schema, [ReadonlyKind]: "Readonly" });
}
function ReadonlyWithFlag(schema, F2) {
  return F2 === false ? RemoveReadonly(schema) : AddReadonly(schema);
}
function Readonly(schema, enable) {
  const F2 = enable ?? true;
  return IsMappedResult(schema) ? ReadonlyFromMappedResult(schema, F2) : ReadonlyWithFlag(schema, F2);
}

// ../../../node_modules/.pnpm/@sinclair+typebox@0.34.33/node_modules/@sinclair/typebox/build/esm/type/readonly/readonly-from-mapped-result.mjs
function FromProperties2(K, F2) {
  const Acc = {};
  for (const K2 of globalThis.Object.getOwnPropertyNames(K))
    Acc[K2] = Readonly(K[K2], F2);
  return Acc;
}
function FromMappedResult2(R3, F2) {
  return FromProperties2(R3.properties, F2);
}
function ReadonlyFromMappedResult(R3, F2) {
  const P3 = FromMappedResult2(R3, F2);
  return MappedResult(P3);
}

// ../../../node_modules/.pnpm/@sinclair+typebox@0.34.33/node_modules/@sinclair/typebox/build/esm/type/tuple/tuple.mjs
init_define_ENV_DEFINED_IN_BUILD_STEP();
function Tuple(types, options) {
  return CreateType(types.length > 0 ? { [Kind]: "Tuple", type: "array", items: types, additionalItems: false, minItems: types.length, maxItems: types.length } : { [Kind]: "Tuple", type: "array", minItems: types.length, maxItems: types.length }, options);
}

// ../../../node_modules/.pnpm/@sinclair+typebox@0.34.33/node_modules/@sinclair/typebox/build/esm/type/mapped/mapped.mjs
function FromMappedResult3(K, P3) {
  return K in P3 ? FromSchemaType(K, P3[K]) : MappedResult(P3);
}
function MappedKeyToKnownMappedResultProperties(K) {
  return { [K]: Literal(K) };
}
function MappedKeyToUnknownMappedResultProperties(P3) {
  const Acc = {};
  for (const L3 of P3)
    Acc[L3] = Literal(L3);
  return Acc;
}
function MappedKeyToMappedResultProperties(K, P3) {
  return SetIncludes(P3, K) ? MappedKeyToKnownMappedResultProperties(K) : MappedKeyToUnknownMappedResultProperties(P3);
}
function FromMappedKey(K, P3) {
  const R3 = MappedKeyToMappedResultProperties(K, P3);
  return FromMappedResult3(K, R3);
}
function FromRest2(K, T3) {
  return T3.map((L3) => FromSchemaType(K, L3));
}
function FromProperties3(K, T3) {
  const Acc = {};
  for (const K2 of globalThis.Object.getOwnPropertyNames(T3))
    Acc[K2] = FromSchemaType(K, T3[K2]);
  return Acc;
}
function FromSchemaType(K, T3) {
  const options = { ...T3 };
  return (
    // unevaluated modifier types
    IsOptional(T3) ? Optional(FromSchemaType(K, Discard(T3, [OptionalKind]))) : IsReadonly(T3) ? Readonly(FromSchemaType(K, Discard(T3, [ReadonlyKind]))) : (
      // unevaluated mapped types
      IsMappedResult(T3) ? FromMappedResult3(K, T3.properties) : IsMappedKey(T3) ? FromMappedKey(K, T3.keys) : (
        // unevaluated types
        IsConstructor(T3) ? Constructor(FromRest2(K, T3.parameters), FromSchemaType(K, T3.returns), options) : IsFunction3(T3) ? Function2(FromRest2(K, T3.parameters), FromSchemaType(K, T3.returns), options) : IsAsyncIterator3(T3) ? AsyncIterator(FromSchemaType(K, T3.items), options) : IsIterator3(T3) ? Iterator(FromSchemaType(K, T3.items), options) : IsIntersect(T3) ? Intersect(FromRest2(K, T3.allOf), options) : IsUnion(T3) ? Union(FromRest2(K, T3.anyOf), options) : IsTuple(T3) ? Tuple(FromRest2(K, T3.items ?? []), options) : IsObject3(T3) ? Object2(FromProperties3(K, T3.properties), options) : IsArray3(T3) ? Array2(FromSchemaType(K, T3.items), options) : IsPromise2(T3) ? Promise2(FromSchemaType(K, T3.item), options) : T3
      )
    )
  );
}
function MappedFunctionReturnType(K, T3) {
  const Acc = {};
  for (const L3 of K)
    Acc[L3] = FromSchemaType(L3, T3);
  return Acc;
}
function Mapped(key, map3, options) {
  const K = IsSchema(key) ? IndexPropertyKeys(key) : key;
  const RT = map3({ [Kind]: "MappedKey", keys: K });
  const R3 = MappedFunctionReturnType(K, RT);
  return Object2(R3, options);
}

// ../../../node_modules/.pnpm/@sinclair+typebox@0.34.33/node_modules/@sinclair/typebox/build/esm/type/optional/optional.mjs
init_define_ENV_DEFINED_IN_BUILD_STEP();
function RemoveOptional(schema) {
  return CreateType(Discard(schema, [OptionalKind]));
}
function AddOptional(schema) {
  return CreateType({ ...schema, [OptionalKind]: "Optional" });
}
function OptionalWithFlag(schema, F2) {
  return F2 === false ? RemoveOptional(schema) : AddOptional(schema);
}
function Optional(schema, enable) {
  const F2 = enable ?? true;
  return IsMappedResult(schema) ? OptionalFromMappedResult(schema, F2) : OptionalWithFlag(schema, F2);
}

// ../../../node_modules/.pnpm/@sinclair+typebox@0.34.33/node_modules/@sinclair/typebox/build/esm/type/optional/optional-from-mapped-result.mjs
function FromProperties4(P3, F2) {
  const Acc = {};
  for (const K2 of globalThis.Object.getOwnPropertyNames(P3))
    Acc[K2] = Optional(P3[K2], F2);
  return Acc;
}
function FromMappedResult4(R3, F2) {
  return FromProperties4(R3.properties, F2);
}
function OptionalFromMappedResult(R3, F2) {
  const P3 = FromMappedResult4(R3, F2);
  return MappedResult(P3);
}

// ../../../node_modules/.pnpm/@sinclair+typebox@0.34.33/node_modules/@sinclair/typebox/build/esm/type/intersect/intersect-create.mjs
init_define_ENV_DEFINED_IN_BUILD_STEP();
function IntersectCreate(T3, options = {}) {
  const allObjects = T3.every((schema) => IsObject3(schema));
  const clonedUnevaluatedProperties = IsSchema(options.unevaluatedProperties) ? { unevaluatedProperties: options.unevaluatedProperties } : {};
  return CreateType(options.unevaluatedProperties === false || IsSchema(options.unevaluatedProperties) || allObjects ? { ...clonedUnevaluatedProperties, [Kind]: "Intersect", type: "object", allOf: T3 } : { ...clonedUnevaluatedProperties, [Kind]: "Intersect", allOf: T3 }, options);
}

// ../../../node_modules/.pnpm/@sinclair+typebox@0.34.33/node_modules/@sinclair/typebox/build/esm/type/intersect/intersect-evaluated.mjs
function IsIntersectOptional(types) {
  return types.every((left) => IsOptional(left));
}
function RemoveOptionalFromType2(type) {
  return Discard(type, [OptionalKind]);
}
function RemoveOptionalFromRest2(types) {
  return types.map((left) => IsOptional(left) ? RemoveOptionalFromType2(left) : left);
}
function ResolveIntersect(types, options) {
  return IsIntersectOptional(types) ? Optional(IntersectCreate(RemoveOptionalFromRest2(types), options)) : IntersectCreate(RemoveOptionalFromRest2(types), options);
}
function IntersectEvaluated(types, options = {}) {
  if (types.length === 1)
    return CreateType(types[0], options);
  if (types.length === 0)
    return Never(options);
  if (types.some((schema) => IsTransform(schema)))
    throw new Error("Cannot intersect transform types");
  return ResolveIntersect(types, options);
}

// ../../../node_modules/.pnpm/@sinclair+typebox@0.34.33/node_modules/@sinclair/typebox/build/esm/type/intersect/intersect.mjs
init_define_ENV_DEFINED_IN_BUILD_STEP();
function Intersect(types, options) {
  if (types.length === 1)
    return CreateType(types[0], options);
  if (types.length === 0)
    return Never(options);
  if (types.some((schema) => IsTransform(schema)))
    throw new Error("Cannot intersect transform types");
  return IntersectCreate(types, options);
}

// ../../../node_modules/.pnpm/@sinclair+typebox@0.34.33/node_modules/@sinclair/typebox/build/esm/type/ref/ref.mjs
init_define_ENV_DEFINED_IN_BUILD_STEP();
function Ref(...args) {
  const [$ref, options] = typeof args[0] === "string" ? [args[0], args[1]] : [args[0].$id, args[1]];
  if (typeof $ref !== "string")
    throw new TypeBoxError("Ref: $ref must be a string");
  return CreateType({ [Kind]: "Ref", $ref }, options);
}

// ../../../node_modules/.pnpm/@sinclair+typebox@0.34.33/node_modules/@sinclair/typebox/build/esm/type/awaited/awaited.mjs
function FromComputed(target, parameters) {
  return Computed("Awaited", [Computed(target, parameters)]);
}
function FromRef($ref) {
  return Computed("Awaited", [Ref($ref)]);
}
function FromIntersect2(types) {
  return Intersect(FromRest3(types));
}
function FromUnion4(types) {
  return Union(FromRest3(types));
}
function FromPromise(type) {
  return Awaited(type);
}
function FromRest3(types) {
  return types.map((type) => Awaited(type));
}
function Awaited(type, options) {
  return CreateType(IsComputed(type) ? FromComputed(type.target, type.parameters) : IsIntersect(type) ? FromIntersect2(type.allOf) : IsUnion(type) ? FromUnion4(type.anyOf) : IsPromise2(type) ? FromPromise(type.item) : IsRef(type) ? FromRef(type.$ref) : type, options);
}

// ../../../node_modules/.pnpm/@sinclair+typebox@0.34.33/node_modules/@sinclair/typebox/build/esm/type/composite/composite.mjs
init_define_ENV_DEFINED_IN_BUILD_STEP();

// ../../../node_modules/.pnpm/@sinclair+typebox@0.34.33/node_modules/@sinclair/typebox/build/esm/type/keyof/keyof-from-mapped-result.mjs
init_define_ENV_DEFINED_IN_BUILD_STEP();

// ../../../node_modules/.pnpm/@sinclair+typebox@0.34.33/node_modules/@sinclair/typebox/build/esm/type/keyof/keyof.mjs
init_define_ENV_DEFINED_IN_BUILD_STEP();

// ../../../node_modules/.pnpm/@sinclair+typebox@0.34.33/node_modules/@sinclair/typebox/build/esm/type/keyof/keyof-property-keys.mjs
init_define_ENV_DEFINED_IN_BUILD_STEP();
function FromRest4(types) {
  const result = [];
  for (const L3 of types)
    result.push(KeyOfPropertyKeys(L3));
  return result;
}
function FromIntersect3(types) {
  const propertyKeysArray = FromRest4(types);
  const propertyKeys = SetUnionMany(propertyKeysArray);
  return propertyKeys;
}
function FromUnion5(types) {
  const propertyKeysArray = FromRest4(types);
  const propertyKeys = SetIntersectMany(propertyKeysArray);
  return propertyKeys;
}
function FromTuple2(types) {
  return types.map((_3, indexer) => indexer.toString());
}
function FromArray2(_3) {
  return ["[number]"];
}
function FromProperties5(T3) {
  return globalThis.Object.getOwnPropertyNames(T3);
}
function FromPatternProperties(patternProperties) {
  if (!includePatternProperties)
    return [];
  const patternPropertyKeys = globalThis.Object.getOwnPropertyNames(patternProperties);
  return patternPropertyKeys.map((key) => {
    return key[0] === "^" && key[key.length - 1] === "$" ? key.slice(1, key.length - 1) : key;
  });
}
function KeyOfPropertyKeys(type) {
  return IsIntersect(type) ? FromIntersect3(type.allOf) : IsUnion(type) ? FromUnion5(type.anyOf) : IsTuple(type) ? FromTuple2(type.items ?? []) : IsArray3(type) ? FromArray2(type.items) : IsObject3(type) ? FromProperties5(type.properties) : IsRecord(type) ? FromPatternProperties(type.patternProperties) : [];
}
var includePatternProperties = false;
function KeyOfPattern(schema) {
  includePatternProperties = true;
  const keys = KeyOfPropertyKeys(schema);
  includePatternProperties = false;
  const pattern = keys.map((key) => `(${key})`);
  return `^(${pattern.join("|")})$`;
}

// ../../../node_modules/.pnpm/@sinclair+typebox@0.34.33/node_modules/@sinclair/typebox/build/esm/type/keyof/keyof.mjs
function FromComputed2(target, parameters) {
  return Computed("KeyOf", [Computed(target, parameters)]);
}
function FromRef2($ref) {
  return Computed("KeyOf", [Ref($ref)]);
}
function KeyOfFromType(type, options) {
  const propertyKeys = KeyOfPropertyKeys(type);
  const propertyKeyTypes = KeyOfPropertyKeysToRest(propertyKeys);
  const result = UnionEvaluated(propertyKeyTypes);
  return CreateType(result, options);
}
function KeyOfPropertyKeysToRest(propertyKeys) {
  return propertyKeys.map((L3) => L3 === "[number]" ? Number2() : Literal(L3));
}
function KeyOf(type, options) {
  return IsComputed(type) ? FromComputed2(type.target, type.parameters) : IsRef(type) ? FromRef2(type.$ref) : IsMappedResult(type) ? KeyOfFromMappedResult(type, options) : KeyOfFromType(type, options);
}

// ../../../node_modules/.pnpm/@sinclair+typebox@0.34.33/node_modules/@sinclair/typebox/build/esm/type/keyof/keyof-from-mapped-result.mjs
function FromProperties6(properties, options) {
  const result = {};
  for (const K2 of globalThis.Object.getOwnPropertyNames(properties))
    result[K2] = KeyOf(properties[K2], Clone(options));
  return result;
}
function FromMappedResult5(mappedResult, options) {
  return FromProperties6(mappedResult.properties, options);
}
function KeyOfFromMappedResult(mappedResult, options) {
  const properties = FromMappedResult5(mappedResult, options);
  return MappedResult(properties);
}

// ../../../node_modules/.pnpm/@sinclair+typebox@0.34.33/node_modules/@sinclair/typebox/build/esm/type/keyof/keyof-property-entries.mjs
init_define_ENV_DEFINED_IN_BUILD_STEP();
function KeyOfPropertyEntries(schema) {
  const keys = KeyOfPropertyKeys(schema);
  const schemas = IndexFromPropertyKeys(schema, keys);
  return keys.map((_3, index) => [keys[index], schemas[index]]);
}

// ../../../node_modules/.pnpm/@sinclair+typebox@0.34.33/node_modules/@sinclair/typebox/build/esm/type/composite/composite.mjs
function CompositeKeys(T3) {
  const Acc = [];
  for (const L3 of T3)
    Acc.push(...KeyOfPropertyKeys(L3));
  return SetDistinct(Acc);
}
function FilterNever(T3) {
  return T3.filter((L3) => !IsNever(L3));
}
function CompositeProperty(T3, K) {
  const Acc = [];
  for (const L3 of T3)
    Acc.push(...IndexFromPropertyKeys(L3, [K]));
  return FilterNever(Acc);
}
function CompositeProperties(T3, K) {
  const Acc = {};
  for (const L3 of K) {
    Acc[L3] = IntersectEvaluated(CompositeProperty(T3, L3));
  }
  return Acc;
}
function Composite(T3, options) {
  const K = CompositeKeys(T3);
  const P3 = CompositeProperties(T3, K);
  const R3 = Object2(P3, options);
  return R3;
}

// ../../../node_modules/.pnpm/@sinclair+typebox@0.34.33/node_modules/@sinclair/typebox/build/esm/type/const/const.mjs
init_define_ENV_DEFINED_IN_BUILD_STEP();

// ../../../node_modules/.pnpm/@sinclair+typebox@0.34.33/node_modules/@sinclair/typebox/build/esm/type/date/date.mjs
init_define_ENV_DEFINED_IN_BUILD_STEP();
function Date2(options) {
  return CreateType({ [Kind]: "Date", type: "Date" }, options);
}

// ../../../node_modules/.pnpm/@sinclair+typebox@0.34.33/node_modules/@sinclair/typebox/build/esm/type/null/null.mjs
init_define_ENV_DEFINED_IN_BUILD_STEP();
function Null(options) {
  return CreateType({ [Kind]: "Null", type: "null" }, options);
}

// ../../../node_modules/.pnpm/@sinclair+typebox@0.34.33/node_modules/@sinclair/typebox/build/esm/type/symbol/symbol.mjs
init_define_ENV_DEFINED_IN_BUILD_STEP();
function Symbol2(options) {
  return CreateType({ [Kind]: "Symbol", type: "symbol" }, options);
}

// ../../../node_modules/.pnpm/@sinclair+typebox@0.34.33/node_modules/@sinclair/typebox/build/esm/type/undefined/undefined.mjs
init_define_ENV_DEFINED_IN_BUILD_STEP();
function Undefined(options) {
  return CreateType({ [Kind]: "Undefined", type: "undefined" }, options);
}

// ../../../node_modules/.pnpm/@sinclair+typebox@0.34.33/node_modules/@sinclair/typebox/build/esm/type/uint8array/uint8array.mjs
init_define_ENV_DEFINED_IN_BUILD_STEP();
function Uint8Array2(options) {
  return CreateType({ [Kind]: "Uint8Array", type: "Uint8Array" }, options);
}

// ../../../node_modules/.pnpm/@sinclair+typebox@0.34.33/node_modules/@sinclair/typebox/build/esm/type/unknown/unknown.mjs
init_define_ENV_DEFINED_IN_BUILD_STEP();
function Unknown(options) {
  return CreateType({ [Kind]: "Unknown" }, options);
}

// ../../../node_modules/.pnpm/@sinclair+typebox@0.34.33/node_modules/@sinclair/typebox/build/esm/type/const/const.mjs
function FromArray3(T3) {
  return T3.map((L3) => FromValue(L3, false));
}
function FromProperties7(value) {
  const Acc = {};
  for (const K of globalThis.Object.getOwnPropertyNames(value))
    Acc[K] = Readonly(FromValue(value[K], false));
  return Acc;
}
function ConditionalReadonly(T3, root) {
  return root === true ? T3 : Readonly(T3);
}
function FromValue(value, root) {
  return IsAsyncIterator(value) ? ConditionalReadonly(Any(), root) : IsIterator(value) ? ConditionalReadonly(Any(), root) : IsArray(value) ? Readonly(Tuple(FromArray3(value))) : IsUint8Array(value) ? Uint8Array2() : IsDate(value) ? Date2() : IsObject(value) ? ConditionalReadonly(Object2(FromProperties7(value)), root) : IsFunction(value) ? ConditionalReadonly(Function2([], Unknown()), root) : IsUndefined(value) ? Undefined() : IsNull(value) ? Null() : IsSymbol(value) ? Symbol2() : IsBigInt(value) ? BigInt2() : IsNumber(value) ? Literal(value) : IsBoolean(value) ? Literal(value) : IsString(value) ? Literal(value) : Object2({});
}
function Const(T3, options) {
  return CreateType(FromValue(T3, true), options);
}

// ../../../node_modules/.pnpm/@sinclair+typebox@0.34.33/node_modules/@sinclair/typebox/build/esm/type/constructor-parameters/constructor-parameters.mjs
init_define_ENV_DEFINED_IN_BUILD_STEP();
function ConstructorParameters(schema, options) {
  return IsConstructor(schema) ? Tuple(schema.parameters, options) : Never(options);
}

// ../../../node_modules/.pnpm/@sinclair+typebox@0.34.33/node_modules/@sinclair/typebox/build/esm/type/enum/enum.mjs
init_define_ENV_DEFINED_IN_BUILD_STEP();
function Enum(item, options) {
  if (IsUndefined(item))
    throw new Error("Enum undefined or empty");
  const values1 = globalThis.Object.getOwnPropertyNames(item).filter((key) => isNaN(key)).map((key) => item[key]);
  const values2 = [...new Set(values1)];
  const anyOf = values2.map((value) => Literal(value));
  return Union(anyOf, { ...options, [Hint]: "Enum" });
}

// ../../../node_modules/.pnpm/@sinclair+typebox@0.34.33/node_modules/@sinclair/typebox/build/esm/type/exclude/exclude-from-mapped-result.mjs
init_define_ENV_DEFINED_IN_BUILD_STEP();

// ../../../node_modules/.pnpm/@sinclair+typebox@0.34.33/node_modules/@sinclair/typebox/build/esm/type/exclude/exclude.mjs
init_define_ENV_DEFINED_IN_BUILD_STEP();

// ../../../node_modules/.pnpm/@sinclair+typebox@0.34.33/node_modules/@sinclair/typebox/build/esm/type/extends/extends-check.mjs
init_define_ENV_DEFINED_IN_BUILD_STEP();
var ExtendsResolverError = class extends TypeBoxError {
};
var ExtendsResult;
(function(ExtendsResult2) {
  ExtendsResult2[ExtendsResult2["Union"] = 0] = "Union";
  ExtendsResult2[ExtendsResult2["True"] = 1] = "True";
  ExtendsResult2[ExtendsResult2["False"] = 2] = "False";
})(ExtendsResult || (ExtendsResult = {}));
function IntoBooleanResult(result) {
  return result === ExtendsResult.False ? result : ExtendsResult.True;
}
function Throw(message) {
  throw new ExtendsResolverError(message);
}
function IsStructuralRight(right) {
  return type_exports.IsNever(right) || type_exports.IsIntersect(right) || type_exports.IsUnion(right) || type_exports.IsUnknown(right) || type_exports.IsAny(right);
}
function StructuralRight(left, right) {
  return type_exports.IsNever(right) ? FromNeverRight(left, right) : type_exports.IsIntersect(right) ? FromIntersectRight(left, right) : type_exports.IsUnion(right) ? FromUnionRight(left, right) : type_exports.IsUnknown(right) ? FromUnknownRight(left, right) : type_exports.IsAny(right) ? FromAnyRight(left, right) : Throw("StructuralRight");
}
function FromAnyRight(left, right) {
  return ExtendsResult.True;
}
function FromAny(left, right) {
  return type_exports.IsIntersect(right) ? FromIntersectRight(left, right) : type_exports.IsUnion(right) && right.anyOf.some((schema) => type_exports.IsAny(schema) || type_exports.IsUnknown(schema)) ? ExtendsResult.True : type_exports.IsUnion(right) ? ExtendsResult.Union : type_exports.IsUnknown(right) ? ExtendsResult.True : type_exports.IsAny(right) ? ExtendsResult.True : ExtendsResult.Union;
}
function FromArrayRight(left, right) {
  return type_exports.IsUnknown(left) ? ExtendsResult.False : type_exports.IsAny(left) ? ExtendsResult.Union : type_exports.IsNever(left) ? ExtendsResult.True : ExtendsResult.False;
}
function FromArray4(left, right) {
  return type_exports.IsObject(right) && IsObjectArrayLike(right) ? ExtendsResult.True : IsStructuralRight(right) ? StructuralRight(left, right) : !type_exports.IsArray(right) ? ExtendsResult.False : IntoBooleanResult(Visit3(left.items, right.items));
}
function FromAsyncIterator(left, right) {
  return IsStructuralRight(right) ? StructuralRight(left, right) : !type_exports.IsAsyncIterator(right) ? ExtendsResult.False : IntoBooleanResult(Visit3(left.items, right.items));
}
function FromBigInt(left, right) {
  return IsStructuralRight(right) ? StructuralRight(left, right) : type_exports.IsObject(right) ? FromObjectRight(left, right) : type_exports.IsRecord(right) ? FromRecordRight(left, right) : type_exports.IsBigInt(right) ? ExtendsResult.True : ExtendsResult.False;
}
function FromBooleanRight(left, right) {
  return type_exports.IsLiteralBoolean(left) ? ExtendsResult.True : type_exports.IsBoolean(left) ? ExtendsResult.True : ExtendsResult.False;
}
function FromBoolean(left, right) {
  return IsStructuralRight(right) ? StructuralRight(left, right) : type_exports.IsObject(right) ? FromObjectRight(left, right) : type_exports.IsRecord(right) ? FromRecordRight(left, right) : type_exports.IsBoolean(right) ? ExtendsResult.True : ExtendsResult.False;
}
function FromConstructor(left, right) {
  return IsStructuralRight(right) ? StructuralRight(left, right) : type_exports.IsObject(right) ? FromObjectRight(left, right) : !type_exports.IsConstructor(right) ? ExtendsResult.False : left.parameters.length > right.parameters.length ? ExtendsResult.False : !left.parameters.every((schema, index) => IntoBooleanResult(Visit3(right.parameters[index], schema)) === ExtendsResult.True) ? ExtendsResult.False : IntoBooleanResult(Visit3(left.returns, right.returns));
}
function FromDate(left, right) {
  return IsStructuralRight(right) ? StructuralRight(left, right) : type_exports.IsObject(right) ? FromObjectRight(left, right) : type_exports.IsRecord(right) ? FromRecordRight(left, right) : type_exports.IsDate(right) ? ExtendsResult.True : ExtendsResult.False;
}
function FromFunction(left, right) {
  return IsStructuralRight(right) ? StructuralRight(left, right) : type_exports.IsObject(right) ? FromObjectRight(left, right) : !type_exports.IsFunction(right) ? ExtendsResult.False : left.parameters.length > right.parameters.length ? ExtendsResult.False : !left.parameters.every((schema, index) => IntoBooleanResult(Visit3(right.parameters[index], schema)) === ExtendsResult.True) ? ExtendsResult.False : IntoBooleanResult(Visit3(left.returns, right.returns));
}
function FromIntegerRight(left, right) {
  return type_exports.IsLiteral(left) && value_exports.IsNumber(left.const) ? ExtendsResult.True : type_exports.IsNumber(left) || type_exports.IsInteger(left) ? ExtendsResult.True : ExtendsResult.False;
}
function FromInteger(left, right) {
  return type_exports.IsInteger(right) || type_exports.IsNumber(right) ? ExtendsResult.True : IsStructuralRight(right) ? StructuralRight(left, right) : type_exports.IsObject(right) ? FromObjectRight(left, right) : type_exports.IsRecord(right) ? FromRecordRight(left, right) : ExtendsResult.False;
}
function FromIntersectRight(left, right) {
  return right.allOf.every((schema) => Visit3(left, schema) === ExtendsResult.True) ? ExtendsResult.True : ExtendsResult.False;
}
function FromIntersect4(left, right) {
  return left.allOf.some((schema) => Visit3(schema, right) === ExtendsResult.True) ? ExtendsResult.True : ExtendsResult.False;
}
function FromIterator(left, right) {
  return IsStructuralRight(right) ? StructuralRight(left, right) : !type_exports.IsIterator(right) ? ExtendsResult.False : IntoBooleanResult(Visit3(left.items, right.items));
}
function FromLiteral2(left, right) {
  return type_exports.IsLiteral(right) && right.const === left.const ? ExtendsResult.True : IsStructuralRight(right) ? StructuralRight(left, right) : type_exports.IsObject(right) ? FromObjectRight(left, right) : type_exports.IsRecord(right) ? FromRecordRight(left, right) : type_exports.IsString(right) ? FromStringRight(left, right) : type_exports.IsNumber(right) ? FromNumberRight(left, right) : type_exports.IsInteger(right) ? FromIntegerRight(left, right) : type_exports.IsBoolean(right) ? FromBooleanRight(left, right) : ExtendsResult.False;
}
function FromNeverRight(left, right) {
  return ExtendsResult.False;
}
function FromNever(left, right) {
  return ExtendsResult.True;
}
function UnwrapTNot(schema) {
  let [current, depth] = [schema, 0];
  while (true) {
    if (!type_exports.IsNot(current))
      break;
    current = current.not;
    depth += 1;
  }
  return depth % 2 === 0 ? current : Unknown();
}
function FromNot(left, right) {
  return type_exports.IsNot(left) ? Visit3(UnwrapTNot(left), right) : type_exports.IsNot(right) ? Visit3(left, UnwrapTNot(right)) : Throw("Invalid fallthrough for Not");
}
function FromNull(left, right) {
  return IsStructuralRight(right) ? StructuralRight(left, right) : type_exports.IsObject(right) ? FromObjectRight(left, right) : type_exports.IsRecord(right) ? FromRecordRight(left, right) : type_exports.IsNull(right) ? ExtendsResult.True : ExtendsResult.False;
}
function FromNumberRight(left, right) {
  return type_exports.IsLiteralNumber(left) ? ExtendsResult.True : type_exports.IsNumber(left) || type_exports.IsInteger(left) ? ExtendsResult.True : ExtendsResult.False;
}
function FromNumber(left, right) {
  return IsStructuralRight(right) ? StructuralRight(left, right) : type_exports.IsObject(right) ? FromObjectRight(left, right) : type_exports.IsRecord(right) ? FromRecordRight(left, right) : type_exports.IsInteger(right) || type_exports.IsNumber(right) ? ExtendsResult.True : ExtendsResult.False;
}
function IsObjectPropertyCount(schema, count) {
  return Object.getOwnPropertyNames(schema.properties).length === count;
}
function IsObjectStringLike(schema) {
  return IsObjectArrayLike(schema);
}
function IsObjectSymbolLike(schema) {
  return IsObjectPropertyCount(schema, 0) || IsObjectPropertyCount(schema, 1) && "description" in schema.properties && type_exports.IsUnion(schema.properties.description) && schema.properties.description.anyOf.length === 2 && (type_exports.IsString(schema.properties.description.anyOf[0]) && type_exports.IsUndefined(schema.properties.description.anyOf[1]) || type_exports.IsString(schema.properties.description.anyOf[1]) && type_exports.IsUndefined(schema.properties.description.anyOf[0]));
}
function IsObjectNumberLike(schema) {
  return IsObjectPropertyCount(schema, 0);
}
function IsObjectBooleanLike(schema) {
  return IsObjectPropertyCount(schema, 0);
}
function IsObjectBigIntLike(schema) {
  return IsObjectPropertyCount(schema, 0);
}
function IsObjectDateLike(schema) {
  return IsObjectPropertyCount(schema, 0);
}
function IsObjectUint8ArrayLike(schema) {
  return IsObjectArrayLike(schema);
}
function IsObjectFunctionLike(schema) {
  const length = Number2();
  return IsObjectPropertyCount(schema, 0) || IsObjectPropertyCount(schema, 1) && "length" in schema.properties && IntoBooleanResult(Visit3(schema.properties["length"], length)) === ExtendsResult.True;
}
function IsObjectConstructorLike(schema) {
  return IsObjectPropertyCount(schema, 0);
}
function IsObjectArrayLike(schema) {
  const length = Number2();
  return IsObjectPropertyCount(schema, 0) || IsObjectPropertyCount(schema, 1) && "length" in schema.properties && IntoBooleanResult(Visit3(schema.properties["length"], length)) === ExtendsResult.True;
}
function IsObjectPromiseLike(schema) {
  const then = Function2([Any()], Any());
  return IsObjectPropertyCount(schema, 0) || IsObjectPropertyCount(schema, 1) && "then" in schema.properties && IntoBooleanResult(Visit3(schema.properties["then"], then)) === ExtendsResult.True;
}
function Property(left, right) {
  return Visit3(left, right) === ExtendsResult.False ? ExtendsResult.False : type_exports.IsOptional(left) && !type_exports.IsOptional(right) ? ExtendsResult.False : ExtendsResult.True;
}
function FromObjectRight(left, right) {
  return type_exports.IsUnknown(left) ? ExtendsResult.False : type_exports.IsAny(left) ? ExtendsResult.Union : type_exports.IsNever(left) || type_exports.IsLiteralString(left) && IsObjectStringLike(right) || type_exports.IsLiteralNumber(left) && IsObjectNumberLike(right) || type_exports.IsLiteralBoolean(left) && IsObjectBooleanLike(right) || type_exports.IsSymbol(left) && IsObjectSymbolLike(right) || type_exports.IsBigInt(left) && IsObjectBigIntLike(right) || type_exports.IsString(left) && IsObjectStringLike(right) || type_exports.IsSymbol(left) && IsObjectSymbolLike(right) || type_exports.IsNumber(left) && IsObjectNumberLike(right) || type_exports.IsInteger(left) && IsObjectNumberLike(right) || type_exports.IsBoolean(left) && IsObjectBooleanLike(right) || type_exports.IsUint8Array(left) && IsObjectUint8ArrayLike(right) || type_exports.IsDate(left) && IsObjectDateLike(right) || type_exports.IsConstructor(left) && IsObjectConstructorLike(right) || type_exports.IsFunction(left) && IsObjectFunctionLike(right) ? ExtendsResult.True : type_exports.IsRecord(left) && type_exports.IsString(RecordKey(left)) ? (() => {
    return right[Hint] === "Record" ? ExtendsResult.True : ExtendsResult.False;
  })() : type_exports.IsRecord(left) && type_exports.IsNumber(RecordKey(left)) ? (() => {
    return IsObjectPropertyCount(right, 0) ? ExtendsResult.True : ExtendsResult.False;
  })() : ExtendsResult.False;
}
function FromObject(left, right) {
  return IsStructuralRight(right) ? StructuralRight(left, right) : type_exports.IsRecord(right) ? FromRecordRight(left, right) : !type_exports.IsObject(right) ? ExtendsResult.False : (() => {
    for (const key of Object.getOwnPropertyNames(right.properties)) {
      if (!(key in left.properties) && !type_exports.IsOptional(right.properties[key])) {
        return ExtendsResult.False;
      }
      if (type_exports.IsOptional(right.properties[key])) {
        return ExtendsResult.True;
      }
      if (Property(left.properties[key], right.properties[key]) === ExtendsResult.False) {
        return ExtendsResult.False;
      }
    }
    return ExtendsResult.True;
  })();
}
function FromPromise2(left, right) {
  return IsStructuralRight(right) ? StructuralRight(left, right) : type_exports.IsObject(right) && IsObjectPromiseLike(right) ? ExtendsResult.True : !type_exports.IsPromise(right) ? ExtendsResult.False : IntoBooleanResult(Visit3(left.item, right.item));
}
function RecordKey(schema) {
  return PatternNumberExact in schema.patternProperties ? Number2() : PatternStringExact in schema.patternProperties ? String2() : Throw("Unknown record key pattern");
}
function RecordValue(schema) {
  return PatternNumberExact in schema.patternProperties ? schema.patternProperties[PatternNumberExact] : PatternStringExact in schema.patternProperties ? schema.patternProperties[PatternStringExact] : Throw("Unable to get record value schema");
}
function FromRecordRight(left, right) {
  const [Key2, Value] = [RecordKey(right), RecordValue(right)];
  return type_exports.IsLiteralString(left) && type_exports.IsNumber(Key2) && IntoBooleanResult(Visit3(left, Value)) === ExtendsResult.True ? ExtendsResult.True : type_exports.IsUint8Array(left) && type_exports.IsNumber(Key2) ? Visit3(left, Value) : type_exports.IsString(left) && type_exports.IsNumber(Key2) ? Visit3(left, Value) : type_exports.IsArray(left) && type_exports.IsNumber(Key2) ? Visit3(left, Value) : type_exports.IsObject(left) ? (() => {
    for (const key of Object.getOwnPropertyNames(left.properties)) {
      if (Property(Value, left.properties[key]) === ExtendsResult.False) {
        return ExtendsResult.False;
      }
    }
    return ExtendsResult.True;
  })() : ExtendsResult.False;
}
function FromRecord(left, right) {
  return IsStructuralRight(right) ? StructuralRight(left, right) : type_exports.IsObject(right) ? FromObjectRight(left, right) : !type_exports.IsRecord(right) ? ExtendsResult.False : Visit3(RecordValue(left), RecordValue(right));
}
function FromRegExp(left, right) {
  const L3 = type_exports.IsRegExp(left) ? String2() : left;
  const R3 = type_exports.IsRegExp(right) ? String2() : right;
  return Visit3(L3, R3);
}
function FromStringRight(left, right) {
  return type_exports.IsLiteral(left) && value_exports.IsString(left.const) ? ExtendsResult.True : type_exports.IsString(left) ? ExtendsResult.True : ExtendsResult.False;
}
function FromString(left, right) {
  return IsStructuralRight(right) ? StructuralRight(left, right) : type_exports.IsObject(right) ? FromObjectRight(left, right) : type_exports.IsRecord(right) ? FromRecordRight(left, right) : type_exports.IsString(right) ? ExtendsResult.True : ExtendsResult.False;
}
function FromSymbol(left, right) {
  return IsStructuralRight(right) ? StructuralRight(left, right) : type_exports.IsObject(right) ? FromObjectRight(left, right) : type_exports.IsRecord(right) ? FromRecordRight(left, right) : type_exports.IsSymbol(right) ? ExtendsResult.True : ExtendsResult.False;
}
function FromTemplateLiteral2(left, right) {
  return type_exports.IsTemplateLiteral(left) ? Visit3(TemplateLiteralToUnion(left), right) : type_exports.IsTemplateLiteral(right) ? Visit3(left, TemplateLiteralToUnion(right)) : Throw("Invalid fallthrough for TemplateLiteral");
}
function IsArrayOfTuple(left, right) {
  return type_exports.IsArray(right) && left.items !== void 0 && left.items.every((schema) => Visit3(schema, right.items) === ExtendsResult.True);
}
function FromTupleRight(left, right) {
  return type_exports.IsNever(left) ? ExtendsResult.True : type_exports.IsUnknown(left) ? ExtendsResult.False : type_exports.IsAny(left) ? ExtendsResult.Union : ExtendsResult.False;
}
function FromTuple3(left, right) {
  return IsStructuralRight(right) ? StructuralRight(left, right) : type_exports.IsObject(right) && IsObjectArrayLike(right) ? ExtendsResult.True : type_exports.IsArray(right) && IsArrayOfTuple(left, right) ? ExtendsResult.True : !type_exports.IsTuple(right) ? ExtendsResult.False : value_exports.IsUndefined(left.items) && !value_exports.IsUndefined(right.items) || !value_exports.IsUndefined(left.items) && value_exports.IsUndefined(right.items) ? ExtendsResult.False : value_exports.IsUndefined(left.items) && !value_exports.IsUndefined(right.items) ? ExtendsResult.True : left.items.every((schema, index) => Visit3(schema, right.items[index]) === ExtendsResult.True) ? ExtendsResult.True : ExtendsResult.False;
}
function FromUint8Array(left, right) {
  return IsStructuralRight(right) ? StructuralRight(left, right) : type_exports.IsObject(right) ? FromObjectRight(left, right) : type_exports.IsRecord(right) ? FromRecordRight(left, right) : type_exports.IsUint8Array(right) ? ExtendsResult.True : ExtendsResult.False;
}
function FromUndefined(left, right) {
  return IsStructuralRight(right) ? StructuralRight(left, right) : type_exports.IsObject(right) ? FromObjectRight(left, right) : type_exports.IsRecord(right) ? FromRecordRight(left, right) : type_exports.IsVoid(right) ? FromVoidRight(left, right) : type_exports.IsUndefined(right) ? ExtendsResult.True : ExtendsResult.False;
}
function FromUnionRight(left, right) {
  return right.anyOf.some((schema) => Visit3(left, schema) === ExtendsResult.True) ? ExtendsResult.True : ExtendsResult.False;
}
function FromUnion6(left, right) {
  return left.anyOf.every((schema) => Visit3(schema, right) === ExtendsResult.True) ? ExtendsResult.True : ExtendsResult.False;
}
function FromUnknownRight(left, right) {
  return ExtendsResult.True;
}
function FromUnknown(left, right) {
  return type_exports.IsNever(right) ? FromNeverRight(left, right) : type_exports.IsIntersect(right) ? FromIntersectRight(left, right) : type_exports.IsUnion(right) ? FromUnionRight(left, right) : type_exports.IsAny(right) ? FromAnyRight(left, right) : type_exports.IsString(right) ? FromStringRight(left, right) : type_exports.IsNumber(right) ? FromNumberRight(left, right) : type_exports.IsInteger(right) ? FromIntegerRight(left, right) : type_exports.IsBoolean(right) ? FromBooleanRight(left, right) : type_exports.IsArray(right) ? FromArrayRight(left, right) : type_exports.IsTuple(right) ? FromTupleRight(left, right) : type_exports.IsObject(right) ? FromObjectRight(left, right) : type_exports.IsUnknown(right) ? ExtendsResult.True : ExtendsResult.False;
}
function FromVoidRight(left, right) {
  return type_exports.IsUndefined(left) ? ExtendsResult.True : type_exports.IsUndefined(left) ? ExtendsResult.True : ExtendsResult.False;
}
function FromVoid(left, right) {
  return type_exports.IsIntersect(right) ? FromIntersectRight(left, right) : type_exports.IsUnion(right) ? FromUnionRight(left, right) : type_exports.IsUnknown(right) ? FromUnknownRight(left, right) : type_exports.IsAny(right) ? FromAnyRight(left, right) : type_exports.IsObject(right) ? FromObjectRight(left, right) : type_exports.IsVoid(right) ? ExtendsResult.True : ExtendsResult.False;
}
function Visit3(left, right) {
  return (
    // resolvable
    type_exports.IsTemplateLiteral(left) || type_exports.IsTemplateLiteral(right) ? FromTemplateLiteral2(left, right) : type_exports.IsRegExp(left) || type_exports.IsRegExp(right) ? FromRegExp(left, right) : type_exports.IsNot(left) || type_exports.IsNot(right) ? FromNot(left, right) : (
      // standard
      type_exports.IsAny(left) ? FromAny(left, right) : type_exports.IsArray(left) ? FromArray4(left, right) : type_exports.IsBigInt(left) ? FromBigInt(left, right) : type_exports.IsBoolean(left) ? FromBoolean(left, right) : type_exports.IsAsyncIterator(left) ? FromAsyncIterator(left, right) : type_exports.IsConstructor(left) ? FromConstructor(left, right) : type_exports.IsDate(left) ? FromDate(left, right) : type_exports.IsFunction(left) ? FromFunction(left, right) : type_exports.IsInteger(left) ? FromInteger(left, right) : type_exports.IsIntersect(left) ? FromIntersect4(left, right) : type_exports.IsIterator(left) ? FromIterator(left, right) : type_exports.IsLiteral(left) ? FromLiteral2(left, right) : type_exports.IsNever(left) ? FromNever(left, right) : type_exports.IsNull(left) ? FromNull(left, right) : type_exports.IsNumber(left) ? FromNumber(left, right) : type_exports.IsObject(left) ? FromObject(left, right) : type_exports.IsRecord(left) ? FromRecord(left, right) : type_exports.IsString(left) ? FromString(left, right) : type_exports.IsSymbol(left) ? FromSymbol(left, right) : type_exports.IsTuple(left) ? FromTuple3(left, right) : type_exports.IsPromise(left) ? FromPromise2(left, right) : type_exports.IsUint8Array(left) ? FromUint8Array(left, right) : type_exports.IsUndefined(left) ? FromUndefined(left, right) : type_exports.IsUnion(left) ? FromUnion6(left, right) : type_exports.IsUnknown(left) ? FromUnknown(left, right) : type_exports.IsVoid(left) ? FromVoid(left, right) : Throw(`Unknown left type operand '${left[Kind]}'`)
    )
  );
}
function ExtendsCheck(left, right) {
  return Visit3(left, right);
}

// ../../../node_modules/.pnpm/@sinclair+typebox@0.34.33/node_modules/@sinclair/typebox/build/esm/type/extends/extends-from-mapped-key.mjs
init_define_ENV_DEFINED_IN_BUILD_STEP();

// ../../../node_modules/.pnpm/@sinclair+typebox@0.34.33/node_modules/@sinclair/typebox/build/esm/type/extends/extends.mjs
init_define_ENV_DEFINED_IN_BUILD_STEP();

// ../../../node_modules/.pnpm/@sinclair+typebox@0.34.33/node_modules/@sinclair/typebox/build/esm/type/extends/extends-from-mapped-result.mjs
init_define_ENV_DEFINED_IN_BUILD_STEP();
function FromProperties8(P3, Right, True, False, options) {
  const Acc = {};
  for (const K2 of globalThis.Object.getOwnPropertyNames(P3))
    Acc[K2] = Extends(P3[K2], Right, True, False, Clone(options));
  return Acc;
}
function FromMappedResult6(Left, Right, True, False, options) {
  return FromProperties8(Left.properties, Right, True, False, options);
}
function ExtendsFromMappedResult(Left, Right, True, False, options) {
  const P3 = FromMappedResult6(Left, Right, True, False, options);
  return MappedResult(P3);
}

// ../../../node_modules/.pnpm/@sinclair+typebox@0.34.33/node_modules/@sinclair/typebox/build/esm/type/extends/extends.mjs
function ExtendsResolve(left, right, trueType, falseType) {
  const R3 = ExtendsCheck(left, right);
  return R3 === ExtendsResult.Union ? Union([trueType, falseType]) : R3 === ExtendsResult.True ? trueType : falseType;
}
function Extends(L3, R3, T3, F2, options) {
  return IsMappedResult(L3) ? ExtendsFromMappedResult(L3, R3, T3, F2, options) : IsMappedKey(L3) ? CreateType(ExtendsFromMappedKey(L3, R3, T3, F2, options)) : CreateType(ExtendsResolve(L3, R3, T3, F2), options);
}

// ../../../node_modules/.pnpm/@sinclair+typebox@0.34.33/node_modules/@sinclair/typebox/build/esm/type/extends/extends-from-mapped-key.mjs
function FromPropertyKey(K, U2, L3, R3, options) {
  return {
    [K]: Extends(Literal(K), U2, L3, R3, Clone(options))
  };
}
function FromPropertyKeys(K, U2, L3, R3, options) {
  return K.reduce((Acc, LK) => {
    return { ...Acc, ...FromPropertyKey(LK, U2, L3, R3, options) };
  }, {});
}
function FromMappedKey2(K, U2, L3, R3, options) {
  return FromPropertyKeys(K.keys, U2, L3, R3, options);
}
function ExtendsFromMappedKey(T3, U2, L3, R3, options) {
  const P3 = FromMappedKey2(T3, U2, L3, R3, options);
  return MappedResult(P3);
}

// ../../../node_modules/.pnpm/@sinclair+typebox@0.34.33/node_modules/@sinclair/typebox/build/esm/type/extends/extends-undefined.mjs
init_define_ENV_DEFINED_IN_BUILD_STEP();
function Intersect2(schema) {
  return schema.allOf.every((schema2) => ExtendsUndefinedCheck(schema2));
}
function Union2(schema) {
  return schema.anyOf.some((schema2) => ExtendsUndefinedCheck(schema2));
}
function Not(schema) {
  return !ExtendsUndefinedCheck(schema.not);
}
function ExtendsUndefinedCheck(schema) {
  return schema[Kind] === "Intersect" ? Intersect2(schema) : schema[Kind] === "Union" ? Union2(schema) : schema[Kind] === "Not" ? Not(schema) : schema[Kind] === "Undefined" ? true : false;
}

// ../../../node_modules/.pnpm/@sinclair+typebox@0.34.33/node_modules/@sinclair/typebox/build/esm/type/exclude/exclude-from-template-literal.mjs
init_define_ENV_DEFINED_IN_BUILD_STEP();
function ExcludeFromTemplateLiteral(L3, R3) {
  return Exclude(TemplateLiteralToUnion(L3), R3);
}

// ../../../node_modules/.pnpm/@sinclair+typebox@0.34.33/node_modules/@sinclair/typebox/build/esm/type/exclude/exclude.mjs
function ExcludeRest(L3, R3) {
  const excluded = L3.filter((inner) => ExtendsCheck(inner, R3) === ExtendsResult.False);
  return excluded.length === 1 ? excluded[0] : Union(excluded);
}
function Exclude(L3, R3, options = {}) {
  if (IsTemplateLiteral(L3))
    return CreateType(ExcludeFromTemplateLiteral(L3, R3), options);
  if (IsMappedResult(L3))
    return CreateType(ExcludeFromMappedResult(L3, R3), options);
  return CreateType(IsUnion(L3) ? ExcludeRest(L3.anyOf, R3) : ExtendsCheck(L3, R3) !== ExtendsResult.False ? Never() : L3, options);
}

// ../../../node_modules/.pnpm/@sinclair+typebox@0.34.33/node_modules/@sinclair/typebox/build/esm/type/exclude/exclude-from-mapped-result.mjs
function FromProperties9(P3, U2) {
  const Acc = {};
  for (const K2 of globalThis.Object.getOwnPropertyNames(P3))
    Acc[K2] = Exclude(P3[K2], U2);
  return Acc;
}
function FromMappedResult7(R3, T3) {
  return FromProperties9(R3.properties, T3);
}
function ExcludeFromMappedResult(R3, T3) {
  const P3 = FromMappedResult7(R3, T3);
  return MappedResult(P3);
}

// ../../../node_modules/.pnpm/@sinclair+typebox@0.34.33/node_modules/@sinclair/typebox/build/esm/type/extract/extract-from-mapped-result.mjs
init_define_ENV_DEFINED_IN_BUILD_STEP();

// ../../../node_modules/.pnpm/@sinclair+typebox@0.34.33/node_modules/@sinclair/typebox/build/esm/type/extract/extract.mjs
init_define_ENV_DEFINED_IN_BUILD_STEP();

// ../../../node_modules/.pnpm/@sinclair+typebox@0.34.33/node_modules/@sinclair/typebox/build/esm/type/extract/extract-from-template-literal.mjs
init_define_ENV_DEFINED_IN_BUILD_STEP();
function ExtractFromTemplateLiteral(L3, R3) {
  return Extract(TemplateLiteralToUnion(L3), R3);
}

// ../../../node_modules/.pnpm/@sinclair+typebox@0.34.33/node_modules/@sinclair/typebox/build/esm/type/extract/extract.mjs
function ExtractRest(L3, R3) {
  const extracted = L3.filter((inner) => ExtendsCheck(inner, R3) !== ExtendsResult.False);
  return extracted.length === 1 ? extracted[0] : Union(extracted);
}
function Extract(L3, R3, options) {
  if (IsTemplateLiteral(L3))
    return CreateType(ExtractFromTemplateLiteral(L3, R3), options);
  if (IsMappedResult(L3))
    return CreateType(ExtractFromMappedResult(L3, R3), options);
  return CreateType(IsUnion(L3) ? ExtractRest(L3.anyOf, R3) : ExtendsCheck(L3, R3) !== ExtendsResult.False ? L3 : Never(), options);
}

// ../../../node_modules/.pnpm/@sinclair+typebox@0.34.33/node_modules/@sinclair/typebox/build/esm/type/extract/extract-from-mapped-result.mjs
function FromProperties10(P3, T3) {
  const Acc = {};
  for (const K2 of globalThis.Object.getOwnPropertyNames(P3))
    Acc[K2] = Extract(P3[K2], T3);
  return Acc;
}
function FromMappedResult8(R3, T3) {
  return FromProperties10(R3.properties, T3);
}
function ExtractFromMappedResult(R3, T3) {
  const P3 = FromMappedResult8(R3, T3);
  return MappedResult(P3);
}

// ../../../node_modules/.pnpm/@sinclair+typebox@0.34.33/node_modules/@sinclair/typebox/build/esm/type/instance-type/instance-type.mjs
init_define_ENV_DEFINED_IN_BUILD_STEP();
function InstanceType(schema, options) {
  return IsConstructor(schema) ? CreateType(schema.returns, options) : Never(options);
}

// ../../../node_modules/.pnpm/@sinclair+typebox@0.34.33/node_modules/@sinclair/typebox/build/esm/type/instantiate/instantiate.mjs
init_define_ENV_DEFINED_IN_BUILD_STEP();

// ../../../node_modules/.pnpm/@sinclair+typebox@0.34.33/node_modules/@sinclair/typebox/build/esm/type/readonly-optional/readonly-optional.mjs
init_define_ENV_DEFINED_IN_BUILD_STEP();
function ReadonlyOptional(schema) {
  return Readonly(Optional(schema));
}

// ../../../node_modules/.pnpm/@sinclair+typebox@0.34.33/node_modules/@sinclair/typebox/build/esm/type/record/record.mjs
init_define_ENV_DEFINED_IN_BUILD_STEP();
function RecordCreateFromPattern(pattern, T3, options) {
  return CreateType({ [Kind]: "Record", type: "object", patternProperties: { [pattern]: T3 } }, options);
}
function RecordCreateFromKeys(K, T3, options) {
  const result = {};
  for (const K2 of K)
    result[K2] = T3;
  return Object2(result, { ...options, [Hint]: "Record" });
}
function FromTemplateLiteralKey(K, T3, options) {
  return IsTemplateLiteralFinite(K) ? RecordCreateFromKeys(IndexPropertyKeys(K), T3, options) : RecordCreateFromPattern(K.pattern, T3, options);
}
function FromUnionKey(key, type, options) {
  return RecordCreateFromKeys(IndexPropertyKeys(Union(key)), type, options);
}
function FromLiteralKey(key, type, options) {
  return RecordCreateFromKeys([key.toString()], type, options);
}
function FromRegExpKey(key, type, options) {
  return RecordCreateFromPattern(key.source, type, options);
}
function FromStringKey(key, type, options) {
  const pattern = IsUndefined(key.pattern) ? PatternStringExact : key.pattern;
  return RecordCreateFromPattern(pattern, type, options);
}
function FromAnyKey(_3, type, options) {
  return RecordCreateFromPattern(PatternStringExact, type, options);
}
function FromNeverKey(_key, type, options) {
  return RecordCreateFromPattern(PatternNeverExact, type, options);
}
function FromBooleanKey(_key, type, options) {
  return Object2({ true: type, false: type }, options);
}
function FromIntegerKey(_key, type, options) {
  return RecordCreateFromPattern(PatternNumberExact, type, options);
}
function FromNumberKey(_3, type, options) {
  return RecordCreateFromPattern(PatternNumberExact, type, options);
}
function Record(key, type, options = {}) {
  return IsUnion(key) ? FromUnionKey(key.anyOf, type, options) : IsTemplateLiteral(key) ? FromTemplateLiteralKey(key, type, options) : IsLiteral(key) ? FromLiteralKey(key.const, type, options) : IsBoolean3(key) ? FromBooleanKey(key, type, options) : IsInteger2(key) ? FromIntegerKey(key, type, options) : IsNumber3(key) ? FromNumberKey(key, type, options) : IsRegExp2(key) ? FromRegExpKey(key, type, options) : IsString3(key) ? FromStringKey(key, type, options) : IsAny(key) ? FromAnyKey(key, type, options) : IsNever(key) ? FromNeverKey(key, type, options) : Never(options);
}
function RecordPattern(record) {
  return globalThis.Object.getOwnPropertyNames(record.patternProperties)[0];
}
function RecordKey2(type) {
  const pattern = RecordPattern(type);
  return pattern === PatternStringExact ? String2() : pattern === PatternNumberExact ? Number2() : String2({ pattern });
}
function RecordValue2(type) {
  return type.patternProperties[RecordPattern(type)];
}

// ../../../node_modules/.pnpm/@sinclair+typebox@0.34.33/node_modules/@sinclair/typebox/build/esm/type/instantiate/instantiate.mjs
function FromConstructor2(args, type) {
  type.parameters = FromTypes(args, type.parameters);
  type.returns = FromType(args, type.returns);
  return type;
}
function FromFunction2(args, type) {
  type.parameters = FromTypes(args, type.parameters);
  type.returns = FromType(args, type.returns);
  return type;
}
function FromIntersect5(args, type) {
  type.allOf = FromTypes(args, type.allOf);
  return type;
}
function FromUnion7(args, type) {
  type.anyOf = FromTypes(args, type.anyOf);
  return type;
}
function FromTuple4(args, type) {
  if (IsUndefined(type.items))
    return type;
  type.items = FromTypes(args, type.items);
  return type;
}
function FromArray5(args, type) {
  type.items = FromType(args, type.items);
  return type;
}
function FromAsyncIterator2(args, type) {
  type.items = FromType(args, type.items);
  return type;
}
function FromIterator2(args, type) {
  type.items = FromType(args, type.items);
  return type;
}
function FromPromise3(args, type) {
  type.item = FromType(args, type.item);
  return type;
}
function FromObject2(args, type) {
  const mappedProperties = FromProperties11(args, type.properties);
  return { ...type, ...Object2(mappedProperties) };
}
function FromRecord2(args, type) {
  const mappedKey = FromType(args, RecordKey2(type));
  const mappedValue = FromType(args, RecordValue2(type));
  const result = Record(mappedKey, mappedValue);
  return { ...type, ...result };
}
function FromArgument(args, argument) {
  return argument.index in args ? args[argument.index] : Unknown();
}
function FromProperty2(args, type) {
  const isReadonly = IsReadonly(type);
  const isOptional = IsOptional(type);
  const mapped = FromType(args, type);
  return isReadonly && isOptional ? ReadonlyOptional(mapped) : isReadonly && !isOptional ? Readonly(mapped) : !isReadonly && isOptional ? Optional(mapped) : mapped;
}
function FromProperties11(args, properties) {
  return globalThis.Object.getOwnPropertyNames(properties).reduce((result, key) => {
    return { ...result, [key]: FromProperty2(args, properties[key]) };
  }, {});
}
function FromTypes(args, types) {
  return types.map((type) => FromType(args, type));
}
function FromType(args, type) {
  return IsConstructor(type) ? FromConstructor2(args, type) : IsFunction3(type) ? FromFunction2(args, type) : IsIntersect(type) ? FromIntersect5(args, type) : IsUnion(type) ? FromUnion7(args, type) : IsTuple(type) ? FromTuple4(args, type) : IsArray3(type) ? FromArray5(args, type) : IsAsyncIterator3(type) ? FromAsyncIterator2(args, type) : IsIterator3(type) ? FromIterator2(args, type) : IsPromise2(type) ? FromPromise3(args, type) : IsObject3(type) ? FromObject2(args, type) : IsRecord(type) ? FromRecord2(args, type) : IsArgument(type) ? FromArgument(args, type) : type;
}
function Instantiate(type, args) {
  return FromType(args, CloneType(type));
}

// ../../../node_modules/.pnpm/@sinclair+typebox@0.34.33/node_modules/@sinclair/typebox/build/esm/type/integer/integer.mjs
init_define_ENV_DEFINED_IN_BUILD_STEP();
function Integer(options) {
  return CreateType({ [Kind]: "Integer", type: "integer" }, options);
}

// ../../../node_modules/.pnpm/@sinclair+typebox@0.34.33/node_modules/@sinclair/typebox/build/esm/type/intrinsic/capitalize.mjs
init_define_ENV_DEFINED_IN_BUILD_STEP();

// ../../../node_modules/.pnpm/@sinclair+typebox@0.34.33/node_modules/@sinclair/typebox/build/esm/type/intrinsic/intrinsic.mjs
init_define_ENV_DEFINED_IN_BUILD_STEP();

// ../../../node_modules/.pnpm/@sinclair+typebox@0.34.33/node_modules/@sinclair/typebox/build/esm/type/intrinsic/intrinsic-from-mapped-key.mjs
init_define_ENV_DEFINED_IN_BUILD_STEP();
function MappedIntrinsicPropertyKey(K, M2, options) {
  return {
    [K]: Intrinsic(Literal(K), M2, Clone(options))
  };
}
function MappedIntrinsicPropertyKeys(K, M2, options) {
  const result = K.reduce((Acc, L3) => {
    return { ...Acc, ...MappedIntrinsicPropertyKey(L3, M2, options) };
  }, {});
  return result;
}
function MappedIntrinsicProperties(T3, M2, options) {
  return MappedIntrinsicPropertyKeys(T3["keys"], M2, options);
}
function IntrinsicFromMappedKey(T3, M2, options) {
  const P3 = MappedIntrinsicProperties(T3, M2, options);
  return MappedResult(P3);
}

// ../../../node_modules/.pnpm/@sinclair+typebox@0.34.33/node_modules/@sinclair/typebox/build/esm/type/intrinsic/intrinsic.mjs
function ApplyUncapitalize(value) {
  const [first, rest] = [value.slice(0, 1), value.slice(1)];
  return [first.toLowerCase(), rest].join("");
}
function ApplyCapitalize(value) {
  const [first, rest] = [value.slice(0, 1), value.slice(1)];
  return [first.toUpperCase(), rest].join("");
}
function ApplyUppercase(value) {
  return value.toUpperCase();
}
function ApplyLowercase(value) {
  return value.toLowerCase();
}
function FromTemplateLiteral3(schema, mode, options) {
  const expression = TemplateLiteralParseExact(schema.pattern);
  const finite = IsTemplateLiteralExpressionFinite(expression);
  if (!finite)
    return { ...schema, pattern: FromLiteralValue(schema.pattern, mode) };
  const strings = [...TemplateLiteralExpressionGenerate(expression)];
  const literals = strings.map((value) => Literal(value));
  const mapped = FromRest5(literals, mode);
  const union = Union(mapped);
  return TemplateLiteral([union], options);
}
function FromLiteralValue(value, mode) {
  return typeof value === "string" ? mode === "Uncapitalize" ? ApplyUncapitalize(value) : mode === "Capitalize" ? ApplyCapitalize(value) : mode === "Uppercase" ? ApplyUppercase(value) : mode === "Lowercase" ? ApplyLowercase(value) : value : value.toString();
}
function FromRest5(T3, M2) {
  return T3.map((L3) => Intrinsic(L3, M2));
}
function Intrinsic(schema, mode, options = {}) {
  return (
    // Intrinsic-Mapped-Inference
    IsMappedKey(schema) ? IntrinsicFromMappedKey(schema, mode, options) : (
      // Standard-Inference
      IsTemplateLiteral(schema) ? FromTemplateLiteral3(schema, mode, options) : IsUnion(schema) ? Union(FromRest5(schema.anyOf, mode), options) : IsLiteral(schema) ? Literal(FromLiteralValue(schema.const, mode), options) : (
        // Default Type
        CreateType(schema, options)
      )
    )
  );
}

// ../../../node_modules/.pnpm/@sinclair+typebox@0.34.33/node_modules/@sinclair/typebox/build/esm/type/intrinsic/capitalize.mjs
function Capitalize(T3, options = {}) {
  return Intrinsic(T3, "Capitalize", options);
}

// ../../../node_modules/.pnpm/@sinclair+typebox@0.34.33/node_modules/@sinclair/typebox/build/esm/type/intrinsic/lowercase.mjs
init_define_ENV_DEFINED_IN_BUILD_STEP();
function Lowercase(T3, options = {}) {
  return Intrinsic(T3, "Lowercase", options);
}

// ../../../node_modules/.pnpm/@sinclair+typebox@0.34.33/node_modules/@sinclair/typebox/build/esm/type/intrinsic/uncapitalize.mjs
init_define_ENV_DEFINED_IN_BUILD_STEP();
function Uncapitalize(T3, options = {}) {
  return Intrinsic(T3, "Uncapitalize", options);
}

// ../../../node_modules/.pnpm/@sinclair+typebox@0.34.33/node_modules/@sinclair/typebox/build/esm/type/intrinsic/uppercase.mjs
init_define_ENV_DEFINED_IN_BUILD_STEP();
function Uppercase(T3, options = {}) {
  return Intrinsic(T3, "Uppercase", options);
}

// ../../../node_modules/.pnpm/@sinclair+typebox@0.34.33/node_modules/@sinclair/typebox/build/esm/type/module/module.mjs
init_define_ENV_DEFINED_IN_BUILD_STEP();

// ../../../node_modules/.pnpm/@sinclair+typebox@0.34.33/node_modules/@sinclair/typebox/build/esm/type/module/compute.mjs
init_define_ENV_DEFINED_IN_BUILD_STEP();

// ../../../node_modules/.pnpm/@sinclair+typebox@0.34.33/node_modules/@sinclair/typebox/build/esm/type/omit/omit-from-mapped-key.mjs
init_define_ENV_DEFINED_IN_BUILD_STEP();

// ../../../node_modules/.pnpm/@sinclair+typebox@0.34.33/node_modules/@sinclair/typebox/build/esm/type/omit/omit.mjs
init_define_ENV_DEFINED_IN_BUILD_STEP();

// ../../../node_modules/.pnpm/@sinclair+typebox@0.34.33/node_modules/@sinclair/typebox/build/esm/type/omit/omit-from-mapped-result.mjs
init_define_ENV_DEFINED_IN_BUILD_STEP();
function FromProperties12(properties, propertyKeys, options) {
  const result = {};
  for (const K2 of globalThis.Object.getOwnPropertyNames(properties))
    result[K2] = Omit(properties[K2], propertyKeys, Clone(options));
  return result;
}
function FromMappedResult9(mappedResult, propertyKeys, options) {
  return FromProperties12(mappedResult.properties, propertyKeys, options);
}
function OmitFromMappedResult(mappedResult, propertyKeys, options) {
  const properties = FromMappedResult9(mappedResult, propertyKeys, options);
  return MappedResult(properties);
}

// ../../../node_modules/.pnpm/@sinclair+typebox@0.34.33/node_modules/@sinclair/typebox/build/esm/type/omit/omit.mjs
function FromIntersect6(types, propertyKeys) {
  return types.map((type) => OmitResolve(type, propertyKeys));
}
function FromUnion8(types, propertyKeys) {
  return types.map((type) => OmitResolve(type, propertyKeys));
}
function FromProperty3(properties, key) {
  const { [key]: _3, ...R3 } = properties;
  return R3;
}
function FromProperties13(properties, propertyKeys) {
  return propertyKeys.reduce((T3, K2) => FromProperty3(T3, K2), properties);
}
function FromObject3(properties, propertyKeys) {
  const options = Discard(properties, [TransformKind, "$id", "required", "properties"]);
  const omittedProperties = FromProperties13(properties["properties"], propertyKeys);
  return Object2(omittedProperties, options);
}
function UnionFromPropertyKeys(propertyKeys) {
  const result = propertyKeys.reduce((result2, key) => IsLiteralValue(key) ? [...result2, Literal(key)] : result2, []);
  return Union(result);
}
function OmitResolve(properties, propertyKeys) {
  return IsIntersect(properties) ? Intersect(FromIntersect6(properties.allOf, propertyKeys)) : IsUnion(properties) ? Union(FromUnion8(properties.anyOf, propertyKeys)) : IsObject3(properties) ? FromObject3(properties, propertyKeys) : Object2({});
}
function Omit(type, key, options) {
  const typeKey = IsArray(key) ? UnionFromPropertyKeys(key) : key;
  const propertyKeys = IsSchema(key) ? IndexPropertyKeys(key) : key;
  const isTypeRef = IsRef(type);
  const isKeyRef = IsRef(key);
  return IsMappedResult(type) ? OmitFromMappedResult(type, propertyKeys, options) : IsMappedKey(key) ? OmitFromMappedKey(type, key, options) : isTypeRef && isKeyRef ? Computed("Omit", [type, typeKey], options) : !isTypeRef && isKeyRef ? Computed("Omit", [type, typeKey], options) : isTypeRef && !isKeyRef ? Computed("Omit", [type, typeKey], options) : CreateType({ ...OmitResolve(type, propertyKeys), ...options });
}

// ../../../node_modules/.pnpm/@sinclair+typebox@0.34.33/node_modules/@sinclair/typebox/build/esm/type/omit/omit-from-mapped-key.mjs
function FromPropertyKey2(type, key, options) {
  return { [key]: Omit(type, [key], Clone(options)) };
}
function FromPropertyKeys2(type, propertyKeys, options) {
  return propertyKeys.reduce((Acc, LK) => {
    return { ...Acc, ...FromPropertyKey2(type, LK, options) };
  }, {});
}
function FromMappedKey3(type, mappedKey, options) {
  return FromPropertyKeys2(type, mappedKey.keys, options);
}
function OmitFromMappedKey(type, mappedKey, options) {
  const properties = FromMappedKey3(type, mappedKey, options);
  return MappedResult(properties);
}

// ../../../node_modules/.pnpm/@sinclair+typebox@0.34.33/node_modules/@sinclair/typebox/build/esm/type/pick/pick-from-mapped-key.mjs
init_define_ENV_DEFINED_IN_BUILD_STEP();

// ../../../node_modules/.pnpm/@sinclair+typebox@0.34.33/node_modules/@sinclair/typebox/build/esm/type/pick/pick.mjs
init_define_ENV_DEFINED_IN_BUILD_STEP();

// ../../../node_modules/.pnpm/@sinclair+typebox@0.34.33/node_modules/@sinclair/typebox/build/esm/type/pick/pick-from-mapped-result.mjs
init_define_ENV_DEFINED_IN_BUILD_STEP();
function FromProperties14(properties, propertyKeys, options) {
  const result = {};
  for (const K2 of globalThis.Object.getOwnPropertyNames(properties))
    result[K2] = Pick(properties[K2], propertyKeys, Clone(options));
  return result;
}
function FromMappedResult10(mappedResult, propertyKeys, options) {
  return FromProperties14(mappedResult.properties, propertyKeys, options);
}
function PickFromMappedResult(mappedResult, propertyKeys, options) {
  const properties = FromMappedResult10(mappedResult, propertyKeys, options);
  return MappedResult(properties);
}

// ../../../node_modules/.pnpm/@sinclair+typebox@0.34.33/node_modules/@sinclair/typebox/build/esm/type/pick/pick.mjs
function FromIntersect7(types, propertyKeys) {
  return types.map((type) => PickResolve(type, propertyKeys));
}
function FromUnion9(types, propertyKeys) {
  return types.map((type) => PickResolve(type, propertyKeys));
}
function FromProperties15(properties, propertyKeys) {
  const result = {};
  for (const K2 of propertyKeys)
    if (K2 in properties)
      result[K2] = properties[K2];
  return result;
}
function FromObject4(T3, K) {
  const options = Discard(T3, [TransformKind, "$id", "required", "properties"]);
  const properties = FromProperties15(T3["properties"], K);
  return Object2(properties, options);
}
function UnionFromPropertyKeys2(propertyKeys) {
  const result = propertyKeys.reduce((result2, key) => IsLiteralValue(key) ? [...result2, Literal(key)] : result2, []);
  return Union(result);
}
function PickResolve(properties, propertyKeys) {
  return IsIntersect(properties) ? Intersect(FromIntersect7(properties.allOf, propertyKeys)) : IsUnion(properties) ? Union(FromUnion9(properties.anyOf, propertyKeys)) : IsObject3(properties) ? FromObject4(properties, propertyKeys) : Object2({});
}
function Pick(type, key, options) {
  const typeKey = IsArray(key) ? UnionFromPropertyKeys2(key) : key;
  const propertyKeys = IsSchema(key) ? IndexPropertyKeys(key) : key;
  const isTypeRef = IsRef(type);
  const isKeyRef = IsRef(key);
  return IsMappedResult(type) ? PickFromMappedResult(type, propertyKeys, options) : IsMappedKey(key) ? PickFromMappedKey(type, key, options) : isTypeRef && isKeyRef ? Computed("Pick", [type, typeKey], options) : !isTypeRef && isKeyRef ? Computed("Pick", [type, typeKey], options) : isTypeRef && !isKeyRef ? Computed("Pick", [type, typeKey], options) : CreateType({ ...PickResolve(type, propertyKeys), ...options });
}

// ../../../node_modules/.pnpm/@sinclair+typebox@0.34.33/node_modules/@sinclair/typebox/build/esm/type/pick/pick-from-mapped-key.mjs
function FromPropertyKey3(type, key, options) {
  return {
    [key]: Pick(type, [key], Clone(options))
  };
}
function FromPropertyKeys3(type, propertyKeys, options) {
  return propertyKeys.reduce((result, leftKey) => {
    return { ...result, ...FromPropertyKey3(type, leftKey, options) };
  }, {});
}
function FromMappedKey4(type, mappedKey, options) {
  return FromPropertyKeys3(type, mappedKey.keys, options);
}
function PickFromMappedKey(type, mappedKey, options) {
  const properties = FromMappedKey4(type, mappedKey, options);
  return MappedResult(properties);
}

// ../../../node_modules/.pnpm/@sinclair+typebox@0.34.33/node_modules/@sinclair/typebox/build/esm/type/partial/partial-from-mapped-result.mjs
init_define_ENV_DEFINED_IN_BUILD_STEP();

// ../../../node_modules/.pnpm/@sinclair+typebox@0.34.33/node_modules/@sinclair/typebox/build/esm/type/partial/partial.mjs
init_define_ENV_DEFINED_IN_BUILD_STEP();
function FromComputed3(target, parameters) {
  return Computed("Partial", [Computed(target, parameters)]);
}
function FromRef3($ref) {
  return Computed("Partial", [Ref($ref)]);
}
function FromProperties16(properties) {
  const partialProperties = {};
  for (const K of globalThis.Object.getOwnPropertyNames(properties))
    partialProperties[K] = Optional(properties[K]);
  return partialProperties;
}
function FromObject5(type) {
  const options = Discard(type, [TransformKind, "$id", "required", "properties"]);
  const properties = FromProperties16(type["properties"]);
  return Object2(properties, options);
}
function FromRest6(types) {
  return types.map((type) => PartialResolve(type));
}
function PartialResolve(type) {
  return (
    // Mappable
    IsComputed(type) ? FromComputed3(type.target, type.parameters) : IsRef(type) ? FromRef3(type.$ref) : IsIntersect(type) ? Intersect(FromRest6(type.allOf)) : IsUnion(type) ? Union(FromRest6(type.anyOf)) : IsObject3(type) ? FromObject5(type) : (
      // Intrinsic
      IsBigInt3(type) ? type : IsBoolean3(type) ? type : IsInteger2(type) ? type : IsLiteral(type) ? type : IsNull3(type) ? type : IsNumber3(type) ? type : IsString3(type) ? type : IsSymbol3(type) ? type : IsUndefined3(type) ? type : (
        // Passthrough
        Object2({})
      )
    )
  );
}
function Partial(type, options) {
  if (IsMappedResult(type)) {
    return PartialFromMappedResult(type, options);
  } else {
    return CreateType({ ...PartialResolve(type), ...options });
  }
}

// ../../../node_modules/.pnpm/@sinclair+typebox@0.34.33/node_modules/@sinclair/typebox/build/esm/type/partial/partial-from-mapped-result.mjs
function FromProperties17(K, options) {
  const Acc = {};
  for (const K2 of globalThis.Object.getOwnPropertyNames(K))
    Acc[K2] = Partial(K[K2], Clone(options));
  return Acc;
}
function FromMappedResult11(R3, options) {
  return FromProperties17(R3.properties, options);
}
function PartialFromMappedResult(R3, options) {
  const P3 = FromMappedResult11(R3, options);
  return MappedResult(P3);
}

// ../../../node_modules/.pnpm/@sinclair+typebox@0.34.33/node_modules/@sinclair/typebox/build/esm/type/required/required-from-mapped-result.mjs
init_define_ENV_DEFINED_IN_BUILD_STEP();

// ../../../node_modules/.pnpm/@sinclair+typebox@0.34.33/node_modules/@sinclair/typebox/build/esm/type/required/required.mjs
init_define_ENV_DEFINED_IN_BUILD_STEP();
function FromComputed4(target, parameters) {
  return Computed("Required", [Computed(target, parameters)]);
}
function FromRef4($ref) {
  return Computed("Required", [Ref($ref)]);
}
function FromProperties18(properties) {
  const requiredProperties = {};
  for (const K of globalThis.Object.getOwnPropertyNames(properties))
    requiredProperties[K] = Discard(properties[K], [OptionalKind]);
  return requiredProperties;
}
function FromObject6(type) {
  const options = Discard(type, [TransformKind, "$id", "required", "properties"]);
  const properties = FromProperties18(type["properties"]);
  return Object2(properties, options);
}
function FromRest7(types) {
  return types.map((type) => RequiredResolve(type));
}
function RequiredResolve(type) {
  return (
    // Mappable
    IsComputed(type) ? FromComputed4(type.target, type.parameters) : IsRef(type) ? FromRef4(type.$ref) : IsIntersect(type) ? Intersect(FromRest7(type.allOf)) : IsUnion(type) ? Union(FromRest7(type.anyOf)) : IsObject3(type) ? FromObject6(type) : (
      // Intrinsic
      IsBigInt3(type) ? type : IsBoolean3(type) ? type : IsInteger2(type) ? type : IsLiteral(type) ? type : IsNull3(type) ? type : IsNumber3(type) ? type : IsString3(type) ? type : IsSymbol3(type) ? type : IsUndefined3(type) ? type : (
        // Passthrough
        Object2({})
      )
    )
  );
}
function Required(type, options) {
  if (IsMappedResult(type)) {
    return RequiredFromMappedResult(type, options);
  } else {
    return CreateType({ ...RequiredResolve(type), ...options });
  }
}

// ../../../node_modules/.pnpm/@sinclair+typebox@0.34.33/node_modules/@sinclair/typebox/build/esm/type/required/required-from-mapped-result.mjs
function FromProperties19(P3, options) {
  const Acc = {};
  for (const K2 of globalThis.Object.getOwnPropertyNames(P3))
    Acc[K2] = Required(P3[K2], options);
  return Acc;
}
function FromMappedResult12(R3, options) {
  return FromProperties19(R3.properties, options);
}
function RequiredFromMappedResult(R3, options) {
  const P3 = FromMappedResult12(R3, options);
  return MappedResult(P3);
}

// ../../../node_modules/.pnpm/@sinclair+typebox@0.34.33/node_modules/@sinclair/typebox/build/esm/type/module/compute.mjs
function DereferenceParameters(moduleProperties, types) {
  return types.map((type) => {
    return IsRef(type) ? Dereference(moduleProperties, type.$ref) : FromType2(moduleProperties, type);
  });
}
function Dereference(moduleProperties, ref) {
  return ref in moduleProperties ? IsRef(moduleProperties[ref]) ? Dereference(moduleProperties, moduleProperties[ref].$ref) : FromType2(moduleProperties, moduleProperties[ref]) : Never();
}
function FromAwaited(parameters) {
  return Awaited(parameters[0]);
}
function FromIndex(parameters) {
  return Index(parameters[0], parameters[1]);
}
function FromKeyOf(parameters) {
  return KeyOf(parameters[0]);
}
function FromPartial(parameters) {
  return Partial(parameters[0]);
}
function FromOmit(parameters) {
  return Omit(parameters[0], parameters[1]);
}
function FromPick(parameters) {
  return Pick(parameters[0], parameters[1]);
}
function FromRequired(parameters) {
  return Required(parameters[0]);
}
function FromComputed5(moduleProperties, target, parameters) {
  const dereferenced = DereferenceParameters(moduleProperties, parameters);
  return target === "Awaited" ? FromAwaited(dereferenced) : target === "Index" ? FromIndex(dereferenced) : target === "KeyOf" ? FromKeyOf(dereferenced) : target === "Partial" ? FromPartial(dereferenced) : target === "Omit" ? FromOmit(dereferenced) : target === "Pick" ? FromPick(dereferenced) : target === "Required" ? FromRequired(dereferenced) : Never();
}
function FromArray6(moduleProperties, type) {
  return Array2(FromType2(moduleProperties, type));
}
function FromAsyncIterator3(moduleProperties, type) {
  return AsyncIterator(FromType2(moduleProperties, type));
}
function FromConstructor3(moduleProperties, parameters, instanceType) {
  return Constructor(FromTypes2(moduleProperties, parameters), FromType2(moduleProperties, instanceType));
}
function FromFunction3(moduleProperties, parameters, returnType) {
  return Function2(FromTypes2(moduleProperties, parameters), FromType2(moduleProperties, returnType));
}
function FromIntersect8(moduleProperties, types) {
  return Intersect(FromTypes2(moduleProperties, types));
}
function FromIterator3(moduleProperties, type) {
  return Iterator(FromType2(moduleProperties, type));
}
function FromObject7(moduleProperties, properties) {
  return Object2(globalThis.Object.keys(properties).reduce((result, key) => {
    return { ...result, [key]: FromType2(moduleProperties, properties[key]) };
  }, {}));
}
function FromRecord3(moduleProperties, type) {
  const [value, pattern] = [FromType2(moduleProperties, RecordValue2(type)), RecordPattern(type)];
  const result = CloneType(type);
  result.patternProperties[pattern] = value;
  return result;
}
function FromTransform(moduleProperties, transform) {
  return IsRef(transform) ? { ...Dereference(moduleProperties, transform.$ref), [TransformKind]: transform[TransformKind] } : transform;
}
function FromTuple5(moduleProperties, types) {
  return Tuple(FromTypes2(moduleProperties, types));
}
function FromUnion10(moduleProperties, types) {
  return Union(FromTypes2(moduleProperties, types));
}
function FromTypes2(moduleProperties, types) {
  return types.map((type) => FromType2(moduleProperties, type));
}
function FromType2(moduleProperties, type) {
  return (
    // Modifiers
    IsOptional(type) ? CreateType(FromType2(moduleProperties, Discard(type, [OptionalKind])), type) : IsReadonly(type) ? CreateType(FromType2(moduleProperties, Discard(type, [ReadonlyKind])), type) : (
      // Transform
      IsTransform(type) ? CreateType(FromTransform(moduleProperties, type), type) : (
        // Types
        IsArray3(type) ? CreateType(FromArray6(moduleProperties, type.items), type) : IsAsyncIterator3(type) ? CreateType(FromAsyncIterator3(moduleProperties, type.items), type) : IsComputed(type) ? CreateType(FromComputed5(moduleProperties, type.target, type.parameters)) : IsConstructor(type) ? CreateType(FromConstructor3(moduleProperties, type.parameters, type.returns), type) : IsFunction3(type) ? CreateType(FromFunction3(moduleProperties, type.parameters, type.returns), type) : IsIntersect(type) ? CreateType(FromIntersect8(moduleProperties, type.allOf), type) : IsIterator3(type) ? CreateType(FromIterator3(moduleProperties, type.items), type) : IsObject3(type) ? CreateType(FromObject7(moduleProperties, type.properties), type) : IsRecord(type) ? CreateType(FromRecord3(moduleProperties, type)) : IsTuple(type) ? CreateType(FromTuple5(moduleProperties, type.items || []), type) : IsUnion(type) ? CreateType(FromUnion10(moduleProperties, type.anyOf), type) : type
      )
    )
  );
}
function ComputeType(moduleProperties, key) {
  return key in moduleProperties ? FromType2(moduleProperties, moduleProperties[key]) : Never();
}
function ComputeModuleProperties(moduleProperties) {
  return globalThis.Object.getOwnPropertyNames(moduleProperties).reduce((result, key) => {
    return { ...result, [key]: ComputeType(moduleProperties, key) };
  }, {});
}

// ../../../node_modules/.pnpm/@sinclair+typebox@0.34.33/node_modules/@sinclair/typebox/build/esm/type/module/module.mjs
var TModule = class {
  constructor($defs) {
    const computed = ComputeModuleProperties($defs);
    const identified = this.WithIdentifiers(computed);
    this.$defs = identified;
  }
  /** `[Json]` Imports a Type by Key. */
  Import(key, options) {
    const $defs = { ...this.$defs, [key]: CreateType(this.$defs[key], options) };
    return CreateType({ [Kind]: "Import", $defs, $ref: key });
  }
  // prettier-ignore
  WithIdentifiers($defs) {
    return globalThis.Object.getOwnPropertyNames($defs).reduce((result, key) => {
      return { ...result, [key]: { ...$defs[key], $id: key } };
    }, {});
  }
};
function Module(properties) {
  return new TModule(properties);
}

// ../../../node_modules/.pnpm/@sinclair+typebox@0.34.33/node_modules/@sinclair/typebox/build/esm/type/not/not.mjs
init_define_ENV_DEFINED_IN_BUILD_STEP();
function Not2(type, options) {
  return CreateType({ [Kind]: "Not", not: type }, options);
}

// ../../../node_modules/.pnpm/@sinclair+typebox@0.34.33/node_modules/@sinclair/typebox/build/esm/type/parameters/parameters.mjs
init_define_ENV_DEFINED_IN_BUILD_STEP();
function Parameters(schema, options) {
  return IsFunction3(schema) ? Tuple(schema.parameters, options) : Never();
}

// ../../../node_modules/.pnpm/@sinclair+typebox@0.34.33/node_modules/@sinclair/typebox/build/esm/type/recursive/recursive.mjs
init_define_ENV_DEFINED_IN_BUILD_STEP();
var Ordinal = 0;
function Recursive(callback, options = {}) {
  if (IsUndefined(options.$id))
    options.$id = `T${Ordinal++}`;
  const thisType = CloneType(callback({ [Kind]: "This", $ref: `${options.$id}` }));
  thisType.$id = options.$id;
  return CreateType({ [Hint]: "Recursive", ...thisType }, options);
}

// ../../../node_modules/.pnpm/@sinclair+typebox@0.34.33/node_modules/@sinclair/typebox/build/esm/type/regexp/regexp.mjs
init_define_ENV_DEFINED_IN_BUILD_STEP();
function RegExp2(unresolved, options) {
  const expr = IsString(unresolved) ? new globalThis.RegExp(unresolved) : unresolved;
  return CreateType({ [Kind]: "RegExp", type: "RegExp", source: expr.source, flags: expr.flags }, options);
}

// ../../../node_modules/.pnpm/@sinclair+typebox@0.34.33/node_modules/@sinclair/typebox/build/esm/type/rest/rest.mjs
init_define_ENV_DEFINED_IN_BUILD_STEP();
function RestResolve(T3) {
  return IsIntersect(T3) ? T3.allOf : IsUnion(T3) ? T3.anyOf : IsTuple(T3) ? T3.items ?? [] : [];
}
function Rest(T3) {
  return RestResolve(T3);
}

// ../../../node_modules/.pnpm/@sinclair+typebox@0.34.33/node_modules/@sinclair/typebox/build/esm/type/return-type/return-type.mjs
init_define_ENV_DEFINED_IN_BUILD_STEP();
function ReturnType(schema, options) {
  return IsFunction3(schema) ? CreateType(schema.returns, options) : Never(options);
}

// ../../../node_modules/.pnpm/@sinclair+typebox@0.34.33/node_modules/@sinclair/typebox/build/esm/type/transform/transform.mjs
init_define_ENV_DEFINED_IN_BUILD_STEP();
var TransformDecodeBuilder = class {
  constructor(schema) {
    this.schema = schema;
  }
  Decode(decode) {
    return new TransformEncodeBuilder(this.schema, decode);
  }
};
var TransformEncodeBuilder = class {
  constructor(schema, decode) {
    this.schema = schema;
    this.decode = decode;
  }
  EncodeTransform(encode, schema) {
    const Encode = (value) => schema[TransformKind].Encode(encode(value));
    const Decode = (value) => this.decode(schema[TransformKind].Decode(value));
    const Codec = { Encode, Decode };
    return { ...schema, [TransformKind]: Codec };
  }
  EncodeSchema(encode, schema) {
    const Codec = { Decode: this.decode, Encode: encode };
    return { ...schema, [TransformKind]: Codec };
  }
  Encode(encode) {
    return IsTransform(this.schema) ? this.EncodeTransform(encode, this.schema) : this.EncodeSchema(encode, this.schema);
  }
};
function Transform(schema) {
  return new TransformDecodeBuilder(schema);
}

// ../../../node_modules/.pnpm/@sinclair+typebox@0.34.33/node_modules/@sinclair/typebox/build/esm/type/unsafe/unsafe.mjs
init_define_ENV_DEFINED_IN_BUILD_STEP();
function Unsafe(options = {}) {
  return CreateType({ [Kind]: options[Kind] ?? "Unsafe" }, options);
}

// ../../../node_modules/.pnpm/@sinclair+typebox@0.34.33/node_modules/@sinclair/typebox/build/esm/type/void/void.mjs
init_define_ENV_DEFINED_IN_BUILD_STEP();
function Void(options) {
  return CreateType({ [Kind]: "Void", type: "void" }, options);
}

// ../../../node_modules/.pnpm/@sinclair+typebox@0.34.33/node_modules/@sinclair/typebox/build/esm/type/type/index.mjs
init_define_ENV_DEFINED_IN_BUILD_STEP();

// ../../../node_modules/.pnpm/@sinclair+typebox@0.34.33/node_modules/@sinclair/typebox/build/esm/type/type/type.mjs
var type_exports3 = {};
__export(type_exports3, {
  Any: () => Any,
  Argument: () => Argument2,
  Array: () => Array2,
  AsyncIterator: () => AsyncIterator,
  Awaited: () => Awaited,
  BigInt: () => BigInt2,
  Boolean: () => Boolean2,
  Capitalize: () => Capitalize,
  Composite: () => Composite,
  Const: () => Const,
  Constructor: () => Constructor,
  ConstructorParameters: () => ConstructorParameters,
  Date: () => Date2,
  Enum: () => Enum,
  Exclude: () => Exclude,
  Extends: () => Extends,
  Extract: () => Extract,
  Function: () => Function2,
  Index: () => Index,
  InstanceType: () => InstanceType,
  Instantiate: () => Instantiate,
  Integer: () => Integer,
  Intersect: () => Intersect,
  Iterator: () => Iterator,
  KeyOf: () => KeyOf,
  Literal: () => Literal,
  Lowercase: () => Lowercase,
  Mapped: () => Mapped,
  Module: () => Module,
  Never: () => Never,
  Not: () => Not2,
  Null: () => Null,
  Number: () => Number2,
  Object: () => Object2,
  Omit: () => Omit,
  Optional: () => Optional,
  Parameters: () => Parameters,
  Partial: () => Partial,
  Pick: () => Pick,
  Promise: () => Promise2,
  Readonly: () => Readonly,
  ReadonlyOptional: () => ReadonlyOptional,
  Record: () => Record,
  Recursive: () => Recursive,
  Ref: () => Ref,
  RegExp: () => RegExp2,
  Required: () => Required,
  Rest: () => Rest,
  ReturnType: () => ReturnType,
  String: () => String2,
  Symbol: () => Symbol2,
  TemplateLiteral: () => TemplateLiteral,
  Transform: () => Transform,
  Tuple: () => Tuple,
  Uint8Array: () => Uint8Array2,
  Uncapitalize: () => Uncapitalize,
  Undefined: () => Undefined,
  Union: () => Union,
  Unknown: () => Unknown,
  Unsafe: () => Unsafe,
  Uppercase: () => Uppercase,
  Void: () => Void
});
init_define_ENV_DEFINED_IN_BUILD_STEP();

// ../../../node_modules/.pnpm/@sinclair+typebox@0.34.33/node_modules/@sinclair/typebox/build/esm/type/type/index.mjs
var Type = type_exports3;

// ../../../packages/zettel/zettel-ast/dist/schema.js
var Key = Type.String({
  description: "Unique key for this node within the document",
  minLength: 6
});
var ZettelNode = Type.Intersect([
  Type.Object({
    type: Type.String(),
    zettel_key: Key
  }, {
    propertyNames: Type.String({
      pattern: "^(?!zettel_).*|^zettel_key$",
      description: "Property names must not start with 'zettel_' except 'zettel_key'"
    }),
    additionalProperties: true
  }),
  Type.Record(Type.String({ pattern: "^(?!zettel_).*|^zettel_key$" }), Type.Unknown())
]);
var Metadata = Type.Optional(Type.Record(Type.String(), Type.Unknown()));
var ZettelLinkMark = Type.Object({
  type: Type.Literal("zettel_link"),
  zettel_key: Key,
  href: Type.String({
    description: "The target URL of the link"
  }),
  metadata: Metadata
});
var ZettelBoldMark = Type.Object({
  type: Type.Literal("zettel_bold"),
  zettel_key: Key
});
var ZettelItalicMark = Type.Object({
  type: Type.Literal("zettel_italic"),
  zettel_key: Key
});
var CustomMark = Type.Object({
  type: Type.String({ pattern: "^(?!zettel_).*" }),
  zettel_key: Key
}, {
  additionalProperties: true,
  propertyNames: Type.String({ pattern: "^(?!zettel_).*|^zettel_key$" })
});
var ZettelSpan = Type.Object({
  type: Type.Literal("zettel_span"),
  zettel_key: Key,
  marks: Type.Optional(Type.Array(Type.Union([ZettelBoldMark, ZettelItalicMark, ZettelLinkMark, CustomMark]))),
  text: Type.String({ description: "The text content of this span" }),
  metadata: Metadata
});
var ZettelTextBlock = Type.Object({
  type: Type.Literal("zettel_text_block"),
  zettel_key: Key,
  style: Type.Union([
    Type.Literal("zettel_normal"),
    Type.String({
      description: "The key of a custom block. Renderers that don't support this block will render it as a zettel_normal block."
    })
  ]),
  children: Type.Array(ZettelSpan, {
    description: "Array of inline spans that make up the block content"
  }),
  metadata: Metadata
});
var CustomBlock = Type.Intersect([
  Type.Object({
    type: Type.String({ pattern: "^(?!zettel_text_block$).*" }),
    zettel_key: Key
  }, {
    propertyNames: Type.String({ pattern: "^(?!zettel_).*|^zettel_key$" }),
    additionalProperties: true
  }),
  Type.Record(Type.String({ pattern: "^(?!zettel_).*|^zettel_key$" }), Type.Unknown())
]);
var ZettelDoc = Type.Object({
  type: Type.Literal("zettel_doc"),
  content: Type.Array(Type.Union([ZettelTextBlock, CustomBlock]))
});
var ZettelDocJsonSchema = ZettelDoc;

// ../../../packages/zettel/zettel-ast/dist/validate.js
init_define_ENV_DEFINED_IN_BUILD_STEP();

// ../../../node_modules/.pnpm/@sinclair+typebox@0.34.33/node_modules/@sinclair/typebox/build/esm/errors/errors.mjs
init_define_ENV_DEFINED_IN_BUILD_STEP();

// ../../../node_modules/.pnpm/@sinclair+typebox@0.34.33/node_modules/@sinclair/typebox/build/esm/errors/function.mjs
init_define_ENV_DEFINED_IN_BUILD_STEP();
function DefaultErrorFunction(error) {
  switch (error.errorType) {
    case ValueErrorType.ArrayContains:
      return "Expected array to contain at least one matching value";
    case ValueErrorType.ArrayMaxContains:
      return `Expected array to contain no more than ${error.schema.maxContains} matching values`;
    case ValueErrorType.ArrayMinContains:
      return `Expected array to contain at least ${error.schema.minContains} matching values`;
    case ValueErrorType.ArrayMaxItems:
      return `Expected array length to be less or equal to ${error.schema.maxItems}`;
    case ValueErrorType.ArrayMinItems:
      return `Expected array length to be greater or equal to ${error.schema.minItems}`;
    case ValueErrorType.ArrayUniqueItems:
      return "Expected array elements to be unique";
    case ValueErrorType.Array:
      return "Expected array";
    case ValueErrorType.AsyncIterator:
      return "Expected AsyncIterator";
    case ValueErrorType.BigIntExclusiveMaximum:
      return `Expected bigint to be less than ${error.schema.exclusiveMaximum}`;
    case ValueErrorType.BigIntExclusiveMinimum:
      return `Expected bigint to be greater than ${error.schema.exclusiveMinimum}`;
    case ValueErrorType.BigIntMaximum:
      return `Expected bigint to be less or equal to ${error.schema.maximum}`;
    case ValueErrorType.BigIntMinimum:
      return `Expected bigint to be greater or equal to ${error.schema.minimum}`;
    case ValueErrorType.BigIntMultipleOf:
      return `Expected bigint to be a multiple of ${error.schema.multipleOf}`;
    case ValueErrorType.BigInt:
      return "Expected bigint";
    case ValueErrorType.Boolean:
      return "Expected boolean";
    case ValueErrorType.DateExclusiveMinimumTimestamp:
      return `Expected Date timestamp to be greater than ${error.schema.exclusiveMinimumTimestamp}`;
    case ValueErrorType.DateExclusiveMaximumTimestamp:
      return `Expected Date timestamp to be less than ${error.schema.exclusiveMaximumTimestamp}`;
    case ValueErrorType.DateMinimumTimestamp:
      return `Expected Date timestamp to be greater or equal to ${error.schema.minimumTimestamp}`;
    case ValueErrorType.DateMaximumTimestamp:
      return `Expected Date timestamp to be less or equal to ${error.schema.maximumTimestamp}`;
    case ValueErrorType.DateMultipleOfTimestamp:
      return `Expected Date timestamp to be a multiple of ${error.schema.multipleOfTimestamp}`;
    case ValueErrorType.Date:
      return "Expected Date";
    case ValueErrorType.Function:
      return "Expected function";
    case ValueErrorType.IntegerExclusiveMaximum:
      return `Expected integer to be less than ${error.schema.exclusiveMaximum}`;
    case ValueErrorType.IntegerExclusiveMinimum:
      return `Expected integer to be greater than ${error.schema.exclusiveMinimum}`;
    case ValueErrorType.IntegerMaximum:
      return `Expected integer to be less or equal to ${error.schema.maximum}`;
    case ValueErrorType.IntegerMinimum:
      return `Expected integer to be greater or equal to ${error.schema.minimum}`;
    case ValueErrorType.IntegerMultipleOf:
      return `Expected integer to be a multiple of ${error.schema.multipleOf}`;
    case ValueErrorType.Integer:
      return "Expected integer";
    case ValueErrorType.IntersectUnevaluatedProperties:
      return "Unexpected property";
    case ValueErrorType.Intersect:
      return "Expected all values to match";
    case ValueErrorType.Iterator:
      return "Expected Iterator";
    case ValueErrorType.Literal:
      return `Expected ${typeof error.schema.const === "string" ? `'${error.schema.const}'` : error.schema.const}`;
    case ValueErrorType.Never:
      return "Never";
    case ValueErrorType.Not:
      return "Value should not match";
    case ValueErrorType.Null:
      return "Expected null";
    case ValueErrorType.NumberExclusiveMaximum:
      return `Expected number to be less than ${error.schema.exclusiveMaximum}`;
    case ValueErrorType.NumberExclusiveMinimum:
      return `Expected number to be greater than ${error.schema.exclusiveMinimum}`;
    case ValueErrorType.NumberMaximum:
      return `Expected number to be less or equal to ${error.schema.maximum}`;
    case ValueErrorType.NumberMinimum:
      return `Expected number to be greater or equal to ${error.schema.minimum}`;
    case ValueErrorType.NumberMultipleOf:
      return `Expected number to be a multiple of ${error.schema.multipleOf}`;
    case ValueErrorType.Number:
      return "Expected number";
    case ValueErrorType.Object:
      return "Expected object";
    case ValueErrorType.ObjectAdditionalProperties:
      return "Unexpected property";
    case ValueErrorType.ObjectMaxProperties:
      return `Expected object to have no more than ${error.schema.maxProperties} properties`;
    case ValueErrorType.ObjectMinProperties:
      return `Expected object to have at least ${error.schema.minProperties} properties`;
    case ValueErrorType.ObjectRequiredProperty:
      return "Expected required property";
    case ValueErrorType.Promise:
      return "Expected Promise";
    case ValueErrorType.RegExp:
      return "Expected string to match regular expression";
    case ValueErrorType.StringFormatUnknown:
      return `Unknown format '${error.schema.format}'`;
    case ValueErrorType.StringFormat:
      return `Expected string to match '${error.schema.format}' format`;
    case ValueErrorType.StringMaxLength:
      return `Expected string length less or equal to ${error.schema.maxLength}`;
    case ValueErrorType.StringMinLength:
      return `Expected string length greater or equal to ${error.schema.minLength}`;
    case ValueErrorType.StringPattern:
      return `Expected string to match '${error.schema.pattern}'`;
    case ValueErrorType.String:
      return "Expected string";
    case ValueErrorType.Symbol:
      return "Expected symbol";
    case ValueErrorType.TupleLength:
      return `Expected tuple to have ${error.schema.maxItems || 0} elements`;
    case ValueErrorType.Tuple:
      return "Expected tuple";
    case ValueErrorType.Uint8ArrayMaxByteLength:
      return `Expected byte length less or equal to ${error.schema.maxByteLength}`;
    case ValueErrorType.Uint8ArrayMinByteLength:
      return `Expected byte length greater or equal to ${error.schema.minByteLength}`;
    case ValueErrorType.Uint8Array:
      return "Expected Uint8Array";
    case ValueErrorType.Undefined:
      return "Expected undefined";
    case ValueErrorType.Union:
      return "Expected union value";
    case ValueErrorType.Void:
      return "Expected void";
    case ValueErrorType.Kind:
      return `Expected kind '${error.schema[Kind]}'`;
    default:
      return "Unknown error type";
  }
}
var errorFunction = DefaultErrorFunction;
function GetErrorFunction() {
  return errorFunction;
}

// ../../../node_modules/.pnpm/@sinclair+typebox@0.34.33/node_modules/@sinclair/typebox/build/esm/value/deref/deref.mjs
init_define_ENV_DEFINED_IN_BUILD_STEP();
var TypeDereferenceError = class extends TypeBoxError {
  constructor(schema) {
    super(`Unable to dereference schema with $id '${schema.$ref}'`);
    this.schema = schema;
  }
};
function Resolve(schema, references) {
  const target = references.find((target2) => target2.$id === schema.$ref);
  if (target === void 0)
    throw new TypeDereferenceError(schema);
  return Deref(target, references);
}
function Pushref(schema, references) {
  if (!IsString2(schema.$id) || references.some((target) => target.$id === schema.$id))
    return references;
  references.push(schema);
  return references;
}
function Deref(schema, references) {
  return schema[Kind] === "This" || schema[Kind] === "Ref" ? Resolve(schema, references) : schema;
}

// ../../../node_modules/.pnpm/@sinclair+typebox@0.34.33/node_modules/@sinclair/typebox/build/esm/value/hash/hash.mjs
init_define_ENV_DEFINED_IN_BUILD_STEP();
var ValueHashError = class extends TypeBoxError {
  constructor(value) {
    super(`Unable to hash value`);
    this.value = value;
  }
};
var ByteMarker;
(function(ByteMarker2) {
  ByteMarker2[ByteMarker2["Undefined"] = 0] = "Undefined";
  ByteMarker2[ByteMarker2["Null"] = 1] = "Null";
  ByteMarker2[ByteMarker2["Boolean"] = 2] = "Boolean";
  ByteMarker2[ByteMarker2["Number"] = 3] = "Number";
  ByteMarker2[ByteMarker2["String"] = 4] = "String";
  ByteMarker2[ByteMarker2["Object"] = 5] = "Object";
  ByteMarker2[ByteMarker2["Array"] = 6] = "Array";
  ByteMarker2[ByteMarker2["Date"] = 7] = "Date";
  ByteMarker2[ByteMarker2["Uint8Array"] = 8] = "Uint8Array";
  ByteMarker2[ByteMarker2["Symbol"] = 9] = "Symbol";
  ByteMarker2[ByteMarker2["BigInt"] = 10] = "BigInt";
})(ByteMarker || (ByteMarker = {}));
var Accumulator = BigInt("14695981039346656037");
var [Prime, Size] = [BigInt("1099511628211"), BigInt(
  "18446744073709551616"
  /* 2 ^ 64 */
)];
var Bytes = Array.from({ length: 256 }).map((_3, i2) => BigInt(i2));
var F64 = new Float64Array(1);
var F64In = new DataView(F64.buffer);
var F64Out = new Uint8Array(F64.buffer);
function* NumberToBytes(value) {
  const byteCount = value === 0 ? 1 : Math.ceil(Math.floor(Math.log2(value) + 1) / 8);
  for (let i2 = 0; i2 < byteCount; i2++) {
    yield value >> 8 * (byteCount - 1 - i2) & 255;
  }
}
function ArrayType2(value) {
  FNV1A64(ByteMarker.Array);
  for (const item of value) {
    Visit4(item);
  }
}
function BooleanType(value) {
  FNV1A64(ByteMarker.Boolean);
  FNV1A64(value ? 1 : 0);
}
function BigIntType(value) {
  FNV1A64(ByteMarker.BigInt);
  F64In.setBigInt64(0, value);
  for (const byte of F64Out) {
    FNV1A64(byte);
  }
}
function DateType2(value) {
  FNV1A64(ByteMarker.Date);
  Visit4(value.getTime());
}
function NullType(value) {
  FNV1A64(ByteMarker.Null);
}
function NumberType(value) {
  FNV1A64(ByteMarker.Number);
  F64In.setFloat64(0, value);
  for (const byte of F64Out) {
    FNV1A64(byte);
  }
}
function ObjectType2(value) {
  FNV1A64(ByteMarker.Object);
  for (const key of globalThis.Object.getOwnPropertyNames(value).sort()) {
    Visit4(key);
    Visit4(value[key]);
  }
}
function StringType(value) {
  FNV1A64(ByteMarker.String);
  for (let i2 = 0; i2 < value.length; i2++) {
    for (const byte of NumberToBytes(value.charCodeAt(i2))) {
      FNV1A64(byte);
    }
  }
}
function SymbolType(value) {
  FNV1A64(ByteMarker.Symbol);
  Visit4(value.description);
}
function Uint8ArrayType2(value) {
  FNV1A64(ByteMarker.Uint8Array);
  for (let i2 = 0; i2 < value.length; i2++) {
    FNV1A64(value[i2]);
  }
}
function UndefinedType(value) {
  return FNV1A64(ByteMarker.Undefined);
}
function Visit4(value) {
  if (IsArray2(value))
    return ArrayType2(value);
  if (IsBoolean2(value))
    return BooleanType(value);
  if (IsBigInt2(value))
    return BigIntType(value);
  if (IsDate2(value))
    return DateType2(value);
  if (IsNull2(value))
    return NullType(value);
  if (IsNumber2(value))
    return NumberType(value);
  if (IsObject2(value))
    return ObjectType2(value);
  if (IsString2(value))
    return StringType(value);
  if (IsSymbol2(value))
    return SymbolType(value);
  if (IsUint8Array2(value))
    return Uint8ArrayType2(value);
  if (IsUndefined2(value))
    return UndefinedType(value);
  throw new ValueHashError(value);
}
function FNV1A64(byte) {
  Accumulator = Accumulator ^ Bytes[byte];
  Accumulator = Accumulator * Prime % Size;
}
function Hash(value) {
  Accumulator = BigInt("14695981039346656037");
  Visit4(value);
  return Accumulator;
}

// ../../../node_modules/.pnpm/@sinclair+typebox@0.34.33/node_modules/@sinclair/typebox/build/esm/value/check/check.mjs
init_define_ENV_DEFINED_IN_BUILD_STEP();
var ValueCheckUnknownTypeError = class extends TypeBoxError {
  constructor(schema) {
    super(`Unknown type`);
    this.schema = schema;
  }
};
function IsAnyOrUnknown(schema) {
  return schema[Kind] === "Any" || schema[Kind] === "Unknown";
}
function IsDefined(value) {
  return value !== void 0;
}
function FromAny2(schema, references, value) {
  return true;
}
function FromArgument2(schema, references, value) {
  return true;
}
function FromArray7(schema, references, value) {
  if (!IsArray2(value))
    return false;
  if (IsDefined(schema.minItems) && !(value.length >= schema.minItems)) {
    return false;
  }
  if (IsDefined(schema.maxItems) && !(value.length <= schema.maxItems)) {
    return false;
  }
  if (!value.every((value2) => Visit5(schema.items, references, value2))) {
    return false;
  }
  if (schema.uniqueItems === true && !function() {
    const set = /* @__PURE__ */ new Set();
    for (const element of value) {
      const hashed = Hash(element);
      if (set.has(hashed)) {
        return false;
      } else {
        set.add(hashed);
      }
    }
    return true;
  }()) {
    return false;
  }
  if (!(IsDefined(schema.contains) || IsNumber2(schema.minContains) || IsNumber2(schema.maxContains))) {
    return true;
  }
  const containsSchema = IsDefined(schema.contains) ? schema.contains : Never();
  const containsCount = value.reduce((acc, value2) => Visit5(containsSchema, references, value2) ? acc + 1 : acc, 0);
  if (containsCount === 0) {
    return false;
  }
  if (IsNumber2(schema.minContains) && containsCount < schema.minContains) {
    return false;
  }
  if (IsNumber2(schema.maxContains) && containsCount > schema.maxContains) {
    return false;
  }
  return true;
}
function FromAsyncIterator4(schema, references, value) {
  return IsAsyncIterator2(value);
}
function FromBigInt2(schema, references, value) {
  if (!IsBigInt2(value))
    return false;
  if (IsDefined(schema.exclusiveMaximum) && !(value < schema.exclusiveMaximum)) {
    return false;
  }
  if (IsDefined(schema.exclusiveMinimum) && !(value > schema.exclusiveMinimum)) {
    return false;
  }
  if (IsDefined(schema.maximum) && !(value <= schema.maximum)) {
    return false;
  }
  if (IsDefined(schema.minimum) && !(value >= schema.minimum)) {
    return false;
  }
  if (IsDefined(schema.multipleOf) && !(value % schema.multipleOf === BigInt(0))) {
    return false;
  }
  return true;
}
function FromBoolean2(schema, references, value) {
  return IsBoolean2(value);
}
function FromConstructor4(schema, references, value) {
  return Visit5(schema.returns, references, value.prototype);
}
function FromDate2(schema, references, value) {
  if (!IsDate2(value))
    return false;
  if (IsDefined(schema.exclusiveMaximumTimestamp) && !(value.getTime() < schema.exclusiveMaximumTimestamp)) {
    return false;
  }
  if (IsDefined(schema.exclusiveMinimumTimestamp) && !(value.getTime() > schema.exclusiveMinimumTimestamp)) {
    return false;
  }
  if (IsDefined(schema.maximumTimestamp) && !(value.getTime() <= schema.maximumTimestamp)) {
    return false;
  }
  if (IsDefined(schema.minimumTimestamp) && !(value.getTime() >= schema.minimumTimestamp)) {
    return false;
  }
  if (IsDefined(schema.multipleOfTimestamp) && !(value.getTime() % schema.multipleOfTimestamp === 0)) {
    return false;
  }
  return true;
}
function FromFunction4(schema, references, value) {
  return IsFunction2(value);
}
function FromImport(schema, references, value) {
  const definitions = globalThis.Object.values(schema.$defs);
  const target = schema.$defs[schema.$ref];
  return Visit5(target, [...references, ...definitions], value);
}
function FromInteger2(schema, references, value) {
  if (!IsInteger(value)) {
    return false;
  }
  if (IsDefined(schema.exclusiveMaximum) && !(value < schema.exclusiveMaximum)) {
    return false;
  }
  if (IsDefined(schema.exclusiveMinimum) && !(value > schema.exclusiveMinimum)) {
    return false;
  }
  if (IsDefined(schema.maximum) && !(value <= schema.maximum)) {
    return false;
  }
  if (IsDefined(schema.minimum) && !(value >= schema.minimum)) {
    return false;
  }
  if (IsDefined(schema.multipleOf) && !(value % schema.multipleOf === 0)) {
    return false;
  }
  return true;
}
function FromIntersect9(schema, references, value) {
  const check1 = schema.allOf.every((schema2) => Visit5(schema2, references, value));
  if (schema.unevaluatedProperties === false) {
    const keyPattern = new RegExp(KeyOfPattern(schema));
    const check2 = Object.getOwnPropertyNames(value).every((key) => keyPattern.test(key));
    return check1 && check2;
  } else if (IsSchema(schema.unevaluatedProperties)) {
    const keyCheck = new RegExp(KeyOfPattern(schema));
    const check2 = Object.getOwnPropertyNames(value).every((key) => keyCheck.test(key) || Visit5(schema.unevaluatedProperties, references, value[key]));
    return check1 && check2;
  } else {
    return check1;
  }
}
function FromIterator4(schema, references, value) {
  return IsIterator2(value);
}
function FromLiteral3(schema, references, value) {
  return value === schema.const;
}
function FromNever2(schema, references, value) {
  return false;
}
function FromNot2(schema, references, value) {
  return !Visit5(schema.not, references, value);
}
function FromNull2(schema, references, value) {
  return IsNull2(value);
}
function FromNumber2(schema, references, value) {
  if (!TypeSystemPolicy.IsNumberLike(value))
    return false;
  if (IsDefined(schema.exclusiveMaximum) && !(value < schema.exclusiveMaximum)) {
    return false;
  }
  if (IsDefined(schema.exclusiveMinimum) && !(value > schema.exclusiveMinimum)) {
    return false;
  }
  if (IsDefined(schema.minimum) && !(value >= schema.minimum)) {
    return false;
  }
  if (IsDefined(schema.maximum) && !(value <= schema.maximum)) {
    return false;
  }
  if (IsDefined(schema.multipleOf) && !(value % schema.multipleOf === 0)) {
    return false;
  }
  return true;
}
function FromObject8(schema, references, value) {
  if (!TypeSystemPolicy.IsObjectLike(value))
    return false;
  if (IsDefined(schema.minProperties) && !(Object.getOwnPropertyNames(value).length >= schema.minProperties)) {
    return false;
  }
  if (IsDefined(schema.maxProperties) && !(Object.getOwnPropertyNames(value).length <= schema.maxProperties)) {
    return false;
  }
  const knownKeys = Object.getOwnPropertyNames(schema.properties);
  for (const knownKey of knownKeys) {
    const property = schema.properties[knownKey];
    if (schema.required && schema.required.includes(knownKey)) {
      if (!Visit5(property, references, value[knownKey])) {
        return false;
      }
      if ((ExtendsUndefinedCheck(property) || IsAnyOrUnknown(property)) && !(knownKey in value)) {
        return false;
      }
    } else {
      if (TypeSystemPolicy.IsExactOptionalProperty(value, knownKey) && !Visit5(property, references, value[knownKey])) {
        return false;
      }
    }
  }
  if (schema.additionalProperties === false) {
    const valueKeys = Object.getOwnPropertyNames(value);
    if (schema.required && schema.required.length === knownKeys.length && valueKeys.length === knownKeys.length) {
      return true;
    } else {
      return valueKeys.every((valueKey) => knownKeys.includes(valueKey));
    }
  } else if (typeof schema.additionalProperties === "object") {
    const valueKeys = Object.getOwnPropertyNames(value);
    return valueKeys.every((key) => knownKeys.includes(key) || Visit5(schema.additionalProperties, references, value[key]));
  } else {
    return true;
  }
}
function FromPromise4(schema, references, value) {
  return IsPromise(value);
}
function FromRecord4(schema, references, value) {
  if (!TypeSystemPolicy.IsRecordLike(value)) {
    return false;
  }
  if (IsDefined(schema.minProperties) && !(Object.getOwnPropertyNames(value).length >= schema.minProperties)) {
    return false;
  }
  if (IsDefined(schema.maxProperties) && !(Object.getOwnPropertyNames(value).length <= schema.maxProperties)) {
    return false;
  }
  const [patternKey, patternSchema] = Object.entries(schema.patternProperties)[0];
  const regex2 = new RegExp(patternKey);
  const check1 = Object.entries(value).every(([key, value2]) => {
    return regex2.test(key) ? Visit5(patternSchema, references, value2) : true;
  });
  const check2 = typeof schema.additionalProperties === "object" ? Object.entries(value).every(([key, value2]) => {
    return !regex2.test(key) ? Visit5(schema.additionalProperties, references, value2) : true;
  }) : true;
  const check3 = schema.additionalProperties === false ? Object.getOwnPropertyNames(value).every((key) => {
    return regex2.test(key);
  }) : true;
  return check1 && check2 && check3;
}
function FromRef5(schema, references, value) {
  return Visit5(Deref(schema, references), references, value);
}
function FromRegExp2(schema, references, value) {
  const regex2 = new RegExp(schema.source, schema.flags);
  if (IsDefined(schema.minLength)) {
    if (!(value.length >= schema.minLength))
      return false;
  }
  if (IsDefined(schema.maxLength)) {
    if (!(value.length <= schema.maxLength))
      return false;
  }
  return regex2.test(value);
}
function FromString2(schema, references, value) {
  if (!IsString2(value)) {
    return false;
  }
  if (IsDefined(schema.minLength)) {
    if (!(value.length >= schema.minLength))
      return false;
  }
  if (IsDefined(schema.maxLength)) {
    if (!(value.length <= schema.maxLength))
      return false;
  }
  if (IsDefined(schema.pattern)) {
    const regex2 = new RegExp(schema.pattern);
    if (!regex2.test(value))
      return false;
  }
  if (IsDefined(schema.format)) {
    if (!format_exports.Has(schema.format))
      return false;
    const func = format_exports.Get(schema.format);
    return func(value);
  }
  return true;
}
function FromSymbol2(schema, references, value) {
  return IsSymbol2(value);
}
function FromTemplateLiteral4(schema, references, value) {
  return IsString2(value) && new RegExp(schema.pattern).test(value);
}
function FromThis(schema, references, value) {
  return Visit5(Deref(schema, references), references, value);
}
function FromTuple6(schema, references, value) {
  if (!IsArray2(value)) {
    return false;
  }
  if (schema.items === void 0 && !(value.length === 0)) {
    return false;
  }
  if (!(value.length === schema.maxItems)) {
    return false;
  }
  if (!schema.items) {
    return true;
  }
  for (let i2 = 0; i2 < schema.items.length; i2++) {
    if (!Visit5(schema.items[i2], references, value[i2]))
      return false;
  }
  return true;
}
function FromUndefined2(schema, references, value) {
  return IsUndefined2(value);
}
function FromUnion11(schema, references, value) {
  return schema.anyOf.some((inner) => Visit5(inner, references, value));
}
function FromUint8Array2(schema, references, value) {
  if (!IsUint8Array2(value)) {
    return false;
  }
  if (IsDefined(schema.maxByteLength) && !(value.length <= schema.maxByteLength)) {
    return false;
  }
  if (IsDefined(schema.minByteLength) && !(value.length >= schema.minByteLength)) {
    return false;
  }
  return true;
}
function FromUnknown2(schema, references, value) {
  return true;
}
function FromVoid2(schema, references, value) {
  return TypeSystemPolicy.IsVoidLike(value);
}
function FromKind(schema, references, value) {
  if (!type_exports2.Has(schema[Kind]))
    return false;
  const func = type_exports2.Get(schema[Kind]);
  return func(schema, value);
}
function Visit5(schema, references, value) {
  const references_ = IsDefined(schema.$id) ? Pushref(schema, references) : references;
  const schema_ = schema;
  switch (schema_[Kind]) {
    case "Any":
      return FromAny2(schema_, references_, value);
    case "Argument":
      return FromArgument2(schema_, references_, value);
    case "Array":
      return FromArray7(schema_, references_, value);
    case "AsyncIterator":
      return FromAsyncIterator4(schema_, references_, value);
    case "BigInt":
      return FromBigInt2(schema_, references_, value);
    case "Boolean":
      return FromBoolean2(schema_, references_, value);
    case "Constructor":
      return FromConstructor4(schema_, references_, value);
    case "Date":
      return FromDate2(schema_, references_, value);
    case "Function":
      return FromFunction4(schema_, references_, value);
    case "Import":
      return FromImport(schema_, references_, value);
    case "Integer":
      return FromInteger2(schema_, references_, value);
    case "Intersect":
      return FromIntersect9(schema_, references_, value);
    case "Iterator":
      return FromIterator4(schema_, references_, value);
    case "Literal":
      return FromLiteral3(schema_, references_, value);
    case "Never":
      return FromNever2(schema_, references_, value);
    case "Not":
      return FromNot2(schema_, references_, value);
    case "Null":
      return FromNull2(schema_, references_, value);
    case "Number":
      return FromNumber2(schema_, references_, value);
    case "Object":
      return FromObject8(schema_, references_, value);
    case "Promise":
      return FromPromise4(schema_, references_, value);
    case "Record":
      return FromRecord4(schema_, references_, value);
    case "Ref":
      return FromRef5(schema_, references_, value);
    case "RegExp":
      return FromRegExp2(schema_, references_, value);
    case "String":
      return FromString2(schema_, references_, value);
    case "Symbol":
      return FromSymbol2(schema_, references_, value);
    case "TemplateLiteral":
      return FromTemplateLiteral4(schema_, references_, value);
    case "This":
      return FromThis(schema_, references_, value);
    case "Tuple":
      return FromTuple6(schema_, references_, value);
    case "Undefined":
      return FromUndefined2(schema_, references_, value);
    case "Union":
      return FromUnion11(schema_, references_, value);
    case "Uint8Array":
      return FromUint8Array2(schema_, references_, value);
    case "Unknown":
      return FromUnknown2(schema_, references_, value);
    case "Void":
      return FromVoid2(schema_, references_, value);
    default:
      if (!type_exports2.Has(schema_[Kind]))
        throw new ValueCheckUnknownTypeError(schema_);
      return FromKind(schema_, references_, value);
  }
}
function Check(...args) {
  return args.length === 3 ? Visit5(args[0], args[1], args[2]) : Visit5(args[0], [], args[1]);
}

// ../../../node_modules/.pnpm/@sinclair+typebox@0.34.33/node_modules/@sinclair/typebox/build/esm/errors/errors.mjs
var ValueErrorType;
(function(ValueErrorType2) {
  ValueErrorType2[ValueErrorType2["ArrayContains"] = 0] = "ArrayContains";
  ValueErrorType2[ValueErrorType2["ArrayMaxContains"] = 1] = "ArrayMaxContains";
  ValueErrorType2[ValueErrorType2["ArrayMaxItems"] = 2] = "ArrayMaxItems";
  ValueErrorType2[ValueErrorType2["ArrayMinContains"] = 3] = "ArrayMinContains";
  ValueErrorType2[ValueErrorType2["ArrayMinItems"] = 4] = "ArrayMinItems";
  ValueErrorType2[ValueErrorType2["ArrayUniqueItems"] = 5] = "ArrayUniqueItems";
  ValueErrorType2[ValueErrorType2["Array"] = 6] = "Array";
  ValueErrorType2[ValueErrorType2["AsyncIterator"] = 7] = "AsyncIterator";
  ValueErrorType2[ValueErrorType2["BigIntExclusiveMaximum"] = 8] = "BigIntExclusiveMaximum";
  ValueErrorType2[ValueErrorType2["BigIntExclusiveMinimum"] = 9] = "BigIntExclusiveMinimum";
  ValueErrorType2[ValueErrorType2["BigIntMaximum"] = 10] = "BigIntMaximum";
  ValueErrorType2[ValueErrorType2["BigIntMinimum"] = 11] = "BigIntMinimum";
  ValueErrorType2[ValueErrorType2["BigIntMultipleOf"] = 12] = "BigIntMultipleOf";
  ValueErrorType2[ValueErrorType2["BigInt"] = 13] = "BigInt";
  ValueErrorType2[ValueErrorType2["Boolean"] = 14] = "Boolean";
  ValueErrorType2[ValueErrorType2["DateExclusiveMaximumTimestamp"] = 15] = "DateExclusiveMaximumTimestamp";
  ValueErrorType2[ValueErrorType2["DateExclusiveMinimumTimestamp"] = 16] = "DateExclusiveMinimumTimestamp";
  ValueErrorType2[ValueErrorType2["DateMaximumTimestamp"] = 17] = "DateMaximumTimestamp";
  ValueErrorType2[ValueErrorType2["DateMinimumTimestamp"] = 18] = "DateMinimumTimestamp";
  ValueErrorType2[ValueErrorType2["DateMultipleOfTimestamp"] = 19] = "DateMultipleOfTimestamp";
  ValueErrorType2[ValueErrorType2["Date"] = 20] = "Date";
  ValueErrorType2[ValueErrorType2["Function"] = 21] = "Function";
  ValueErrorType2[ValueErrorType2["IntegerExclusiveMaximum"] = 22] = "IntegerExclusiveMaximum";
  ValueErrorType2[ValueErrorType2["IntegerExclusiveMinimum"] = 23] = "IntegerExclusiveMinimum";
  ValueErrorType2[ValueErrorType2["IntegerMaximum"] = 24] = "IntegerMaximum";
  ValueErrorType2[ValueErrorType2["IntegerMinimum"] = 25] = "IntegerMinimum";
  ValueErrorType2[ValueErrorType2["IntegerMultipleOf"] = 26] = "IntegerMultipleOf";
  ValueErrorType2[ValueErrorType2["Integer"] = 27] = "Integer";
  ValueErrorType2[ValueErrorType2["IntersectUnevaluatedProperties"] = 28] = "IntersectUnevaluatedProperties";
  ValueErrorType2[ValueErrorType2["Intersect"] = 29] = "Intersect";
  ValueErrorType2[ValueErrorType2["Iterator"] = 30] = "Iterator";
  ValueErrorType2[ValueErrorType2["Kind"] = 31] = "Kind";
  ValueErrorType2[ValueErrorType2["Literal"] = 32] = "Literal";
  ValueErrorType2[ValueErrorType2["Never"] = 33] = "Never";
  ValueErrorType2[ValueErrorType2["Not"] = 34] = "Not";
  ValueErrorType2[ValueErrorType2["Null"] = 35] = "Null";
  ValueErrorType2[ValueErrorType2["NumberExclusiveMaximum"] = 36] = "NumberExclusiveMaximum";
  ValueErrorType2[ValueErrorType2["NumberExclusiveMinimum"] = 37] = "NumberExclusiveMinimum";
  ValueErrorType2[ValueErrorType2["NumberMaximum"] = 38] = "NumberMaximum";
  ValueErrorType2[ValueErrorType2["NumberMinimum"] = 39] = "NumberMinimum";
  ValueErrorType2[ValueErrorType2["NumberMultipleOf"] = 40] = "NumberMultipleOf";
  ValueErrorType2[ValueErrorType2["Number"] = 41] = "Number";
  ValueErrorType2[ValueErrorType2["ObjectAdditionalProperties"] = 42] = "ObjectAdditionalProperties";
  ValueErrorType2[ValueErrorType2["ObjectMaxProperties"] = 43] = "ObjectMaxProperties";
  ValueErrorType2[ValueErrorType2["ObjectMinProperties"] = 44] = "ObjectMinProperties";
  ValueErrorType2[ValueErrorType2["ObjectRequiredProperty"] = 45] = "ObjectRequiredProperty";
  ValueErrorType2[ValueErrorType2["Object"] = 46] = "Object";
  ValueErrorType2[ValueErrorType2["Promise"] = 47] = "Promise";
  ValueErrorType2[ValueErrorType2["RegExp"] = 48] = "RegExp";
  ValueErrorType2[ValueErrorType2["StringFormatUnknown"] = 49] = "StringFormatUnknown";
  ValueErrorType2[ValueErrorType2["StringFormat"] = 50] = "StringFormat";
  ValueErrorType2[ValueErrorType2["StringMaxLength"] = 51] = "StringMaxLength";
  ValueErrorType2[ValueErrorType2["StringMinLength"] = 52] = "StringMinLength";
  ValueErrorType2[ValueErrorType2["StringPattern"] = 53] = "StringPattern";
  ValueErrorType2[ValueErrorType2["String"] = 54] = "String";
  ValueErrorType2[ValueErrorType2["Symbol"] = 55] = "Symbol";
  ValueErrorType2[ValueErrorType2["TupleLength"] = 56] = "TupleLength";
  ValueErrorType2[ValueErrorType2["Tuple"] = 57] = "Tuple";
  ValueErrorType2[ValueErrorType2["Uint8ArrayMaxByteLength"] = 58] = "Uint8ArrayMaxByteLength";
  ValueErrorType2[ValueErrorType2["Uint8ArrayMinByteLength"] = 59] = "Uint8ArrayMinByteLength";
  ValueErrorType2[ValueErrorType2["Uint8Array"] = 60] = "Uint8Array";
  ValueErrorType2[ValueErrorType2["Undefined"] = 61] = "Undefined";
  ValueErrorType2[ValueErrorType2["Union"] = 62] = "Union";
  ValueErrorType2[ValueErrorType2["Void"] = 63] = "Void";
})(ValueErrorType || (ValueErrorType = {}));
var ValueErrorsUnknownTypeError = class extends TypeBoxError {
  constructor(schema) {
    super("Unknown type");
    this.schema = schema;
  }
};
function EscapeKey(key) {
  return key.replace(/~/g, "~0").replace(/\//g, "~1");
}
function IsDefined2(value) {
  return value !== void 0;
}
var ValueErrorIterator = class {
  constructor(iterator) {
    this.iterator = iterator;
  }
  [Symbol.iterator]() {
    return this.iterator;
  }
  /** Returns the first value error or undefined if no errors */
  First() {
    const next = this.iterator.next();
    return next.done ? void 0 : next.value;
  }
};
function Create(errorType, schema, path2, value, errors = []) {
  return {
    type: errorType,
    schema,
    path: path2,
    value,
    message: GetErrorFunction()({ errorType, path: path2, schema, value, errors }),
    errors
  };
}
function* FromAny3(schema, references, path2, value) {
}
function* FromArgument3(schema, references, path2, value) {
}
function* FromArray8(schema, references, path2, value) {
  if (!IsArray2(value)) {
    return yield Create(ValueErrorType.Array, schema, path2, value);
  }
  if (IsDefined2(schema.minItems) && !(value.length >= schema.minItems)) {
    yield Create(ValueErrorType.ArrayMinItems, schema, path2, value);
  }
  if (IsDefined2(schema.maxItems) && !(value.length <= schema.maxItems)) {
    yield Create(ValueErrorType.ArrayMaxItems, schema, path2, value);
  }
  for (let i2 = 0; i2 < value.length; i2++) {
    yield* Visit6(schema.items, references, `${path2}/${i2}`, value[i2]);
  }
  if (schema.uniqueItems === true && !function() {
    const set = /* @__PURE__ */ new Set();
    for (const element of value) {
      const hashed = Hash(element);
      if (set.has(hashed)) {
        return false;
      } else {
        set.add(hashed);
      }
    }
    return true;
  }()) {
    yield Create(ValueErrorType.ArrayUniqueItems, schema, path2, value);
  }
  if (!(IsDefined2(schema.contains) || IsDefined2(schema.minContains) || IsDefined2(schema.maxContains))) {
    return;
  }
  const containsSchema = IsDefined2(schema.contains) ? schema.contains : Never();
  const containsCount = value.reduce((acc, value2, index) => Visit6(containsSchema, references, `${path2}${index}`, value2).next().done === true ? acc + 1 : acc, 0);
  if (containsCount === 0) {
    yield Create(ValueErrorType.ArrayContains, schema, path2, value);
  }
  if (IsNumber2(schema.minContains) && containsCount < schema.minContains) {
    yield Create(ValueErrorType.ArrayMinContains, schema, path2, value);
  }
  if (IsNumber2(schema.maxContains) && containsCount > schema.maxContains) {
    yield Create(ValueErrorType.ArrayMaxContains, schema, path2, value);
  }
}
function* FromAsyncIterator5(schema, references, path2, value) {
  if (!IsAsyncIterator2(value))
    yield Create(ValueErrorType.AsyncIterator, schema, path2, value);
}
function* FromBigInt3(schema, references, path2, value) {
  if (!IsBigInt2(value))
    return yield Create(ValueErrorType.BigInt, schema, path2, value);
  if (IsDefined2(schema.exclusiveMaximum) && !(value < schema.exclusiveMaximum)) {
    yield Create(ValueErrorType.BigIntExclusiveMaximum, schema, path2, value);
  }
  if (IsDefined2(schema.exclusiveMinimum) && !(value > schema.exclusiveMinimum)) {
    yield Create(ValueErrorType.BigIntExclusiveMinimum, schema, path2, value);
  }
  if (IsDefined2(schema.maximum) && !(value <= schema.maximum)) {
    yield Create(ValueErrorType.BigIntMaximum, schema, path2, value);
  }
  if (IsDefined2(schema.minimum) && !(value >= schema.minimum)) {
    yield Create(ValueErrorType.BigIntMinimum, schema, path2, value);
  }
  if (IsDefined2(schema.multipleOf) && !(value % schema.multipleOf === BigInt(0))) {
    yield Create(ValueErrorType.BigIntMultipleOf, schema, path2, value);
  }
}
function* FromBoolean3(schema, references, path2, value) {
  if (!IsBoolean2(value))
    yield Create(ValueErrorType.Boolean, schema, path2, value);
}
function* FromConstructor5(schema, references, path2, value) {
  yield* Visit6(schema.returns, references, path2, value.prototype);
}
function* FromDate3(schema, references, path2, value) {
  if (!IsDate2(value))
    return yield Create(ValueErrorType.Date, schema, path2, value);
  if (IsDefined2(schema.exclusiveMaximumTimestamp) && !(value.getTime() < schema.exclusiveMaximumTimestamp)) {
    yield Create(ValueErrorType.DateExclusiveMaximumTimestamp, schema, path2, value);
  }
  if (IsDefined2(schema.exclusiveMinimumTimestamp) && !(value.getTime() > schema.exclusiveMinimumTimestamp)) {
    yield Create(ValueErrorType.DateExclusiveMinimumTimestamp, schema, path2, value);
  }
  if (IsDefined2(schema.maximumTimestamp) && !(value.getTime() <= schema.maximumTimestamp)) {
    yield Create(ValueErrorType.DateMaximumTimestamp, schema, path2, value);
  }
  if (IsDefined2(schema.minimumTimestamp) && !(value.getTime() >= schema.minimumTimestamp)) {
    yield Create(ValueErrorType.DateMinimumTimestamp, schema, path2, value);
  }
  if (IsDefined2(schema.multipleOfTimestamp) && !(value.getTime() % schema.multipleOfTimestamp === 0)) {
    yield Create(ValueErrorType.DateMultipleOfTimestamp, schema, path2, value);
  }
}
function* FromFunction5(schema, references, path2, value) {
  if (!IsFunction2(value))
    yield Create(ValueErrorType.Function, schema, path2, value);
}
function* FromImport2(schema, references, path2, value) {
  const definitions = globalThis.Object.values(schema.$defs);
  const target = schema.$defs[schema.$ref];
  yield* Visit6(target, [...references, ...definitions], path2, value);
}
function* FromInteger3(schema, references, path2, value) {
  if (!IsInteger(value))
    return yield Create(ValueErrorType.Integer, schema, path2, value);
  if (IsDefined2(schema.exclusiveMaximum) && !(value < schema.exclusiveMaximum)) {
    yield Create(ValueErrorType.IntegerExclusiveMaximum, schema, path2, value);
  }
  if (IsDefined2(schema.exclusiveMinimum) && !(value > schema.exclusiveMinimum)) {
    yield Create(ValueErrorType.IntegerExclusiveMinimum, schema, path2, value);
  }
  if (IsDefined2(schema.maximum) && !(value <= schema.maximum)) {
    yield Create(ValueErrorType.IntegerMaximum, schema, path2, value);
  }
  if (IsDefined2(schema.minimum) && !(value >= schema.minimum)) {
    yield Create(ValueErrorType.IntegerMinimum, schema, path2, value);
  }
  if (IsDefined2(schema.multipleOf) && !(value % schema.multipleOf === 0)) {
    yield Create(ValueErrorType.IntegerMultipleOf, schema, path2, value);
  }
}
function* FromIntersect10(schema, references, path2, value) {
  let hasError = false;
  for (const inner of schema.allOf) {
    for (const error of Visit6(inner, references, path2, value)) {
      hasError = true;
      yield error;
    }
  }
  if (hasError) {
    return yield Create(ValueErrorType.Intersect, schema, path2, value);
  }
  if (schema.unevaluatedProperties === false) {
    const keyCheck = new RegExp(KeyOfPattern(schema));
    for (const valueKey of Object.getOwnPropertyNames(value)) {
      if (!keyCheck.test(valueKey)) {
        yield Create(ValueErrorType.IntersectUnevaluatedProperties, schema, `${path2}/${valueKey}`, value);
      }
    }
  }
  if (typeof schema.unevaluatedProperties === "object") {
    const keyCheck = new RegExp(KeyOfPattern(schema));
    for (const valueKey of Object.getOwnPropertyNames(value)) {
      if (!keyCheck.test(valueKey)) {
        const next = Visit6(schema.unevaluatedProperties, references, `${path2}/${valueKey}`, value[valueKey]).next();
        if (!next.done)
          yield next.value;
      }
    }
  }
}
function* FromIterator5(schema, references, path2, value) {
  if (!IsIterator2(value))
    yield Create(ValueErrorType.Iterator, schema, path2, value);
}
function* FromLiteral4(schema, references, path2, value) {
  if (!(value === schema.const))
    yield Create(ValueErrorType.Literal, schema, path2, value);
}
function* FromNever3(schema, references, path2, value) {
  yield Create(ValueErrorType.Never, schema, path2, value);
}
function* FromNot3(schema, references, path2, value) {
  if (Visit6(schema.not, references, path2, value).next().done === true)
    yield Create(ValueErrorType.Not, schema, path2, value);
}
function* FromNull3(schema, references, path2, value) {
  if (!IsNull2(value))
    yield Create(ValueErrorType.Null, schema, path2, value);
}
function* FromNumber3(schema, references, path2, value) {
  if (!TypeSystemPolicy.IsNumberLike(value))
    return yield Create(ValueErrorType.Number, schema, path2, value);
  if (IsDefined2(schema.exclusiveMaximum) && !(value < schema.exclusiveMaximum)) {
    yield Create(ValueErrorType.NumberExclusiveMaximum, schema, path2, value);
  }
  if (IsDefined2(schema.exclusiveMinimum) && !(value > schema.exclusiveMinimum)) {
    yield Create(ValueErrorType.NumberExclusiveMinimum, schema, path2, value);
  }
  if (IsDefined2(schema.maximum) && !(value <= schema.maximum)) {
    yield Create(ValueErrorType.NumberMaximum, schema, path2, value);
  }
  if (IsDefined2(schema.minimum) && !(value >= schema.minimum)) {
    yield Create(ValueErrorType.NumberMinimum, schema, path2, value);
  }
  if (IsDefined2(schema.multipleOf) && !(value % schema.multipleOf === 0)) {
    yield Create(ValueErrorType.NumberMultipleOf, schema, path2, value);
  }
}
function* FromObject9(schema, references, path2, value) {
  if (!TypeSystemPolicy.IsObjectLike(value))
    return yield Create(ValueErrorType.Object, schema, path2, value);
  if (IsDefined2(schema.minProperties) && !(Object.getOwnPropertyNames(value).length >= schema.minProperties)) {
    yield Create(ValueErrorType.ObjectMinProperties, schema, path2, value);
  }
  if (IsDefined2(schema.maxProperties) && !(Object.getOwnPropertyNames(value).length <= schema.maxProperties)) {
    yield Create(ValueErrorType.ObjectMaxProperties, schema, path2, value);
  }
  const requiredKeys = Array.isArray(schema.required) ? schema.required : [];
  const knownKeys = Object.getOwnPropertyNames(schema.properties);
  const unknownKeys = Object.getOwnPropertyNames(value);
  for (const requiredKey of requiredKeys) {
    if (unknownKeys.includes(requiredKey))
      continue;
    yield Create(ValueErrorType.ObjectRequiredProperty, schema.properties[requiredKey], `${path2}/${EscapeKey(requiredKey)}`, void 0);
  }
  if (schema.additionalProperties === false) {
    for (const valueKey of unknownKeys) {
      if (!knownKeys.includes(valueKey)) {
        yield Create(ValueErrorType.ObjectAdditionalProperties, schema, `${path2}/${EscapeKey(valueKey)}`, value[valueKey]);
      }
    }
  }
  if (typeof schema.additionalProperties === "object") {
    for (const valueKey of unknownKeys) {
      if (knownKeys.includes(valueKey))
        continue;
      yield* Visit6(schema.additionalProperties, references, `${path2}/${EscapeKey(valueKey)}`, value[valueKey]);
    }
  }
  for (const knownKey of knownKeys) {
    const property = schema.properties[knownKey];
    if (schema.required && schema.required.includes(knownKey)) {
      yield* Visit6(property, references, `${path2}/${EscapeKey(knownKey)}`, value[knownKey]);
      if (ExtendsUndefinedCheck(schema) && !(knownKey in value)) {
        yield Create(ValueErrorType.ObjectRequiredProperty, property, `${path2}/${EscapeKey(knownKey)}`, void 0);
      }
    } else {
      if (TypeSystemPolicy.IsExactOptionalProperty(value, knownKey)) {
        yield* Visit6(property, references, `${path2}/${EscapeKey(knownKey)}`, value[knownKey]);
      }
    }
  }
}
function* FromPromise5(schema, references, path2, value) {
  if (!IsPromise(value))
    yield Create(ValueErrorType.Promise, schema, path2, value);
}
function* FromRecord5(schema, references, path2, value) {
  if (!TypeSystemPolicy.IsRecordLike(value))
    return yield Create(ValueErrorType.Object, schema, path2, value);
  if (IsDefined2(schema.minProperties) && !(Object.getOwnPropertyNames(value).length >= schema.minProperties)) {
    yield Create(ValueErrorType.ObjectMinProperties, schema, path2, value);
  }
  if (IsDefined2(schema.maxProperties) && !(Object.getOwnPropertyNames(value).length <= schema.maxProperties)) {
    yield Create(ValueErrorType.ObjectMaxProperties, schema, path2, value);
  }
  const [patternKey, patternSchema] = Object.entries(schema.patternProperties)[0];
  const regex2 = new RegExp(patternKey);
  for (const [propertyKey, propertyValue] of Object.entries(value)) {
    if (regex2.test(propertyKey))
      yield* Visit6(patternSchema, references, `${path2}/${EscapeKey(propertyKey)}`, propertyValue);
  }
  if (typeof schema.additionalProperties === "object") {
    for (const [propertyKey, propertyValue] of Object.entries(value)) {
      if (!regex2.test(propertyKey))
        yield* Visit6(schema.additionalProperties, references, `${path2}/${EscapeKey(propertyKey)}`, propertyValue);
    }
  }
  if (schema.additionalProperties === false) {
    for (const [propertyKey, propertyValue] of Object.entries(value)) {
      if (regex2.test(propertyKey))
        continue;
      return yield Create(ValueErrorType.ObjectAdditionalProperties, schema, `${path2}/${EscapeKey(propertyKey)}`, propertyValue);
    }
  }
}
function* FromRef6(schema, references, path2, value) {
  yield* Visit6(Deref(schema, references), references, path2, value);
}
function* FromRegExp3(schema, references, path2, value) {
  if (!IsString2(value))
    return yield Create(ValueErrorType.String, schema, path2, value);
  if (IsDefined2(schema.minLength) && !(value.length >= schema.minLength)) {
    yield Create(ValueErrorType.StringMinLength, schema, path2, value);
  }
  if (IsDefined2(schema.maxLength) && !(value.length <= schema.maxLength)) {
    yield Create(ValueErrorType.StringMaxLength, schema, path2, value);
  }
  const regex2 = new RegExp(schema.source, schema.flags);
  if (!regex2.test(value)) {
    return yield Create(ValueErrorType.RegExp, schema, path2, value);
  }
}
function* FromString3(schema, references, path2, value) {
  if (!IsString2(value))
    return yield Create(ValueErrorType.String, schema, path2, value);
  if (IsDefined2(schema.minLength) && !(value.length >= schema.minLength)) {
    yield Create(ValueErrorType.StringMinLength, schema, path2, value);
  }
  if (IsDefined2(schema.maxLength) && !(value.length <= schema.maxLength)) {
    yield Create(ValueErrorType.StringMaxLength, schema, path2, value);
  }
  if (IsString2(schema.pattern)) {
    const regex2 = new RegExp(schema.pattern);
    if (!regex2.test(value)) {
      yield Create(ValueErrorType.StringPattern, schema, path2, value);
    }
  }
  if (IsString2(schema.format)) {
    if (!format_exports.Has(schema.format)) {
      yield Create(ValueErrorType.StringFormatUnknown, schema, path2, value);
    } else {
      const format = format_exports.Get(schema.format);
      if (!format(value)) {
        yield Create(ValueErrorType.StringFormat, schema, path2, value);
      }
    }
  }
}
function* FromSymbol3(schema, references, path2, value) {
  if (!IsSymbol2(value))
    yield Create(ValueErrorType.Symbol, schema, path2, value);
}
function* FromTemplateLiteral5(schema, references, path2, value) {
  if (!IsString2(value))
    return yield Create(ValueErrorType.String, schema, path2, value);
  const regex2 = new RegExp(schema.pattern);
  if (!regex2.test(value)) {
    yield Create(ValueErrorType.StringPattern, schema, path2, value);
  }
}
function* FromThis2(schema, references, path2, value) {
  yield* Visit6(Deref(schema, references), references, path2, value);
}
function* FromTuple7(schema, references, path2, value) {
  if (!IsArray2(value))
    return yield Create(ValueErrorType.Tuple, schema, path2, value);
  if (schema.items === void 0 && !(value.length === 0)) {
    return yield Create(ValueErrorType.TupleLength, schema, path2, value);
  }
  if (!(value.length === schema.maxItems)) {
    return yield Create(ValueErrorType.TupleLength, schema, path2, value);
  }
  if (!schema.items) {
    return;
  }
  for (let i2 = 0; i2 < schema.items.length; i2++) {
    yield* Visit6(schema.items[i2], references, `${path2}/${i2}`, value[i2]);
  }
}
function* FromUndefined3(schema, references, path2, value) {
  if (!IsUndefined2(value))
    yield Create(ValueErrorType.Undefined, schema, path2, value);
}
function* FromUnion12(schema, references, path2, value) {
  if (Check(schema, references, value))
    return;
  const errors = schema.anyOf.map((variant) => new ValueErrorIterator(Visit6(variant, references, path2, value)));
  yield Create(ValueErrorType.Union, schema, path2, value, errors);
}
function* FromUint8Array3(schema, references, path2, value) {
  if (!IsUint8Array2(value))
    return yield Create(ValueErrorType.Uint8Array, schema, path2, value);
  if (IsDefined2(schema.maxByteLength) && !(value.length <= schema.maxByteLength)) {
    yield Create(ValueErrorType.Uint8ArrayMaxByteLength, schema, path2, value);
  }
  if (IsDefined2(schema.minByteLength) && !(value.length >= schema.minByteLength)) {
    yield Create(ValueErrorType.Uint8ArrayMinByteLength, schema, path2, value);
  }
}
function* FromUnknown3(schema, references, path2, value) {
}
function* FromVoid3(schema, references, path2, value) {
  if (!TypeSystemPolicy.IsVoidLike(value))
    yield Create(ValueErrorType.Void, schema, path2, value);
}
function* FromKind2(schema, references, path2, value) {
  const check = type_exports2.Get(schema[Kind]);
  if (!check(schema, value))
    yield Create(ValueErrorType.Kind, schema, path2, value);
}
function* Visit6(schema, references, path2, value) {
  const references_ = IsDefined2(schema.$id) ? [...references, schema] : references;
  const schema_ = schema;
  switch (schema_[Kind]) {
    case "Any":
      return yield* FromAny3(schema_, references_, path2, value);
    case "Argument":
      return yield* FromArgument3(schema_, references_, path2, value);
    case "Array":
      return yield* FromArray8(schema_, references_, path2, value);
    case "AsyncIterator":
      return yield* FromAsyncIterator5(schema_, references_, path2, value);
    case "BigInt":
      return yield* FromBigInt3(schema_, references_, path2, value);
    case "Boolean":
      return yield* FromBoolean3(schema_, references_, path2, value);
    case "Constructor":
      return yield* FromConstructor5(schema_, references_, path2, value);
    case "Date":
      return yield* FromDate3(schema_, references_, path2, value);
    case "Function":
      return yield* FromFunction5(schema_, references_, path2, value);
    case "Import":
      return yield* FromImport2(schema_, references_, path2, value);
    case "Integer":
      return yield* FromInteger3(schema_, references_, path2, value);
    case "Intersect":
      return yield* FromIntersect10(schema_, references_, path2, value);
    case "Iterator":
      return yield* FromIterator5(schema_, references_, path2, value);
    case "Literal":
      return yield* FromLiteral4(schema_, references_, path2, value);
    case "Never":
      return yield* FromNever3(schema_, references_, path2, value);
    case "Not":
      return yield* FromNot3(schema_, references_, path2, value);
    case "Null":
      return yield* FromNull3(schema_, references_, path2, value);
    case "Number":
      return yield* FromNumber3(schema_, references_, path2, value);
    case "Object":
      return yield* FromObject9(schema_, references_, path2, value);
    case "Promise":
      return yield* FromPromise5(schema_, references_, path2, value);
    case "Record":
      return yield* FromRecord5(schema_, references_, path2, value);
    case "Ref":
      return yield* FromRef6(schema_, references_, path2, value);
    case "RegExp":
      return yield* FromRegExp3(schema_, references_, path2, value);
    case "String":
      return yield* FromString3(schema_, references_, path2, value);
    case "Symbol":
      return yield* FromSymbol3(schema_, references_, path2, value);
    case "TemplateLiteral":
      return yield* FromTemplateLiteral5(schema_, references_, path2, value);
    case "This":
      return yield* FromThis2(schema_, references_, path2, value);
    case "Tuple":
      return yield* FromTuple7(schema_, references_, path2, value);
    case "Undefined":
      return yield* FromUndefined3(schema_, references_, path2, value);
    case "Union":
      return yield* FromUnion12(schema_, references_, path2, value);
    case "Uint8Array":
      return yield* FromUint8Array3(schema_, references_, path2, value);
    case "Unknown":
      return yield* FromUnknown3(schema_, references_, path2, value);
    case "Void":
      return yield* FromVoid3(schema_, references_, path2, value);
    default:
      if (!type_exports2.Has(schema_[Kind]))
        throw new ValueErrorsUnknownTypeError(schema);
      return yield* FromKind2(schema_, references_, path2, value);
  }
}
function Errors(...args) {
  const iterator = args.length === 3 ? Visit6(args[0], args[1], "", args[2]) : Visit6(args[0], [], "", args[1]);
  return new ValueErrorIterator(iterator);
}

// ../../../node_modules/.pnpm/@sinclair+typebox@0.34.33/node_modules/@sinclair/typebox/build/esm/compiler/compiler.mjs
init_define_ENV_DEFINED_IN_BUILD_STEP();

// ../../../node_modules/.pnpm/@sinclair+typebox@0.34.33/node_modules/@sinclair/typebox/build/esm/value/transform/decode.mjs
init_define_ENV_DEFINED_IN_BUILD_STEP();
var TransformDecodeCheckError = class extends TypeBoxError {
  constructor(schema, value, error) {
    super(`Unable to decode value as it does not match the expected schema`);
    this.schema = schema;
    this.value = value;
    this.error = error;
  }
};
var TransformDecodeError = class extends TypeBoxError {
  constructor(schema, path2, value, error) {
    super(error instanceof Error ? error.message : "Unknown error");
    this.schema = schema;
    this.path = path2;
    this.value = value;
    this.error = error;
  }
};
function Default(schema, path2, value) {
  try {
    return IsTransform(schema) ? schema[TransformKind].Decode(value) : value;
  } catch (error) {
    throw new TransformDecodeError(schema, path2, value, error);
  }
}
function FromArray9(schema, references, path2, value) {
  return IsArray2(value) ? Default(schema, path2, value.map((value2, index) => Visit7(schema.items, references, `${path2}/${index}`, value2))) : Default(schema, path2, value);
}
function FromIntersect11(schema, references, path2, value) {
  if (!IsObject2(value) || IsValueType(value))
    return Default(schema, path2, value);
  const knownEntries = KeyOfPropertyEntries(schema);
  const knownKeys = knownEntries.map((entry) => entry[0]);
  const knownProperties = { ...value };
  for (const [knownKey, knownSchema] of knownEntries)
    if (knownKey in knownProperties) {
      knownProperties[knownKey] = Visit7(knownSchema, references, `${path2}/${knownKey}`, knownProperties[knownKey]);
    }
  if (!IsTransform(schema.unevaluatedProperties)) {
    return Default(schema, path2, knownProperties);
  }
  const unknownKeys = Object.getOwnPropertyNames(knownProperties);
  const unevaluatedProperties = schema.unevaluatedProperties;
  const unknownProperties = { ...knownProperties };
  for (const key of unknownKeys)
    if (!knownKeys.includes(key)) {
      unknownProperties[key] = Default(unevaluatedProperties, `${path2}/${key}`, unknownProperties[key]);
    }
  return Default(schema, path2, unknownProperties);
}
function FromImport3(schema, references, path2, value) {
  const additional = globalThis.Object.values(schema.$defs);
  const target = schema.$defs[schema.$ref];
  const result = Visit7(target, [...references, ...additional], path2, value);
  return Default(schema, path2, result);
}
function FromNot4(schema, references, path2, value) {
  return Default(schema, path2, Visit7(schema.not, references, path2, value));
}
function FromObject10(schema, references, path2, value) {
  if (!IsObject2(value))
    return Default(schema, path2, value);
  const knownKeys = KeyOfPropertyKeys(schema);
  const knownProperties = { ...value };
  for (const key of knownKeys) {
    if (!HasPropertyKey2(knownProperties, key))
      continue;
    if (IsUndefined2(knownProperties[key]) && (!IsUndefined3(schema.properties[key]) || TypeSystemPolicy.IsExactOptionalProperty(knownProperties, key)))
      continue;
    knownProperties[key] = Visit7(schema.properties[key], references, `${path2}/${key}`, knownProperties[key]);
  }
  if (!IsSchema(schema.additionalProperties)) {
    return Default(schema, path2, knownProperties);
  }
  const unknownKeys = Object.getOwnPropertyNames(knownProperties);
  const additionalProperties = schema.additionalProperties;
  const unknownProperties = { ...knownProperties };
  for (const key of unknownKeys)
    if (!knownKeys.includes(key)) {
      unknownProperties[key] = Default(additionalProperties, `${path2}/${key}`, unknownProperties[key]);
    }
  return Default(schema, path2, unknownProperties);
}
function FromRecord6(schema, references, path2, value) {
  if (!IsObject2(value))
    return Default(schema, path2, value);
  const pattern = Object.getOwnPropertyNames(schema.patternProperties)[0];
  const knownKeys = new RegExp(pattern);
  const knownProperties = { ...value };
  for (const key of Object.getOwnPropertyNames(value))
    if (knownKeys.test(key)) {
      knownProperties[key] = Visit7(schema.patternProperties[pattern], references, `${path2}/${key}`, knownProperties[key]);
    }
  if (!IsSchema(schema.additionalProperties)) {
    return Default(schema, path2, knownProperties);
  }
  const unknownKeys = Object.getOwnPropertyNames(knownProperties);
  const additionalProperties = schema.additionalProperties;
  const unknownProperties = { ...knownProperties };
  for (const key of unknownKeys)
    if (!knownKeys.test(key)) {
      unknownProperties[key] = Default(additionalProperties, `${path2}/${key}`, unknownProperties[key]);
    }
  return Default(schema, path2, unknownProperties);
}
function FromRef7(schema, references, path2, value) {
  const target = Deref(schema, references);
  return Default(schema, path2, Visit7(target, references, path2, value));
}
function FromThis3(schema, references, path2, value) {
  const target = Deref(schema, references);
  return Default(schema, path2, Visit7(target, references, path2, value));
}
function FromTuple8(schema, references, path2, value) {
  return IsArray2(value) && IsArray2(schema.items) ? Default(schema, path2, schema.items.map((schema2, index) => Visit7(schema2, references, `${path2}/${index}`, value[index]))) : Default(schema, path2, value);
}
function FromUnion13(schema, references, path2, value) {
  for (const subschema of schema.anyOf) {
    if (!Check(subschema, references, value))
      continue;
    const decoded = Visit7(subschema, references, path2, value);
    return Default(schema, path2, decoded);
  }
  return Default(schema, path2, value);
}
function Visit7(schema, references, path2, value) {
  const references_ = Pushref(schema, references);
  const schema_ = schema;
  switch (schema[Kind]) {
    case "Array":
      return FromArray9(schema_, references_, path2, value);
    case "Import":
      return FromImport3(schema_, references_, path2, value);
    case "Intersect":
      return FromIntersect11(schema_, references_, path2, value);
    case "Not":
      return FromNot4(schema_, references_, path2, value);
    case "Object":
      return FromObject10(schema_, references_, path2, value);
    case "Record":
      return FromRecord6(schema_, references_, path2, value);
    case "Ref":
      return FromRef7(schema_, references_, path2, value);
    case "Symbol":
      return Default(schema_, path2, value);
    case "This":
      return FromThis3(schema_, references_, path2, value);
    case "Tuple":
      return FromTuple8(schema_, references_, path2, value);
    case "Union":
      return FromUnion13(schema_, references_, path2, value);
    default:
      return Default(schema_, path2, value);
  }
}
function TransformDecode(schema, references, value) {
  return Visit7(schema, references, "", value);
}

// ../../../node_modules/.pnpm/@sinclair+typebox@0.34.33/node_modules/@sinclair/typebox/build/esm/value/transform/encode.mjs
init_define_ENV_DEFINED_IN_BUILD_STEP();
var TransformEncodeCheckError = class extends TypeBoxError {
  constructor(schema, value, error) {
    super(`The encoded value does not match the expected schema`);
    this.schema = schema;
    this.value = value;
    this.error = error;
  }
};
var TransformEncodeError = class extends TypeBoxError {
  constructor(schema, path2, value, error) {
    super(`${error instanceof Error ? error.message : "Unknown error"}`);
    this.schema = schema;
    this.path = path2;
    this.value = value;
    this.error = error;
  }
};
function Default2(schema, path2, value) {
  try {
    return IsTransform(schema) ? schema[TransformKind].Encode(value) : value;
  } catch (error) {
    throw new TransformEncodeError(schema, path2, value, error);
  }
}
function FromArray10(schema, references, path2, value) {
  const defaulted = Default2(schema, path2, value);
  return IsArray2(defaulted) ? defaulted.map((value2, index) => Visit8(schema.items, references, `${path2}/${index}`, value2)) : defaulted;
}
function FromImport4(schema, references, path2, value) {
  const additional = globalThis.Object.values(schema.$defs);
  const target = schema.$defs[schema.$ref];
  const result = Default2(schema, path2, value);
  return Visit8(target, [...references, ...additional], path2, result);
}
function FromIntersect12(schema, references, path2, value) {
  const defaulted = Default2(schema, path2, value);
  if (!IsObject2(value) || IsValueType(value))
    return defaulted;
  const knownEntries = KeyOfPropertyEntries(schema);
  const knownKeys = knownEntries.map((entry) => entry[0]);
  const knownProperties = { ...defaulted };
  for (const [knownKey, knownSchema] of knownEntries)
    if (knownKey in knownProperties) {
      knownProperties[knownKey] = Visit8(knownSchema, references, `${path2}/${knownKey}`, knownProperties[knownKey]);
    }
  if (!IsTransform(schema.unevaluatedProperties)) {
    return knownProperties;
  }
  const unknownKeys = Object.getOwnPropertyNames(knownProperties);
  const unevaluatedProperties = schema.unevaluatedProperties;
  const properties = { ...knownProperties };
  for (const key of unknownKeys)
    if (!knownKeys.includes(key)) {
      properties[key] = Default2(unevaluatedProperties, `${path2}/${key}`, properties[key]);
    }
  return properties;
}
function FromNot5(schema, references, path2, value) {
  return Default2(schema.not, path2, Default2(schema, path2, value));
}
function FromObject11(schema, references, path2, value) {
  const defaulted = Default2(schema, path2, value);
  if (!IsObject2(defaulted))
    return defaulted;
  const knownKeys = KeyOfPropertyKeys(schema);
  const knownProperties = { ...defaulted };
  for (const key of knownKeys) {
    if (!HasPropertyKey2(knownProperties, key))
      continue;
    if (IsUndefined2(knownProperties[key]) && (!IsUndefined3(schema.properties[key]) || TypeSystemPolicy.IsExactOptionalProperty(knownProperties, key)))
      continue;
    knownProperties[key] = Visit8(schema.properties[key], references, `${path2}/${key}`, knownProperties[key]);
  }
  if (!IsSchema(schema.additionalProperties)) {
    return knownProperties;
  }
  const unknownKeys = Object.getOwnPropertyNames(knownProperties);
  const additionalProperties = schema.additionalProperties;
  const properties = { ...knownProperties };
  for (const key of unknownKeys)
    if (!knownKeys.includes(key)) {
      properties[key] = Default2(additionalProperties, `${path2}/${key}`, properties[key]);
    }
  return properties;
}
function FromRecord7(schema, references, path2, value) {
  const defaulted = Default2(schema, path2, value);
  if (!IsObject2(value))
    return defaulted;
  const pattern = Object.getOwnPropertyNames(schema.patternProperties)[0];
  const knownKeys = new RegExp(pattern);
  const knownProperties = { ...defaulted };
  for (const key of Object.getOwnPropertyNames(value))
    if (knownKeys.test(key)) {
      knownProperties[key] = Visit8(schema.patternProperties[pattern], references, `${path2}/${key}`, knownProperties[key]);
    }
  if (!IsSchema(schema.additionalProperties)) {
    return knownProperties;
  }
  const unknownKeys = Object.getOwnPropertyNames(knownProperties);
  const additionalProperties = schema.additionalProperties;
  const properties = { ...knownProperties };
  for (const key of unknownKeys)
    if (!knownKeys.test(key)) {
      properties[key] = Default2(additionalProperties, `${path2}/${key}`, properties[key]);
    }
  return properties;
}
function FromRef8(schema, references, path2, value) {
  const target = Deref(schema, references);
  const resolved = Visit8(target, references, path2, value);
  return Default2(schema, path2, resolved);
}
function FromThis4(schema, references, path2, value) {
  const target = Deref(schema, references);
  const resolved = Visit8(target, references, path2, value);
  return Default2(schema, path2, resolved);
}
function FromTuple9(schema, references, path2, value) {
  const value1 = Default2(schema, path2, value);
  return IsArray2(schema.items) ? schema.items.map((schema2, index) => Visit8(schema2, references, `${path2}/${index}`, value1[index])) : [];
}
function FromUnion14(schema, references, path2, value) {
  for (const subschema of schema.anyOf) {
    if (!Check(subschema, references, value))
      continue;
    const value1 = Visit8(subschema, references, path2, value);
    return Default2(schema, path2, value1);
  }
  for (const subschema of schema.anyOf) {
    const value1 = Visit8(subschema, references, path2, value);
    if (!Check(schema, references, value1))
      continue;
    return Default2(schema, path2, value1);
  }
  return Default2(schema, path2, value);
}
function Visit8(schema, references, path2, value) {
  const references_ = Pushref(schema, references);
  const schema_ = schema;
  switch (schema[Kind]) {
    case "Array":
      return FromArray10(schema_, references_, path2, value);
    case "Import":
      return FromImport4(schema_, references_, path2, value);
    case "Intersect":
      return FromIntersect12(schema_, references_, path2, value);
    case "Not":
      return FromNot5(schema_, references_, path2, value);
    case "Object":
      return FromObject11(schema_, references_, path2, value);
    case "Record":
      return FromRecord7(schema_, references_, path2, value);
    case "Ref":
      return FromRef8(schema_, references_, path2, value);
    case "This":
      return FromThis4(schema_, references_, path2, value);
    case "Tuple":
      return FromTuple9(schema_, references_, path2, value);
    case "Union":
      return FromUnion14(schema_, references_, path2, value);
    default:
      return Default2(schema_, path2, value);
  }
}
function TransformEncode(schema, references, value) {
  return Visit8(schema, references, "", value);
}

// ../../../node_modules/.pnpm/@sinclair+typebox@0.34.33/node_modules/@sinclair/typebox/build/esm/value/transform/has.mjs
init_define_ENV_DEFINED_IN_BUILD_STEP();
function FromArray11(schema, references) {
  return IsTransform(schema) || Visit9(schema.items, references);
}
function FromAsyncIterator6(schema, references) {
  return IsTransform(schema) || Visit9(schema.items, references);
}
function FromConstructor6(schema, references) {
  return IsTransform(schema) || Visit9(schema.returns, references) || schema.parameters.some((schema2) => Visit9(schema2, references));
}
function FromFunction6(schema, references) {
  return IsTransform(schema) || Visit9(schema.returns, references) || schema.parameters.some((schema2) => Visit9(schema2, references));
}
function FromIntersect13(schema, references) {
  return IsTransform(schema) || IsTransform(schema.unevaluatedProperties) || schema.allOf.some((schema2) => Visit9(schema2, references));
}
function FromImport5(schema, references) {
  const additional = globalThis.Object.getOwnPropertyNames(schema.$defs).reduce((result, key) => [...result, schema.$defs[key]], []);
  const target = schema.$defs[schema.$ref];
  return IsTransform(schema) || Visit9(target, [...additional, ...references]);
}
function FromIterator6(schema, references) {
  return IsTransform(schema) || Visit9(schema.items, references);
}
function FromNot6(schema, references) {
  return IsTransform(schema) || Visit9(schema.not, references);
}
function FromObject12(schema, references) {
  return IsTransform(schema) || Object.values(schema.properties).some((schema2) => Visit9(schema2, references)) || IsSchema(schema.additionalProperties) && Visit9(schema.additionalProperties, references);
}
function FromPromise6(schema, references) {
  return IsTransform(schema) || Visit9(schema.item, references);
}
function FromRecord8(schema, references) {
  const pattern = Object.getOwnPropertyNames(schema.patternProperties)[0];
  const property = schema.patternProperties[pattern];
  return IsTransform(schema) || Visit9(property, references) || IsSchema(schema.additionalProperties) && IsTransform(schema.additionalProperties);
}
function FromRef9(schema, references) {
  if (IsTransform(schema))
    return true;
  return Visit9(Deref(schema, references), references);
}
function FromThis5(schema, references) {
  if (IsTransform(schema))
    return true;
  return Visit9(Deref(schema, references), references);
}
function FromTuple10(schema, references) {
  return IsTransform(schema) || !IsUndefined2(schema.items) && schema.items.some((schema2) => Visit9(schema2, references));
}
function FromUnion15(schema, references) {
  return IsTransform(schema) || schema.anyOf.some((schema2) => Visit9(schema2, references));
}
function Visit9(schema, references) {
  const references_ = Pushref(schema, references);
  const schema_ = schema;
  if (schema.$id && visited.has(schema.$id))
    return false;
  if (schema.$id)
    visited.add(schema.$id);
  switch (schema[Kind]) {
    case "Array":
      return FromArray11(schema_, references_);
    case "AsyncIterator":
      return FromAsyncIterator6(schema_, references_);
    case "Constructor":
      return FromConstructor6(schema_, references_);
    case "Function":
      return FromFunction6(schema_, references_);
    case "Import":
      return FromImport5(schema_, references_);
    case "Intersect":
      return FromIntersect13(schema_, references_);
    case "Iterator":
      return FromIterator6(schema_, references_);
    case "Not":
      return FromNot6(schema_, references_);
    case "Object":
      return FromObject12(schema_, references_);
    case "Promise":
      return FromPromise6(schema_, references_);
    case "Record":
      return FromRecord8(schema_, references_);
    case "Ref":
      return FromRef9(schema_, references_);
    case "This":
      return FromThis5(schema_, references_);
    case "Tuple":
      return FromTuple10(schema_, references_);
    case "Union":
      return FromUnion15(schema_, references_);
    default:
      return IsTransform(schema);
  }
}
var visited = /* @__PURE__ */ new Set();
function HasTransform(schema, references) {
  visited.clear();
  return Visit9(schema, references);
}

// ../../../node_modules/.pnpm/@sinclair+typebox@0.34.33/node_modules/@sinclair/typebox/build/esm/compiler/compiler.mjs
var TypeCheck = class {
  constructor(schema, references, checkFunc, code) {
    this.schema = schema;
    this.references = references;
    this.checkFunc = checkFunc;
    this.code = code;
    this.hasTransform = HasTransform(schema, references);
  }
  /** Returns the generated assertion code used to validate this type. */
  Code() {
    return this.code;
  }
  /** Returns the schema type used to validate */
  Schema() {
    return this.schema;
  }
  /** Returns reference types used to validate */
  References() {
    return this.references;
  }
  /** Returns an iterator for each error in this value. */
  Errors(value) {
    return Errors(this.schema, this.references, value);
  }
  /** Returns true if the value matches the compiled type. */
  Check(value) {
    return this.checkFunc(value);
  }
  /** Decodes a value or throws if error */
  Decode(value) {
    if (!this.checkFunc(value))
      throw new TransformDecodeCheckError(this.schema, value, this.Errors(value).First());
    return this.hasTransform ? TransformDecode(this.schema, this.references, value) : value;
  }
  /** Encodes a value or throws if error */
  Encode(value) {
    const encoded = this.hasTransform ? TransformEncode(this.schema, this.references, value) : value;
    if (!this.checkFunc(encoded))
      throw new TransformEncodeCheckError(this.schema, value, this.Errors(value).First());
    return encoded;
  }
};
var Character;
(function(Character2) {
  function DollarSign(code) {
    return code === 36;
  }
  Character2.DollarSign = DollarSign;
  function IsUnderscore(code) {
    return code === 95;
  }
  Character2.IsUnderscore = IsUnderscore;
  function IsAlpha(code) {
    return code >= 65 && code <= 90 || code >= 97 && code <= 122;
  }
  Character2.IsAlpha = IsAlpha;
  function IsNumeric(code) {
    return code >= 48 && code <= 57;
  }
  Character2.IsNumeric = IsNumeric;
})(Character || (Character = {}));
var MemberExpression;
(function(MemberExpression2) {
  function IsFirstCharacterNumeric(value) {
    if (value.length === 0)
      return false;
    return Character.IsNumeric(value.charCodeAt(0));
  }
  function IsAccessor(value) {
    if (IsFirstCharacterNumeric(value))
      return false;
    for (let i2 = 0; i2 < value.length; i2++) {
      const code = value.charCodeAt(i2);
      const check = Character.IsAlpha(code) || Character.IsNumeric(code) || Character.DollarSign(code) || Character.IsUnderscore(code);
      if (!check)
        return false;
    }
    return true;
  }
  function EscapeHyphen(key) {
    return key.replace(/'/g, "\\'");
  }
  function Encode(object, key) {
    return IsAccessor(key) ? `${object}.${key}` : `${object}['${EscapeHyphen(key)}']`;
  }
  MemberExpression2.Encode = Encode;
})(MemberExpression || (MemberExpression = {}));
var Identifier;
(function(Identifier2) {
  function Encode($id) {
    const buffer = [];
    for (let i2 = 0; i2 < $id.length; i2++) {
      const code = $id.charCodeAt(i2);
      if (Character.IsNumeric(code) || Character.IsAlpha(code)) {
        buffer.push($id.charAt(i2));
      } else {
        buffer.push(`_${code}_`);
      }
    }
    return buffer.join("").replace(/__/g, "_");
  }
  Identifier2.Encode = Encode;
})(Identifier || (Identifier = {}));
var LiteralString;
(function(LiteralString2) {
  function Escape2(content) {
    return content.replace(/'/g, "\\'");
  }
  LiteralString2.Escape = Escape2;
})(LiteralString || (LiteralString = {}));
var TypeCompilerUnknownTypeError = class extends TypeBoxError {
  constructor(schema) {
    super("Unknown type");
    this.schema = schema;
  }
};
var TypeCompilerTypeGuardError = class extends TypeBoxError {
  constructor(schema) {
    super("Preflight validation check failed to guard for the given schema");
    this.schema = schema;
  }
};
var Policy;
(function(Policy2) {
  function IsExactOptionalProperty(value, key, expression) {
    return TypeSystemPolicy.ExactOptionalPropertyTypes ? `('${key}' in ${value} ? ${expression} : true)` : `(${MemberExpression.Encode(value, key)} !== undefined ? ${expression} : true)`;
  }
  Policy2.IsExactOptionalProperty = IsExactOptionalProperty;
  function IsObjectLike(value) {
    return !TypeSystemPolicy.AllowArrayObject ? `(typeof ${value} === 'object' && ${value} !== null && !Array.isArray(${value}))` : `(typeof ${value} === 'object' && ${value} !== null)`;
  }
  Policy2.IsObjectLike = IsObjectLike;
  function IsRecordLike(value) {
    return !TypeSystemPolicy.AllowArrayObject ? `(typeof ${value} === 'object' && ${value} !== null && !Array.isArray(${value}) && !(${value} instanceof Date) && !(${value} instanceof Uint8Array))` : `(typeof ${value} === 'object' && ${value} !== null && !(${value} instanceof Date) && !(${value} instanceof Uint8Array))`;
  }
  Policy2.IsRecordLike = IsRecordLike;
  function IsNumberLike(value) {
    return TypeSystemPolicy.AllowNaN ? `typeof ${value} === 'number'` : `Number.isFinite(${value})`;
  }
  Policy2.IsNumberLike = IsNumberLike;
  function IsVoidLike(value) {
    return TypeSystemPolicy.AllowNullVoid ? `(${value} === undefined || ${value} === null)` : `${value} === undefined`;
  }
  Policy2.IsVoidLike = IsVoidLike;
})(Policy || (Policy = {}));
var TypeCompiler;
(function(TypeCompiler2) {
  function IsAnyOrUnknown2(schema) {
    return schema[Kind] === "Any" || schema[Kind] === "Unknown";
  }
  function* FromAny4(schema, references, value) {
    yield "true";
  }
  function* FromArgument4(schema, references, value) {
    yield "true";
  }
  function* FromArray12(schema, references, value) {
    yield `Array.isArray(${value})`;
    const [parameter, accumulator] = [CreateParameter("value", "any"), CreateParameter("acc", "number")];
    if (IsNumber2(schema.maxItems))
      yield `${value}.length <= ${schema.maxItems}`;
    if (IsNumber2(schema.minItems))
      yield `${value}.length >= ${schema.minItems}`;
    const elementExpression = CreateExpression(schema.items, references, "value");
    yield `${value}.every((${parameter}) => ${elementExpression})`;
    if (IsSchema2(schema.contains) || IsNumber2(schema.minContains) || IsNumber2(schema.maxContains)) {
      const containsSchema = IsSchema2(schema.contains) ? schema.contains : Never();
      const checkExpression = CreateExpression(containsSchema, references, "value");
      const checkMinContains = IsNumber2(schema.minContains) ? [`(count >= ${schema.minContains})`] : [];
      const checkMaxContains = IsNumber2(schema.maxContains) ? [`(count <= ${schema.maxContains})`] : [];
      const checkCount = `const count = value.reduce((${accumulator}, ${parameter}) => ${checkExpression} ? acc + 1 : acc, 0)`;
      const check = [`(count > 0)`, ...checkMinContains, ...checkMaxContains].join(" && ");
      yield `((${parameter}) => { ${checkCount}; return ${check}})(${value})`;
    }
    if (schema.uniqueItems === true) {
      const check = `const hashed = hash(element); if(set.has(hashed)) { return false } else { set.add(hashed) } } return true`;
      const block = `const set = new Set(); for(const element of value) { ${check} }`;
      yield `((${parameter}) => { ${block} )(${value})`;
    }
  }
  function* FromAsyncIterator7(schema, references, value) {
    yield `(typeof value === 'object' && Symbol.asyncIterator in ${value})`;
  }
  function* FromBigInt4(schema, references, value) {
    yield `(typeof ${value} === 'bigint')`;
    if (IsBigInt2(schema.exclusiveMaximum))
      yield `${value} < BigInt(${schema.exclusiveMaximum})`;
    if (IsBigInt2(schema.exclusiveMinimum))
      yield `${value} > BigInt(${schema.exclusiveMinimum})`;
    if (IsBigInt2(schema.maximum))
      yield `${value} <= BigInt(${schema.maximum})`;
    if (IsBigInt2(schema.minimum))
      yield `${value} >= BigInt(${schema.minimum})`;
    if (IsBigInt2(schema.multipleOf))
      yield `(${value} % BigInt(${schema.multipleOf})) === 0`;
  }
  function* FromBoolean4(schema, references, value) {
    yield `(typeof ${value} === 'boolean')`;
  }
  function* FromConstructor7(schema, references, value) {
    yield* Visit10(schema.returns, references, `${value}.prototype`);
  }
  function* FromDate4(schema, references, value) {
    yield `(${value} instanceof Date) && Number.isFinite(${value}.getTime())`;
    if (IsNumber2(schema.exclusiveMaximumTimestamp))
      yield `${value}.getTime() < ${schema.exclusiveMaximumTimestamp}`;
    if (IsNumber2(schema.exclusiveMinimumTimestamp))
      yield `${value}.getTime() > ${schema.exclusiveMinimumTimestamp}`;
    if (IsNumber2(schema.maximumTimestamp))
      yield `${value}.getTime() <= ${schema.maximumTimestamp}`;
    if (IsNumber2(schema.minimumTimestamp))
      yield `${value}.getTime() >= ${schema.minimumTimestamp}`;
    if (IsNumber2(schema.multipleOfTimestamp))
      yield `(${value}.getTime() % ${schema.multipleOfTimestamp}) === 0`;
  }
  function* FromFunction7(schema, references, value) {
    yield `(typeof ${value} === 'function')`;
  }
  function* FromImport6(schema, references, value) {
    const members = globalThis.Object.getOwnPropertyNames(schema.$defs).reduce((result, key) => {
      return [...result, schema.$defs[key]];
    }, []);
    yield* Visit10(Ref(schema.$ref), [...references, ...members], value);
  }
  function* FromInteger4(schema, references, value) {
    yield `Number.isInteger(${value})`;
    if (IsNumber2(schema.exclusiveMaximum))
      yield `${value} < ${schema.exclusiveMaximum}`;
    if (IsNumber2(schema.exclusiveMinimum))
      yield `${value} > ${schema.exclusiveMinimum}`;
    if (IsNumber2(schema.maximum))
      yield `${value} <= ${schema.maximum}`;
    if (IsNumber2(schema.minimum))
      yield `${value} >= ${schema.minimum}`;
    if (IsNumber2(schema.multipleOf))
      yield `(${value} % ${schema.multipleOf}) === 0`;
  }
  function* FromIntersect14(schema, references, value) {
    const check1 = schema.allOf.map((schema2) => CreateExpression(schema2, references, value)).join(" && ");
    if (schema.unevaluatedProperties === false) {
      const keyCheck = CreateVariable(`${new RegExp(KeyOfPattern(schema))};`);
      const check2 = `Object.getOwnPropertyNames(${value}).every(key => ${keyCheck}.test(key))`;
      yield `(${check1} && ${check2})`;
    } else if (IsSchema2(schema.unevaluatedProperties)) {
      const keyCheck = CreateVariable(`${new RegExp(KeyOfPattern(schema))};`);
      const check2 = `Object.getOwnPropertyNames(${value}).every(key => ${keyCheck}.test(key) || ${CreateExpression(schema.unevaluatedProperties, references, `${value}[key]`)})`;
      yield `(${check1} && ${check2})`;
    } else {
      yield `(${check1})`;
    }
  }
  function* FromIterator7(schema, references, value) {
    yield `(typeof value === 'object' && Symbol.iterator in ${value})`;
  }
  function* FromLiteral5(schema, references, value) {
    if (typeof schema.const === "number" || typeof schema.const === "boolean") {
      yield `(${value} === ${schema.const})`;
    } else {
      yield `(${value} === '${LiteralString.Escape(schema.const)}')`;
    }
  }
  function* FromNever4(schema, references, value) {
    yield `false`;
  }
  function* FromNot7(schema, references, value) {
    const expression = CreateExpression(schema.not, references, value);
    yield `(!${expression})`;
  }
  function* FromNull4(schema, references, value) {
    yield `(${value} === null)`;
  }
  function* FromNumber4(schema, references, value) {
    yield Policy.IsNumberLike(value);
    if (IsNumber2(schema.exclusiveMaximum))
      yield `${value} < ${schema.exclusiveMaximum}`;
    if (IsNumber2(schema.exclusiveMinimum))
      yield `${value} > ${schema.exclusiveMinimum}`;
    if (IsNumber2(schema.maximum))
      yield `${value} <= ${schema.maximum}`;
    if (IsNumber2(schema.minimum))
      yield `${value} >= ${schema.minimum}`;
    if (IsNumber2(schema.multipleOf))
      yield `(${value} % ${schema.multipleOf}) === 0`;
  }
  function* FromObject13(schema, references, value) {
    yield Policy.IsObjectLike(value);
    if (IsNumber2(schema.minProperties))
      yield `Object.getOwnPropertyNames(${value}).length >= ${schema.minProperties}`;
    if (IsNumber2(schema.maxProperties))
      yield `Object.getOwnPropertyNames(${value}).length <= ${schema.maxProperties}`;
    const knownKeys = Object.getOwnPropertyNames(schema.properties);
    for (const knownKey of knownKeys) {
      const memberExpression = MemberExpression.Encode(value, knownKey);
      const property = schema.properties[knownKey];
      if (schema.required && schema.required.includes(knownKey)) {
        yield* Visit10(property, references, memberExpression);
        if (ExtendsUndefinedCheck(property) || IsAnyOrUnknown2(property))
          yield `('${knownKey}' in ${value})`;
      } else {
        const expression = CreateExpression(property, references, memberExpression);
        yield Policy.IsExactOptionalProperty(value, knownKey, expression);
      }
    }
    if (schema.additionalProperties === false) {
      if (schema.required && schema.required.length === knownKeys.length) {
        yield `Object.getOwnPropertyNames(${value}).length === ${knownKeys.length}`;
      } else {
        const keys = `[${knownKeys.map((key) => `'${key}'`).join(", ")}]`;
        yield `Object.getOwnPropertyNames(${value}).every(key => ${keys}.includes(key))`;
      }
    }
    if (typeof schema.additionalProperties === "object") {
      const expression = CreateExpression(schema.additionalProperties, references, `${value}[key]`);
      const keys = `[${knownKeys.map((key) => `'${key}'`).join(", ")}]`;
      yield `(Object.getOwnPropertyNames(${value}).every(key => ${keys}.includes(key) || ${expression}))`;
    }
  }
  function* FromPromise7(schema, references, value) {
    yield `${value} instanceof Promise`;
  }
  function* FromRecord9(schema, references, value) {
    yield Policy.IsRecordLike(value);
    if (IsNumber2(schema.minProperties))
      yield `Object.getOwnPropertyNames(${value}).length >= ${schema.minProperties}`;
    if (IsNumber2(schema.maxProperties))
      yield `Object.getOwnPropertyNames(${value}).length <= ${schema.maxProperties}`;
    const [patternKey, patternSchema] = Object.entries(schema.patternProperties)[0];
    const variable = CreateVariable(`${new RegExp(patternKey)}`);
    const check1 = CreateExpression(patternSchema, references, "value");
    const check2 = IsSchema2(schema.additionalProperties) ? CreateExpression(schema.additionalProperties, references, value) : schema.additionalProperties === false ? "false" : "true";
    const expression = `(${variable}.test(key) ? ${check1} : ${check2})`;
    yield `(Object.entries(${value}).every(([key, value]) => ${expression}))`;
  }
  function* FromRef10(schema, references, value) {
    const target = Deref(schema, references);
    if (state.functions.has(schema.$ref))
      return yield `${CreateFunctionName(schema.$ref)}(${value})`;
    yield* Visit10(target, references, value);
  }
  function* FromRegExp4(schema, references, value) {
    const variable = CreateVariable(`${new RegExp(schema.source, schema.flags)};`);
    yield `(typeof ${value} === 'string')`;
    if (IsNumber2(schema.maxLength))
      yield `${value}.length <= ${schema.maxLength}`;
    if (IsNumber2(schema.minLength))
      yield `${value}.length >= ${schema.minLength}`;
    yield `${variable}.test(${value})`;
  }
  function* FromString4(schema, references, value) {
    yield `(typeof ${value} === 'string')`;
    if (IsNumber2(schema.maxLength))
      yield `${value}.length <= ${schema.maxLength}`;
    if (IsNumber2(schema.minLength))
      yield `${value}.length >= ${schema.minLength}`;
    if (schema.pattern !== void 0) {
      const variable = CreateVariable(`${new RegExp(schema.pattern)};`);
      yield `${variable}.test(${value})`;
    }
    if (schema.format !== void 0) {
      yield `format('${schema.format}', ${value})`;
    }
  }
  function* FromSymbol4(schema, references, value) {
    yield `(typeof ${value} === 'symbol')`;
  }
  function* FromTemplateLiteral6(schema, references, value) {
    yield `(typeof ${value} === 'string')`;
    const variable = CreateVariable(`${new RegExp(schema.pattern)};`);
    yield `${variable}.test(${value})`;
  }
  function* FromThis6(schema, references, value) {
    yield `${CreateFunctionName(schema.$ref)}(${value})`;
  }
  function* FromTuple11(schema, references, value) {
    yield `Array.isArray(${value})`;
    if (schema.items === void 0)
      return yield `${value}.length === 0`;
    yield `(${value}.length === ${schema.maxItems})`;
    for (let i2 = 0; i2 < schema.items.length; i2++) {
      const expression = CreateExpression(schema.items[i2], references, `${value}[${i2}]`);
      yield `${expression}`;
    }
  }
  function* FromUndefined4(schema, references, value) {
    yield `${value} === undefined`;
  }
  function* FromUnion16(schema, references, value) {
    const expressions = schema.anyOf.map((schema2) => CreateExpression(schema2, references, value));
    yield `(${expressions.join(" || ")})`;
  }
  function* FromUint8Array4(schema, references, value) {
    yield `${value} instanceof Uint8Array`;
    if (IsNumber2(schema.maxByteLength))
      yield `(${value}.length <= ${schema.maxByteLength})`;
    if (IsNumber2(schema.minByteLength))
      yield `(${value}.length >= ${schema.minByteLength})`;
  }
  function* FromUnknown4(schema, references, value) {
    yield "true";
  }
  function* FromVoid4(schema, references, value) {
    yield Policy.IsVoidLike(value);
  }
  function* FromKind3(schema, references, value) {
    const instance = state.instances.size;
    state.instances.set(instance, schema);
    yield `kind('${schema[Kind]}', ${instance}, ${value})`;
  }
  function* Visit10(schema, references, value, useHoisting = true) {
    const references_ = IsString2(schema.$id) ? [...references, schema] : references;
    const schema_ = schema;
    if (useHoisting && IsString2(schema.$id)) {
      const functionName = CreateFunctionName(schema.$id);
      if (state.functions.has(functionName)) {
        return yield `${functionName}(${value})`;
      } else {
        state.functions.set(functionName, "<deferred>");
        const functionCode = CreateFunction(functionName, schema, references, "value", false);
        state.functions.set(functionName, functionCode);
        return yield `${functionName}(${value})`;
      }
    }
    switch (schema_[Kind]) {
      case "Any":
        return yield* FromAny4(schema_, references_, value);
      case "Argument":
        return yield* FromArgument4(schema_, references_, value);
      case "Array":
        return yield* FromArray12(schema_, references_, value);
      case "AsyncIterator":
        return yield* FromAsyncIterator7(schema_, references_, value);
      case "BigInt":
        return yield* FromBigInt4(schema_, references_, value);
      case "Boolean":
        return yield* FromBoolean4(schema_, references_, value);
      case "Constructor":
        return yield* FromConstructor7(schema_, references_, value);
      case "Date":
        return yield* FromDate4(schema_, references_, value);
      case "Function":
        return yield* FromFunction7(schema_, references_, value);
      case "Import":
        return yield* FromImport6(schema_, references_, value);
      case "Integer":
        return yield* FromInteger4(schema_, references_, value);
      case "Intersect":
        return yield* FromIntersect14(schema_, references_, value);
      case "Iterator":
        return yield* FromIterator7(schema_, references_, value);
      case "Literal":
        return yield* FromLiteral5(schema_, references_, value);
      case "Never":
        return yield* FromNever4(schema_, references_, value);
      case "Not":
        return yield* FromNot7(schema_, references_, value);
      case "Null":
        return yield* FromNull4(schema_, references_, value);
      case "Number":
        return yield* FromNumber4(schema_, references_, value);
      case "Object":
        return yield* FromObject13(schema_, references_, value);
      case "Promise":
        return yield* FromPromise7(schema_, references_, value);
      case "Record":
        return yield* FromRecord9(schema_, references_, value);
      case "Ref":
        return yield* FromRef10(schema_, references_, value);
      case "RegExp":
        return yield* FromRegExp4(schema_, references_, value);
      case "String":
        return yield* FromString4(schema_, references_, value);
      case "Symbol":
        return yield* FromSymbol4(schema_, references_, value);
      case "TemplateLiteral":
        return yield* FromTemplateLiteral6(schema_, references_, value);
      case "This":
        return yield* FromThis6(schema_, references_, value);
      case "Tuple":
        return yield* FromTuple11(schema_, references_, value);
      case "Undefined":
        return yield* FromUndefined4(schema_, references_, value);
      case "Union":
        return yield* FromUnion16(schema_, references_, value);
      case "Uint8Array":
        return yield* FromUint8Array4(schema_, references_, value);
      case "Unknown":
        return yield* FromUnknown4(schema_, references_, value);
      case "Void":
        return yield* FromVoid4(schema_, references_, value);
      default:
        if (!type_exports2.Has(schema_[Kind]))
          throw new TypeCompilerUnknownTypeError(schema);
        return yield* FromKind3(schema_, references_, value);
    }
  }
  const state = {
    language: "javascript",
    // target language
    functions: /* @__PURE__ */ new Map(),
    // local functions
    variables: /* @__PURE__ */ new Map(),
    // local variables
    instances: /* @__PURE__ */ new Map()
    // exterior kind instances
  };
  function CreateExpression(schema, references, value, useHoisting = true) {
    return `(${[...Visit10(schema, references, value, useHoisting)].join(" && ")})`;
  }
  function CreateFunctionName($id) {
    return `check_${Identifier.Encode($id)}`;
  }
  function CreateVariable(expression) {
    const variableName = `local_${state.variables.size}`;
    state.variables.set(variableName, `const ${variableName} = ${expression}`);
    return variableName;
  }
  function CreateFunction(name, schema, references, value, useHoisting = true) {
    const [newline, pad] = ["\n", (length) => "".padStart(length, " ")];
    const parameter = CreateParameter("value", "any");
    const returns = CreateReturns("boolean");
    const expression = [...Visit10(schema, references, value, useHoisting)].map((expression2) => `${pad(4)}${expression2}`).join(` &&${newline}`);
    return `function ${name}(${parameter})${returns} {${newline}${pad(2)}return (${newline}${expression}${newline}${pad(2)})
}`;
  }
  function CreateParameter(name, type) {
    const annotation = state.language === "typescript" ? `: ${type}` : "";
    return `${name}${annotation}`;
  }
  function CreateReturns(type) {
    return state.language === "typescript" ? `: ${type}` : "";
  }
  function Build(schema, references, options) {
    const functionCode = CreateFunction("check", schema, references, "value");
    const parameter = CreateParameter("value", "any");
    const returns = CreateReturns("boolean");
    const functions = [...state.functions.values()];
    const variables = [...state.variables.values()];
    const checkFunction = IsString2(schema.$id) ? `return function check(${parameter})${returns} {
  return ${CreateFunctionName(schema.$id)}(value)
}` : `return ${functionCode}`;
    return [...variables, ...functions, checkFunction].join("\n");
  }
  function Code(...args) {
    const defaults = { language: "javascript" };
    const [schema, references, options] = args.length === 2 && IsArray2(args[1]) ? [args[0], args[1], defaults] : args.length === 2 && !IsArray2(args[1]) ? [args[0], [], args[1]] : args.length === 3 ? [args[0], args[1], args[2]] : args.length === 1 ? [args[0], [], defaults] : [null, [], defaults];
    state.language = options.language;
    state.variables.clear();
    state.functions.clear();
    state.instances.clear();
    if (!IsSchema2(schema))
      throw new TypeCompilerTypeGuardError(schema);
    for (const schema2 of references)
      if (!IsSchema2(schema2))
        throw new TypeCompilerTypeGuardError(schema2);
    return Build(schema, references, options);
  }
  TypeCompiler2.Code = Code;
  function Compile(schema, references = []) {
    const generatedCode = Code(schema, references, { language: "javascript" });
    const compiledFunction = globalThis.Function("kind", "format", "hash", generatedCode);
    const instances = new Map(state.instances);
    function typeRegistryFunction(kind, instance, value) {
      if (!type_exports2.Has(kind) || !instances.has(instance))
        return false;
      const checkFunc = type_exports2.Get(kind);
      const schema2 = instances.get(instance);
      return checkFunc(schema2, value);
    }
    function formatRegistryFunction(format, value) {
      if (!format_exports.Has(format))
        return false;
      const checkFunc = format_exports.Get(format);
      return checkFunc(value);
    }
    function hashFunction(value) {
      return Hash(value);
    }
    const checkFunction = compiledFunction(typeRegistryFunction, formatRegistryFunction, hashFunction);
    return new TypeCheck(schema, references, checkFunction, generatedCode);
  }
  TypeCompiler2.Compile = Compile;
})(TypeCompiler || (TypeCompiler = {}));

// ../../../packages/zettel/zettel-ast/dist/validate.js
var Z = TypeCompiler.Compile(ZettelDocJsonSchema);
function validate(zettel) {
  const result = Z.Check(zettel);
  if (!result) {
    const errors = [...Z.Errors(zettel)];
    return {
      success: false,
      data: void 0,
      errors: errors.map((error) => ({ message: error.message }))
    };
  }
  return {
    success: true,
    data: zettel,
    errors: void 0
  };
}

// ../../../packages/lix-sdk/dist/thread/database-schema.js
function applyThreadDatabaseSchema(sqlite2) {
  sqlite2.createFunction({
    name: "validate_zettel_doc",
    arity: 1,
    xFunc: (_ctx, value) => {
      const result = validate(JSON.parse(value));
      if (result.errors) {
        throw new Error("The Zettel Doc is invalid: " + result.errors.join("\n"));
      }
      return 1;
    },
    deterministic: true
  });
  const sql2 = `
  CREATE TABLE IF NOT EXISTS thread (
    id TEXT PRIMARY KEY DEFAULT (nano_id())
  ) STRICT;

  CREATE TABLE IF NOT EXISTS thread_comment (
    id TEXT PRIMARY KEY DEFAULT (nano_id()),
    thread_id TEXT NOT NULL,
    parent_id TEXT,

    body BLOB NOT NULL, --JSONB
    FOREIGN KEY(thread_id) REFERENCES thread(id),
    FOREIGN KEY(parent_id) REFERENCES thread_comment(id)
  ) STRICT;

  -- TEMP TRIGGER to validate ZettelDoc for inserts
  CREATE TEMP TRIGGER IF NOT EXISTS validate_thread_comment_doc_insert
  BEFORE INSERT ON thread_comment
  FOR EACH ROW
  BEGIN
    SELECT
      CASE
        WHEN validate_zettel_doc(json(NEW.body)) = 0
        THEN RAISE(ABORT, 'Invalid ZettelDoc: body must be a valid ZettelDoc')
      END;
  END;

  -- TEMP TRIGGER to validate ZettelDoc for upserts/updates
  CREATE TEMP TRIGGER IF NOT EXISTS validate_thread_comment_doc_update
  BEFORE UPDATE OF body ON thread_comment
  FOR EACH ROW
  BEGIN
    SELECT
      CASE
        WHEN validate_zettel_doc(json(NEW.body)) = 0
        THEN RAISE(ABORT, 'Invalid ZettelDoc: body must be a valid ZettelDoc')
      END;
  END;
`;
  return sqlite2.exec(sql2);
}

// ../../../packages/lix-sdk/dist/database/apply-schema.js
function applySchema(args) {
  applyAccountDatabaseSchema(args.sqlite);
  applyKeyValueDatabaseSchema(args.sqlite);
  applyThreadDatabaseSchema(args.sqlite);
  applyFileDatabaseSchema(args.sqlite);
  applySnapshotDatabaseSchema(args.sqlite);
  args.sqlite.exec`

  PRAGMA foreign_keys = ON;
  PRAGMA auto_vacuum = 2; -- incremental https://www.sqlite.org/pragma.html#pragma_auto_vacuum

  CREATE TABLE IF NOT EXISTS change (
    id TEXT PRIMARY KEY DEFAULT (uuid_v7()),
    entity_id TEXT NOT NULL,
    schema_key TEXT NOT NULL,
    file_id TEXT NOT NULL,
    plugin_key TEXT NOT NULL,
    snapshot_id TEXT NOT NULL,
    created_at TEXT DEFAULT CURRENT_TIMESTAMP NOT NULL,

    UNIQUE (id, entity_id, file_id, schema_key),
    FOREIGN KEY(snapshot_id) REFERENCES snapshot(id)
  ) STRICT;

  CREATE TABLE IF NOT EXISTS change_author (
    change_id TEXT NOT NULL,
    account_id TEXT NOT NULL,

    PRIMARY KEY (change_id, account_id),
    FOREIGN KEY(change_id) REFERENCES change(id),
    FOREIGN KEY(account_id) REFERENCES account(id)
  ) strict;
  `;
  applyChangeSetDatabaseSchema(args.sqlite);
  args.sqlite.exec`

  -- labels
  
  CREATE TABLE IF NOT EXISTS label (
    id TEXT PRIMARY KEY DEFAULT (nano_id(8)),
    
    name TEXT NOT NULL UNIQUE  -- e.g., 'checkpoint', 'reviewed'
    
  ) STRICT;

  INSERT OR IGNORE INTO label (name) VALUES ('checkpoint');

  CREATE TEMP TRIGGER IF NOT EXISTS insert_account_if_not_exists_on_change_author
  BEFORE INSERT ON change_author
  FOR EACH ROW
  WHEN NEW.account_id NOT IN (SELECT id FROM account) AND NEW.account_id IN (SELECT id FROM temp.active_account)
  BEGIN
    INSERT OR IGNORE INTO account
      SELECT 
      *
      FROM active_account 
      WHERE id = NEW.account_id;
  END;
  `;
  applyFileQueueDatabaseSchema(args.sqlite);
  applyChangeSetEdgeDatabaseSchema(args.sqlite);
  applyVersionV2DatabaseSchema(args.sqlite, args.db);
  applyOwnChangeControlTriggers(args.sqlite, args.db);
  applyLogDatabaseSchema(args.sqlite);
  return args.sqlite;
}

// ../../../packages/lix-sdk/dist/database/kysely-plugin/parse-jsonb-plugin-v1.js
init_define_ENV_DEFINED_IN_BUILD_STEP();
var sqlite;
function ParseJsonBPluginV1(jsonbColumns) {
  const jsonColumnNames = Object.keys(jsonbColumns).flatMap((key) => jsonbColumns[key]);
  return {
    transformResult: async (args) => {
      if (!sqlite) {
        sqlite = await createInMemoryDatabase({});
      }
      for (const row of args.result.rows) {
        for (const col of jsonColumnNames) {
          const raw = row[col];
          if (!(raw instanceof Uint8Array)) {
            continue;
          }
          try {
            const json = sqlite.exec("SELECT json(?)", {
              bind: [raw],
              returnValue: "resultRows"
            })[0][0];
            row[col] = JSON.parse(json);
          } catch {
            continue;
          }
        }
      }
      return args.result;
    },
    transformQuery: (args) => args.node
  };
}

// ../../../packages/lix-sdk/dist/database/kysely-plugin/serialize-jsonb-plugin.js
init_define_ENV_DEFINED_IN_BUILD_STEP();
function SerializeJsonBPlugin(jsonbColumns) {
  return {
    transformResult: async (args) => args.result,
    transformQuery(args) {
      if (args.node.kind === "InsertQueryNode") {
        const tableNode = args.node.into;
        const table = tableNode && tableNode.kind === "TableNode" ? tableNode.table.identifier.name : void 0;
        const columns = args.node.columns;
        const transformer = new SerializeJsonbTransformer(jsonbColumns, table, columns);
        return transformer.transformNode(args.node);
      }
      if (args.node.kind === "UpdateQueryNode") {
        const tableNode = args.node.table;
        let table = void 0;
        if (tableNode && tableNode.kind === "TableNode") {
          table = tableNode.table.identifier.name;
        }
        const transformer = new SerializeJsonbTransformer(jsonbColumns, table, void 0);
        return transformer.transformNode(args.node);
      }
      return args.node;
    }
  };
}
var SerializeJsonbTransformer = class extends OperationNodeTransformer {
  jsonbColumns;
  table;
  columns;
  constructor(jsonbColumns, table, columns) {
    super();
    this.jsonbColumns = jsonbColumns;
    this.table = table;
    this.columns = columns;
  }
  isJsonbColumn(columnName) {
    var _a8;
    if (!this.table || !columnName)
      return false;
    return ((_a8 = this.jsonbColumns[this.table]) == null ? void 0 : _a8.includes(columnName)) ?? false;
  }
  transformOnConflict(node) {
    if (!node.updates) {
      return node;
    }
    const newUpdates = node.updates.map((updateItem) => {
      if (updateItem.kind === "ColumnUpdateNode") {
        const columnName = updateItem.column.column.name;
        if (this.isJsonbColumn(columnName)) {
          const valueNode = updateItem.value;
          if (valueNode.kind === "ValueNode") {
            return {
              ...updateItem,
              // @ts-expect-error - kysely type narrowing
              value: this.serializeValue(valueNode)
            };
          }
        }
      }
      return updateItem;
    });
    return {
      ...node,
      updates: newUpdates
    };
  }
  transformNode(node) {
    if (!node) {
      return node;
    }
    return super.transformNode(node);
  }
  // Serialize JSONB values in updates for ColumnUpdateNodes
  transformColumnUpdate(node) {
    const columnName = node.column.column.name;
    if (this.isJsonbColumn(columnName)) {
      return {
        ...node,
        // @ts-expect-error - kysely type narrowing
        value: this.serializeValue(node.value)
      };
    }
    return super.transformColumnUpdate(node);
  }
  // Support .set("col", value) syntax (SetOperationNode)
  transformSetOperation(node) {
    var _a8, _b5;
    const columnName = (_b5 = (_a8 = node.column) == null ? void 0 : _a8.column) == null ? void 0 : _b5.name;
    if (columnName && this.isJsonbColumn(columnName)) {
      return {
        ...node,
        value: this.serializeValue(node.value)
      };
    }
    return super.transformSetOperation(node);
  }
  transformValues(node) {
    const newValues = node.values.map((row) => {
      if (row.kind === "PrimitiveValueListNode") {
        const newValueNodes = row.values.map((val, idx) => {
          var _a8;
          const colNode = (_a8 = this.columns) == null ? void 0 : _a8[idx];
          const valNode = { kind: "ValueNode", value: val };
          if ((colNode == null ? void 0 : colNode.kind) === "ColumnNode" && this.isJsonbColumn(colNode.column.name)) {
            return this.serializeValue(valNode);
          }
          return valNode;
        });
        return {
          kind: "ValueListNode",
          values: newValueNodes
        };
      }
      if (row.kind === "ValueListNode") {
        const newValuesList = row.values.map((valNode, idx) => {
          var _a8;
          const colNode = (_a8 = this.columns) == null ? void 0 : _a8[idx];
          if ((colNode == null ? void 0 : colNode.kind) === "ColumnNode" && this.isJsonbColumn(colNode.column.name)) {
            return this.serializeValue(valNode);
          }
          return valNode;
        });
        return { ...row, values: newValuesList };
      }
      return row;
    });
    return { ...node, values: newValues };
  }
  serializeValue(node) {
    const val = node.value;
    if (val instanceof ArrayBuffer || ArrayBuffer.isView(val) || val === null) {
      return node;
    }
    const jsonText = JSON.stringify(val);
    return {
      kind: "FunctionNode",
      func: "jsonb",
      arguments: [{ kind: "ValueNode", value: jsonText }]
    };
  }
};

// ../../../packages/lix-sdk/dist/database/init-db.js
var import_human_id2 = __toESM(require_dist(), 1);

// ../../../packages/lix-sdk/dist/database/nano-id.js
init_define_ENV_DEFINED_IN_BUILD_STEP();
var insecureRandom = (array) => {
  for (let i2 = 0; i2 < array.length; i2++) {
    array[i2] = Math.floor(Math.random() * 256);
  }
  return array;
};
var random = (bytes) => {
  const array = new Uint8Array(bytes);
  if (typeof crypto !== "undefined" && crypto.getRandomValues) {
    return crypto.getRandomValues(array);
  }
  return insecureRandom(array);
};
var customRandom = (alphabet, defaultSize, getRandom) => {
  const mask = (2 << Math.log2(alphabet.length - 1)) - 1;
  const step = -~(1.6 * mask * defaultSize / alphabet.length);
  return (size = defaultSize) => {
    let id = "";
    while (true) {
      const bytes = getRandom(step);
      let j2 = step | 0;
      while (j2--) {
        id += alphabet[bytes[j2] & mask] || "";
        if (id.length >= size)
          return id;
      }
    }
  };
};
var customAlphabet = (alphabet, size = 21) => customRandom(alphabet, size | 0, random);
var _nanoIdAlphabet = "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz";
var nanoid = customAlphabet(_nanoIdAlphabet);

// ../../../packages/lix-sdk/dist/database/init-db.js
var TablesWithJSONBColumns = {
  file: ["metadata"],
  file_queue: ["metadata_before", "metadata_after"],
  snapshot: ["content"],
  thread: ["body"],
  key_value: ["value"],
  thread_comment: ["body"]
};
function initDb(args) {
  initFunctions({ sqlite: args.sqlite });
  const db = new Kysely({
    // log: ["error", "query"],
    dialect: createDialect({
      database: args.sqlite
    }),
    plugins: [
      // fallback json parser in case column aliases are used
      new ParseJSONResultsPlugin(),
      ParseJsonBPluginV1(TablesWithJSONBColumns),
      SerializeJsonBPlugin(TablesWithJSONBColumns)
    ]
  });
  applySchema({ sqlite: args.sqlite, db });
  return db;
}
function initFunctions(args) {
  args.sqlite.createFunction({
    name: "uuid_v7",
    arity: 0,
    xFunc: () => v7_default()
  });
  args.sqlite.createFunction({
    name: "uuid_v4",
    arity: 0,
    xFunc: () => v4_default()
  });
  args.sqlite.createFunction({
    name: "human_id",
    arity: 0,
    xFunc: () => (0, import_human_id2.humanId)({ separator: "-", capitalize: false })
  });
  args.sqlite.createFunction({
    name: "nano_id",
    arity: -1,
    // @ts-expect-error - not sure why this is not working
    xFunc: (_ctx, length) => {
      return nanoid(length);
    }
  });
}

// ../../../packages/lix-sdk/dist/file-queue/file-queue-process.js
init_define_ENV_DEFINED_IN_BUILD_STEP();

// ../../../packages/lix-sdk/dist/file-queue/file-handlers.js
init_define_ENV_DEFINED_IN_BUILD_STEP();
async function glob(args) {
  var _a8;
  const result = await sql`SELECT CASE WHEN ${args.path} GLOB ${args.glob} THEN 1 ELSE 0 END AS matches`.execute(args.lix.db);
  return ((_a8 = result.rows[0]) == null ? void 0 : _a8.matches) === 1;
}
async function handleFileInsert(args) {
  const detectedChanges = [];
  const plugins = await args.lix.plugin.getAll();
  const path2 = args.fileQueueEntry.path_after ?? args.fileQueueEntry.path_before;
  if (path2 === null) {
    throw new Error("Both before and after paths are null");
  }
  for (const plugin2 of plugins) {
    if (!plugin2.detectChangesGlob || !await glob({
      lix: args.lix,
      path: path2,
      glob: plugin2.detectChangesGlob
    })) {
      break;
    }
    if (plugin2.detectChanges === void 0) {
      const error = new Error("Plugin does not support detecting changes even though the glob matches.");
      console.error(error);
      throw error;
    }
    if (args.fileQueueEntry.data_after === null) {
      throw new Error("Data after is null");
    }
    for (const change of await plugin2.detectChanges({
      lix: args.lix,
      before: void 0,
      after: {
        id: args.fileQueueEntry.file_id,
        path: path2,
        metadata: args.fileQueueEntry.metadata_after,
        data: args.fileQueueEntry.data_after
      }
    })) {
      detectedChanges.push({
        ...change,
        pluginKey: plugin2.key
      });
    }
  }
  await args.lix.db.transaction().execute(async (trx) => {
    const currentAuthors = await trx.selectFrom("active_account").selectAll().execute();
    const insertedChanges = await Promise.all(detectedChanges.map(async (detectedChange) => {
      return createChange({
        lix: { ...args.lix, db: trx },
        authors: currentAuthors,
        entityId: detectedChange.entity_id,
        fileId: args.fileQueueEntry.file_id,
        pluginKey: detectedChange.pluginKey,
        schemaKey: detectedChange.schema.key,
        snapshotContent: detectedChange.snapshot
      });
    }));
    await updateChangesInActiveVersion({
      lix: { ...args.lix, db: trx },
      changes: insertedChanges
    });
    await trx.deleteFrom("file_queue").where("id", "=", args.fileQueueEntry.id).execute();
  });
}
async function handleFileUpdate(args) {
  const detectedChanges = [];
  const plugins = await args.lix.plugin.getAll();
  const path2 = args.fileQueueEntry.path_after ?? args.fileQueueEntry.path_before;
  if (path2 === null) {
    throw new Error("Both before and after paths are null");
  }
  for (const plugin2 of plugins) {
    if (!plugin2.detectChangesGlob || !await glob({
      lix: args.lix,
      path: path2,
      glob: plugin2.detectChangesGlob
    })) {
      break;
    }
    if (plugin2.detectChanges === void 0) {
      const error = new Error("Plugin does not support detecting changes even though the glob matches.");
      console.error(error);
      throw error;
    }
    for (const change of await plugin2.detectChanges({
      lix: args.lix,
      before: args.fileQueueEntry.data_before ? {
        id: args.fileQueueEntry.file_id,
        path: path2,
        metadata: args.fileQueueEntry.metadata_before,
        data: args.fileQueueEntry.data_before
      } : void 0,
      after: {
        id: args.fileQueueEntry.file_id,
        path: path2,
        metadata: args.fileQueueEntry.metadata_after,
        data: args.fileQueueEntry.data_after
      }
    })) {
      detectedChanges.push({
        ...change,
        pluginKey: plugin2.key
      });
    }
  }
  await args.lix.db.transaction().execute(async (trx) => {
    const currentAuthors = await trx.selectFrom("active_account").selectAll().execute();
    const insertedChanges = await Promise.all(detectedChanges.map(async (detectedChange) => {
      return createChange({
        lix: { ...args.lix, db: trx },
        authors: currentAuthors,
        entityId: detectedChange.entity_id,
        fileId: args.fileQueueEntry.file_id,
        pluginKey: detectedChange.pluginKey,
        schemaKey: detectedChange.schema.key,
        snapshotContent: detectedChange.snapshot
      });
    }));
    await updateChangesInActiveVersion({
      lix: { ...args.lix, db: trx },
      changes: insertedChanges
    });
    await trx.deleteFrom("file_queue").where("id", "=", args.fileQueueEntry.id).execute();
  });
}
async function handleFileDelete(args) {
  await args.lix.db.transaction().execute(async (trx) => {
    const activeVersion = await trx.selectFrom("active_version").innerJoin("version", "active_version.version_id", "version.id").selectAll("version").executeTakeFirstOrThrow();
    const toBeDeletedEntities = await trx.selectFrom("change").innerJoin("change_set_element", "change.id", "change_set_element.change_id").where("change.file_id", "=", args.fileQueueEntry.file_id).where(changeSetElementIsLeafOf([{ id: activeVersion.change_set_id }])).selectAll().execute();
    const currentAuthors = await trx.selectFrom("active_account").selectAll().execute();
    const insertedChanges = await Promise.all(toBeDeletedEntities.map(async (change) => {
      return createChange({
        lix: { ...args.lix, db: trx },
        authors: currentAuthors,
        entityId: change.entity_id,
        fileId: args.fileQueueEntry.file_id,
        pluginKey: change.plugin_key,
        schemaKey: change.schema_key,
        snapshotContent: null
        // Snapshot is null for deletions
      });
    }));
    await updateChangesInActiveVersion({
      lix: { ...args.lix, db: trx },
      changes: insertedChanges
    });
    await trx.deleteFrom("file_queue").where("id", "=", args.fileQueueEntry.id).execute();
  });
}
async function updateChangesInActiveVersion(args) {
  const executeInTransaction = async (trx) => {
    const activeVersion = await trx.selectFrom("active_version").innerJoin("version", "active_version.version_id", "version.id").selectAll("version").executeTakeFirstOrThrow();
    const newChangeSet = await createChangeSet({
      lix: { ...args.lix, db: trx },
      elements: args.changes.map((change) => ({
        change_id: change.id,
        entity_id: change.entity_id,
        schema_key: change.schema_key,
        file_id: change.file_id
      })),
      parents: [{ id: activeVersion.change_set_id }]
    });
    await trx.updateTable("version").set({
      change_set_id: newChangeSet.id
    }).where("id", "=", activeVersion.id).execute();
  };
  if (args.lix.db.isTransaction) {
    return executeInTransaction(args.lix.db);
  } else {
    return args.lix.db.transaction().execute(executeInTransaction);
  }
}

// ../../../packages/lix-sdk/dist/file-queue/file-queue-process.js
async function initFileQueueProcess(args) {
  args.lix.sqlite.createFunction({
    name: "triggerFileQueue",
    arity: 0,
    // @ts-expect-error - dynamic function
    xFunc: () => {
      queueWorker();
    }
  });
  let pending;
  let resolve2;
  let runNumber = 1;
  let hasMoreEntriesSince = void 0;
  async function queueWorker(trail = false) {
    try {
      if (args.lix.sqlite.isOpen() === false) {
        return;
      }
      if (pending && !trail) {
        hasMoreEntriesSince = runNumber;
        return;
      }
      runNumber++;
      if (!pending) {
        pending = new Promise((res) => {
          resolve2 = res;
        });
      }
      const entry = await args.lix.db.selectFrom("file_queue").selectAll().orderBy("id asc").limit(1).executeTakeFirst();
      if (entry) {
        try {
          if (entry.data_before && entry.data_after) {
            await handleFileUpdate({
              fileQueueEntry: entry,
              lix: args.lix
            });
          } else if (!entry.data_before && entry.data_after) {
            await handleFileInsert({
              fileQueueEntry: entry,
              lix: args.lix
            });
          } else {
            await handleFileDelete({
              fileQueueEntry: entry,
              lix: args.lix
            });
          }
        } catch (err) {
          console.error("Error processing file queue entry:", err);
          await args.lix.db.deleteFrom("file_queue").where("id", "=", entry.id).execute();
        }
      }
      const { numEntries } = await args.lix.db.selectFrom("file_queue").select((eb) => eb.fn.count("id").as("numEntries")).executeTakeFirstOrThrow();
      if (!hasMoreEntriesSince || numEntries === 0 && hasMoreEntriesSince < runNumber) {
        resolve2();
        hasMoreEntriesSince = void 0;
        pending = void 0;
      } else {
        queueWorker(true);
      }
    } catch (e2) {
      if (e2 instanceof Error && (e2.message.includes("DB has been closed") || e2.message.includes("driver has already been destroyed"))) {
        return;
      }
      console.error("file queue failed ", e2);
    }
  }
  queueWorker();
  return;
}

// ../../../packages/lix-sdk/dist/services/telemetry/capture.js
init_define_ENV_DEFINED_IN_BUILD_STEP();

// ../../../packages/lix-sdk/dist/services/env-variables/index.js
init_define_ENV_DEFINED_IN_BUILD_STEP();
var ENV_VARIABLES = {
  LIX_SDK_POSTHOG_TOKEN: "phc_6492KFrhZMsb2HOZiloRb6R9tJQWZWVVAiebkwfWATT",
  LIX_SDK_VERSION: "0.4.7"
};

// ../../../packages/lix-sdk/dist/services/telemetry/capture.js
var capture = async (event, args) => {
  if (ENV_VARIABLES.LIX_SDK_POSTHOG_TOKEN === void 0) {
    return;
  } else if (args.telemetryKeyValue === "off") {
    return;
  }
  try {
    await fetch("https://eu.posthog.com/capture/", {
      method: "POST",
      body: JSON.stringify({
        api_key: ENV_VARIABLES.LIX_SDK_POSTHOG_TOKEN,
        event,
        distinct_id: args.accountId,
        properties: {
          $groups: { lix_id: args.lixId },
          ...args.properties
        }
      })
    });
    await identifyLix({
      lixId: args.lixId,
      accountId: args.accountId,
      // using the id for now as a name but can be changed in the future
      // we need at least one property to make a project visible in the dashboard
      properties: { name: args.lixId }
    });
  } catch {
  }
};
var identifyLix = async (args) => {
  if (ENV_VARIABLES.LIX_SDK_POSTHOG_TOKEN === void 0) {
    return;
  }
  try {
    await fetch("https://eu.posthog.com/capture/", {
      method: "POST",
      body: JSON.stringify({
        api_key: ENV_VARIABLES.LIX_SDK_POSTHOG_TOKEN,
        event: "$groupidentify",
        distinct_id: args.accountId,
        properties: {
          $group_type: "lix",
          $group_key: args.lixId,
          $group_set: {
            ...args.properties
          }
        }
      })
    });
  } catch {
  }
};

// ../../../packages/lix-sdk/dist/lix/open-lix.js
async function openLix(args) {
  const db = initDb({ sqlite: args.database });
  if (args.keyValues && args.keyValues.length > 0) {
    await db.insertInto("key_value").values(args.keyValues).onConflict((oc) => oc.doUpdateSet((eb) => ({ value: eb.ref("excluded.value") }))).execute();
  }
  if (args.account) {
    await db.transaction().execute(async (trx) => {
      await trx.deleteFrom("active_account").execute();
      await trx.insertInto("active_account").values(args.account).onConflict((oc) => oc.doUpdateSet(() => ({ ...args.account }))).execute();
    });
  }
  const plugins = [];
  if (args.providePlugins && args.providePlugins.length > 0) {
    plugins.push(...args.providePlugins);
  }
  const plugin2 = {
    getAll: async () => plugins
  };
  await initFileQueueProcess({ lix: { db, plugin: plugin2, sqlite: args.database } });
  captureOpened({ db });
  return {
    db,
    sqlite: args.database,
    plugin: plugin2
  };
}
async function captureOpened(args) {
  try {
    const telemetry = await args.db.selectFrom("key_value").select("value").where("key", "=", "lix_telemetry").executeTakeFirst();
    if ((telemetry == null ? void 0 : telemetry.value) === "off") {
      return;
    }
    const activeAccount = await args.db.selectFrom("active_account").select("id").executeTakeFirstOrThrow();
    const lixId = await args.db.selectFrom("key_value").select("value").where("key", "=", "lix_id").executeTakeFirstOrThrow();
    const fileExtensions = await usedFileExtensions(args.db);
    if (Math.random() > 0.1) {
      await capture("LIX-SDK lix opened", {
        accountId: activeAccount.id,
        lixId: lixId.value,
        telemetryKeyValue: (telemetry == null ? void 0 : telemetry.value) ?? "on",
        properties: {
          lix_sdk_version: ENV_VARIABLES.LIX_SDK_VERSION,
          stored_file_extensions: fileExtensions
        }
      });
    }
  } catch {
  }
}
async function usedFileExtensions(db) {
  const result = await sql`
	WITH RECURSIVE numbers(i) AS (
		SELECT 1
		UNION ALL
		SELECT i + 1 FROM numbers WHERE i < 1000 -- Limit to 1000 characters for path length
	),
	REVERSED AS (
		SELECT id,
					GROUP_CONCAT(SUBSTR(path, LENGTH(path) - i + 1, 1), '') AS reversed_path
		FROM file, numbers
		WHERE i <= LENGTH(path)
		GROUP BY id, path
	),
	EXTENSIONS AS (
		SELECT DISTINCT SUBSTR(path, LENGTH(path) - INSTR(reversed_path, '.') + 2) AS extension
		FROM file
		JOIN REVERSED ON file.id = REVERSED.id
		WHERE INSTR(reversed_path, '.') > 0
	)
	SELECT extension FROM EXTENSIONS;
	`.execute(db);
  return result.rows.map((row) => row.extension);
}

// ../../../packages/lix-sdk/dist/lix/open-lix-in-memory.js
init_define_ENV_DEFINED_IN_BUILD_STEP();
async function openLixInMemory(args) {
  const database = await createInMemoryDatabase({
    readOnly: false
  });
  if (args.blob) {
    importDatabase({
      db: database,
      content: new Uint8Array(await args.blob.arrayBuffer())
    });
  }
  return openLix({ ...args, database });
}

// ../../../packages/lix-sdk/dist/lix/new-lix.js
init_define_ENV_DEFINED_IN_BUILD_STEP();

// ../../../packages/lix-sdk/dist/lix/close-lix.js
init_define_ENV_DEFINED_IN_BUILD_STEP();
async function closeLix(args) {
  await args.lix.db.destroy();
}

// ../../../packages/lix-sdk/dist/lix/new-lix.js
async function newLixFile() {
  const sqlite2 = await createInMemoryDatabase({
    readOnly: false
  });
  const db = initDb({ sqlite: sqlite2 });
  try {
    return new Blob([contentFromDatabase(sqlite2)]);
  } catch (e2) {
    throw new Error(`Failed to create new Lix file: ${e2}`, { cause: e2 });
  } finally {
    closeLix({ lix: { db } });
  }
}

// ../../../packages/lix-sdk/dist/lix/to-blob.js
init_define_ENV_DEFINED_IN_BUILD_STEP();
async function toBlob(args) {
  return new Blob([contentFromDatabase(args.lix.sqlite)]);
}

// ../sdk/dist/database/initDb.js
init_define_ENV_DEFINED_IN_BUILD_STEP();

// ../sdk/dist/database/schema.js
init_define_ENV_DEFINED_IN_BUILD_STEP();
function applySchema2(args) {
  const foreignKeyActivated = args.sqlite.exec("PRAGMA foreign_keys", {
    returnValue: "resultRows"
  });
  if (
    // first row that is returned
    // first column of the first row
    // is equal to 0, then foreign keys are disabled
    foreignKeyActivated[0][0] === 0
  ) {
    args.sqlite.exec("PRAGMA foreign_keys = ON", {
      returnValue: "resultRows"
    });
  }
  args.sqlite.exec(`
CREATE TABLE IF NOT EXISTS bundle (
  id TEXT PRIMARY KEY DEFAULT (human_id()),
	declarations BLOB NOT NULL DEFAULT (jsonb('[]'))
) strict;

CREATE TABLE IF NOT EXISTS message (
  id TEXT PRIMARY KEY DEFAULT (uuid_v7()), 
  bundle_id TEXT NOT NULL,
  locale TEXT NOT NULL,
  selectors BLOB NOT NULL DEFAULT (jsonb('[]')),
  FOREIGN KEY (bundle_id) REFERENCES bundle(id) ON DELETE CASCADE
) strict;


CREATE TABLE IF NOT EXISTS variant (
  id TEXT PRIMARY KEY DEFAULT (uuid_v7()), 
  message_id TEXT NOT NULL,
  matches BLOB NOT NULL DEFAULT (jsonb('[]')),
  pattern BLOB NOT NULL DEFAULT (jsonb('[]')),
  FOREIGN KEY (message_id) REFERENCES message(id) ON DELETE CASCADE
) strict;
  
CREATE INDEX IF NOT EXISTS idx_message_bundle_id ON message (bundle_id);
CREATE INDEX IF NOT EXISTS idx_variant_message_id ON variant (message_id);
		`);
}

// ../sdk/dist/human-id/human-id.js
init_define_ENV_DEFINED_IN_BUILD_STEP();

// ../sdk/dist/human-id/words.js
init_define_ENV_DEFINED_IN_BUILD_STEP();
var animals = [
  "albatross",
  "alligator",
  "alpaca",
  "anaconda",
  "angelfish",
  "ant",
  "anteater",
  "antelope",
  "ape",
  "baboon",
  "badger",
  "barbel",
  "bat",
  "bear",
  "beaver",
  "bee",
  "beetle",
  "bird",
  "bison",
  "blackbird",
  "boar",
  "bobcat",
  "bulldog",
  "bullock",
  "bumblebee",
  "butterfly",
  "buzzard",
  "camel",
  "canary",
  "capybara",
  "carp",
  "cat",
  "cheetah",
  "chicken",
  "chipmunk",
  "clownfish",
  "cobra",
  "cockroach",
  "cod",
  "cougar",
  "cow",
  "cowfish",
  "coyote",
  "crab",
  "crocodile",
  "crossbill",
  "crow",
  "cuckoo",
  "dachshund",
  "deer",
  "dingo",
  "dog",
  "dolphin",
  "donkey",
  "dove",
  "dragonfly",
  "duck",
  "eagle",
  "earthworm",
  "eel",
  "elephant",
  "elk",
  "emu",
  "falcon",
  "felix",
  "finch",
  "fireant",
  "firefox",
  "fish",
  "flamingo",
  "flea",
  "florian",
  "fly",
  "fox",
  "frog",
  "gadfly",
  "gazelle",
  "gecko",
  "gibbon",
  "giraffe",
  "goat",
  "goldfish",
  "goose",
  "gopher",
  "gorilla",
  "grebe",
  "grizzly",
  "gull",
  "guppy",
  "haddock",
  "halibut",
  "hamster",
  "hare",
  "hawk",
  "hedgehog",
  "herring",
  "hornet",
  "horse",
  "hound",
  "husky",
  "hyena",
  "ibex",
  "iguana",
  "impala",
  "insect",
  "jackal",
  "jackdaw",
  "jaguar",
  "jan",
  "jannes",
  "javelina",
  "jay",
  "jellyfish",
  "jurgen",
  "kangaroo",
  "kestrel",
  "kitten",
  "koala",
  "kudu",
  "ladybug",
  "lamb",
  "lark",
  "larva",
  "lemming",
  "lemur",
  "leopard",
  "liger",
  "lion",
  "lionfish",
  "lizard",
  "llama",
  "lobster",
  "loris",
  "lynx",
  "macaw",
  "maggot",
  "mallard",
  "mammoth",
  "manatee",
  "mantis",
  "mare",
  "marlin",
  "marmot",
  "marten",
  "martin",
  "mayfly",
  "meerkat",
  "midge",
  "millipede",
  "mink",
  "mole",
  "mongoose",
  "monkey",
  "moose",
  "moth",
  "mouse",
  "mule",
  "myna",
  "newt",
  "niklas",
  "nils",
  "nuthatch",
  "ocelot",
  "octopus",
  "okapi",
  "opossum",
  "orangutan",
  "oryx",
  "osprey",
  "ostrich",
  "otter",
  "owl",
  "ox",
  "panda",
  "panther",
  "parakeet",
  "parrot",
  "peacock",
  "pelican",
  "penguin",
  "pig",
  "pigeon",
  "piranha",
  "platypus",
  "polecat",
  "pony",
  "poodle",
  "porpoise",
  "puffin",
  "pug",
  "puma",
  "quail",
  "rabbit",
  "racoon",
  "rat",
  "raven",
  "ray",
  "reindeer",
  "robin",
  "rook",
  "rooster",
  "salmon",
  "samuel",
  "sawfish",
  "scallop",
  "seahorse",
  "seal",
  "shad",
  "shark",
  "sheep",
  "shell",
  "shrike",
  "shrimp",
  "skate",
  "skunk",
  "sloth",
  "slug",
  "snail",
  "snake",
  "sparrow",
  "spider",
  "squid",
  "squirrel",
  "starfish",
  "stingray",
  "stork",
  "swallow",
  "swan",
  "tadpole",
  "tapir",
  "termite",
  "tern",
  "thrush",
  "tiger",
  "toad",
  "tortoise",
  "toucan",
  "trout",
  "tuna",
  "turkey",
  "turtle",
  "vole",
  "vulture",
  "wallaby",
  "walrus",
  "warbler",
  "warthog",
  "wasp",
  "weasel",
  "whale",
  "wolf",
  "wombat",
  "worm",
  "wren",
  "yak",
  "zebra"
];
var adjectives = [
  "acidic",
  "active",
  "actual",
  "agent",
  "ago",
  "alert",
  "alive",
  "aloof",
  "antsy",
  "any",
  "aqua",
  "arable",
  "awake",
  "aware",
  "away",
  "awful",
  "bad",
  "bald",
  "basic",
  "best",
  "big",
  "bland",
  "blue",
  "bold",
  "born",
  "brave",
  "brief",
  "bright",
  "broad",
  "busy",
  "calm",
  "candid",
  "careful",
  "caring",
  "chunky",
  "civil",
  "clean",
  "clear",
  "close",
  "cool",
  "cozy",
  "crazy",
  "crisp",
  "cuddly",
  "curly",
  "cute",
  "dark",
  "day",
  "deft",
  "direct",
  "dirty",
  "dizzy",
  "drab",
  "dry",
  "due",
  "dull",
  "each",
  "early",
  "east",
  "elegant",
  "empty",
  "equal",
  "even",
  "every",
  "extra",
  "factual",
  "fair",
  "fancy",
  "few",
  "fine",
  "fit",
  "flaky",
  "flat",
  "fluffy",
  "formal",
  "frail",
  "free",
  "fresh",
  "front",
  "full",
  "fun",
  "funny",
  "fuzzy",
  "game",
  "gaudy",
  "giant",
  "glad",
  "good",
  "grand",
  "grassy",
  "gray",
  "great",
  "green",
  "gross",
  "happy",
  "heavy",
  "helpful",
  "heroic",
  "home",
  "honest",
  "hour",
  "house",
  "icy",
  "ideal",
  "inclusive",
  "inner",
  "jolly",
  "jumpy",
  "just",
  "keen",
  "key",
  "kind",
  "knotty",
  "known",
  "large",
  "last",
  "late",
  "lazy",
  "least",
  "left",
  "legal",
  "less",
  "level",
  "light",
  "lime",
  "livid",
  "lofty",
  "long",
  "loose",
  "lost",
  "loud",
  "loved",
  "low",
  "lower",
  "lucky",
  "mad",
  "main",
  "major",
  "male",
  "many",
  "maroon",
  "mealy",
  "mean",
  "mellow",
  "merry",
  "mild",
  "minor",
  "misty",
  "moving",
  "muddy",
  "mushy",
  "neat",
  "new",
  "next",
  "nice",
  "nimble",
  "noble",
  "noisy",
  "north",
  "novel",
  "odd",
  "ok",
  "only",
  "orange",
  "ornate",
  "patchy",
  "patient",
  "petty",
  "pink",
  "plain",
  "plane",
  "polite",
  "pretty",
  "proof",
  "proud",
  "quaint",
  "quick",
  "quiet",
  "raw",
  "real",
  "red",
  "round",
  "royal",
  "sad",
  "safe",
  "salty",
  "same",
  "sea",
  "seemly",
  "sharp",
  "short",
  "shy",
  "silly",
  "simple",
  "sleek",
  "slimy",
  "slow",
  "small",
  "smart",
  "smug",
  "soft",
  "solid",
  "sound",
  "sour",
  "spare",
  "spicy",
  "spry",
  "stale",
  "steep",
  "still",
  "stock",
  "stout",
  "strong",
  "suave",
  "such",
  "sunny",
  "super",
  "sweet",
  "swift",
  "tame",
  "tangy",
  "tasty",
  "teal",
  "teary",
  "tense",
  "that",
  "these",
  "this",
  "tidy",
  "tiny",
  "tired",
  "top",
  "topical",
  "tough",
  "trick",
  "trite",
  "true",
  "upper",
  "vexed",
  "vivid",
  "wacky",
  "warm",
  "watery",
  "weak",
  "weary",
  "weird",
  "white",
  "whole",
  "wide",
  "wild",
  "wise",
  "witty",
  "yummy",
  "zany",
  "zesty",
  "zippy"
];
var verbs = [
  "absorb",
  "accept",
  "achieve",
  "adapt",
  "adore",
  "advise",
  "affirm",
  "agree",
  "aid",
  "aim",
  "amaze",
  "amuse",
  "animate",
  "approve",
  "arise",
  "arrive",
  "ascend",
  "ask",
  "aspire",
  "assure",
  "attend",
  "bake",
  "bask",
  "beam",
  "believe",
  "belong",
  "bend",
  "blend",
  "bless",
  "blink",
  "bloom",
  "boil",
  "boost",
  "borrow",
  "breathe",
  "bubble",
  "build",
  "bump",
  "burn",
  "buy",
  "buzz",
  "care",
  "catch",
  "charm",
  "cheer",
  "cherish",
  "chop",
  "clap",
  "clasp",
  "climb",
  "clip",
  "coax",
  "comfort",
  "commend",
  "compose",
  "conquer",
  "cook",
  "create",
  "cry",
  "cuddle",
  "cure",
  "cut",
  "dance",
  "dare",
  "dart",
  "dash",
  "dazzle",
  "delight",
  "devour",
  "dial",
  "dig",
  "dine",
  "dream",
  "drip",
  "drop",
  "drum",
  "dust",
  "earn",
  "edit",
  "embrace",
  "emerge",
  "empower",
  "enchant",
  "endure",
  "engage",
  "enjoy",
  "enrich",
  "evoke",
  "exhale",
  "expand",
  "explore",
  "express",
  "fade",
  "fall",
  "favor",
  "fear",
  "feast",
  "feel",
  "fetch",
  "file",
  "find",
  "flip",
  "flop",
  "flow",
  "fold",
  "fond",
  "forgive",
  "foster",
  "fry",
  "fulfill",
  "gasp",
  "gaze",
  "gleam",
  "glow",
  "grace",
  "grasp",
  "greet",
  "grin",
  "grip",
  "grow",
  "gulp",
  "hack",
  "harbor",
  "heal",
  "heart",
  "hike",
  "hint",
  "honor",
  "hope",
  "hug",
  "hunt",
  "hurl",
  "hush",
  "imagine",
  "inspire",
  "intend",
  "jest",
  "jolt",
  "jump",
  "kick",
  "kiss",
  "laugh",
  "launch",
  "lead",
  "leap",
  "learn",
  "lend",
  "lift",
  "link",
  "list",
  "lock",
  "loop",
  "love",
  "mend",
  "mix",
  "mop",
  "nail",
  "nourish",
  "nudge",
  "nurture",
  "offer",
  "pat",
  "pause",
  "pave",
  "peek",
  "peel",
  "persist",
  "pet",
  "pick",
  "pinch",
  "play",
  "pop",
  "pout",
  "praise",
  "pray",
  "pride",
  "promise",
  "propel",
  "prosper",
  "pull",
  "push",
  "quell",
  "quiz",
  "race",
  "radiate",
  "read",
  "reap",
  "relish",
  "renew",
  "reside",
  "rest",
  "revive",
  "ripple",
  "rise",
  "roam",
  "roar",
  "rush",
  "sail",
  "savor",
  "scold",
  "scoop",
  "seek",
  "sew",
  "shine",
  "sing",
  "skip",
  "slide",
  "slurp",
  "smile",
  "snap",
  "snip",
  "soar",
  "spark",
  "spin",
  "splash",
  "sprout",
  "spur",
  "stab",
  "startle",
  "stir",
  "stop",
  "strive",
  "succeed",
  "support",
  "surge",
  "sway",
  "swim",
  "talk",
  "tap",
  "taste",
  "tear",
  "tend",
  "thrive",
  "tickle",
  "transform",
  "treasure",
  "treat",
  "trim",
  "trip",
  "trust",
  "twirl",
  "twist",
  "type",
  "urge",
  "value",
  "vent",
  "view",
  "walk",
  "wave",
  "win",
  "wish",
  "work",
  "yell",
  "zap",
  "zip",
  "zoom"
];

// ../sdk/dist/human-id/human-id.js
function humanId3() {
  return `${adjectives[Math.floor(Math.random() * 256)]}_${adjectives[Math.floor(Math.random() * 256)]}_${animals[Math.floor(Math.random() * 256)]}_${verbs[Math.floor(Math.random() * 256)]}`;
}

// ../sdk/dist/database/jsonbPlugin.js
init_define_ENV_DEFINED_IN_BUILD_STEP();
var JsonbPlugin = class {
  #serializeJsonTransformer = new SerializeJsonbTransformer2();
  #parseJsonPlugin = new ParseJSONResultsPlugin();
  #database;
  constructor(args) {
    this.#database = args.database;
  }
  /**
   * For an outgoing query like insert or update, the JSON
   * values are transformed into `jsonb` function calls when
   * executed against the database.
   */
  transformQuery(args) {
    if (args.node.kind === "InsertQueryNode" || args.node.kind === "UpdateQueryNode") {
      const result = this.#serializeJsonTransformer.transformNode(args.node);
      return result;
    }
    return args.node;
  }
  /**
   * For incoming query results, the JSON binaries are parsed
   * into JSON objects.
   */
  async transformResult(args) {
    for (const row of args.result.rows) {
      for (const key in row) {
        if (row[key] instanceof ArrayBuffer || // uint8array, etc
        ArrayBuffer.isView(row[key])) {
          try {
            const res = this.#database.exec(`SELECT json(?)`, {
              returnValue: "resultRows",
              bind: [row[key]]
            });
            row[key] = JSON.parse(res[0]);
          } catch {
          }
        }
      }
    }
    return this.#parseJsonPlugin.transformResult(args);
  }
};
var SerializeJsonbTransformer2 = class extends OperationNodeTransformer {
  transformOnConflict(node) {
    var _a8;
    return super.transformOnConflict({
      ...node,
      updates: (_a8 = node.updates) == null ? void 0 : _a8.map((updateItem) => {
        if (updateItem.kind !== "ColumnUpdateNode") {
          return updateItem;
        }
        return {
          kind: "ColumnUpdateNode",
          column: updateItem.column,
          // @ts-expect-error - we know that the value is a ValueNode
          value: this.transformValue(updateItem.value)
        };
      })
    });
  }
  transformValue(node) {
    const { value } = node;
    const serializedValue = maybeSerializeJson(value);
    if (value === serializedValue) {
      return node;
    }
    return sql`jsonb(${serializedValue})`.toOperationNode();
  }
  /**
   * Transforms the value list node by replacing all JSON objects with `jsonb` function calls.
   */
  transformValueList(node) {
    return super.transformValueList({
      ...node,
      values: node.values.map((listNodeItem) => {
        if (listNodeItem.kind !== "ValueNode") {
          return listNodeItem;
        }
        const { value } = listNodeItem;
        const serializedValue = maybeSerializeJson(value);
        if (value === serializedValue) {
          return listNodeItem;
        }
        return sql`jsonb(${serializedValue})`.toOperationNode();
      })
    });
  }
  /**
   * Why this function is needed or why this works remains a mystery.
   */
  transformValues(node) {
    return super.transformValues({
      ...node,
      values: node.values.map((valueItemNode) => {
        if (valueItemNode.kind !== "PrimitiveValueListNode") {
          return valueItemNode;
        }
        return {
          kind: "ValueListNode",
          values: valueItemNode.values.map((value) => ({
            kind: "ValueNode",
            value
          }))
        };
      })
    });
  }
};
function maybeSerializeJson(value) {
  if (
    // binary data
    value instanceof ArrayBuffer || // uint8array, etc
    ArrayBuffer.isView(value) || value === null || value === void 0
  ) {
    return value;
  } else if (typeof value === "object" || Array.isArray(value)) {
    return JSON.stringify(value);
  }
  return value;
}

// ../sdk/dist/database/initDb.js
function initDb2(args) {
  initDefaultValueFunctions({ sqlite: args.sqlite });
  applySchema2({ sqlite: args.sqlite });
  const db = new Kysely({
    dialect: createDialect({
      database: args.sqlite
    }),
    plugins: [
      new CamelCasePlugin(),
      new JsonbPlugin({ database: args.sqlite })
    ]
  });
  return db;
}
function initDefaultValueFunctions(args) {
  args.sqlite.createFunction({
    name: "uuid_v7",
    arity: 0,
    xFunc: () => v7_default()
  });
  args.sqlite.createFunction({
    name: "human_id",
    arity: 0,
    xFunc: () => humanId3()
  });
}

// ../sdk/dist/project/newProject.js
async function newProject(args) {
  var _a8;
  const sqlite2 = await createInMemoryDatabase({
    readOnly: false
  });
  initDb2({ sqlite: sqlite2 });
  try {
    const inlangDbContent = contentFromDatabase(sqlite2);
    const lix = await openLixInMemory({
      blob: await newLixFile(),
      keyValues: [
        { key: "lix_telemetry", value: ((_a8 = args == null ? void 0 : args.settings) == null ? void 0 : _a8.telemetry) ?? "on" }
      ]
    });
    const { value: lixId } = await lix.db.selectFrom("key_value").select("value").where("key", "=", "lix_id").executeTakeFirstOrThrow();
    await lix.db.insertInto("file").values([
      {
        path: "/db.sqlite",
        data: inlangDbContent
      },
      {
        path: "/settings.json",
        data: new TextEncoder().encode(JSON.stringify((args == null ? void 0 : args.settings) ?? defaultProjectSettings, void 0, 2))
      },
      {
        path: "/project_id",
        data: new TextEncoder().encode(lixId)
      }
    ]).execute();
    const blob = toBlob({ lix });
    lix.sqlite.close();
    return blob;
  } catch (e2) {
    const error = new Error(`Failed to create new inlang project: ${e2}`, {
      cause: e2
    });
    throw error;
  } finally {
    sqlite2.close();
  }
}
var defaultProjectSettings = {
  $schema: "https://inlang.com/schema/project-settings",
  baseLocale: "en",
  locales: ["en"],
  modules: [
    // for instant gratification, we're adding common rules
    // "https://cdn.jsdelivr.net/npm/@inlang/message-lint-rule-empty-pattern@latest/dist/index.js",
    // "https://cdn.jsdelivr.net/npm/@inlang/message-lint-rule-missing-translation@latest/dist/index.js",
    // "https://cdn.jsdelivr.net/npm/@inlang/message-lint-rule-without-source@latest/dist/index.js",
    // default to the message format plugin because it supports all features
    // "https://cdn.jsdelivr.net/npm/@inlang/plugin-message-format@latest/dist/index.js",
    // the m function matcher should be installed by default in case Sherlock (VS Code extension) is adopted
    // "https://cdn.jsdelivr.net/npm/@inlang/plugin-m-function-matcher@latest/dist/index.js",
  ]
};

// ../sdk/dist/project/loadProjectInMemory.js
init_define_ENV_DEFINED_IN_BUILD_STEP();

// ../sdk/dist/project/loadProject.js
init_define_ENV_DEFINED_IN_BUILD_STEP();

// ../sdk/dist/plugin/importPlugins.js
init_define_ENV_DEFINED_IN_BUILD_STEP();

// ../sdk/dist/plugin/errors.js
init_define_ENV_DEFINED_IN_BUILD_STEP();
var PluginError = class extends Error {
  plugin;
  constructor(message, options) {
    super(message);
    this.name = "PluginError";
    this.plugin = options.plugin;
    this.cause = options.cause;
  }
};
var PluginImportError = class extends PluginError {
  constructor(options) {
    super(`Couldn't import the plugin "${options.plugin}":

${options.cause}`, options);
    this.name = "PluginImportError";
  }
};
var PluginDoesNotImplementFunctionError = class extends PluginError {
  constructor(options) {
    super(`The plugin "${options.plugin}" does not implement the "${options.function}" function.`, options);
    this.name = "PluginDoesNotImplementFunction";
  }
};
var PluginMissingError = class extends PluginError {
  constructor(options) {
    super(`The plugin "${options.plugin}" does not exist`, options);
    this.name = "PluginMissingError";
  }
};

// ../sdk/dist/plugin/cache.js
init_define_ENV_DEFINED_IN_BUILD_STEP();
function escape(url) {
  const bytes = new TextEncoder().encode(url);
  const hash = bytes.reduce((hash2, byte) => BigInt.asUintN(64, (hash2 ^ BigInt(byte)) * 1099511628211n), 14695981039346656037n);
  return hash.toString(36);
}
async function readModuleFromCache(moduleURI, lix) {
  const moduleHash = escape(moduleURI);
  const filePath = `/cache/plugins/${moduleHash}`;
  const file = await lix.db.selectFrom("file").where("path", "=", filePath).selectAll().executeTakeFirst();
  if (file) {
    return new TextDecoder().decode(file.data);
  }
  return void 0;
}
async function writeModuleToCache(moduleURI, moduleContent, lix) {
  const moduleHash = escape(moduleURI);
  const filePath = `/cache/plugins/${moduleHash}`;
  await lix.db.insertInto("file").values({
    path: filePath,
    data: new TextEncoder().encode(moduleContent)
  }).onConflict((oc) => oc.doUpdateSet({ data: new TextEncoder().encode(moduleContent) })).execute();
}
function withCache(moduleLoader, lix) {
  return async (uri) => {
    try {
      const moduleAsText = await moduleLoader(uri);
      await writeModuleToCache(uri, moduleAsText, lix);
      return moduleAsText;
    } catch (e2) {
      const cacheResult = await readModuleFromCache(uri, lix);
      if (cacheResult) {
        return cacheResult;
      } else {
        throw e2;
      }
    }
  };
}

// ../sdk/dist/plugin/importPlugins.js
async function importPlugins(args) {
  var _a8;
  const plugins = [];
  const errors = [];
  for (const uri of args.settings.modules ?? []) {
    try {
      let moduleAsText = await withCache(fetchPlugin, args.lix)(uri);
      if (args.preprocessPluginBeforeImport) {
        moduleAsText = await args.preprocessPluginBeforeImport(moduleAsText);
      }
      let moduleAsURL;
      if (process.versions.bun) {
        moduleAsURL = URL.createObjectURL(new Blob([moduleAsText], { type: "text/javascript" }));
      } else {
        moduleAsURL = "data:text/javascript;base64," + btoa(moduleAsText);
      }
      const { default: module } = await import(
        /* @vite-ignore */
        moduleAsURL
      );
      if ((_a8 = module.id) == null ? void 0 : _a8.includes("messageLintRule")) {
        continue;
      }
      plugins.push(module);
    } catch (e2) {
      errors.push(new PluginImportError({ plugin: uri, cause: e2 }));
    }
  }
  return { plugins, errors };
}
async function fetchPlugin(uri) {
  try {
    const response = await fetch(uri);
    return await response.text();
  } catch (error) {
    throw new PluginImportError({
      plugin: uri,
      cause: error
    });
  }
}

// ../sdk/dist/migrations/v2/withLanguageTagToLocaleMigration.js
init_define_ENV_DEFINED_IN_BUILD_STEP();
function withLanguageTagToLocaleMigration(settings) {
  if (settings.sourceLanguageTag === void 0) {
    settings.sourceLanguageTag = settings.baseLocale;
  }
  if (settings.languageTags === void 0) {
    settings.languageTags = settings.locales;
  }
  if (settings.baseLocale === void 0) {
    settings.baseLocale = settings.sourceLanguageTag;
  }
  if (settings.locales === void 0) {
    settings.locales = settings.languageTags;
  }
  if (settings.sourceLanguageTag !== settings.baseLocale) {
    settings.sourceLanguageTag = settings.baseLocale;
  }
  if (settings.languageTags !== settings.locales) {
    settings.languageTags = settings.locales;
  }
  return settings;
}

// ../sdk/dist/project/maybeCaptureTelemetry.js
init_define_ENV_DEFINED_IN_BUILD_STEP();

// ../sdk/dist/services/telemetry/capture.js
init_define_ENV_DEFINED_IN_BUILD_STEP();

// ../sdk/dist/services/env-variables/index.js
init_define_ENV_DEFINED_IN_BUILD_STEP();
var ENV_VARIABLES2 = {
  PUBLIC_POSTHOG_TOKEN: "phc_m5yJZCxjOGxF8CJvP5sQ3H0d76xpnLrsmiZHduT4jDz",
  PUBLIC_INLANG_SDK_SENTRY_DSN: "https://c3d92d5d011122e525e9f9b368e0905d@o4504345873285120.ingest.us.sentry.io/4507903389335553",
  SDK_VERSION: "2.4.9"
};

// ../sdk/dist/services/telemetry/capture.js
var capture2 = async (event, args) => {
  if (args.settings.telemetry === "off") {
    return;
  } else if (ENV_VARIABLES2.PUBLIC_POSTHOG_TOKEN === void 0) {
    return;
  }
  try {
    await fetch("https://eu.posthog.com/capture/", {
      method: "POST",
      body: JSON.stringify({
        api_key: ENV_VARIABLES2.PUBLIC_POSTHOG_TOKEN,
        event,
        distinct_id: args.accountId,
        properties: {
          $groups: { project: args.projectId },
          ...args.properties
        }
      })
    });
    await identifyProject({
      projectId: args.projectId,
      accountId: args.accountId,
      // using the id for now as a name but can be changed in the future
      // we need at least one property to make a project visible in the dashboar
      properties: { name: args.projectId }
    });
  } catch {
  }
};
var identifyProject = async (args) => {
  if (ENV_VARIABLES2.PUBLIC_POSTHOG_TOKEN === void 0) {
    return;
  }
  try {
    await fetch("https://eu.posthog.com/capture/", {
      method: "POST",
      body: JSON.stringify({
        api_key: ENV_VARIABLES2.PUBLIC_POSTHOG_TOKEN,
        event: "$groupidentify",
        distinct_id: args.accountId,
        properties: {
          $group_type: "project",
          $group_key: args.projectId,
          $group_set: {
            ...args.properties
          }
        }
      })
    });
  } catch {
  }
};

// ../sdk/dist/project/maybeCaptureTelemetry.js
async function maybeCaptureLoadedProject(args) {
  if (args.settings.telemetry === "off") {
    return;
  }
  if (args.forceCapture !== true && Math.random() > 0.1) {
    return;
  }
  try {
    const activeAccount = await args.lix.db.selectFrom("active_account").select("id").executeTakeFirstOrThrow();
    const bundles = await args.db.selectFrom("bundle").select((s2) => s2.fn.count("id").as("count")).executeTakeFirst();
    const messages = await args.db.selectFrom("message").select((s2) => s2.fn.count("id").as("count")).executeTakeFirst();
    const variants = await args.db.selectFrom("variant").select((s2) => s2.fn.count("id").as("count")).executeTakeFirst();
    await capture2("SDK loaded project", {
      projectId: args.id,
      settings: args.settings,
      accountId: activeAccount.id,
      properties: {
        // Insight: Which app is used by the SDK
        appId: args.appId,
        // Insight: How many languages are used, etc.
        settings: args.settings,
        // Insight on the used plugins (which one's to prioritize)
        pluginKeys: args.plugins.map((plugin2) => plugin2.key),
        // Insight: Which version of the SDK is used (can be used to deprecate old versions)
        sdkVersion: ENV_VARIABLES2.SDK_VERSION,
        // Insight: Scale of projects (what project size to optimize for)
        numBundles: bundles == null ? void 0 : bundles.count,
        numMessages: messages == null ? void 0 : messages.count,
        numVariants: variants == null ? void 0 : variants.count
      }
    });
  } catch (e2) {
    if (e2 instanceof Error && e2.message.includes("driver has already been destroyed")) {
      return;
    }
  }
}

// ../sdk/dist/import-export/importFiles.js
init_define_ENV_DEFINED_IN_BUILD_STEP();
async function importFiles(args) {
  const plugin2 = args.plugins.find((p3) => p3.key === args.pluginKey);
  if (!plugin2)
    throw new PluginMissingError({ plugin: args.pluginKey });
  if (!plugin2.importFiles) {
    throw new PluginDoesNotImplementFunctionError({
      plugin: args.pluginKey,
      function: "importFiles"
    });
  }
  const imported = await plugin2.importFiles({
    files: args.files,
    settings: structuredClone(args.settings)
  });
  await args.db.transaction().execute(async (trx) => {
    for (const bundle of imported.bundles) {
      await trx.insertInto("bundle").values(bundle).onConflict((oc) => oc.column("id").doUpdateSet(bundle)).execute();
    }
    for (const message of imported.messages) {
      if (message.id === void 0) {
        const exisingMessage = await trx.selectFrom("message").where("bundleId", "=", message.bundleId).where("locale", "=", message.locale).select("id").executeTakeFirst();
        message.id = exisingMessage == null ? void 0 : exisingMessage.id;
      }
      try {
        await trx.insertInto("message").values(message).onConflict((oc) => oc.column("id").doUpdateSet(message)).execute();
      } catch (e2) {
        if ((e2 == null ? void 0 : e2.resultCode) === 787) {
          await trx.insertInto("bundle").values({ id: message.bundleId }).execute();
          await trx.insertInto("message").values(message).execute();
        } else {
          throw e2;
        }
      }
    }
    for (const variant of imported.variants) {
      if (variant.id === void 0) {
        let existingMessage = await trx.selectFrom("message").where("bundleId", "=", variant.messageBundleId).where("locale", "=", variant.messageLocale).select("id").executeTakeFirst();
        if (existingMessage === void 0) {
          const existingBundle = await trx.selectFrom("bundle").where("id", "=", variant.messageBundleId).select("id").executeTakeFirst();
          if (existingBundle === void 0) {
            await trx.insertInto("bundle").values({ id: variant.messageBundleId }).execute();
          }
          existingMessage = await trx.insertInto("message").values({
            bundleId: variant.messageBundleId,
            locale: variant.messageLocale
          }).returningAll().executeTakeFirstOrThrow();
        }
        const existingVariants = await trx.selectFrom("variant").where("messageId", "=", existingMessage.id).selectAll().execute();
        const existingVariant = existingVariants.find((v3) => JSON.stringify(v3.matches) === JSON.stringify(variant.matches));
        variant.id = existingVariant == null ? void 0 : existingVariant.id;
        variant.messageId = existingMessage.id;
      }
      const toBeInsertedVariant = {
        ...variant,
        // @ts-expect-error - bundle id is provided by VariantImport but not needed when inserting
        messageBundleId: void 0,
        messageLocale: void 0
      };
      await trx.insertInto("variant").values(toBeInsertedVariant).onConflict((oc) => oc.column("id").doUpdateSet(toBeInsertedVariant)).execute();
    }
  });
}

// ../sdk/dist/import-export/exportFiles.js
init_define_ENV_DEFINED_IN_BUILD_STEP();
async function exportFiles(opts) {
  const plugin2 = opts.plugins.find((p3) => p3.key === opts.pluginKey);
  if (!plugin2)
    throw new PluginMissingError({ plugin: opts.pluginKey });
  if (!plugin2.exportFiles) {
    throw new PluginDoesNotImplementFunctionError({
      plugin: opts.pluginKey,
      function: "exportFiles"
    });
  }
  const bundles = await opts.db.selectFrom("bundle").selectAll().execute();
  const messages = await opts.db.selectFrom("message").selectAll().execute();
  const variants = await opts.db.selectFrom("variant").selectAll().execute();
  const files = await plugin2.exportFiles({
    settings: structuredClone(opts.settings),
    bundles,
    messages,
    variants
  });
  return files;
}

// ../sdk/dist/project/loadProject.js
async function loadProject(args) {
  const db = initDb2({ sqlite: args.sqlite });
  await maybeMigrateFirstProjectId({ lix: args.lix });
  const settingsFile = await args.lix.db.selectFrom("file").select("data").where("path", "=", "/settings.json").executeTakeFirstOrThrow();
  const settings = withLanguageTagToLocaleMigration(JSON.parse(new TextDecoder().decode(settingsFile.data)));
  const importedPlugins = await importPlugins({
    settings,
    lix: args.lix,
    preprocessPluginBeforeImport: args.preprocessPluginBeforeImport
  });
  const plugins = [...args.providePlugins ?? [], ...importedPlugins.plugins];
  const idFile = await args.lix.db.selectFrom("file").where("path", "=", "/project_id").select("data").executeTakeFirstOrThrow();
  const id = new TextDecoder().decode(idFile.data);
  maybeCaptureLoadedProject({
    db,
    id,
    settings,
    plugins,
    lix: args.lix,
    appId: args.appId
  });
  return {
    db,
    id: {
      get: async () => {
        const file = await args.lix.db.selectFrom("file").where("path", "=", "/project_id").select("file.data").executeTakeFirstOrThrow();
        return new TextDecoder().decode(file.data);
      }
    },
    settings: {
      get: async () => {
        const file = await args.lix.db.selectFrom("file").where("path", "=", "/settings.json").select("file.data").executeTakeFirstOrThrow();
        return withLanguageTagToLocaleMigration(JSON.parse(new TextDecoder().decode(file.data)));
      },
      set: async (newSettings) => {
        const cloned = JSON.parse(JSON.stringify(newSettings));
        cloned.languageTags = cloned.locales;
        cloned.sourceLanguageTag = cloned.baseLocale;
        await args.lix.db.updateTable("file").where("path", "=", "/settings.json").set({
          data: new TextEncoder().encode(JSON.stringify(cloned, void 0, 2))
        }).execute();
      }
    },
    plugins: {
      get: async () => plugins
    },
    errors: {
      get: async () => [...importedPlugins.errors]
    },
    // errors: state.errors,
    importFiles: async ({ files, pluginKey }) => {
      const settingsFile2 = await args.lix.db.selectFrom("file").where("path", "=", "/settings.json").select("file.data").executeTakeFirstOrThrow();
      const settings2 = JSON.parse(new TextDecoder().decode(settingsFile2.data));
      return await importFiles({
        files,
        pluginKey,
        settings: settings2,
        // TODO don't use global state, might be stale
        plugins,
        db
      });
    },
    exportFiles: async ({ pluginKey }) => {
      const settingsFile2 = await args.lix.db.selectFrom("file").where("path", "=", "/settings.json").select("file.data").executeTakeFirstOrThrow();
      const settings2 = JSON.parse(new TextDecoder().decode(settingsFile2.data));
      return (await exportFiles({
        pluginKey,
        db,
        settings: settings2,
        // TODO don't use global state, might be stale
        plugins
      })).map((output) => ({ ...output, pluginKey }));
    },
    close: async () => {
      await saveDbToLix({ sqlite: args.sqlite, lix: args.lix });
      await db.destroy();
      await args.lix.db.destroy();
    },
    _sqlite: args.sqlite,
    toBlob: async () => {
      await saveDbToLix({ sqlite: args.sqlite, lix: args.lix });
      return await toBlob({ lix: args.lix });
    },
    lix: args.lix
  };
}
async function saveDbToLix(args) {
  const data = contentFromDatabase(args.sqlite);
  await args.lix.db.updateTable("file").set("data", data).where("path", "=", "/db.sqlite").execute();
}
async function maybeMigrateFirstProjectId(args) {
  const firstProjectIdFile = await args.lix.db.selectFrom("file").select("data").where("path", "=", "/project_id").executeTakeFirst();
  if (!firstProjectIdFile) {
    await args.lix.db.insertInto("file").values({
      path: "/project_id",
      data: new TextEncoder().encode(v4_default())
    }).execute();
  }
}

// ../sdk/dist/project/loadProjectInMemory.js
async function loadProjectInMemory(args) {
  const lix = await openLixInMemory({
    blob: args.blob,
    account: args.account,
    keyValues: args.lixKeyValues,
    providePlugins: [
      // inlangLixPluginV1
    ]
  });
  const dbFile = await lix.db.selectFrom("file").select("data").where("path", "=", "/db.sqlite").executeTakeFirstOrThrow();
  const sqlite2 = await createInMemoryDatabase({});
  importDatabase({ db: sqlite2, content: new Uint8Array(dbFile.data) });
  return await loadProject({
    // pass common arguments to loadProject
    ...args,
    sqlite: sqlite2,
    lix
  });
}

// ../sdk/dist/project/loadProjectFromDirectory.js
init_define_ENV_DEFINED_IN_BUILD_STEP();
import nodePath from "node:path";

// ../sdk/dist/json-schema/old-v1-message/fromMessageV1.js
init_define_ENV_DEFINED_IN_BUILD_STEP();
function fromMessageV1(messageV1) {
  const bundleId = messageV1.id;
  const languages = [
    ...new Set(messageV1.variants.map((variant) => variant.languageTag))
  ];
  const declarations = /* @__PURE__ */ new Set();
  const messages = languages.map((language) => {
    const messageId = bundleId + "_" + language;
    const v1Variants = messageV1.variants.filter((variant) => variant.languageTag === language);
    const selectorNames = /* @__PURE__ */ new Set();
    for (const v1Selector of messageV1.selectors ?? []) {
      selectorNames.add(v1Selector.name);
    }
    const variableNames = new Set(selectorNames);
    const variants = [];
    let variantIndex = 1;
    for (const v1Variant of v1Variants) {
      for (const element of v1Variant.pattern) {
        if (element.type === "VariableReference") {
          variableNames.add(element.name);
        }
      }
      variants.push({
        // matching was not supported. no problem should arise
        matches: [],
        pattern: fromPatternV1(v1Variant.pattern),
        id: messageId + "_" + variantIndex,
        messageId
      });
      variantIndex += 1;
    }
    for (const variable of variableNames) {
      declarations.add({
        type: "input-variable",
        name: variable
      });
    }
    return {
      id: messageId,
      bundleId,
      locale: language,
      selectors: [],
      variants
    };
  });
  return {
    id: bundleId,
    declarations: [...declarations],
    messages
  };
}
function fromPatternV1(pattern) {
  return pattern.map((element) => {
    switch (element.type) {
      case "Text": {
        return {
          type: "text",
          value: element.value
        };
      }
      case "VariableReference":
        return {
          type: "expression",
          arg: {
            type: "variable-reference",
            name: element.name
          }
        };
    }
  });
}

// ../sdk/dist/import-export/upsertBundleNestedMatchByProperties.js
init_define_ENV_DEFINED_IN_BUILD_STEP();
var upsertBundleNestedMatchByProperties = async (db, bundle) => {
  if (bundle.id === void 0) {
    throw new Error("upsert expets a bundle id for matching");
  }
  const bundleToInsert = { ...bundle, messages: void 0 };
  await db.transaction().execute(async (trx) => {
    const insertedBundle = await trx.insertInto("bundle").values(bundleToInsert).onConflict((oc) => oc.column("id").doUpdateSet(bundleToInsert)).returning("id").executeTakeFirstOrThrow();
    const existingMessages = await trx.selectFrom("message").where("bundleId", "=", insertedBundle.id).selectAll().execute();
    for (const message of bundle.messages) {
      const existingMessage = existingMessages.find((m2) => m2.locale === message.locale);
      const messageToInsert = {
        ...message,
        id: existingMessage == null ? void 0 : existingMessage.id,
        bundleId: insertedBundle.id,
        variants: void 0
      };
      const insertedMessage = await trx.insertInto("message").values(messageToInsert).onConflict((oc) => oc.column("id").doUpdateSet(messageToInsert)).returning("id").executeTakeFirstOrThrow();
      const existingVariants = await trx.selectFrom("variant").where("messageId", "=", insertedMessage.id).selectAll().execute();
      for (const variant of message.variants) {
        const existingVariant = existingVariants.find((v3) => JSON.stringify(v3.matches) === JSON.stringify(variant.matches));
        const variantToInsert = {
          ...variant,
          id: existingVariant == null ? void 0 : existingVariant.id,
          messageId: insertedMessage.id
        };
        await trx.insertInto("variant").values(variantToInsert).onConflict((oc) => oc.column("id").doUpdateSet(variantToInsert)).execute();
      }
    }
  });
};

// ../sdk/dist/project/loadProjectFromDirectory.js
async function loadProjectFromDirectory(args) {
  const settingsPath = nodePath.join(args.path, "settings.json");
  const settings = JSON.parse(await args.fs.promises.readFile(settingsPath, "utf8"));
  let inlangId = void 0;
  try {
    inlangId = await args.fs.promises.readFile(nodePath.join(args.path, "project_id"), "utf8");
  } catch {
  }
  const localImport = await importLocalPlugins({
    fs: args.fs,
    settings,
    path: args.path
  });
  const providePluginsWithLocalPlugins = [
    ...args.providePlugins ?? [],
    ...localImport.locallyImportedPlugins
  ];
  const newLix = await newProject({
    settings
  });
  const tempLix = await openLixInMemory({ blob: newLix });
  await syncLixFsFiles({
    fs: args.fs,
    path: args.path,
    lix: tempLix,
    syncInterval: void 0
  });
  const project = await loadProjectInMemory({
    ...args,
    providePlugins: providePluginsWithLocalPlugins,
    lixKeyValues: inlangId ? (
      // reversing the id to have distinguishable lix ids from inlang ids
      [{ key: "lix_id", value: inlangId }]
    ) : void 0,
    blob: await toBlob({ lix: tempLix })
  });
  await closeLix({ lix: tempLix });
  await syncLixFsFiles({
    fs: args.fs,
    path: args.path,
    lix: project.lix,
    syncInterval: args.syncInterval
  });
  const allPlugins = await project.plugins.get();
  const { loadSavePlugins, importExportPlugins } = categorizePlugins(allPlugins);
  if (loadSavePlugins.length > 1) {
    throw new Error("Max one loadMessages (found: " + loadSavePlugins.length + ") and one saveMessages plugins (found: " + loadSavePlugins.length + ") are allowed ");
  }
  const importedResourceFileErrors = [];
  for (const plugin2 of importExportPlugins) {
    const files = [];
    if (plugin2.toBeImportedFiles) {
      const toBeImportedFiles = await plugin2.toBeImportedFiles({
        settings: await project.settings.get()
      });
      for (const toBeImported of toBeImportedFiles) {
        const absolute = absolutePathFromProject(args.path, toBeImported.path);
        try {
          const data = await args.fs.promises.readFile(absolute);
          files.push({
            locale: toBeImported.locale,
            content: data,
            toBeImportedFilesMetadata: toBeImported.metadata
          });
        } catch (e2) {
          if ((e2 == null ? void 0 : e2.code) === "ENOENT") {
            continue;
          }
          importedResourceFileErrors.push(new ResourceFileImportError({
            cause: e2,
            path: toBeImported.path
          }));
        }
      }
    }
    await project.importFiles({
      pluginKey: plugin2.key,
      files
    });
  }
  for (const plugin2 of loadSavePlugins) {
    await loadLegacyMessages({
      project,
      pluginKey: plugin2.key ?? plugin2.id,
      loadMessagesFn: plugin2.loadMessages,
      projectPath: args.path,
      fs: args.fs
    });
  }
  return {
    ...project,
    errors: {
      get: async () => {
        return [
          ...filterLocalPluginImportErrors(await project.errors.get()),
          ...localImport.errors,
          ...importedResourceFileErrors
        ];
      }
      // subscribe: (
      // 	callback: Parameters<InlangProject["errors"]["subscribe"]>[0]
      // ) => {
      // 	return project.errors.subscribe((value) => {
      // 		callback([
      // 			...withLocallyImportedPluginWarning(value),
      // 			...localImport.errors,
      // 			...importedResourceFileErrors,
      // 		]);
      // 	});
      // },
    }
  };
}
async function loadLegacyMessages(args) {
  const loadedLegacyMessages = await args.loadMessagesFn({
    settings: await args.project.settings.get(),
    // @ts-expect-error - type mismatch
    nodeishFs: withAbsolutePaths(args.fs.promises, args.projectPath)
  });
  const upsertQueries = [];
  for (const legacyMessage of loadedLegacyMessages) {
    const messageBundle = fromMessageV1(legacyMessage);
    upsertQueries.push(upsertBundleNestedMatchByProperties(args.project.db, messageBundle));
  }
  return await Promise.all(upsertQueries);
}
function arrayBuffersEqual(a3, b) {
  if (a3.byteLength !== b.byteLength)
    return false;
  const view1 = new Uint8Array(a3);
  const view2 = new Uint8Array(b);
  for (const [i2, element] of view1.entries()) {
    if (element !== view2[i2]) {
      return false;
    }
  }
  return true;
}
function filterLocalPluginImportErrors(errors) {
  return errors.filter((error) => {
    if (error instanceof PluginImportError && error.plugin.startsWith("http") === false) {
      return false;
    }
    return true;
  });
}
async function syncLixFsFiles(args) {
  async function checkFsStateRecursive(dirPath, currentState) {
    const entries = args.fs.readdirSync(dirPath, { withFileTypes: true });
    for (const entry of entries) {
      const fullPath = nodePath.join(dirPath, entry.name);
      if (entry.isDirectory()) {
        checkFsStateRecursive(fullPath, currentState);
      } else {
        const data = args.fs.readFileSync(fullPath);
        const relativePath = "/" + nodePath.relative(args.path, fullPath);
        if (!currentState[relativePath]) {
          currentState[relativePath] = {
            content: data,
            state: "unknown"
          };
        } else {
          if (arrayBuffersEqual(currentState[relativePath].content, data)) {
            currentState[relativePath].state = "known";
          } else {
            currentState[relativePath].state = "updated";
            currentState[relativePath].content = data;
          }
        }
      }
    }
  }
  async function checkLixState(currentLixState) {
    const filesInLix = await args.lix.db.selectFrom("file").where("path", "not like", "%db.sqlite").selectAll().execute();
    for (const fileInLix of filesInLix) {
      const currentStateOfFileInLix = currentLixState[fileInLix.path];
      if (!currentStateOfFileInLix) {
        currentLixState[fileInLix.path] = {
          content: new Uint8Array(fileInLix.data).buffer,
          state: "unknown"
        };
      } else {
        if (arrayBuffersEqual(currentStateOfFileInLix.content, fileInLix.data.buffer)) {
          currentStateOfFileInLix.state = "known";
        } else {
          currentStateOfFileInLix.state = "updated";
          currentStateOfFileInLix.content = fileInLix.data.buffer;
        }
      }
    }
  }
  async function syncUpFsAndLixFiles(statesToSync) {
    for (const [path2, fsState] of Object.entries(statesToSync.fsFileStates)) {
      if (!statesToSync.lixFileStates[path2]) {
        if (fsState.state === "unknown") {
          await upsertFileInLix(args, path2, fsState.content);
          statesToSync.lixFileStates[path2] = {
            state: "known",
            content: fsState.content
          };
          fsState.state = "known";
        } else {
          throw new Error("Illeagal lix<->fs sync state. The file [" + path2 + "] that was " + fsState.state + " on disc did not exit in lix");
        }
      } else {
        const lixState = statesToSync.lixFileStates[path2];
        if (fsState.state === "unknown") {
          if (lixState.state === "unknown") {
            if (arrayBuffersEqual(lixState.content, fsState.content)) {
              lixState.state = "known";
              fsState.state = "known";
            } else {
              await upsertFileInLix(args, path2, fsState.content);
              lixState.content = fsState.content;
              lixState.state = "known";
              fsState.state = "known";
            }
          } else {
            throw new Error("Illeagal lix<->fs sync state. The file [" + path2 + "] that was " + fsState.state + " but did exist in lix already");
          }
        } else if (fsState.state === "known") {
          if (lixState.state === "known") {
          } else if (lixState.state === "updated") {
            args.fs.writeFileSync(
              // TODO check platform dependent folder separator
              args.path + path2,
              Buffer.from(lixState.content)
            );
            fsState.content = lixState.content;
            fsState.state = "known";
            lixState.state = "known";
          } else if (lixState.state === "gone") {
            args.fs.unlinkSync(args.path + path2);
            fsState.state = "gone";
            lixState.state = "gone";
          }
        } else if (fsState.state === "updated") {
          if (lixState.state === "unknown") {
            throw new Error("Illeagal lix<->fs sync state. The file [" + path2 + "] that was " + fsState.state + " but it was not known by lix yet?");
          } else if (lixState.state === "known") {
            await upsertFileInLix(args, path2, fsState.content);
            lixState.content = fsState.content;
            fsState.state = "known";
          } else if (lixState.state === "updated") {
            console.warn("seems like we saw an update on the file " + path2 + " in fs while some changes on lix have not been reached fs? FS -> Winns?");
            await upsertFileInLix(args, path2, fsState.content);
            lixState.content = fsState.content;
            lixState.state = "known";
            fsState.state = "known";
          } else if (lixState.state === "gone") {
            console.warn("seems like we saw an delete in lix while some changes on fs have not been reached fs? FS -> Winns?");
            lixState.content = fsState.content;
            lixState.state = "known";
            fsState.state = "known";
          }
        } else if (fsState.state === "gone") {
          if (lixState.state === "unknown") {
            throw new Error("Illeagal lix<->fs sync state. The file [" + path2 + "] that was " + fsState.state + " but it was not known by lix yet?");
          } else if (lixState.state === "known") {
            await args.lix.db.deleteFrom("file").where("path", "=", path2).execute();
            lixState.state = "gone";
          } else if (lixState.state === "updated") {
            console.warn("seems like we saw an update on the file in fs while some changes on lix have not been reached fs? FS -> Winns?");
            await args.lix.db.deleteFrom("file").where("path", "=", path2).execute();
            lixState.state = "gone";
            fsState.state = "gone";
          } else if (lixState.state === "gone") {
            console.warn("seems like we saw an delete in lix while we have a delete in lix simultaniously?");
            lixState.state = "gone";
            fsState.state = "gone";
          }
        }
      }
    }
    for (const [path2, lixState] of Object.entries(statesToSync.lixFileStates)) {
      if (!statesToSync.fsFileStates[path2]) {
        if (lixState.state == "unknown") {
          try {
            args.fs.mkdirSync(nodePath.dirname(nodePath.join(args.path, path2)), {
              recursive: true
            });
          } catch (e2) {
            if ((e2 == null ? void 0 : e2.code) !== "EEXIST") {
              throw e2;
            }
          }
          args.fs.writeFileSync(nodePath.join(args.path, path2), Buffer.from(lixState.content));
          statesToSync.fsFileStates[path2] = {
            state: "known",
            content: lixState.content
          };
        } else {
          throw new Error("Illeagal lix<->fs sync state. The file [" + path2 + "] that was in the state" + lixState.state + " for lix did not exist on disk");
        }
      } else {
        if (lixState.state === "gone" && statesToSync.fsFileStates[path2].state === "gone") {
          delete statesToSync.lixFileStates[path2];
          delete statesToSync.fsFileStates[path2];
        } else if (lixState.state !== statesToSync.fsFileStates[path2].state) {
          throw new Error("At this stage both states should be in sync lix state " + lixState.state + " fs state " + statesToSync.fsFileStates[path2].state);
        }
      }
    }
  }
  async function syncFiles(dirPath, fileStates, interval) {
    for (const fsState of Object.values(fileStates.fsFileStates)) {
      fsState.state = "gone";
    }
    for (const lixState of Object.values(fileStates.lixFileStates)) {
      lixState.state = "gone";
    }
    await checkFsStateRecursive(dirPath, fileStates.fsFileStates);
    await checkLixState(fileStates.lixFileStates);
    await syncUpFsAndLixFiles(fileStates);
    if (interval) {
      setTimeout(() => {
        syncFiles(dirPath, fileStates, interval);
      }, interval);
    }
    return;
  }
  await syncFiles(args.path, { fsFileStates: {}, lixFileStates: {} }, args.syncInterval);
  return;
}
async function upsertFileInLix(args, path2, data) {
  let posixPath = path2.split(nodePath.win32.sep).join(nodePath.posix.sep);
  if (posixPath.startsWith("/") === false) {
    posixPath = "/" + posixPath;
  }
  await args.lix.db.insertInto("file").values({
    path: posixPath,
    data: new Uint8Array(data)
  }).onConflict((oc) => oc.column("path").doUpdateSet({ data: new Uint8Array(data) })).execute();
}
function categorizePlugins(plugins) {
  const loadSavePlugins = [];
  const importExportPlugins = [];
  for (const plugin2 of plugins) {
    if (plugin2.loadMessages && plugin2.saveMessages && !(plugin2.importFiles && plugin2.exportFiles)) {
      loadSavePlugins.push(plugin2);
    } else if (plugin2.importFiles || plugin2.exportFiles) {
      importExportPlugins.push(plugin2);
    }
  }
  return { loadSavePlugins, importExportPlugins };
}
async function importLocalPlugins(args) {
  const errors = [];
  const locallyImportedPlugins = [];
  for (const module of args.settings.modules ?? []) {
    if (module.startsWith("http")) {
      continue;
    }
    const modulePath = absolutePathFromProject(args.path, module);
    try {
      let moduleAsText = await args.fs.promises.readFile(modulePath, "utf8");
      if (moduleAsText.includes("messageLintRule")) {
        errors.push(new WarningDeprecatedLintRule(module));
        continue;
      }
      if (args.preprocessPluginBeforeImport) {
        moduleAsText = await args.preprocessPluginBeforeImport(moduleAsText);
      }
      const moduleWithMimeType = "data:application/javascript," + encodeURIComponent(moduleAsText);
      const { default: plugin2 } = await import(
        /* @vite-ignore */
        moduleWithMimeType
      );
      locallyImportedPlugins.push(plugin2);
    } catch (e2) {
      errors.push(new PluginImportError({ plugin: module, cause: e2 }));
      continue;
    }
  }
  return {
    errors,
    locallyImportedPlugins
  };
}
var WarningDeprecatedLintRule = class extends Error {
  constructor(module) {
    super(`The lint rule ${module} is deprecated. Please remove the lint rule from the settings. Lint rules are interim built into apps and will be succeeded by more generilizable lix validation rules.`);
    this.name = "WarningDeprecatedLintRule";
  }
};
function withAbsolutePaths(fs3, projectPath) {
  return {
    // @ts-expect-error - node type mismatch
    readFile: (path2, options) => {
      return fs3.readFile(absolutePathFromProject(projectPath, path2), options);
    },
    writeFile: (path2, data) => {
      return fs3.writeFile(absolutePathFromProject(projectPath, path2), data);
    },
    mkdir: (path2) => {
      return fs3.mkdir(absolutePathFromProject(projectPath, path2));
    },
    readdir: (path2) => {
      return fs3.readdir(absolutePathFromProject(projectPath, path2));
    }
  };
}
function absolutePathFromProject(projectPath, filePath) {
  const normalizedProjectPath = nodePath.normalize(projectPath).replace(/\\/g, "/");
  const normalizedFilePath = nodePath.normalize(filePath).replace(/\\/g, "/");
  const projectRoot = nodePath.dirname(normalizedProjectPath);
  if (nodePath.isAbsolute(normalizedFilePath)) {
    return normalizedFilePath;
  }
  const resolvedPath = nodePath.resolve(projectRoot, normalizedFilePath);
  return resolvedPath.replace(/\\/g, "/");
}
var ResourceFileImportError = class extends Error {
  path;
  constructor(args) {
    super("Could not import a resource file");
    this.name = "ResourceFileImportError";
    this.cause = args.cause;
    this.path = args.path;
  }
};

// ../sdk/dist/project/saveProjectToDirectory.js
init_define_ENV_DEFINED_IN_BUILD_STEP();
import path from "node:path";

// ../sdk/dist/json-schema/old-v1-message/toMessageV1.js
init_define_ENV_DEFINED_IN_BUILD_STEP();
function toMessageV1(bundle) {
  const variants = [];
  const selectorNames = /* @__PURE__ */ new Set();
  for (const message of bundle.messages) {
    for (const selector of message.selectors.map((s2) => ({
      type: "variable-reference",
      name: s2.name
    }))) {
      selectorNames.add(selector.name);
    }
    for (const variant of message.variants) {
      variants.push({
        languageTag: message.locale,
        match: [],
        pattern: toV1Pattern(variant.pattern)
      });
    }
  }
  const selectors = [...selectorNames].map((name) => ({
    type: "VariableReference",
    name
  }));
  return {
    id: bundle.id,
    alias: {},
    variants,
    selectors
  };
}
function toV1Pattern(pattern) {
  return pattern.map((element) => {
    switch (element.type) {
      case "text": {
        return {
          type: "Text",
          value: element.value
        };
      }
      case "expression": {
        if (element.arg.type === "variable-reference") {
          return {
            type: "VariableReference",
            name: element.arg.name
          };
        }
        throw new Error(`Unsupported expression argument type`);
      }
      default: {
        throw new Error(`Unsupported pattern element type`);
      }
    }
  });
}

// ../sdk/dist/utilities/detectJsonFormatting.js
init_define_ENV_DEFINED_IN_BUILD_STEP();
var detectJsonFormatting = (file) => {
  const endsWithNewLine = file.endsWith("\n");
  const spacing = guessJsonIndent(file);
  return (value, replacer) => JSON.stringify(value, replacer, spacing) + (endsWithNewLine ? "\n" : "");
};
var guessJsonIndent = (jsonString) => {
  const firstIndex = skipWhitespaces(jsonString, 0);
  if (firstIndex === void 0 || !isJsonObjectOrArray(jsonString[firstIndex])) {
    return;
  }
  const secondIndex = skipWhitespaces(jsonString, firstIndex + 1);
  if (secondIndex === void 0) {
    return;
  }
  return getIndent(jsonString, firstIndex, secondIndex);
};
var skipWhitespaces = (jsonString, startIndex) => {
  for (let index = startIndex; index < jsonString.length; index += 1) {
    const character = jsonString[index];
    if (!isJsonWhitespace(character)) {
      return index;
    }
  }
  return;
};
var isJsonWhitespace = (character) => character === " " || character === "	" || character === "\n" || character === "\r";
var isJsonObjectOrArray = (character) => character === "{" || character === "[";
var getIndent = (jsonString, firstIndex, secondIndex) => {
  let indent;
  for (let index = secondIndex - 1; index > firstIndex; index -= 1) {
    const character = jsonString[index];
    if (character === "\r") {
      return;
    }
    if (character === "\n") {
      return normalizeIndent(indent);
    }
    if (indent === void 0) {
      indent = character;
    } else if (indent[0] === character) {
      indent += character;
    } else {
      return;
    }
  }
};
var normalizeIndent = (indent) => {
  if (indent === void 0) {
    return 0;
  }
  return indent[0] === " " ? indent.length : indent;
};

// ../sdk/dist/query-utilities/selectBundleNested.js
init_define_ENV_DEFINED_IN_BUILD_STEP();
var selectBundleNested = (db) => {
  return db.selectFrom("bundle").select((eb) => [
    // select all columns from bundle
    "id",
    "declarations",
    // select all columns from messages as "messages"
    jsonArrayFrom(eb.selectFrom("message").select((eb2) => [
      // select all columns from message
      "id",
      "bundleId",
      "locale",
      "selectors",
      // select all columns from variants as "variants"
      jsonArrayFrom(eb2.selectFrom("variant").select(["id", "messageId", "matches", "pattern"]).whereRef("variant.messageId", "=", "message.id")).as("variants")
    ]).whereRef("message.bundleId", "=", "bundle.id")).as("messages")
  ]);
};

// ../sdk/dist/project/saveProjectToDirectory.js
async function saveProjectToDirectory(args) {
  var _a8;
  if (args.path.endsWith(".inlang") === false) {
    throw new Error("The path must end with .inlang");
  }
  const files = await args.project.lix.db.selectFrom("file").selectAll().execute();
  let hasGitignore = false;
  for (const file of files) {
    if (file.path.endsWith("db.sqlite")) {
      continue;
    } else if (file.path.endsWith(".gitignore")) {
      hasGitignore = true;
    }
    const p3 = path.join(args.path, file.path);
    await args.fs.mkdir(path.dirname(p3), { recursive: true });
    await args.fs.writeFile(p3, new Uint8Array(file.data));
  }
  if (hasGitignore === false) {
    await args.fs.writeFile(path.join(args.path, ".gitignore"), new TextEncoder().encode("cache"));
  }
  const plugins = await args.project.plugins.get();
  const settings = await args.project.settings.get();
  for (const plugin2 of plugins) {
    if (plugin2.exportFiles) {
      const bundles = await args.project.db.selectFrom("bundle").selectAll().execute();
      const messages = await args.project.db.selectFrom("message").selectAll().execute();
      const variants = await args.project.db.selectFrom("variant").selectAll().execute();
      const files2 = await plugin2.exportFiles({
        bundles,
        messages,
        variants,
        settings
      });
      for (const file of files2) {
        const pathPattern = (_a8 = settings[plugin2.key]) == null ? void 0 : _a8.pathPattern;
        const formattedPathPatterns = Array.isArray(pathPattern) ? pathPattern : [pathPattern];
        for (const pathPattern2 of formattedPathPatterns) {
          const p3 = pathPattern2 ? absolutePathFromProject(args.path, pathPattern2.replace(/\{(languageTag|locale)\}/g, file.locale)) : absolutePathFromProject(args.path, file.name);
          const dirname = path.dirname(p3);
          if ((await args.fs.stat(dirname)).isDirectory() === false) {
            await args.fs.mkdir(dirname, { recursive: true });
          }
          if (p3.endsWith(".json")) {
            try {
              const existing = await args.fs.readFile(p3, "utf-8");
              const stringify = detectJsonFormatting(existing);
              await args.fs.writeFile(p3, new TextEncoder().encode(stringify(JSON.parse(new TextDecoder().decode(file.content)))));
            } catch {
              await args.fs.writeFile(p3, new Uint8Array(file.content));
            }
          } else {
            await args.fs.writeFile(p3, new Uint8Array(file.content));
          }
        }
      }
    } else if (plugin2.saveMessages) {
      const bundlesNested = await selectBundleNested(args.project.db).execute();
      await plugin2.saveMessages({
        messages: bundlesNested.map((b) => toMessageV1(b)),
        // @ts-expect-error - legacy
        nodeishFs: withAbsolutePaths(args.fs, args.path),
        settings
      });
    }
  }
}

// ../sdk/dist/query-utilities/index.js
init_define_ENV_DEFINED_IN_BUILD_STEP();

// ../sdk/dist/query-utilities/upsertBundleNested.js
init_define_ENV_DEFINED_IN_BUILD_STEP();
var upsertBundleNested = async (db, bundle) => {
  await db.transaction().execute(async (trx) => {
    const insertedBundle = await trx.insertInto("bundle").values({
      id: bundle.id,
      declarations: bundle.declarations
    }).returning("id").onConflict((oc) => oc.column("id").doUpdateSet({
      ...bundle,
      // @ts-expect-error - undefined
      messages: void 0
    })).executeTakeFirstOrThrow();
    for (const message of bundle.messages) {
      const insertedMessage = await trx.insertInto("message").values({
        id: message.id,
        bundleId: insertedBundle.id,
        locale: message.locale,
        selectors: message.selectors
      }).onConflict((oc) => oc.column("id").doUpdateSet({
        ...message,
        // @ts-expect-error - undefined
        variants: void 0
      })).returning("id").executeTakeFirstOrThrow();
      for (const variant of message.variants) {
        await trx.insertInto("variant").values({
          id: variant.id,
          messageId: insertedMessage.id,
          matches: variant.matches,
          pattern: variant.pattern
        }).onConflict((oc) => oc.column("id").doUpdateSet(variant)).execute();
      }
    }
  });
};

// src/utilities/getInlangProject.ts
import { resolve } from "node:path";
var lastUsedProject;
async function getInlangProject(args) {
  try {
    const baseDirectory = process.cwd();
    const projectPath = resolve(baseDirectory, args.projectPath);
    const project = await loadProjectFromDirectory({
      path: projectPath,
      fs,
      appId: "app"
    });
    lastUsedProject = project;
    return project;
  } catch (err) {
    console.error(`Error opening inlang project at ${args.projectPath}`, err);
    process.exit(1);
  }
}

// src/utilities/log.ts
init_define_ENV_DEFINED_IN_BUILD_STEP();

// ../../../node_modules/.pnpm/consola@3.4.0/node_modules/consola/dist/index.mjs
init_define_ENV_DEFINED_IN_BUILD_STEP();

// ../../../node_modules/.pnpm/consola@3.4.0/node_modules/consola/dist/core.mjs
init_define_ENV_DEFINED_IN_BUILD_STEP();
var LogLevels = {
  silent: Number.NEGATIVE_INFINITY,
  fatal: 0,
  error: 0,
  warn: 1,
  log: 2,
  info: 3,
  success: 3,
  fail: 3,
  ready: 3,
  start: 3,
  box: 3,
  debug: 4,
  trace: 5,
  verbose: Number.POSITIVE_INFINITY
};
var LogTypes = {
  // Silent
  silent: {
    level: -1
  },
  // Level 0
  fatal: {
    level: LogLevels.fatal
  },
  error: {
    level: LogLevels.error
  },
  // Level 1
  warn: {
    level: LogLevels.warn
  },
  // Level 2
  log: {
    level: LogLevels.log
  },
  // Level 3
  info: {
    level: LogLevels.info
  },
  success: {
    level: LogLevels.success
  },
  fail: {
    level: LogLevels.fail
  },
  ready: {
    level: LogLevels.info
  },
  start: {
    level: LogLevels.info
  },
  box: {
    level: LogLevels.info
  },
  // Level 4
  debug: {
    level: LogLevels.debug
  },
  // Level 5
  trace: {
    level: LogLevels.trace
  },
  // Verbose
  verbose: {
    level: LogLevels.verbose
  }
};
function isPlainObject$1(value) {
  if (value === null || typeof value !== "object") {
    return false;
  }
  const prototype = Object.getPrototypeOf(value);
  if (prototype !== null && prototype !== Object.prototype && Object.getPrototypeOf(prototype) !== null) {
    return false;
  }
  if (Symbol.iterator in value) {
    return false;
  }
  if (Symbol.toStringTag in value) {
    return Object.prototype.toString.call(value) === "[object Module]";
  }
  return true;
}
function _defu(baseObject, defaults, namespace = ".", merger) {
  if (!isPlainObject$1(defaults)) {
    return _defu(baseObject, {}, namespace, merger);
  }
  const object = Object.assign({}, defaults);
  for (const key in baseObject) {
    if (key === "__proto__" || key === "constructor") {
      continue;
    }
    const value = baseObject[key];
    if (value === null || value === void 0) {
      continue;
    }
    if (merger && merger(object, key, value, namespace)) {
      continue;
    }
    if (Array.isArray(value) && Array.isArray(object[key])) {
      object[key] = [...value, ...object[key]];
    } else if (isPlainObject$1(value) && isPlainObject$1(object[key])) {
      object[key] = _defu(
        value,
        object[key],
        (namespace ? `${namespace}.` : "") + key.toString(),
        merger
      );
    } else {
      object[key] = value;
    }
  }
  return object;
}
function createDefu(merger) {
  return (...arguments_) => (
    // eslint-disable-next-line unicorn/no-array-reduce
    arguments_.reduce((p3, c3) => _defu(p3, c3, "", merger), {})
  );
}
var defu = createDefu();
function isPlainObject2(obj) {
  return Object.prototype.toString.call(obj) === "[object Object]";
}
function isLogObj(arg) {
  if (!isPlainObject2(arg)) {
    return false;
  }
  if (!arg.message && !arg.args) {
    return false;
  }
  if (arg.stack) {
    return false;
  }
  return true;
}
var paused = false;
var queue = [];
var Consola = class _Consola {
  options;
  _lastLog;
  _mockFn;
  /**
   * Creates an instance of Consola with specified options or defaults.
   *
   * @param {Partial<ConsolaOptions>} [options={}] - Configuration options for the Consola instance.
   */
  constructor(options = {}) {
    const types = options.types || LogTypes;
    this.options = defu(
      {
        ...options,
        defaults: { ...options.defaults },
        level: _normalizeLogLevel(options.level, types),
        reporters: [...options.reporters || []]
      },
      {
        types: LogTypes,
        throttle: 1e3,
        throttleMin: 5,
        formatOptions: {
          date: true,
          colors: false,
          compact: true
        }
      }
    );
    for (const type in types) {
      const defaults = {
        type,
        ...this.options.defaults,
        ...types[type]
      };
      this[type] = this._wrapLogFn(defaults);
      this[type].raw = this._wrapLogFn(
        defaults,
        true
      );
    }
    if (this.options.mockFn) {
      this.mockTypes();
    }
    this._lastLog = {};
  }
  /**
   * Gets the current log level of the Consola instance.
   *
   * @returns {number} The current log level.
   */
  get level() {
    return this.options.level;
  }
  /**
   * Sets the minimum log level that will be output by the instance.
   *
   * @param {number} level - The new log level to set.
   */
  set level(level) {
    this.options.level = _normalizeLogLevel(
      level,
      this.options.types,
      this.options.level
    );
  }
  /**
   * Displays a prompt to the user and returns the response.
   * Throw an error if `prompt` is not supported by the current configuration.
   *
   * @template T
   * @param {string} message - The message to display in the prompt.
   * @param {T} [opts] - Optional options for the prompt. See {@link PromptOptions}.
   * @returns {promise<T>} A promise that infer with the prompt options. See {@link PromptOptions}.
   */
  prompt(message, opts) {
    if (!this.options.prompt) {
      throw new Error("prompt is not supported!");
    }
    return this.options.prompt(message, opts);
  }
  /**
   * Creates a new instance of Consola, inheriting options from the current instance, with possible overrides.
   *
   * @param {Partial<ConsolaOptions>} options - Optional overrides for the new instance. See {@link ConsolaOptions}.
   * @returns {ConsolaInstance} A new Consola instance. See {@link ConsolaInstance}.
   */
  create(options) {
    const instance = new _Consola({
      ...this.options,
      ...options
    });
    if (this._mockFn) {
      instance.mockTypes(this._mockFn);
    }
    return instance;
  }
  /**
   * Creates a new Consola instance with the specified default log object properties.
   *
   * @param {InputLogObject} defaults - Default properties to include in any log from the new instance. See {@link InputLogObject}.
   * @returns {ConsolaInstance} A new Consola instance. See {@link ConsolaInstance}.
   */
  withDefaults(defaults) {
    return this.create({
      ...this.options,
      defaults: {
        ...this.options.defaults,
        ...defaults
      }
    });
  }
  /**
   * Creates a new Consola instance with a specified tag, which will be included in every log.
   *
   * @param {string} tag - The tag to include in each log of the new instance.
   * @returns {ConsolaInstance} A new Consola instance. See {@link ConsolaInstance}.
   */
  withTag(tag) {
    return this.withDefaults({
      tag: this.options.defaults.tag ? this.options.defaults.tag + ":" + tag : tag
    });
  }
  /**
   * Adds a custom reporter to the Consola instance.
   * Reporters will be called for each log message, depending on their implementation and log level.
   *
   * @param {ConsolaReporter} reporter - The reporter to add. See {@link ConsolaReporter}.
   * @returns {Consola} The current Consola instance.
   */
  addReporter(reporter) {
    this.options.reporters.push(reporter);
    return this;
  }
  /**
   * Removes a custom reporter from the Consola instance.
   * If no reporter is specified, all reporters will be removed.
   *
   * @param {ConsolaReporter} reporter - The reporter to remove. See {@link ConsolaReporter}.
   * @returns {Consola} The current Consola instance.
   */
  removeReporter(reporter) {
    if (reporter) {
      const i2 = this.options.reporters.indexOf(reporter);
      if (i2 !== -1) {
        return this.options.reporters.splice(i2, 1);
      }
    } else {
      this.options.reporters.splice(0);
    }
    return this;
  }
  /**
   * Replaces all reporters of the Consola instance with the specified array of reporters.
   *
   * @param {ConsolaReporter[]} reporters - The new reporters to set. See {@link ConsolaReporter}.
   * @returns {Consola} The current Consola instance.
   */
  setReporters(reporters) {
    this.options.reporters = Array.isArray(reporters) ? reporters : [reporters];
    return this;
  }
  wrapAll() {
    this.wrapConsole();
    this.wrapStd();
  }
  restoreAll() {
    this.restoreConsole();
    this.restoreStd();
  }
  /**
   * Overrides console methods with Consola logging methods for consistent logging.
   */
  wrapConsole() {
    for (const type in this.options.types) {
      if (!console["__" + type]) {
        console["__" + type] = console[type];
      }
      console[type] = this[type].raw;
    }
  }
  /**
   * Restores the original console methods, removing Consola overrides.
   */
  restoreConsole() {
    for (const type in this.options.types) {
      if (console["__" + type]) {
        console[type] = console["__" + type];
        delete console["__" + type];
      }
    }
  }
  /**
   * Overrides standard output and error streams to redirect them through Consola.
   */
  wrapStd() {
    this._wrapStream(this.options.stdout, "log");
    this._wrapStream(this.options.stderr, "log");
  }
  _wrapStream(stream, type) {
    if (!stream) {
      return;
    }
    if (!stream.__write) {
      stream.__write = stream.write;
    }
    stream.write = (data) => {
      this[type].raw(String(data).trim());
    };
  }
  /**
   * Restores the original standard output and error streams, removing the Consola redirection.
   */
  restoreStd() {
    this._restoreStream(this.options.stdout);
    this._restoreStream(this.options.stderr);
  }
  _restoreStream(stream) {
    if (!stream) {
      return;
    }
    if (stream.__write) {
      stream.write = stream.__write;
      delete stream.__write;
    }
  }
  /**
   * Pauses logging, queues incoming logs until resumed.
   */
  pauseLogs() {
    paused = true;
  }
  /**
   * Resumes logging, processing any queued logs.
   */
  resumeLogs() {
    paused = false;
    const _queue = queue.splice(0);
    for (const item of _queue) {
      item[0]._logFn(item[1], item[2]);
    }
  }
  /**
   * Replaces logging methods with mocks if a mock function is provided.
   *
   * @param {ConsolaOptions["mockFn"]} mockFn - The function to use for mocking logging methods. See {@link ConsolaOptions["mockFn"]}.
   */
  mockTypes(mockFn) {
    const _mockFn = mockFn || this.options.mockFn;
    this._mockFn = _mockFn;
    if (typeof _mockFn !== "function") {
      return;
    }
    for (const type in this.options.types) {
      this[type] = _mockFn(type, this.options.types[type]) || this[type];
      this[type].raw = this[type];
    }
  }
  _wrapLogFn(defaults, isRaw) {
    return (...args) => {
      if (paused) {
        queue.push([this, defaults, args, isRaw]);
        return;
      }
      return this._logFn(defaults, args, isRaw);
    };
  }
  _logFn(defaults, args, isRaw) {
    if ((defaults.level || 0) > this.level) {
      return false;
    }
    const logObj = {
      date: /* @__PURE__ */ new Date(),
      args: [],
      ...defaults,
      level: _normalizeLogLevel(defaults.level, this.options.types)
    };
    if (!isRaw && args.length === 1 && isLogObj(args[0])) {
      Object.assign(logObj, args[0]);
    } else {
      logObj.args = [...args];
    }
    if (logObj.message) {
      logObj.args.unshift(logObj.message);
      delete logObj.message;
    }
    if (logObj.additional) {
      if (!Array.isArray(logObj.additional)) {
        logObj.additional = logObj.additional.split("\n");
      }
      logObj.args.push("\n" + logObj.additional.join("\n"));
      delete logObj.additional;
    }
    logObj.type = typeof logObj.type === "string" ? logObj.type.toLowerCase() : "log";
    logObj.tag = typeof logObj.tag === "string" ? logObj.tag : "";
    const resolveLog = (newLog = false) => {
      const repeated = (this._lastLog.count || 0) - this.options.throttleMin;
      if (this._lastLog.object && repeated > 0) {
        const args2 = [...this._lastLog.object.args];
        if (repeated > 1) {
          args2.push(`(repeated ${repeated} times)`);
        }
        this._log({ ...this._lastLog.object, args: args2 });
        this._lastLog.count = 1;
      }
      if (newLog) {
        this._lastLog.object = logObj;
        this._log(logObj);
      }
    };
    clearTimeout(this._lastLog.timeout);
    const diffTime = this._lastLog.time && logObj.date ? logObj.date.getTime() - this._lastLog.time.getTime() : 0;
    this._lastLog.time = logObj.date;
    if (diffTime < this.options.throttle) {
      try {
        const serializedLog = JSON.stringify([
          logObj.type,
          logObj.tag,
          logObj.args
        ]);
        const isSameLog = this._lastLog.serialized === serializedLog;
        this._lastLog.serialized = serializedLog;
        if (isSameLog) {
          this._lastLog.count = (this._lastLog.count || 0) + 1;
          if (this._lastLog.count > this.options.throttleMin) {
            this._lastLog.timeout = setTimeout(
              resolveLog,
              this.options.throttle
            );
            return;
          }
        }
      } catch {
      }
    }
    resolveLog(true);
  }
  _log(logObj) {
    for (const reporter of this.options.reporters) {
      reporter.log(logObj, {
        options: this.options
      });
    }
  }
};
function _normalizeLogLevel(input, types = {}, defaultLevel = 3) {
  if (input === void 0) {
    return defaultLevel;
  }
  if (typeof input === "number") {
    return input;
  }
  if (types[input] && types[input].level !== void 0) {
    return types[input].level;
  }
  return defaultLevel;
}
Consola.prototype.add = Consola.prototype.addReporter;
Consola.prototype.remove = Consola.prototype.removeReporter;
Consola.prototype.clear = Consola.prototype.removeReporter;
Consola.prototype.withScope = Consola.prototype.withTag;
Consola.prototype.mock = Consola.prototype.mockTypes;
Consola.prototype.pause = Consola.prototype.pauseLogs;
Consola.prototype.resume = Consola.prototype.resumeLogs;
function createConsola(options = {}) {
  return new Consola(options);
}

// ../../../node_modules/.pnpm/consola@3.4.0/node_modules/consola/dist/shared/consola.Cs5FdtHD.mjs
init_define_ENV_DEFINED_IN_BUILD_STEP();
import { formatWithOptions } from "node:util";
import { sep } from "node:path";
function parseStack(stack) {
  const cwd = process.cwd() + sep;
  const lines = stack.split("\n").splice(1).map((l2) => l2.trim().replace("file://", "").replace(cwd, ""));
  return lines;
}
function writeStream(data, stream) {
  const write = stream.__write || stream.write;
  return write.call(stream, data);
}
var bracket = (x2) => x2 ? `[${x2}]` : "";
var BasicReporter = class {
  formatStack(stack, opts) {
    const indent = "  ".repeat(((opts == null ? void 0 : opts.errorLevel) || 0) + 1);
    return indent + parseStack(stack).join(`
${indent}`);
  }
  formatError(err, opts) {
    const message = err.message ?? formatWithOptions(opts, err);
    const stack = err.stack ? this.formatStack(err.stack, opts) : "";
    const level = (opts == null ? void 0 : opts.errorLevel) || 0;
    const causedPrefix = level > 0 ? `${"  ".repeat(level)}[cause]: ` : "";
    const causedError = err.cause ? "\n\n" + this.formatError(err.cause, { ...opts, errorLevel: level + 1 }) : "";
    return causedPrefix + message + "\n" + stack + causedError;
  }
  formatArgs(args, opts) {
    const _args = args.map((arg) => {
      if (arg && typeof arg.stack === "string") {
        return this.formatError(arg, opts);
      }
      return arg;
    });
    return formatWithOptions(opts, ..._args);
  }
  formatDate(date, opts) {
    return opts.date ? date.toLocaleTimeString() : "";
  }
  filterAndJoin(arr) {
    return arr.filter(Boolean).join(" ");
  }
  formatLogObj(logObj, opts) {
    const message = this.formatArgs(logObj.args, opts);
    if (logObj.type === "box") {
      return "\n" + [
        bracket(logObj.tag),
        logObj.title && logObj.title,
        ...message.split("\n")
      ].filter(Boolean).map((l2) => " > " + l2).join("\n") + "\n";
    }
    return this.filterAndJoin([
      bracket(logObj.type),
      bracket(logObj.tag),
      message
    ]);
  }
  log(logObj, ctx) {
    const line = this.formatLogObj(logObj, {
      columns: ctx.options.stdout.columns || 0,
      ...ctx.options.formatOptions
    });
    return writeStream(
      line + "\n",
      logObj.level < 2 ? ctx.options.stderr || process.stderr : ctx.options.stdout || process.stdout
    );
  }
};

// ../../../node_modules/.pnpm/consola@3.4.0/node_modules/consola/dist/index.mjs
import p$1 from "node:process";

// ../../../node_modules/.pnpm/consola@3.4.0/node_modules/consola/dist/shared/consola.lX6kr4n8.mjs
init_define_ENV_DEFINED_IN_BUILD_STEP();
import * as tty from "node:tty";
var {
  env = {},
  argv = [],
  platform = ""
} = typeof process === "undefined" ? {} : process;
var isDisabled = "NO_COLOR" in env || argv.includes("--no-color");
var isForced = "FORCE_COLOR" in env || argv.includes("--color");
var isWindows = platform === "win32";
var isDumbTerminal = env.TERM === "dumb";
var isCompatibleTerminal = tty && tty.isatty && tty.isatty(1) && env.TERM && !isDumbTerminal;
var isCI = "CI" in env && ("GITHUB_ACTIONS" in env || "GITLAB_CI" in env || "CIRCLECI" in env);
var isColorSupported = !isDisabled && (isForced || isWindows && !isDumbTerminal || isCompatibleTerminal || isCI);
function replaceClose(index, string, close, replace, head = string.slice(0, Math.max(0, index)) + replace, tail = string.slice(Math.max(0, index + close.length)), next = tail.indexOf(close)) {
  return head + (next < 0 ? tail : replaceClose(next, tail, close, replace));
}
function clearBleed(index, string, open, close, replace) {
  return index < 0 ? open + string + close : open + replaceClose(index, string, close, replace) + close;
}
function filterEmpty(open, close, replace = open, at = open.length + 1) {
  return (string) => string || !(string === "" || string === void 0) ? clearBleed(
    ("" + string).indexOf(close, at),
    string,
    open,
    close,
    replace
  ) : "";
}
function init(open, close, replace) {
  return filterEmpty(`\x1B[${open}m`, `\x1B[${close}m`, replace);
}
var colorDefs = {
  reset: init(0, 0),
  bold: init(1, 22, "\x1B[22m\x1B[1m"),
  dim: init(2, 22, "\x1B[22m\x1B[2m"),
  italic: init(3, 23),
  underline: init(4, 24),
  inverse: init(7, 27),
  hidden: init(8, 28),
  strikethrough: init(9, 29),
  black: init(30, 39),
  red: init(31, 39),
  green: init(32, 39),
  yellow: init(33, 39),
  blue: init(34, 39),
  magenta: init(35, 39),
  cyan: init(36, 39),
  white: init(37, 39),
  gray: init(90, 39),
  bgBlack: init(40, 49),
  bgRed: init(41, 49),
  bgGreen: init(42, 49),
  bgYellow: init(43, 49),
  bgBlue: init(44, 49),
  bgMagenta: init(45, 49),
  bgCyan: init(46, 49),
  bgWhite: init(47, 49),
  blackBright: init(90, 39),
  redBright: init(91, 39),
  greenBright: init(92, 39),
  yellowBright: init(93, 39),
  blueBright: init(94, 39),
  magentaBright: init(95, 39),
  cyanBright: init(96, 39),
  whiteBright: init(97, 39),
  bgBlackBright: init(100, 49),
  bgRedBright: init(101, 49),
  bgGreenBright: init(102, 49),
  bgYellowBright: init(103, 49),
  bgBlueBright: init(104, 49),
  bgMagentaBright: init(105, 49),
  bgCyanBright: init(106, 49),
  bgWhiteBright: init(107, 49)
};
function createColors(useColor = isColorSupported) {
  return useColor ? colorDefs : Object.fromEntries(Object.keys(colorDefs).map((key) => [key, String]));
}
var colors = createColors();
function getColor(color, fallback = "reset") {
  return colors[color] || colors[fallback];
}
var ansiRegex = [
  String.raw`[\u001B\u009B][[\]()#;?]*(?:(?:(?:(?:;[-a-zA-Z\d\/#&.:=?%@~_]+)*|[a-zA-Z\d]+(?:;[-a-zA-Z\d\/#&.:=?%@~_]*)*)?\u0007)`,
  String.raw`(?:(?:\d{1,4}(?:;\d{0,4})*)?[\dA-PR-TZcf-nq-uy=><~]))`
].join("|");
function stripAnsi(text) {
  return text.replace(new RegExp(ansiRegex, "g"), "");
}
var boxStylePresets = {
  solid: {
    tl: "\u250C",
    tr: "\u2510",
    bl: "\u2514",
    br: "\u2518",
    h: "\u2500",
    v: "\u2502"
  },
  double: {
    tl: "\u2554",
    tr: "\u2557",
    bl: "\u255A",
    br: "\u255D",
    h: "\u2550",
    v: "\u2551"
  },
  doubleSingle: {
    tl: "\u2553",
    tr: "\u2556",
    bl: "\u2559",
    br: "\u255C",
    h: "\u2500",
    v: "\u2551"
  },
  doubleSingleRounded: {
    tl: "\u256D",
    tr: "\u256E",
    bl: "\u2570",
    br: "\u256F",
    h: "\u2500",
    v: "\u2551"
  },
  singleThick: {
    tl: "\u250F",
    tr: "\u2513",
    bl: "\u2517",
    br: "\u251B",
    h: "\u2501",
    v: "\u2503"
  },
  singleDouble: {
    tl: "\u2552",
    tr: "\u2555",
    bl: "\u2558",
    br: "\u255B",
    h: "\u2550",
    v: "\u2502"
  },
  singleDoubleRounded: {
    tl: "\u256D",
    tr: "\u256E",
    bl: "\u2570",
    br: "\u256F",
    h: "\u2550",
    v: "\u2502"
  },
  rounded: {
    tl: "\u256D",
    tr: "\u256E",
    bl: "\u2570",
    br: "\u256F",
    h: "\u2500",
    v: "\u2502"
  }
};
var defaultStyle = {
  borderColor: "white",
  borderStyle: "rounded",
  valign: "center",
  padding: 2,
  marginLeft: 1,
  marginTop: 1,
  marginBottom: 1
};
function box(text, _opts = {}) {
  const opts = {
    ..._opts,
    style: {
      ...defaultStyle,
      ..._opts.style
    }
  };
  const textLines = text.split("\n");
  const boxLines = [];
  const _color = getColor(opts.style.borderColor);
  const borderStyle = {
    ...typeof opts.style.borderStyle === "string" ? boxStylePresets[opts.style.borderStyle] || boxStylePresets.solid : opts.style.borderStyle
  };
  if (_color) {
    for (const key in borderStyle) {
      borderStyle[key] = _color(
        borderStyle[key]
      );
    }
  }
  const paddingOffset = opts.style.padding % 2 === 0 ? opts.style.padding : opts.style.padding + 1;
  const height = textLines.length + paddingOffset;
  const width = Math.max(...textLines.map((line) => stripAnsi(line).length)) + paddingOffset;
  const widthOffset = width + paddingOffset;
  const leftSpace = opts.style.marginLeft > 0 ? " ".repeat(opts.style.marginLeft) : "";
  if (opts.style.marginTop > 0) {
    boxLines.push("".repeat(opts.style.marginTop));
  }
  if (opts.title) {
    const title = _color ? _color(opts.title) : opts.title;
    const left = borderStyle.h.repeat(
      Math.floor((width - stripAnsi(opts.title).length) / 2)
    );
    const right = borderStyle.h.repeat(
      width - stripAnsi(opts.title).length - stripAnsi(left).length + paddingOffset
    );
    boxLines.push(
      `${leftSpace}${borderStyle.tl}${left}${title}${right}${borderStyle.tr}`
    );
  } else {
    boxLines.push(
      `${leftSpace}${borderStyle.tl}${borderStyle.h.repeat(widthOffset)}${borderStyle.tr}`
    );
  }
  const valignOffset = opts.style.valign === "center" ? Math.floor((height - textLines.length) / 2) : opts.style.valign === "top" ? height - textLines.length - paddingOffset : height - textLines.length;
  for (let i2 = 0; i2 < height; i2++) {
    if (i2 < valignOffset || i2 >= valignOffset + textLines.length) {
      boxLines.push(
        `${leftSpace}${borderStyle.v}${" ".repeat(widthOffset)}${borderStyle.v}`
      );
    } else {
      const line = textLines[i2 - valignOffset];
      const left = " ".repeat(paddingOffset);
      const right = " ".repeat(width - stripAnsi(line).length);
      boxLines.push(
        `${leftSpace}${borderStyle.v}${left}${line}${right}${borderStyle.v}`
      );
    }
  }
  boxLines.push(
    `${leftSpace}${borderStyle.bl}${borderStyle.h.repeat(widthOffset)}${borderStyle.br}`
  );
  if (opts.style.marginBottom > 0) {
    boxLines.push("".repeat(opts.style.marginBottom));
  }
  return boxLines.join("\n");
}

// ../../../node_modules/.pnpm/consola@3.4.0/node_modules/consola/dist/index.mjs
var r2 = /* @__PURE__ */ Object.create(null);
var i = (e2) => {
  var _a8, _b5;
  return ((_a8 = globalThis.process) == null ? void 0 : _a8.env) || import.meta.env || ((_b5 = globalThis.Deno) == null ? void 0 : _b5.env.toObject()) || globalThis.__env__ || (e2 ? r2 : globalThis);
};
var s$1 = new Proxy(r2, { get(e2, o) {
  return i()[o] ?? r2[o];
}, has(e2, o) {
  const E2 = i();
  return o in E2 || o in r2;
}, set(e2, o, E2) {
  const b = i(true);
  return b[o] = E2, true;
}, deleteProperty(e2, o) {
  if (!o)
    return false;
  const E2 = i(true);
  return delete E2[o], true;
}, ownKeys() {
  const e2 = i(true);
  return Object.keys(e2);
} });
var t = typeof process < "u" && process.env && process.env.NODE_ENV || "";
var B2 = [["APPVEYOR"], ["AWS_AMPLIFY", "AWS_APP_ID", { ci: true }], ["AZURE_PIPELINES", "SYSTEM_TEAMFOUNDATIONCOLLECTIONURI"], ["AZURE_STATIC", "INPUT_AZURE_STATIC_WEB_APPS_API_TOKEN"], ["APPCIRCLE", "AC_APPCIRCLE"], ["BAMBOO", "bamboo_planKey"], ["BITBUCKET", "BITBUCKET_COMMIT"], ["BITRISE", "BITRISE_IO"], ["BUDDY", "BUDDY_WORKSPACE_ID"], ["BUILDKITE"], ["CIRCLE", "CIRCLECI"], ["CIRRUS", "CIRRUS_CI"], ["CLOUDFLARE_PAGES", "CF_PAGES", { ci: true }], ["CODEBUILD", "CODEBUILD_BUILD_ARN"], ["CODEFRESH", "CF_BUILD_ID"], ["DRONE"], ["DRONE", "DRONE_BUILD_EVENT"], ["DSARI"], ["GITHUB_ACTIONS"], ["GITLAB", "GITLAB_CI"], ["GITLAB", "CI_MERGE_REQUEST_ID"], ["GOCD", "GO_PIPELINE_LABEL"], ["LAYERCI"], ["HUDSON", "HUDSON_URL"], ["JENKINS", "JENKINS_URL"], ["MAGNUM"], ["NETLIFY"], ["NETLIFY", "NETLIFY_LOCAL", { ci: false }], ["NEVERCODE"], ["RENDER"], ["SAIL", "SAILCI"], ["SEMAPHORE"], ["SCREWDRIVER"], ["SHIPPABLE"], ["SOLANO", "TDDIUM"], ["STRIDER"], ["TEAMCITY", "TEAMCITY_VERSION"], ["TRAVIS"], ["VERCEL", "NOW_BUILDER"], ["VERCEL", "VERCEL", { ci: false }], ["VERCEL", "VERCEL_ENV", { ci: false }], ["APPCENTER", "APPCENTER_BUILD_ID"], ["CODESANDBOX", "CODESANDBOX_SSE", { ci: false }], ["STACKBLITZ"], ["STORMKIT"], ["CLEAVR"], ["ZEABUR"], ["CODESPHERE", "CODESPHERE_APP_ID", { ci: true }], ["RAILWAY", "RAILWAY_PROJECT_ID"], ["RAILWAY", "RAILWAY_SERVICE_ID"], ["DENO-DEPLOY", "DENO_DEPLOYMENT_ID"], ["FIREBASE_APP_HOSTING", "FIREBASE_APP_HOSTING", { ci: true }]];
function p2() {
  var _a8, _b5, _c, _d, _e, _f;
  if ((_a8 = globalThis.process) == null ? void 0 : _a8.env)
    for (const e2 of B2) {
      const o = e2[1] || e2[0];
      if ((_b5 = globalThis.process) == null ? void 0 : _b5.env[o])
        return { name: e2[0].toLowerCase(), ...e2[2] };
    }
  return ((_d = (_c = globalThis.process) == null ? void 0 : _c.env) == null ? void 0 : _d.SHELL) === "/bin/jsh" && ((_f = (_e = globalThis.process) == null ? void 0 : _e.versions) == null ? void 0 : _f.webcontainer) ? { name: "stackblitz", ci: false } : { name: "", ci: false };
}
var l = p2();
l.name;
function n(e2) {
  return e2 ? e2 !== "false" : false;
}
var _a;
var I2 = ((_a = globalThis.process) == null ? void 0 : _a.platform) || "";
var T2 = n(s$1.CI) || l.ci !== false;
var _a2, _b;
var R2 = n(((_a2 = globalThis.process) == null ? void 0 : _a2.stdout) && ((_b = globalThis.process) == null ? void 0 : _b.stdout.isTTY));
var U = n(s$1.DEBUG);
var A2 = t === "test" || n(s$1.TEST);
n(s$1.MINIMAL) || T2 || A2 || !R2;
var _2 = /^win/i.test(I2);
!n(s$1.NO_COLOR) && (n(s$1.FORCE_COLOR) || (R2 || _2) && s$1.TERM !== "dumb" || T2);
var _a3, _b2;
var C = (((_b2 = (_a3 = globalThis.process) == null ? void 0 : _a3.versions) == null ? void 0 : _b2.node) || "").replace(/^v/, "") || null;
Number(C == null ? void 0 : C.split(".")[0]) || null;
var y2 = globalThis.process || /* @__PURE__ */ Object.create(null);
var c2 = { versions: {} };
new Proxy(y2, { get(e2, o) {
  if (o === "env")
    return s$1;
  if (o in e2)
    return e2[o];
  if (o in c2)
    return c2[o];
} });
var _a4, _b3;
var L2 = ((_b3 = (_a4 = globalThis.process) == null ? void 0 : _a4.release) == null ? void 0 : _b3.name) === "node";
var _a5, _b4;
var a2 = !!globalThis.Bun || !!((_b4 = (_a5 = globalThis.process) == null ? void 0 : _a5.versions) == null ? void 0 : _b4.bun);
var D = !!globalThis.Deno;
var O2 = !!globalThis.fastly;
var S2 = !!globalThis.Netlify;
var N2 = !!globalThis.EdgeRuntime;
var _a6;
var P2 = ((_a6 = globalThis.navigator) == null ? void 0 : _a6.userAgent) === "Cloudflare-Workers";
var F = [[S2, "netlify"], [N2, "edge-light"], [P2, "workerd"], [O2, "fastly"], [D, "deno"], [a2, "bun"], [L2, "node"]];
function G2() {
  const e2 = F.find((o) => o[0]);
  if (e2)
    return { name: e2[1] };
}
var u2 = G2();
(u2 == null ? void 0 : u2.name) || "";
function ansiRegex2({ onlyFirst = false } = {}) {
  const ST = "(?:\\u0007|\\u001B\\u005C|\\u009C)";
  const pattern = [
    `[\\u001B\\u009B][[\\]()#;?]*(?:(?:(?:(?:;[-a-zA-Z\\d\\/#&.:=?%@~_]+)*|[a-zA-Z\\d]+(?:;[-a-zA-Z\\d\\/#&.:=?%@~_]*)*)?${ST})`,
    "(?:(?:\\d{1,4}(?:;\\d{0,4})*)?[\\dA-PR-TZcf-nq-uy=><~]))"
  ].join("|");
  return new RegExp(pattern, onlyFirst ? void 0 : "g");
}
var regex = ansiRegex2();
function stripAnsi2(string) {
  if (typeof string !== "string") {
    throw new TypeError(`Expected a \`string\`, got \`${typeof string}\``);
  }
  return string.replace(regex, "");
}
function isAmbiguous(x2) {
  return x2 === 161 || x2 === 164 || x2 === 167 || x2 === 168 || x2 === 170 || x2 === 173 || x2 === 174 || x2 >= 176 && x2 <= 180 || x2 >= 182 && x2 <= 186 || x2 >= 188 && x2 <= 191 || x2 === 198 || x2 === 208 || x2 === 215 || x2 === 216 || x2 >= 222 && x2 <= 225 || x2 === 230 || x2 >= 232 && x2 <= 234 || x2 === 236 || x2 === 237 || x2 === 240 || x2 === 242 || x2 === 243 || x2 >= 247 && x2 <= 250 || x2 === 252 || x2 === 254 || x2 === 257 || x2 === 273 || x2 === 275 || x2 === 283 || x2 === 294 || x2 === 295 || x2 === 299 || x2 >= 305 && x2 <= 307 || x2 === 312 || x2 >= 319 && x2 <= 322 || x2 === 324 || x2 >= 328 && x2 <= 331 || x2 === 333 || x2 === 338 || x2 === 339 || x2 === 358 || x2 === 359 || x2 === 363 || x2 === 462 || x2 === 464 || x2 === 466 || x2 === 468 || x2 === 470 || x2 === 472 || x2 === 474 || x2 === 476 || x2 === 593 || x2 === 609 || x2 === 708 || x2 === 711 || x2 >= 713 && x2 <= 715 || x2 === 717 || x2 === 720 || x2 >= 728 && x2 <= 731 || x2 === 733 || x2 === 735 || x2 >= 768 && x2 <= 879 || x2 >= 913 && x2 <= 929 || x2 >= 931 && x2 <= 937 || x2 >= 945 && x2 <= 961 || x2 >= 963 && x2 <= 969 || x2 === 1025 || x2 >= 1040 && x2 <= 1103 || x2 === 1105 || x2 === 8208 || x2 >= 8211 && x2 <= 8214 || x2 === 8216 || x2 === 8217 || x2 === 8220 || x2 === 8221 || x2 >= 8224 && x2 <= 8226 || x2 >= 8228 && x2 <= 8231 || x2 === 8240 || x2 === 8242 || x2 === 8243 || x2 === 8245 || x2 === 8251 || x2 === 8254 || x2 === 8308 || x2 === 8319 || x2 >= 8321 && x2 <= 8324 || x2 === 8364 || x2 === 8451 || x2 === 8453 || x2 === 8457 || x2 === 8467 || x2 === 8470 || x2 === 8481 || x2 === 8482 || x2 === 8486 || x2 === 8491 || x2 === 8531 || x2 === 8532 || x2 >= 8539 && x2 <= 8542 || x2 >= 8544 && x2 <= 8555 || x2 >= 8560 && x2 <= 8569 || x2 === 8585 || x2 >= 8592 && x2 <= 8601 || x2 === 8632 || x2 === 8633 || x2 === 8658 || x2 === 8660 || x2 === 8679 || x2 === 8704 || x2 === 8706 || x2 === 8707 || x2 === 8711 || x2 === 8712 || x2 === 8715 || x2 === 8719 || x2 === 8721 || x2 === 8725 || x2 === 8730 || x2 >= 8733 && x2 <= 8736 || x2 === 8739 || x2 === 8741 || x2 >= 8743 && x2 <= 8748 || x2 === 8750 || x2 >= 8756 && x2 <= 8759 || x2 === 8764 || x2 === 8765 || x2 === 8776 || x2 === 8780 || x2 === 8786 || x2 === 8800 || x2 === 8801 || x2 >= 8804 && x2 <= 8807 || x2 === 8810 || x2 === 8811 || x2 === 8814 || x2 === 8815 || x2 === 8834 || x2 === 8835 || x2 === 8838 || x2 === 8839 || x2 === 8853 || x2 === 8857 || x2 === 8869 || x2 === 8895 || x2 === 8978 || x2 >= 9312 && x2 <= 9449 || x2 >= 9451 && x2 <= 9547 || x2 >= 9552 && x2 <= 9587 || x2 >= 9600 && x2 <= 9615 || x2 >= 9618 && x2 <= 9621 || x2 === 9632 || x2 === 9633 || x2 >= 9635 && x2 <= 9641 || x2 === 9650 || x2 === 9651 || x2 === 9654 || x2 === 9655 || x2 === 9660 || x2 === 9661 || x2 === 9664 || x2 === 9665 || x2 >= 9670 && x2 <= 9672 || x2 === 9675 || x2 >= 9678 && x2 <= 9681 || x2 >= 9698 && x2 <= 9701 || x2 === 9711 || x2 === 9733 || x2 === 9734 || x2 === 9737 || x2 === 9742 || x2 === 9743 || x2 === 9756 || x2 === 9758 || x2 === 9792 || x2 === 9794 || x2 === 9824 || x2 === 9825 || x2 >= 9827 && x2 <= 9829 || x2 >= 9831 && x2 <= 9834 || x2 === 9836 || x2 === 9837 || x2 === 9839 || x2 === 9886 || x2 === 9887 || x2 === 9919 || x2 >= 9926 && x2 <= 9933 || x2 >= 9935 && x2 <= 9939 || x2 >= 9941 && x2 <= 9953 || x2 === 9955 || x2 === 9960 || x2 === 9961 || x2 >= 9963 && x2 <= 9969 || x2 === 9972 || x2 >= 9974 && x2 <= 9977 || x2 === 9979 || x2 === 9980 || x2 === 9982 || x2 === 9983 || x2 === 10045 || x2 >= 10102 && x2 <= 10111 || x2 >= 11094 && x2 <= 11097 || x2 >= 12872 && x2 <= 12879 || x2 >= 57344 && x2 <= 63743 || x2 >= 65024 && x2 <= 65039 || x2 === 65533 || x2 >= 127232 && x2 <= 127242 || x2 >= 127248 && x2 <= 127277 || x2 >= 127280 && x2 <= 127337 || x2 >= 127344 && x2 <= 127373 || x2 === 127375 || x2 === 127376 || x2 >= 127387 && x2 <= 127404 || x2 >= 917760 && x2 <= 917999 || x2 >= 983040 && x2 <= 1048573 || x2 >= 1048576 && x2 <= 1114109;
}
function isFullWidth(x2) {
  return x2 === 12288 || x2 >= 65281 && x2 <= 65376 || x2 >= 65504 && x2 <= 65510;
}
function isWide(x2) {
  return x2 >= 4352 && x2 <= 4447 || x2 === 8986 || x2 === 8987 || x2 === 9001 || x2 === 9002 || x2 >= 9193 && x2 <= 9196 || x2 === 9200 || x2 === 9203 || x2 === 9725 || x2 === 9726 || x2 === 9748 || x2 === 9749 || x2 >= 9776 && x2 <= 9783 || x2 >= 9800 && x2 <= 9811 || x2 === 9855 || x2 >= 9866 && x2 <= 9871 || x2 === 9875 || x2 === 9889 || x2 === 9898 || x2 === 9899 || x2 === 9917 || x2 === 9918 || x2 === 9924 || x2 === 9925 || x2 === 9934 || x2 === 9940 || x2 === 9962 || x2 === 9970 || x2 === 9971 || x2 === 9973 || x2 === 9978 || x2 === 9981 || x2 === 9989 || x2 === 9994 || x2 === 9995 || x2 === 10024 || x2 === 10060 || x2 === 10062 || x2 >= 10067 && x2 <= 10069 || x2 === 10071 || x2 >= 10133 && x2 <= 10135 || x2 === 10160 || x2 === 10175 || x2 === 11035 || x2 === 11036 || x2 === 11088 || x2 === 11093 || x2 >= 11904 && x2 <= 11929 || x2 >= 11931 && x2 <= 12019 || x2 >= 12032 && x2 <= 12245 || x2 >= 12272 && x2 <= 12287 || x2 >= 12289 && x2 <= 12350 || x2 >= 12353 && x2 <= 12438 || x2 >= 12441 && x2 <= 12543 || x2 >= 12549 && x2 <= 12591 || x2 >= 12593 && x2 <= 12686 || x2 >= 12688 && x2 <= 12773 || x2 >= 12783 && x2 <= 12830 || x2 >= 12832 && x2 <= 12871 || x2 >= 12880 && x2 <= 42124 || x2 >= 42128 && x2 <= 42182 || x2 >= 43360 && x2 <= 43388 || x2 >= 44032 && x2 <= 55203 || x2 >= 63744 && x2 <= 64255 || x2 >= 65040 && x2 <= 65049 || x2 >= 65072 && x2 <= 65106 || x2 >= 65108 && x2 <= 65126 || x2 >= 65128 && x2 <= 65131 || x2 >= 94176 && x2 <= 94180 || x2 === 94192 || x2 === 94193 || x2 >= 94208 && x2 <= 100343 || x2 >= 100352 && x2 <= 101589 || x2 >= 101631 && x2 <= 101640 || x2 >= 110576 && x2 <= 110579 || x2 >= 110581 && x2 <= 110587 || x2 === 110589 || x2 === 110590 || x2 >= 110592 && x2 <= 110882 || x2 === 110898 || x2 >= 110928 && x2 <= 110930 || x2 === 110933 || x2 >= 110948 && x2 <= 110951 || x2 >= 110960 && x2 <= 111355 || x2 >= 119552 && x2 <= 119638 || x2 >= 119648 && x2 <= 119670 || x2 === 126980 || x2 === 127183 || x2 === 127374 || x2 >= 127377 && x2 <= 127386 || x2 >= 127488 && x2 <= 127490 || x2 >= 127504 && x2 <= 127547 || x2 >= 127552 && x2 <= 127560 || x2 === 127568 || x2 === 127569 || x2 >= 127584 && x2 <= 127589 || x2 >= 127744 && x2 <= 127776 || x2 >= 127789 && x2 <= 127797 || x2 >= 127799 && x2 <= 127868 || x2 >= 127870 && x2 <= 127891 || x2 >= 127904 && x2 <= 127946 || x2 >= 127951 && x2 <= 127955 || x2 >= 127968 && x2 <= 127984 || x2 === 127988 || x2 >= 127992 && x2 <= 128062 || x2 === 128064 || x2 >= 128066 && x2 <= 128252 || x2 >= 128255 && x2 <= 128317 || x2 >= 128331 && x2 <= 128334 || x2 >= 128336 && x2 <= 128359 || x2 === 128378 || x2 === 128405 || x2 === 128406 || x2 === 128420 || x2 >= 128507 && x2 <= 128591 || x2 >= 128640 && x2 <= 128709 || x2 === 128716 || x2 >= 128720 && x2 <= 128722 || x2 >= 128725 && x2 <= 128727 || x2 >= 128732 && x2 <= 128735 || x2 === 128747 || x2 === 128748 || x2 >= 128756 && x2 <= 128764 || x2 >= 128992 && x2 <= 129003 || x2 === 129008 || x2 >= 129292 && x2 <= 129338 || x2 >= 129340 && x2 <= 129349 || x2 >= 129351 && x2 <= 129535 || x2 >= 129648 && x2 <= 129660 || x2 >= 129664 && x2 <= 129673 || x2 >= 129679 && x2 <= 129734 || x2 >= 129742 && x2 <= 129756 || x2 >= 129759 && x2 <= 129769 || x2 >= 129776 && x2 <= 129784 || x2 >= 131072 && x2 <= 196605 || x2 >= 196608 && x2 <= 262141;
}
function validate2(codePoint) {
  if (!Number.isSafeInteger(codePoint)) {
    throw new TypeError(`Expected a code point, got \`${typeof codePoint}\`.`);
  }
}
function eastAsianWidth(codePoint, { ambiguousAsWide = false } = {}) {
  validate2(codePoint);
  if (isFullWidth(codePoint) || isWide(codePoint) || ambiguousAsWide && isAmbiguous(codePoint)) {
    return 2;
  }
  return 1;
}
var emojiRegex = () => {
  return /[#*0-9]\uFE0F?\u20E3|[\xA9\xAE\u203C\u2049\u2122\u2139\u2194-\u2199\u21A9\u21AA\u231A\u231B\u2328\u23CF\u23ED-\u23EF\u23F1\u23F2\u23F8-\u23FA\u24C2\u25AA\u25AB\u25B6\u25C0\u25FB\u25FC\u25FE\u2600-\u2604\u260E\u2611\u2614\u2615\u2618\u2620\u2622\u2623\u2626\u262A\u262E\u262F\u2638-\u263A\u2640\u2642\u2648-\u2653\u265F\u2660\u2663\u2665\u2666\u2668\u267B\u267E\u267F\u2692\u2694-\u2697\u2699\u269B\u269C\u26A0\u26A7\u26AA\u26B0\u26B1\u26BD\u26BE\u26C4\u26C8\u26CF\u26D1\u26E9\u26F0-\u26F5\u26F7\u26F8\u26FA\u2702\u2708\u2709\u270F\u2712\u2714\u2716\u271D\u2721\u2733\u2734\u2744\u2747\u2757\u2763\u27A1\u2934\u2935\u2B05-\u2B07\u2B1B\u2B1C\u2B55\u3030\u303D\u3297\u3299]\uFE0F?|[\u261D\u270C\u270D](?:\uD83C[\uDFFB-\uDFFF]|\uFE0F)?|[\u270A\u270B](?:\uD83C[\uDFFB-\uDFFF])?|[\u23E9-\u23EC\u23F0\u23F3\u25FD\u2693\u26A1\u26AB\u26C5\u26CE\u26D4\u26EA\u26FD\u2705\u2728\u274C\u274E\u2753-\u2755\u2795-\u2797\u27B0\u27BF\u2B50]|\u26D3\uFE0F?(?:\u200D\uD83D\uDCA5)?|\u26F9(?:\uD83C[\uDFFB-\uDFFF]|\uFE0F)?(?:\u200D[\u2640\u2642]\uFE0F?)?|\u2764\uFE0F?(?:\u200D(?:\uD83D\uDD25|\uD83E\uDE79))?|\uD83C(?:[\uDC04\uDD70\uDD71\uDD7E\uDD7F\uDE02\uDE37\uDF21\uDF24-\uDF2C\uDF36\uDF7D\uDF96\uDF97\uDF99-\uDF9B\uDF9E\uDF9F\uDFCD\uDFCE\uDFD4-\uDFDF\uDFF5\uDFF7]\uFE0F?|[\uDF85\uDFC2\uDFC7](?:\uD83C[\uDFFB-\uDFFF])?|[\uDFC4\uDFCA](?:\uD83C[\uDFFB-\uDFFF])?(?:\u200D[\u2640\u2642]\uFE0F?)?|[\uDFCB\uDFCC](?:\uD83C[\uDFFB-\uDFFF]|\uFE0F)?(?:\u200D[\u2640\u2642]\uFE0F?)?|[\uDCCF\uDD8E\uDD91-\uDD9A\uDE01\uDE1A\uDE2F\uDE32-\uDE36\uDE38-\uDE3A\uDE50\uDE51\uDF00-\uDF20\uDF2D-\uDF35\uDF37-\uDF43\uDF45-\uDF4A\uDF4C-\uDF7C\uDF7E-\uDF84\uDF86-\uDF93\uDFA0-\uDFC1\uDFC5\uDFC6\uDFC8\uDFC9\uDFCF-\uDFD3\uDFE0-\uDFF0\uDFF8-\uDFFF]|\uDDE6\uD83C[\uDDE8-\uDDEC\uDDEE\uDDF1\uDDF2\uDDF4\uDDF6-\uDDFA\uDDFC\uDDFD\uDDFF]|\uDDE7\uD83C[\uDDE6\uDDE7\uDDE9-\uDDEF\uDDF1-\uDDF4\uDDF6-\uDDF9\uDDFB\uDDFC\uDDFE\uDDFF]|\uDDE8\uD83C[\uDDE6\uDDE8\uDDE9\uDDEB-\uDDEE\uDDF0-\uDDF7\uDDFA-\uDDFF]|\uDDE9\uD83C[\uDDEA\uDDEC\uDDEF\uDDF0\uDDF2\uDDF4\uDDFF]|\uDDEA\uD83C[\uDDE6\uDDE8\uDDEA\uDDEC\uDDED\uDDF7-\uDDFA]|\uDDEB\uD83C[\uDDEE-\uDDF0\uDDF2\uDDF4\uDDF7]|\uDDEC\uD83C[\uDDE6\uDDE7\uDDE9-\uDDEE\uDDF1-\uDDF3\uDDF5-\uDDFA\uDDFC\uDDFE]|\uDDED\uD83C[\uDDF0\uDDF2\uDDF3\uDDF7\uDDF9\uDDFA]|\uDDEE\uD83C[\uDDE8-\uDDEA\uDDF1-\uDDF4\uDDF6-\uDDF9]|\uDDEF\uD83C[\uDDEA\uDDF2\uDDF4\uDDF5]|\uDDF0\uD83C[\uDDEA\uDDEC-\uDDEE\uDDF2\uDDF3\uDDF5\uDDF7\uDDFC\uDDFE\uDDFF]|\uDDF1\uD83C[\uDDE6-\uDDE8\uDDEE\uDDF0\uDDF7-\uDDFB\uDDFE]|\uDDF2\uD83C[\uDDE6\uDDE8-\uDDED\uDDF0-\uDDFF]|\uDDF3\uD83C[\uDDE6\uDDE8\uDDEA-\uDDEC\uDDEE\uDDF1\uDDF4\uDDF5\uDDF7\uDDFA\uDDFF]|\uDDF4\uD83C\uDDF2|\uDDF5\uD83C[\uDDE6\uDDEA-\uDDED\uDDF0-\uDDF3\uDDF7-\uDDF9\uDDFC\uDDFE]|\uDDF6\uD83C\uDDE6|\uDDF7\uD83C[\uDDEA\uDDF4\uDDF8\uDDFA\uDDFC]|\uDDF8\uD83C[\uDDE6-\uDDEA\uDDEC-\uDDF4\uDDF7-\uDDF9\uDDFB\uDDFD-\uDDFF]|\uDDF9\uD83C[\uDDE6\uDDE8\uDDE9\uDDEB-\uDDED\uDDEF-\uDDF4\uDDF7\uDDF9\uDDFB\uDDFC\uDDFF]|\uDDFA\uD83C[\uDDE6\uDDEC\uDDF2\uDDF3\uDDF8\uDDFE\uDDFF]|\uDDFB\uD83C[\uDDE6\uDDE8\uDDEA\uDDEC\uDDEE\uDDF3\uDDFA]|\uDDFC\uD83C[\uDDEB\uDDF8]|\uDDFD\uD83C\uDDF0|\uDDFE\uD83C[\uDDEA\uDDF9]|\uDDFF\uD83C[\uDDE6\uDDF2\uDDFC]|\uDF44(?:\u200D\uD83D\uDFEB)?|\uDF4B(?:\u200D\uD83D\uDFE9)?|\uDFC3(?:\uD83C[\uDFFB-\uDFFF])?(?:\u200D(?:[\u2640\u2642]\uFE0F?(?:\u200D\u27A1\uFE0F?)?|\u27A1\uFE0F?))?|\uDFF3\uFE0F?(?:\u200D(?:\u26A7\uFE0F?|\uD83C\uDF08))?|\uDFF4(?:\u200D\u2620\uFE0F?|\uDB40\uDC67\uDB40\uDC62\uDB40(?:\uDC65\uDB40\uDC6E\uDB40\uDC67|\uDC73\uDB40\uDC63\uDB40\uDC74|\uDC77\uDB40\uDC6C\uDB40\uDC73)\uDB40\uDC7F)?)|\uD83D(?:[\uDC3F\uDCFD\uDD49\uDD4A\uDD6F\uDD70\uDD73\uDD76-\uDD79\uDD87\uDD8A-\uDD8D\uDDA5\uDDA8\uDDB1\uDDB2\uDDBC\uDDC2-\uDDC4\uDDD1-\uDDD3\uDDDC-\uDDDE\uDDE1\uDDE3\uDDE8\uDDEF\uDDF3\uDDFA\uDECB\uDECD-\uDECF\uDEE0-\uDEE5\uDEE9\uDEF0\uDEF3]\uFE0F?|[\uDC42\uDC43\uDC46-\uDC50\uDC66\uDC67\uDC6B-\uDC6D\uDC72\uDC74-\uDC76\uDC78\uDC7C\uDC83\uDC85\uDC8F\uDC91\uDCAA\uDD7A\uDD95\uDD96\uDE4C\uDE4F\uDEC0\uDECC](?:\uD83C[\uDFFB-\uDFFF])?|[\uDC6E\uDC70\uDC71\uDC73\uDC77\uDC81\uDC82\uDC86\uDC87\uDE45-\uDE47\uDE4B\uDE4D\uDE4E\uDEA3\uDEB4\uDEB5](?:\uD83C[\uDFFB-\uDFFF])?(?:\u200D[\u2640\u2642]\uFE0F?)?|[\uDD74\uDD90](?:\uD83C[\uDFFB-\uDFFF]|\uFE0F)?|[\uDC00-\uDC07\uDC09-\uDC14\uDC16-\uDC25\uDC27-\uDC3A\uDC3C-\uDC3E\uDC40\uDC44\uDC45\uDC51-\uDC65\uDC6A\uDC79-\uDC7B\uDC7D-\uDC80\uDC84\uDC88-\uDC8E\uDC90\uDC92-\uDCA9\uDCAB-\uDCFC\uDCFF-\uDD3D\uDD4B-\uDD4E\uDD50-\uDD67\uDDA4\uDDFB-\uDE2D\uDE2F-\uDE34\uDE37-\uDE41\uDE43\uDE44\uDE48-\uDE4A\uDE80-\uDEA2\uDEA4-\uDEB3\uDEB7-\uDEBF\uDEC1-\uDEC5\uDED0-\uDED2\uDED5-\uDED7\uDEDC-\uDEDF\uDEEB\uDEEC\uDEF4-\uDEFC\uDFE0-\uDFEB\uDFF0]|\uDC08(?:\u200D\u2B1B)?|\uDC15(?:\u200D\uD83E\uDDBA)?|\uDC26(?:\u200D(?:\u2B1B|\uD83D\uDD25))?|\uDC3B(?:\u200D\u2744\uFE0F?)?|\uDC41\uFE0F?(?:\u200D\uD83D\uDDE8\uFE0F?)?|\uDC68(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D\uD83D(?:\uDC8B\u200D\uD83D)?\uDC68|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D(?:[\uDC68\uDC69]\u200D\uD83D(?:\uDC66(?:\u200D\uD83D\uDC66)?|\uDC67(?:\u200D\uD83D[\uDC66\uDC67])?)|[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uDC66(?:\u200D\uD83D\uDC66)?|\uDC67(?:\u200D\uD83D[\uDC66\uDC67])?)|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3]))|\uD83C(?:\uDFFB(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D\uD83D(?:\uDC8B\u200D\uD83D)?\uDC68\uD83C[\uDFFB-\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3]|\uDD1D\u200D\uD83D\uDC68\uD83C[\uDFFC-\uDFFF])))?|\uDFFC(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D\uD83D(?:\uDC8B\u200D\uD83D)?\uDC68\uD83C[\uDFFB-\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3]|\uDD1D\u200D\uD83D\uDC68\uD83C[\uDFFB\uDFFD-\uDFFF])))?|\uDFFD(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D\uD83D(?:\uDC8B\u200D\uD83D)?\uDC68\uD83C[\uDFFB-\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3]|\uDD1D\u200D\uD83D\uDC68\uD83C[\uDFFB\uDFFC\uDFFE\uDFFF])))?|\uDFFE(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D\uD83D(?:\uDC8B\u200D\uD83D)?\uDC68\uD83C[\uDFFB-\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3]|\uDD1D\u200D\uD83D\uDC68\uD83C[\uDFFB-\uDFFD\uDFFF])))?|\uDFFF(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D\uD83D(?:\uDC8B\u200D\uD83D)?\uDC68\uD83C[\uDFFB-\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3]|\uDD1D\u200D\uD83D\uDC68\uD83C[\uDFFB-\uDFFE])))?))?|\uDC69(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D\uD83D(?:\uDC8B\u200D\uD83D)?[\uDC68\uDC69]|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D(?:[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uDC66(?:\u200D\uD83D\uDC66)?|\uDC67(?:\u200D\uD83D[\uDC66\uDC67])?|\uDC69\u200D\uD83D(?:\uDC66(?:\u200D\uD83D\uDC66)?|\uDC67(?:\u200D\uD83D[\uDC66\uDC67])?))|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3]))|\uD83C(?:\uDFFB(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D\uD83D(?:[\uDC68\uDC69]|\uDC8B\u200D\uD83D[\uDC68\uDC69])\uD83C[\uDFFB-\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3]|\uDD1D\u200D\uD83D[\uDC68\uDC69]\uD83C[\uDFFC-\uDFFF])))?|\uDFFC(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D\uD83D(?:[\uDC68\uDC69]|\uDC8B\u200D\uD83D[\uDC68\uDC69])\uD83C[\uDFFB-\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3]|\uDD1D\u200D\uD83D[\uDC68\uDC69]\uD83C[\uDFFB\uDFFD-\uDFFF])))?|\uDFFD(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D\uD83D(?:[\uDC68\uDC69]|\uDC8B\u200D\uD83D[\uDC68\uDC69])\uD83C[\uDFFB-\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3]|\uDD1D\u200D\uD83D[\uDC68\uDC69]\uD83C[\uDFFB\uDFFC\uDFFE\uDFFF])))?|\uDFFE(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D\uD83D(?:[\uDC68\uDC69]|\uDC8B\u200D\uD83D[\uDC68\uDC69])\uD83C[\uDFFB-\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3]|\uDD1D\u200D\uD83D[\uDC68\uDC69]\uD83C[\uDFFB-\uDFFD\uDFFF])))?|\uDFFF(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D\uD83D(?:[\uDC68\uDC69]|\uDC8B\u200D\uD83D[\uDC68\uDC69])\uD83C[\uDFFB-\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3]|\uDD1D\u200D\uD83D[\uDC68\uDC69]\uD83C[\uDFFB-\uDFFE])))?))?|\uDC6F(?:\u200D[\u2640\u2642]\uFE0F?)?|\uDD75(?:\uD83C[\uDFFB-\uDFFF]|\uFE0F)?(?:\u200D[\u2640\u2642]\uFE0F?)?|\uDE2E(?:\u200D\uD83D\uDCA8)?|\uDE35(?:\u200D\uD83D\uDCAB)?|\uDE36(?:\u200D\uD83C\uDF2B\uFE0F?)?|\uDE42(?:\u200D[\u2194\u2195]\uFE0F?)?|\uDEB6(?:\uD83C[\uDFFB-\uDFFF])?(?:\u200D(?:[\u2640\u2642]\uFE0F?(?:\u200D\u27A1\uFE0F?)?|\u27A1\uFE0F?))?)|\uD83E(?:[\uDD0C\uDD0F\uDD18-\uDD1F\uDD30-\uDD34\uDD36\uDD77\uDDB5\uDDB6\uDDBB\uDDD2\uDDD3\uDDD5\uDEC3-\uDEC5\uDEF0\uDEF2-\uDEF8](?:\uD83C[\uDFFB-\uDFFF])?|[\uDD26\uDD35\uDD37-\uDD39\uDD3D\uDD3E\uDDB8\uDDB9\uDDCD\uDDCF\uDDD4\uDDD6-\uDDDD](?:\uD83C[\uDFFB-\uDFFF])?(?:\u200D[\u2640\u2642]\uFE0F?)?|[\uDDDE\uDDDF](?:\u200D[\u2640\u2642]\uFE0F?)?|[\uDD0D\uDD0E\uDD10-\uDD17\uDD20-\uDD25\uDD27-\uDD2F\uDD3A\uDD3F-\uDD45\uDD47-\uDD76\uDD78-\uDDB4\uDDB7\uDDBA\uDDBC-\uDDCC\uDDD0\uDDE0-\uDDFF\uDE70-\uDE7C\uDE80-\uDE89\uDE8F-\uDEC2\uDEC6\uDECE-\uDEDC\uDEDF-\uDEE9]|\uDD3C(?:\u200D[\u2640\u2642]\uFE0F?|\uD83C[\uDFFB-\uDFFF])?|\uDDCE(?:\uD83C[\uDFFB-\uDFFF])?(?:\u200D(?:[\u2640\u2642]\uFE0F?(?:\u200D\u27A1\uFE0F?)?|\u27A1\uFE0F?))?|\uDDD1(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\uD83C[\uDF3E\uDF73\uDF7C\uDF84\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3]|\uDD1D\u200D\uD83E\uDDD1|\uDDD1\u200D\uD83E\uDDD2(?:\u200D\uD83E\uDDD2)?|\uDDD2(?:\u200D\uD83E\uDDD2)?))|\uD83C(?:\uDFFB(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D(?:\uD83D\uDC8B\u200D)?\uD83E\uDDD1\uD83C[\uDFFC-\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF84\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3]|\uDD1D\u200D\uD83E\uDDD1\uD83C[\uDFFB-\uDFFF])))?|\uDFFC(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D(?:\uD83D\uDC8B\u200D)?\uD83E\uDDD1\uD83C[\uDFFB\uDFFD-\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF84\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3]|\uDD1D\u200D\uD83E\uDDD1\uD83C[\uDFFB-\uDFFF])))?|\uDFFD(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D(?:\uD83D\uDC8B\u200D)?\uD83E\uDDD1\uD83C[\uDFFB\uDFFC\uDFFE\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF84\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3]|\uDD1D\u200D\uD83E\uDDD1\uD83C[\uDFFB-\uDFFF])))?|\uDFFE(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D(?:\uD83D\uDC8B\u200D)?\uD83E\uDDD1\uD83C[\uDFFB-\uDFFD\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF84\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3]|\uDD1D\u200D\uD83E\uDDD1\uD83C[\uDFFB-\uDFFF])))?|\uDFFF(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D(?:\uD83D\uDC8B\u200D)?\uD83E\uDDD1\uD83C[\uDFFB-\uDFFE]|\uD83C[\uDF3E\uDF73\uDF7C\uDF84\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3]|\uDD1D\u200D\uD83E\uDDD1\uD83C[\uDFFB-\uDFFF])))?))?|\uDEF1(?:\uD83C(?:\uDFFB(?:\u200D\uD83E\uDEF2\uD83C[\uDFFC-\uDFFF])?|\uDFFC(?:\u200D\uD83E\uDEF2\uD83C[\uDFFB\uDFFD-\uDFFF])?|\uDFFD(?:\u200D\uD83E\uDEF2\uD83C[\uDFFB\uDFFC\uDFFE\uDFFF])?|\uDFFE(?:\u200D\uD83E\uDEF2\uD83C[\uDFFB-\uDFFD\uDFFF])?|\uDFFF(?:\u200D\uD83E\uDEF2\uD83C[\uDFFB-\uDFFE])?))?)/g;
};
var _a7;
var segmenter = ((_a7 = globalThis.Intl) == null ? void 0 : _a7.Segmenter) ? new Intl.Segmenter() : { segment: (str) => str.split("") };
var defaultIgnorableCodePointRegex = new RegExp("^\\p{Default_Ignorable_Code_Point}$", "u");
function stringWidth$1(string, options = {}) {
  if (typeof string !== "string" || string.length === 0) {
    return 0;
  }
  const {
    ambiguousIsNarrow = true,
    countAnsiEscapeCodes = false
  } = options;
  if (!countAnsiEscapeCodes) {
    string = stripAnsi2(string);
  }
  if (string.length === 0) {
    return 0;
  }
  let width = 0;
  const eastAsianWidthOptions = { ambiguousAsWide: !ambiguousIsNarrow };
  for (const { segment: character } of segmenter.segment(string)) {
    const codePoint = character.codePointAt(0);
    if (codePoint <= 31 || codePoint >= 127 && codePoint <= 159) {
      continue;
    }
    if (codePoint >= 8203 && codePoint <= 8207 || codePoint === 65279) {
      continue;
    }
    if (codePoint >= 768 && codePoint <= 879 || codePoint >= 6832 && codePoint <= 6911 || codePoint >= 7616 && codePoint <= 7679 || codePoint >= 8400 && codePoint <= 8447 || codePoint >= 65056 && codePoint <= 65071) {
      continue;
    }
    if (codePoint >= 55296 && codePoint <= 57343) {
      continue;
    }
    if (codePoint >= 65024 && codePoint <= 65039) {
      continue;
    }
    if (defaultIgnorableCodePointRegex.test(character)) {
      continue;
    }
    if (emojiRegex().test(character)) {
      width += 2;
      continue;
    }
    width += eastAsianWidth(codePoint, eastAsianWidthOptions);
  }
  return width;
}
function isUnicodeSupported() {
  const { env: env2 } = p$1;
  const { TERM, TERM_PROGRAM } = env2;
  if (p$1.platform !== "win32") {
    return TERM !== "linux";
  }
  return Boolean(env2.WT_SESSION) || Boolean(env2.TERMINUS_SUBLIME) || env2.ConEmuTask === "{cmd::Cmder}" || TERM_PROGRAM === "Terminus-Sublime" || TERM_PROGRAM === "vscode" || TERM === "xterm-256color" || TERM === "alacritty" || TERM === "rxvt-unicode" || TERM === "rxvt-unicode-256color" || env2.TERMINAL_EMULATOR === "JetBrains-JediTerm";
}
var TYPE_COLOR_MAP = {
  info: "cyan",
  fail: "red",
  success: "green",
  ready: "green",
  start: "magenta"
};
var LEVEL_COLOR_MAP = {
  0: "red",
  1: "yellow"
};
var unicode = isUnicodeSupported();
var s = (c3, fallback) => unicode ? c3 : fallback;
var TYPE_ICONS = {
  error: s("\u2716", "\xD7"),
  fatal: s("\u2716", "\xD7"),
  ready: s("\u2714", "\u221A"),
  warn: s("\u26A0", "\u203C"),
  info: s("\u2139", "i"),
  success: s("\u2714", "\u221A"),
  debug: s("\u2699", "D"),
  trace: s("\u2192", "\u2192"),
  fail: s("\u2716", "\xD7"),
  start: s("\u25D0", "o"),
  log: ""
};
function stringWidth(str) {
  const hasICU = typeof Intl === "object";
  if (!hasICU || !Intl.Segmenter) {
    return stripAnsi(str).length;
  }
  return stringWidth$1(str);
}
var FancyReporter = class extends BasicReporter {
  formatStack(stack, opts) {
    const indent = "  ".repeat(((opts == null ? void 0 : opts.errorLevel) || 0) + 1);
    return `
${indent}` + parseStack(stack).map(
      (line) => "  " + line.replace(/^at +/, (m2) => colors.gray(m2)).replace(/\((.+)\)/, (_3, m2) => `(${colors.cyan(m2)})`)
    ).join(`
${indent}`);
  }
  formatType(logObj, isBadge, opts) {
    const typeColor = TYPE_COLOR_MAP[logObj.type] || LEVEL_COLOR_MAP[logObj.level] || "gray";
    if (isBadge) {
      return getBgColor(typeColor)(
        colors.black(` ${logObj.type.toUpperCase()} `)
      );
    }
    const _type = typeof TYPE_ICONS[logObj.type] === "string" ? TYPE_ICONS[logObj.type] : logObj.icon || logObj.type;
    return _type ? getColor2(typeColor)(_type) : "";
  }
  formatLogObj(logObj, opts) {
    const [message, ...additional] = this.formatArgs(logObj.args, opts).split(
      "\n"
    );
    if (logObj.type === "box") {
      return box(
        characterFormat(
          message + (additional.length > 0 ? "\n" + additional.join("\n") : "")
        ),
        {
          title: logObj.title ? characterFormat(logObj.title) : void 0,
          style: logObj.style
        }
      );
    }
    const date = this.formatDate(logObj.date, opts);
    const coloredDate = date && colors.gray(date);
    const isBadge = logObj.badge ?? logObj.level < 2;
    const type = this.formatType(logObj, isBadge, opts);
    const tag = logObj.tag ? colors.gray(logObj.tag) : "";
    let line;
    const left = this.filterAndJoin([type, characterFormat(message)]);
    const right = this.filterAndJoin(opts.columns ? [tag, coloredDate] : [tag]);
    const space = (opts.columns || 0) - stringWidth(left) - stringWidth(right) - 2;
    line = space > 0 && (opts.columns || 0) >= 80 ? left + " ".repeat(space) + right : (right ? `${colors.gray(`[${right}]`)} ` : "") + left;
    line += characterFormat(
      additional.length > 0 ? "\n" + additional.join("\n") : ""
    );
    if (logObj.type === "trace") {
      const _err = new Error("Trace: " + logObj.message);
      line += this.formatStack(_err.stack || "");
    }
    return isBadge ? "\n" + line + "\n" : line;
  }
};
function characterFormat(str) {
  return str.replace(/`([^`]+)`/gm, (_3, m2) => colors.cyan(m2)).replace(/\s+_([^_]+)_\s+/gm, (_3, m2) => ` ${colors.underline(m2)} `);
}
function getColor2(color = "white") {
  return colors[color] || colors.white;
}
function getBgColor(color = "bgWhite") {
  return colors[`bg${color[0].toUpperCase()}${color.slice(1)}`] || colors.bgWhite;
}
function createConsola2(options = {}) {
  let level = _getDefaultLogLevel();
  if (process.env.CONSOLA_LEVEL) {
    level = Number.parseInt(process.env.CONSOLA_LEVEL) ?? level;
  }
  const consola2 = createConsola({
    level,
    defaults: { level },
    stdout: process.stdout,
    stderr: process.stderr,
    prompt: (...args) => Promise.resolve().then(() => (init_prompt(), prompt_exports)).then((m2) => m2.prompt(...args)),
    reporters: options.reporters || [
      options.fancy ?? !(T2 || A2) ? new FancyReporter() : new BasicReporter()
    ],
    ...options
  });
  return consola2;
}
function _getDefaultLogLevel() {
  if (U) {
    return LogLevels.debug;
  }
  if (A2) {
    return LogLevels.warn;
  }
  return LogLevels.info;
}
var consola = createConsola2();

// src/utilities/log.ts
var log = consola;
function logError(error) {
  log.error(causeString(error), error);
}
function causeString(error) {
  var _a8;
  if (typeof error === "object" && error.cause) {
    if ((_a8 = error.cause.errors) == null ? void 0 : _a8.length)
      return error.cause.errors.join(", ");
    if (error.cause.code)
      return "" + error.cause.code;
    return JSON.stringify(error.cause);
  }
  return "";
}

// src/utilities/globalFlags.ts
init_define_ENV_DEFINED_IN_BUILD_STEP();
var projectOption = {
  flags: "--project <path>",
  description: "Path to the inlang project."
};

// src/commands/machine/translate.ts
var import_cli_progress = __toESM(require_cli_progress(), 1);
import fs2 from "node:fs/promises";
var translate = new Command().command("translate").requiredOption(projectOption.flags, projectOption.description).option("-q, --quiet", "don't log every tranlation.", false).option("--locale <source>", "Locales for translation.").option(
  "--targetLocales <targets...>",
  "Comma separated list of target locales for translation."
).option("-n, --nobar", "disable progress bar", false).description("Machine translate bundles.").action(async (args) => {
  try {
    const project = await getInlangProject({ projectPath: args.project });
    await translateCommandAction({ project });
    await saveProjectToDirectory({ fs: fs2, path: args.project, project });
    process.exit(0);
  } catch (error) {
    logError(error);
    process.exit(1);
  }
});
async function translateCommandAction(args) {
  var _a8;
  const options = translate.opts();
  const bar = options.nobar ? void 0 : new import_cli_progress.default.SingleBar(
    {
      clearOnComplete: true,
      format: `\u{1F916} Machine translating bundles | {bar} | {percentage}% | {value}/{total} Bundles`
    },
    import_cli_progress.default.Presets.shades_grey
  );
  try {
    const settings = await args.project.settings.get();
    const targetLocales = options.targetLocales ? (_a8 = options.targetLocales[0]) == null ? void 0 : _a8.split(",") : settings.locales;
    const bundles = await selectBundleNested(args.project.db).selectAll().execute();
    if (bundles.length === 0) {
      log.warn(
        "No message bundles found to translate. Check your project setup with `inlang validate`"
      );
      return;
    }
    bar == null ? void 0 : bar.start(bundles.length, 0);
    const promises = [];
    const errors = [];
    for (const bundle of bundles) {
      promises.push(
        rpc.machineTranslateBundle({
          bundle,
          sourceLocale: settings.baseLocale,
          targetLocales
        }).then((result) => {
          bar == null ? void 0 : bar.increment();
          return result;
        })
      );
    }
    const updatedBundles = await Promise.all(promises);
    for (const bundle of updatedBundles) {
      if (bundle.error) {
        errors.push(bundle.error);
        continue;
      } else if (bundle.data) {
        await upsertBundleNested(args.project.db, bundle.data);
      }
    }
    bar == null ? void 0 : bar.stop();
    log.success("Machine translate complete.");
    if (errors.length > 0) {
      log.warn("Some bundles could not be translated.");
      log.warn(errors.join("\n"));
    }
  } catch (error) {
    logError(error);
  }
}

// src/commands/machine/index.ts
var machine = new Command().command("machine").description("Commands for automating translations.").argument("[command]").addCommand(translate);

// src/commands/plugin/index.ts
init_define_ENV_DEFINED_IN_BUILD_STEP();

// src/commands/plugin/build/command.ts
init_define_ENV_DEFINED_IN_BUILD_STEP();

// src/commands/plugin/build/moduleBuildOptions.ts
init_define_ENV_DEFINED_IN_BUILD_STEP();
var moduleBuildOptions = (args) => {
  return {
    entryPoints: [args.entry],
    outdir: args.outdir,
    minify: args.minify,
    // ----------------------------------
    // allow top level await
    // https://caniuse.com/mdn-javascript_operators_await_top_level
    target: "es2022",
    // inlang does not support import maps
    bundle: true,
    // esm to work in the browser
    format: "esm",
    //! extremly important to be platform neutral
    //! to ensure that modules run in browser
    //! and server contexts.
    platform: "neutral",
    // sourcemaps are unused at the moment
    sourcemap: false,
    plugins: args.plugins
  };
};

// src/commands/plugin/build/command.ts
import { context } from "esbuild-wasm";
var build = new Command().command("build").description("build an inlang module.").requiredOption(
  "--entry <entry>",
  "The path to the entry of the module. Usually src/index.{js|ts}."
).option("--outdir <path>", "The output directory.", "./dist").option("--watch", "Watch for changes and rebuild.", false).option("--minify", "Minifies the plugin. Recommend for distribution.", false).action(buildCommandAction);
async function buildCommandAction(args) {
  try {
    const ctx = await context(
      moduleBuildOptions({
        ...args,
        plugins: [
          {
            name: "logger",
            setup: ({ onEnd }) => onEnd(() => console.info("\u{1F389} changes processed"))
          }
        ]
      })
    );
    if (args.watch) {
      await ctx.watch({});
      console.info("\u{1F440} watching for changes...");
    } else {
      await ctx.rebuild();
      console.info("\u2705 build complete");
      await ctx.dispose();
    }
  } catch (e2) {
    console.error("An error occurred while building the module:");
    console.error(e2);
    process.exit(1);
  }
}

// src/commands/plugin/index.ts
var plugin = new Command().command("plugin").description("Commands for inlang plugins.").argument("[command]").addCommand(build);

// package.json
var version = "3.0.12";

// src/services/error-monitoring/implementation.ts
init_define_ENV_DEFINED_IN_BUILD_STEP();
var Sentry = __toESM(require_cjs5(), 1);

// src/env-variables/index.ts
init_define_ENV_DEFINED_IN_BUILD_STEP();
var ENV_VARIABLES3 = (
  // @ts-expect-error - the env variables are set in the build step
  define_ENV_DEFINED_IN_BUILD_STEP_default
);

// src/services/error-monitoring/implementation.ts
function initErrorMonitoring() {
  Sentry.init({
    dsn: "https://b7a06c6d36454ef2bc5e2ca7e257bd5b@o4504345873285120.ingest.sentry.io/4505172745650176",
    release: version,
    // Not interested in performance data
    tracesSampleRate: 0,
    environment: ENV_VARIABLES3.IS_PRODUCTION ? "production" : "development"
  });
}

// src/commands/validate/index.ts
init_define_ENV_DEFINED_IN_BUILD_STEP();
var validate3 = new Command().command("validate").description("Validate the inlang project settings file.").requiredOption(projectOption.flags, projectOption.description).action(validateCommandAction);
async function validateCommandAction(args) {
  try {
    log.info("\u{1F50E} Validating the inlang project...");
    const project = await getInlangProject({ projectPath: args.project });
    const errors = await project.errors.get();
    if (errors.length > 0) {
      log.info("The project contains errors:");
      for (const error of errors)
        log.error(error);
      process.exit(1);
    }
    log.success("The project is valid!");
    process.exit(0);
  } catch (error) {
    log.error(error);
    process.exit(1);
  }
}

// src/telemetry/capture.ts
init_define_ENV_DEFINED_IN_BUILD_STEP();
var capture3 = async (args) => {
  if (ENV_VARIABLES3.PUBLIC_POSTHOG_TOKEN === void 0) {
    return;
  }
  try {
    await fetch("https://eu.posthog.com/capture/", {
      method: "POST",
      body: JSON.stringify({
        // @ts-expect-error - env variable is set in build step
        api_key: define_ENV_DEFINED_IN_BUILD_STEP_default.PUBLIC_POSTHOG_TOKEN,
        event: args.event,
        // id is "unknown" because no user information is available
        distinct_id: "unknown",
        properties: {
          $groups: args.projectId ? { project: args.projectId } : void 0,
          ...args.properties
        }
      })
    });
  } catch (e2) {
  }
};

// src/commands/lint/index.ts
init_define_ENV_DEFINED_IN_BUILD_STEP();
var lint = new Command().command("lint").description("Validate the inlang project settings file.").option("--project <path>", "Path to the inlang project.").option("--languageTags", "Fix linting errors.").action(lintCommandAction);
async function lintCommandAction(args) {
  log.warn(
    "Inlang lint rules have been removed for the CLI v3 after the major lix and inlang SDK update to be replaced by a new validation system that generalizes beyond inlang and to reduce the scope of the update."
  );
  log.info(
    "Upvote https://github.com/opral/lix-sdk/issues/239 to re-introduce linting."
  );
}

// src/main.ts
initErrorMonitoring();
var cli = new Command().name("inlang").version(version).description("CLI for inlang.").addCommand(validate3).addCommand(machine).addCommand(plugin).addCommand(lint).hook("postAction", async (command) => {
  var _a8;
  const name = command.args.filter(
    // shouldn't start with a flag and the previous arg shouldn't be a flag
    (arg, i2) => {
      var _a9;
      return !arg.startsWith("-") && !((_a9 = command.args[i2 - 1]) == null ? void 0 : _a9.startsWith("-"));
    }
  );
  await capture3({
    event: `CLI command executed`,
    projectId: await ((_a8 = lastUsedProject) == null ? void 0 : _a8.id.get()),
    properties: {
      name: name.join(" "),
      args: command.args.join(" "),
      node_version: process.versions.node,
      platform: process.platform,
      version
    }
  });
});
export {
  cli
};
/*! Bundled license information:

js-sha256/src/sha256.js:
  (**
   * [js-sha256]{@link https://github.com/emn178/js-sha256}
   *
   * @version 0.11.0
   * @author Chen, Yi-Cyuan [emn178@gmail.com]
   * @copyright Chen, Yi-Cyuan 2014-2024
   * @license MIT
   *)

@sentry/node/cjs/integrations/anr/worker-script.js:
  (*! @sentry/node 7.120.2 (85a3cac) | https://github.com/getsentry/sentry-javascript *)

localforage/dist/localforage.js:
  (*!
      localForage -- Offline Storage, Improved
      Version 1.10.0
      https://localforage.github.io/localForage
      (c) 2013-2017 Mozilla, Apache License 2.0
  *)
*/
